{
    "name": "vcd",
    "displayName": "Pulumi vCD",
    "description": "A Pulumi package for creating and managing vcd cloud resources.",
    "keywords": [
        "vcd",
        "category/cloud"
    ],
    "homepage": "https://www.pulumi.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vcd` Terraform Provider](https://github.com/vmware/terraform-provider-vcd).",
    "repository": "https://github.com/ergSey/pulumi-vcd",
    "pluginDownloadURL": "https://github.com/vmware/terraform-provider-vcd/releases/download/v3.14.1/",
    "publisher": "ergSey",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/ergSey/pulumi-vcd/sdk/go/vcd",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing vcd cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/vmware/terraform-provider-vcd)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vcd` repo](https://github.com/ergSey/pulumi-vcd/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vcd` repo](https://github.com/vmware/terraform-provider-vcd/issues).",
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/vmware/terraform-provider-vcd)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vcd` repo](https://github.com/ergSey/pulumi-vcd/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vcd` repo](https://github.com/vmware/terraform-provider-vcd/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "allowApiTokenFile": {
                "type": "boolean",
                "description": "Set this to true if you understand the security risks of using API token files and would like to suppress the warnings\n"
            },
            "allowServiceAccountTokenFile": {
                "type": "boolean",
                "description": "Set this to true if you understand the security risks of using Service Account token files and would like to suppress\nthe warnings\n"
            },
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VCDClient will permit unverifiable SSL certificates.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API token used instead of username/password for VCD API operations. (Requires VCD 10.3.1+)\n"
            },
            "apiTokenFile": {
                "type": "string",
                "description": "The API token file instead of username/password for VCD API operations. (Requires VCD 10.3.1+)\n"
            },
            "authType": {
                "type": "string",
                "description": "'integrated', 'saml_adfs', 'token', 'api_token', 'api_token_file' and 'service_account_token_file' are supported.\n'integrated' is default.\n"
            },
            "ignoreMetadataChanges": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vcd:config/ignoreMetadataChanges:ignoreMetadataChanges"
                },
                "description": "Defines a set of `metadata_entry` that need to be ignored by this provider. All filters on this attribute are computed\nwith a logical AND\n"
            },
            "importSeparator": {
                "type": "string"
            },
            "logging": {
                "type": "boolean",
                "description": "If set, it will enable logging of API requests and responses\n"
            },
            "loggingFile": {
                "type": "string",
                "description": "Defines the full name of the logging file for API calls (requires 'logging')\n"
            },
            "maxRetryTimeout": {
                "type": "integer",
                "description": "Max num seconds to wait for successful response when operating on resources within vCloud (defaults to 60)\n"
            },
            "org": {
                "type": "string",
                "description": "The VCD Org for API operations\n"
            },
            "password": {
                "type": "string",
                "description": "The user password for VCD API operations.\n"
            },
            "samlAdfsCookie": {
                "type": "string",
                "description": "Allows to specify custom cookie for ADFS server lookup. '{{.Org}}' is replaced by real Org - e.g. 'sso-preferred=yes;\nsso_redirect_org={{.Org}}'\n"
            },
            "samlAdfsRptId": {
                "type": "string",
                "description": "Allows to specify custom Relaying Party Trust Identifier for auth_type=saml_adfs\n"
            },
            "serviceAccountTokenFile": {
                "type": "string",
                "description": "The Service Account API token file instead of username/password for VCD API operations. (Requires VCD 10.4.0+)\n"
            },
            "sysorg": {
                "type": "string",
                "description": "The VCD Org for user authentication\n"
            },
            "token": {
                "type": "string",
                "description": "The token used instead of username/password for VCD API operations.\n"
            },
            "url": {
                "type": "string",
                "description": "The VCD url for VCD API operations.\n"
            },
            "user": {
                "type": "string",
                "description": "The user name for VCD API operations.\n"
            },
            "vdc": {
                "type": "string",
                "description": "The VDC for API operations\n"
            }
        },
        "defaults": [
            "org",
            "url"
        ]
    },
    "types": {
        "vcd:config/ignoreMetadataChanges:ignoreMetadataChanges": {
            "properties": {
                "conflictAction": {
                    "type": "string"
                },
                "keyRegex": {
                    "type": "string",
                    "description": "Regular expression of the metadata entry keys to ignore. Either `key_regex` or `value_regex` is required\n"
                },
                "resourceName": {
                    "type": "string",
                    "description": "Ignores metadata from the specific entity in VCD named like this argument\n"
                },
                "resourceType": {
                    "type": "string",
                    "description": "Ignores metadata from the specific resource type\n"
                },
                "valueRegex": {
                    "type": "string",
                    "description": "Regular expression of the metadata entry values to ignore. Either `key_regex` or `value_regex` is required\n"
                }
            },
            "type": "object"
        },
        "vcd:index/CatalogAccessControlSharedWith:CatalogAccessControlSharedWith": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the user or group to which we are sharing. (One of `ReadOnly`, \n`Change`, `FullControl`, but it can only be `ReadOnly` when we share to an Organization)\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of a group with which we are sharing. Required if `user_id` or `org_id` is not set.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of a group with which we are sharing. Required if `user_id` or `group_id` is not set.\n"
                },
                "subjectName": {
                    "type": "string",
                    "description": "the name of the subject (Org, group, or user) with which we are sharing.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of a user with which we are sharing. Required if `group_id` or `org_id` is not set.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "subjectName"
                    ]
                }
            }
        },
        "vcd:index/CatalogItemMetadataEntry:CatalogItemMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/CatalogMediaMetadataEntry:CatalogMediaMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/CatalogMetadataEntry:CatalogMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/CatalogVappTemplateCaptureVapp:CatalogVappTemplateCaptureVapp": {
            "properties": {
                "copyTpmOnInstantiate": {
                    "type": "boolean",
                    "description": "Defines if Trusted Platform Module should be copied (false) or created (true). Default 'false'. VCD 10.4.2+\n"
                },
                "customizeOnInstantiate": {
                    "type": "boolean",
                    "description": "Marks if instantiating applies customization settings ('true'). Default is 'false` - create an identical copy.\n"
                },
                "overwriteCatalogItemId": {
                    "type": "string",
                    "description": "An existing catalog item ID to overwrite\n"
                },
                "sourceId": {
                    "type": "string",
                    "description": "Source vApp ID (can be a vApp ID or 'vapp_id' field of standalone VM 'vcd_vm')\n"
                }
            },
            "type": "object"
        },
        "vcd:index/CatalogVappTemplateLease:CatalogVappTemplateLease": {
            "properties": {
                "storageLeaseInSec": {
                    "type": "integer",
                    "description": "How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org). Regular values accepted from 3600+.\n"
                }
            },
            "type": "object",
            "required": [
                "storageLeaseInSec"
            ]
        },
        "vcd:index/CatalogVappTemplateMetadataEntry:CatalogVappTemplateMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/CseKubernetesClusterControlPlane:CseKubernetesClusterControlPlane": {
            "properties": {
                "diskSizeGi": {
                    "type": "integer",
                    "description": "Disk size, in **Gibibytes (Gi)**, for the control plane VMs. Must be at least `20`. Defaults to `20`\n",
                    "willReplaceOnChanges": true
                },
                "ip": {
                    "type": "string",
                    "description": "IP for the control plane. It will be automatically assigned during cluster creation if left empty\n",
                    "willReplaceOnChanges": true
                },
                "machineCount": {
                    "type": "integer",
                    "description": "The number of nodes that the control plane has. Must be an odd number and higher than `0`. Defaults to `3`\n"
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM Placement policy for the control plane VMs\n",
                    "willReplaceOnChanges": true
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM Sizing policy for the control plane VMs. Must be one of the ones made available during CSE installation\n",
                    "willReplaceOnChanges": true
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Storage profile for the control plane VMs\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ip"
                    ]
                }
            }
        },
        "vcd:index/CseKubernetesClusterDefaultStorageClass:CseKubernetesClusterDefaultStorageClass": {
            "properties": {
                "filesystem": {
                    "type": "string",
                    "description": "Filesystem of the storage class, can be either `ext4` or `xfs`\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the default storage class. It must contain only lowercase alphanumeric characters or \"-\",\nstart with an alphabetic character, end with an alphanumeric, and contain at most 31 characters\n",
                    "willReplaceOnChanges": true
                },
                "reclaimPolicy": {
                    "type": "string",
                    "description": "A value of `delete` deletes the volume when the PersistentVolumeClaim is deleted. `retain` does not,\nand the volume can be manually reclaimed\n",
                    "willReplaceOnChanges": true
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Storage profile for the default storage class\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "filesystem",
                "name",
                "reclaimPolicy",
                "storageProfileId"
            ]
        },
        "vcd:index/CseKubernetesClusterEvent:CseKubernetesClusterEvent": {
            "properties": {
                "details": {
                    "type": "string",
                    "description": "Details of the event\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or \"-\",\nstart with an alphabetic character, end with an alphanumeric, and contain at most 31 characters\n"
                },
                "occurredAt": {
                    "type": "string",
                    "description": "When the event happened\n"
                },
                "resourceId": {
                    "type": "string",
                    "description": "ID of the resource that caused the event\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the event, either `event` or `error`\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "details",
                        "name",
                        "occurredAt",
                        "resourceId",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/CseKubernetesClusterWorkerPool:CseKubernetesClusterWorkerPool": {
            "properties": {
                "autoscalerMaxReplicas": {
                    "type": "integer",
                    "description": "Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'\n"
                },
                "autoscalerMinReplicas": {
                    "type": "integer",
                    "description": "Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'\n"
                },
                "diskSizeGi": {
                    "type": "integer",
                    "description": "Disk size, in Gibibytes (Gi), for this worker pool\n"
                },
                "machineCount": {
                    "type": "integer",
                    "description": "The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or \"-\",\nstart with an alphabetic character, end with an alphanumeric, and contain at most 31 characters\n"
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM Placement policy for this worker pool\n"
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM Sizing policy for this worker pool\n"
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Storage profile for this worker pool\n"
                },
                "vgpuPolicyId": {
                    "type": "string",
                    "description": "vGPU policy for this worker pool\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "vcd:index/DseRegistryConfigurationContainerRegistry:DseRegistryConfigurationContainerRegistry": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Registry description\n"
                },
                "host": {
                    "type": "string",
                    "description": "Registry host\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for registry user\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username for registry access\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "host"
            ]
        },
        "vcd:index/EdgegatewayExternalNetwork:EdgegatewayExternalNetwork": {
            "properties": {
                "enableRateLimit": {
                    "type": "boolean",
                    "description": "Enable rate limiting\n",
                    "willReplaceOnChanges": true
                },
                "incomingRateLimit": {
                    "type": "number",
                    "description": "Incoming rate limit (Mbps)\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the edge gateway.\n",
                    "willReplaceOnChanges": true
                },
                "outgoingRateLimit": {
                    "type": "number",
                    "description": "Outgoing rate limit (Mbps)\n",
                    "willReplaceOnChanges": true
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayExternalNetworkSubnet:EdgegatewayExternalNetworkSubnet"
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "subnets"
                    ]
                }
            }
        },
        "vcd:index/EdgegatewayExternalNetworkSubnet:EdgegatewayExternalNetworkSubnet": {
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n",
                    "willReplaceOnChanges": true
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address on the edge gateway - will be auto-assigned if not defined\n",
                    "willReplaceOnChanges": true
                },
                "netmask": {
                    "type": "string",
                    "description": "Netmask address for a subnet\n",
                    "willReplaceOnChanges": true
                },
                "suballocatePools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayExternalNetworkSubnetSuballocatePool:EdgegatewayExternalNetworkSubnetSuballocatePool"
                    },
                    "description": "Define zero or more blocks to sub-allocate pools on the edge gateway\n",
                    "willReplaceOnChanges": true
                },
                "useForDefaultRoute": {
                    "type": "boolean",
                    "description": "Defines if this subnet should be used as default gateway for edge\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "netmask"
            ]
        },
        "vcd:index/EdgegatewayExternalNetworkSubnetSuballocatePool:EdgegatewayExternalNetworkSubnetSuballocatePool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "startAddress": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/EdgegatewayVpnLocalSubnet:EdgegatewayVpnLocalSubnet": {
            "properties": {
                "localSubnetGateway": {
                    "type": "string"
                },
                "localSubnetMask": {
                    "type": "string"
                },
                "localSubnetName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "localSubnetGateway",
                "localSubnetMask",
                "localSubnetName"
            ]
        },
        "vcd:index/EdgegatewayVpnPeerSubnet:EdgegatewayVpnPeerSubnet": {
            "properties": {
                "peerSubnetGateway": {
                    "type": "string"
                },
                "peerSubnetMask": {
                    "type": "string"
                },
                "peerSubnetName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "peerSubnetGateway",
                "peerSubnetMask",
                "peerSubnetName"
            ]
        },
        "vcd:index/ExternalNetworkIpScope:ExternalNetworkIpScope": {
            "properties": {
                "dns1": {
                    "type": "string",
                    "description": "Primary DNS server\n",
                    "willReplaceOnChanges": true
                },
                "dns2": {
                    "type": "string",
                    "description": "Secondary DNS server\n",
                    "willReplaceOnChanges": true
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "DNS suffix\n",
                    "willReplaceOnChanges": true
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway of the network\n",
                    "willReplaceOnChanges": true
                },
                "netmask": {
                    "type": "string",
                    "description": "Network mask\n",
                    "willReplaceOnChanges": true
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkIpScopeStaticIpPool:ExternalNetworkIpScopeStaticIpPool"
                    },
                    "description": "IP ranges used for static pool allocation in the network\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "netmask"
            ]
        },
        "vcd:index/ExternalNetworkIpScopeStaticIpPool:ExternalNetworkIpScopeStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n",
                    "willReplaceOnChanges": true
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/ExternalNetworkV2IpScope:ExternalNetworkV2IpScope": {
            "properties": {
                "dns1": {
                    "type": "string",
                    "description": "Primary DNS server\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Secondary DNS server\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "DNS suffix\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If subnet is enabled\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway of the network\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Network mask\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkV2IpScopeStaticIpPool:ExternalNetworkV2IpScopeStaticIpPool"
                    },
                    "description": "IP ranges used for static pool allocation in the network\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "prefixLength"
            ]
        },
        "vcd:index/ExternalNetworkV2IpScopeStaticIpPool:ExternalNetworkV2IpScopeStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/ExternalNetworkV2NsxtNetwork:ExternalNetworkV2NsxtNetwork": {
            "properties": {
                "nsxtManagerId": {
                    "type": "string",
                    "description": "ID of NSX-T manager\n",
                    "willReplaceOnChanges": true
                },
                "nsxtSegmentName": {
                    "type": "string",
                    "description": "Name of NSX-T segment (for NSX-T segment backed external network)\n",
                    "willReplaceOnChanges": true
                },
                "nsxtTier0RouterId": {
                    "type": "string",
                    "description": "ID of NSX-T Tier-0 router (for T0 gateway backed external network)\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "nsxtManagerId"
            ]
        },
        "vcd:index/ExternalNetworkV2VsphereNetwork:ExternalNetworkV2VsphereNetwork": {
            "properties": {
                "portgroupId": {
                    "type": "string",
                    "description": "The name of the port group\n",
                    "willReplaceOnChanges": true
                },
                "vcenterId": {
                    "type": "string",
                    "description": "The vCenter server name\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "portgroupId",
                "vcenterId"
            ]
        },
        "vcd:index/ExternalNetworkVsphereNetwork:ExternalNetworkVsphereNetwork": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK\n",
                    "willReplaceOnChanges": true
                },
                "vcenter": {
                    "type": "string",
                    "description": "The vCenter server name\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "vcenter"
            ]
        },
        "vcd:index/IndependentDiskMetadataEntry:IndependentDiskMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/IpSpaceCustomQuotaIpPrefixQuota:IpSpaceCustomQuotaIpPrefixQuota": {
            "properties": {
                "prefixLength": {
                    "type": "string",
                    "description": "Prefix length\n"
                },
                "quota": {
                    "type": "string",
                    "description": "IP Prefix Quota\n"
                }
            },
            "type": "object",
            "required": [
                "prefixLength",
                "quota"
            ]
        },
        "vcd:index/IpSpaceIpPrefix:IpSpaceIpPrefix": {
            "properties": {
                "defaultQuota": {
                    "type": "string",
                    "description": "Floating IP quota\n"
                },
                "prefixes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IpSpaceIpPrefixPrefix:IpSpaceIpPrefixPrefix"
                    },
                    "description": "One or more prefixes\n"
                }
            },
            "type": "object",
            "required": [
                "prefixes"
            ]
        },
        "vcd:index/IpSpaceIpPrefixPrefix:IpSpaceIpPrefixPrefix": {
            "properties": {
                "firstIp": {
                    "type": "string",
                    "description": "First IP\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of IP Prefix\n"
                },
                "prefixCount": {
                    "type": "string",
                    "description": "Number of prefixes to define\n"
                },
                "prefixLength": {
                    "type": "string",
                    "description": "Prefix length\n"
                }
            },
            "type": "object",
            "required": [
                "firstIp",
                "prefixCount",
                "prefixLength"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "firstIp",
                        "id",
                        "prefixCount",
                        "prefixLength"
                    ]
                }
            }
        },
        "vcd:index/IpSpaceIpRange:IpSpaceIpRange": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of IP Range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "endAddress",
                        "id",
                        "startAddress"
                    ]
                }
            }
        },
        "vcd:index/LbServerPoolMember:LbServerPoolMember": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "Defines member state. One of enabled, drain, disabled.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The NSX ID of the load balancer server pool\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address of member in server pool\n"
                },
                "maxConnections": {
                    "type": "integer",
                    "description": "The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released\n"
                },
                "minConnections": {
                    "type": "integer",
                    "description": "Minimum number of concurrent connections a member must always accept\n"
                },
                "monitorPort": {
                    "type": "integer",
                    "description": "Port at which the member is to receive health monitor requests. Can be the same as port\n"
                },
                "name": {
                    "type": "string",
                    "description": "Server Pool name\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port at which the member is to receive traffic from the load balancer\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Proportion of traffic this member is to handle. Must be an integer in the range 1-256\n"
                }
            },
            "type": "object",
            "required": [
                "condition",
                "ipAddress",
                "monitorPort",
                "name",
                "port",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "condition",
                        "id",
                        "ipAddress",
                        "monitorPort",
                        "name",
                        "port",
                        "weight"
                    ]
                }
            }
        },
        "vcd:index/NetworkDirectMetadataEntry:NetworkDirectMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NetworkIsolatedDhcpPool:NetworkIsolatedDhcpPool": {
            "properties": {
                "defaultLeaseTime": {
                    "type": "integer",
                    "description": "The default DHCP lease time to use\n"
                },
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "maxLeaseTime": {
                    "type": "integer",
                    "description": "The maximum DHCP lease time to use\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NetworkIsolatedMetadataEntry:NetworkIsolatedMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NetworkIsolatedStaticIpPool:NetworkIsolatedStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NetworkIsolatedV2MetadataEntry:NetworkIsolatedV2MetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NetworkIsolatedV2SecondaryStaticIpPool:NetworkIsolatedV2SecondaryStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NetworkIsolatedV2StaticIpPool:NetworkIsolatedV2StaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NetworkPoolBacking:NetworkPoolBacking": {
            "properties": {
                "distributedSwitch": {
                    "$ref": "#/types/vcd:index/NetworkPoolBackingDistributedSwitch:NetworkPoolBackingDistributedSwitch",
                    "description": "(Optional) A backing structure used for `VLAN` network pool\n",
                    "willReplaceOnChanges": true
                },
                "portGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkPoolBackingPortGroup:NetworkPoolBackingPortGroup"
                    },
                    "description": "(Optional) A list of backing structure used for `PORTGROUP_BACKED` network pool\n",
                    "willReplaceOnChanges": true
                },
                "rangeIds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkPoolBackingRangeId:NetworkPoolBackingRangeId"
                    },
                    "description": "(Optional) A list of range IDs, required with `VLAN` network pools\n"
                },
                "transportZone": {
                    "$ref": "#/types/vcd:index/NetworkPoolBackingTransportZone:NetworkPoolBackingTransportZone",
                    "description": "(Optional) A backing structure used for `GENEVE` network pool\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "distributedSwitch",
                        "portGroups",
                        "transportZone"
                    ]
                }
            }
        },
        "vcd:index/NetworkPoolBackingDistributedSwitch:NetworkPoolBackingDistributedSwitch": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "(Computed) The ID of the backing element\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique name of network pool\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/NetworkPoolBackingPortGroup:NetworkPoolBackingPortGroup": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "(Computed) The ID of the backing element\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique name of network pool\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/NetworkPoolBackingRangeId:NetworkPoolBackingRangeId": {
            "properties": {
                "endId": {
                    "type": "integer",
                    "description": "(Required) The last ID of the range\n"
                },
                "startId": {
                    "type": "integer",
                    "description": "(Required) The first ID of the range\n"
                }
            },
            "type": "object",
            "required": [
                "endId",
                "startId"
            ]
        },
        "vcd:index/NetworkPoolBackingTransportZone:NetworkPoolBackingTransportZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "(Computed) The ID of the backing element\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique name of network pool\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/NetworkRoutedDhcpPool:NetworkRoutedDhcpPool": {
            "properties": {
                "defaultLeaseTime": {
                    "type": "integer",
                    "description": "The default DHCP lease time to use\n"
                },
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "maxLeaseTime": {
                    "type": "integer",
                    "description": "The maximum DHCP lease time to use\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "defaultLeaseTime",
                        "endAddress",
                        "startAddress"
                    ]
                }
            }
        },
        "vcd:index/NetworkRoutedMetadataEntry:NetworkRoutedMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NetworkRoutedStaticIpPool:NetworkRoutedStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NetworkRoutedV2MetadataEntry:NetworkRoutedV2MetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NetworkRoutedV2SecondaryStaticIpPool:NetworkRoutedV2SecondaryStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NetworkRoutedV2StaticIpPool:NetworkRoutedV2StaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NsxtAlbPoolHealthMonitor:NsxtAlbPoolHealthMonitor": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "A name for ALB Pool\n"
                },
                "systemDefined": {
                    "type": "boolean"
                },
                "type": {
                    "type": "string",
                    "description": "Type of health monitor. One of `HTTP`, `HTTPS`, `TCP`, `UDP`, `PING`\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "systemDefined",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/NsxtAlbPoolMember:NsxtAlbPoolMember": {
            "properties": {
                "detailedHealthMessage": {
                    "type": "string",
                    "description": "Detailed health message\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Boolean value if ALB Pool should be enabled (default `true`)\n"
                },
                "healthStatus": {
                    "type": "string",
                    "description": "Health status\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address of pool member\n"
                },
                "markedDownBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Marked down by provides a set of health monitors that marked the service down\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Member port\n"
                },
                "ratio": {
                    "type": "integer",
                    "description": "Ratio of selecting eligible servers in the pool\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "detailedHealthMessage",
                        "healthStatus",
                        "ipAddress",
                        "markedDownBies"
                    ]
                }
            }
        },
        "vcd:index/NsxtAlbPoolPersistenceProfile:NsxtAlbPoolPersistenceProfile": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "A name for ALB Pool\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of persistence strategy. One of `CLIENT_IP`, `HTTP_COOKIE`, `CUSTOM_HTTP_HEADER`, `APP_COOKIE`, `TLS`\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of attribute based on persistence type\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRule:NsxtAlbVirtualServiceHttpReqRulesRule": {
            "properties": {
                "actions": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActions:NsxtAlbVirtualServiceHttpReqRulesRuleActions",
                    "description": "Actions to perform with the rule that matches\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Defines if the rule is active or not\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines whether to enable logging with headers on rule match or not\n"
                },
                "matchCriteria": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria",
                    "description": "Rule matching Criteria\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rule\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "matchCriteria",
                "name"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActions:NsxtAlbVirtualServiceHttpReqRulesRuleActions": {
            "properties": {
                "modifyHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader:NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader"
                    },
                    "description": "A set of header modification rules\n"
                },
                "redirect": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect:NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect",
                    "description": "Redirect request\n"
                },
                "rewriteUrl": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl:NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl",
                    "description": "URL rewrite rules\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader:NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE\n"
                },
                "name": {
                    "type": "string",
                    "description": "HTTP header name\n"
                },
                "value": {
                    "type": "string",
                    "description": "HTTP header value\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "name"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect:NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Host to which redirect the request\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Should the query part be preserved\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to which redirect the request\n"
                },
                "port": {
                    "type": "string",
                    "description": "Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "HTTP or HTTPS protocol\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "One of the redirect status codes - 301, 302, 307\n"
                }
            },
            "type": "object",
            "required": [
                "protocol",
                "statusCode"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl:NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl": {
            "properties": {
                "existingPath": {
                    "type": "string",
                    "description": "Path to use for the rewritten URL\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Host to use for the rewritten URL\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Whether or not to keep the existing query string when rewriting the URL\n"
                },
                "query": {
                    "type": "string",
                    "description": "Query string to use or append to the existing query string in the rewritten URL\n"
                }
            },
            "type": "object",
            "required": [
                "existingPath",
                "hostHeader"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria": {
            "properties": {
                "clientIpAddress": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress",
                    "description": "Client IP Address criteria\n"
                },
                "cookie": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie",
                    "description": "Criteria for matching cookie\n"
                },
                "httpMethods": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods",
                    "description": "HTTP methods that should be matched\n"
                },
                "path": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath",
                    "description": "Request path criteria\n"
                },
                "protocolType": {
                    "type": "string",
                    "description": "Protocol to match - 'HTTP' or 'HTTPS'\n"
                },
                "queries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP request query strings to match\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader"
                    },
                    "description": "A set of rules for matching request headers\n"
                },
                "servicePorts": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts",
                    "description": "Service Port criteria\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ipAddresses"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP cookie whose value is to be matched\n"
                },
                "value": {
                    "type": "string",
                    "description": "String values to match for an HTTP cookie\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "value"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "methods"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match the path\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "paths"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "values"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts:NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of TCP ports. Allowed values are 1-65535\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ports"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRule:NsxtAlbVirtualServiceHttpRespRulesRule": {
            "properties": {
                "actions": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleActions:NsxtAlbVirtualServiceHttpRespRulesRuleActions",
                    "description": "Actions to perform with the rule that matches\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Defines if the rule is active or not\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines whether to enable logging with headers on rule match or not\n"
                },
                "matchCriteria": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria",
                    "description": "Rule matching Criteria\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rule\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "matchCriteria",
                "name"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleActions:NsxtAlbVirtualServiceHttpRespRulesRuleActions": {
            "properties": {
                "modifyHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader:NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader"
                    },
                    "description": "Modify header\n"
                },
                "rewriteLocationHeader": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader:NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader",
                    "description": "Rewrite location header\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader:NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE\n"
                },
                "name": {
                    "type": "string",
                    "description": "HTTP header name\n"
                },
                "value": {
                    "type": "string",
                    "description": "HTTP header value\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "name"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader:NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Host to which redirect the request\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Should the query part be preserved\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to which redirect the request\n"
                },
                "port": {
                    "type": "string",
                    "description": "Port to which redirect the request\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "HTTP or HTTPS protocol\n"
                }
            },
            "type": "object",
            "required": [
                "port",
                "protocol"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria": {
            "properties": {
                "clientIpAddress": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress",
                    "description": "Client IP Address criteria\n"
                },
                "cookie": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie",
                    "description": "Criteria for matching cookie\n"
                },
                "httpMethods": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods",
                    "description": "HTTP methods that should be matched\n"
                },
                "locationHeader": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader",
                    "description": "A matching criteria for Location header\n"
                },
                "path": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath",
                    "description": "Request path criteria\n"
                },
                "protocolType": {
                    "type": "string",
                    "description": "Protocol to match - 'HTTP' or 'HTTPS'\n"
                },
                "queries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP request query strings to match\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader"
                    },
                    "description": "A set of rules for matching request headers\n"
                },
                "responseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader"
                    },
                    "description": "A set of criteria to match response headers\n"
                },
                "servicePorts": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts",
                    "description": "Service Port criteria\n"
                },
                "statusCode": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode",
                    "description": "HTTP Status code to match\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ipAddresses"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP cookie whose value is to be matched\n"
                },
                "value": {
                    "type": "string",
                    "description": "String values to match for an HTTP cookie\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "value"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "methods"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching location header. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of values to match for criteria\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "values"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match the path\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "paths"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "values"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of TCP ports. Allowed values are 1-65535\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ports"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode:NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.\n"
                },
                "httpStatusCode": {
                    "type": "string",
                    "description": "Enter a http status code or range\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "httpStatusCode"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRule:NsxtAlbVirtualServiceHttpSecRulesRule": {
            "properties": {
                "actions": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActions:NsxtAlbVirtualServiceHttpSecRulesRuleActions",
                    "description": "Actions to perform with the rule that matches\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Defines is the rule is active or not\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines whether to enable logging with headers on rule match or not\n"
                },
                "matchCriteria": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria",
                    "description": "Rule matching Criteria\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rule\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "matchCriteria",
                "name"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActions:NsxtAlbVirtualServiceHttpSecRulesRuleActions": {
            "properties": {
                "connections": {
                    "type": "string",
                    "description": "ALLOW or CLOSE connections\n"
                },
                "rateLimit": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit:NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit",
                    "description": "Apply actions based on rate limits\n"
                },
                "redirectToHttps": {
                    "type": "string",
                    "description": "Port number that should be redirected to HTTPS\n"
                },
                "sendResponse": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse:NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse",
                    "description": "Send custom response\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit:NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit": {
            "properties": {
                "actionCloseConnection": {
                    "type": "boolean",
                    "description": "Set to true if the connection should be closed\n"
                },
                "actionLocalResponses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse:NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse"
                    },
                    "description": "Send custom response\n"
                },
                "actionRedirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect:NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect"
                    },
                    "description": "Redirect based on rate limits\n"
                },
                "count": {
                    "type": "string",
                    "description": "Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000\n"
                },
                "period": {
                    "type": "string",
                    "description": "Time value in seconds to enforce rate count. The period must be between 1 and 1000000000\n"
                }
            },
            "type": "object",
            "required": [
                "count",
                "period"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse:NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse": {
            "properties": {
                "content": {
                    "type": "string",
                    "description": "Base64 encoded content\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME type for the content\n"
                },
                "statusCode": {
                    "type": "string",
                    "description": "HTTP Status code to send\n"
                }
            },
            "type": "object",
            "required": [
                "statusCode"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect:NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Host to which redirect the request\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Should the query part be preserved\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to which redirect the request\n"
                },
                "port": {
                    "type": "string",
                    "description": "Port to which redirect the request\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "HTTP or HTTPS protocol\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "One of the redirect status codes - 301, 302, 307\n"
                }
            },
            "type": "object",
            "required": [
                "port",
                "protocol",
                "statusCode"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse:NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse": {
            "properties": {
                "content": {
                    "type": "string",
                    "description": "Base64 encoded content\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME type for the content\n"
                },
                "statusCode": {
                    "type": "string",
                    "description": "HTTP Status code to send\n"
                }
            },
            "type": "object",
            "required": [
                "statusCode"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria": {
            "properties": {
                "clientIpAddress": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress",
                    "description": "Client IP Address criteria\n"
                },
                "cookie": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie",
                    "description": "Criteria for matching cookie\n"
                },
                "httpMethods": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods",
                    "description": "HTTP methods that should be matched\n"
                },
                "path": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath",
                    "description": "Request path criteria\n"
                },
                "protocolType": {
                    "type": "string",
                    "description": "Protocol to match - 'HTTP' or 'HTTPS'\n"
                },
                "queries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP request query strings to match\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader"
                    },
                    "description": "A set of rules for matching request headers\n"
                },
                "servicePorts": {
                    "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts",
                    "description": "Service Port criteria\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ipAddresses"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP cookie whose value is to be matched\n"
                },
                "value": {
                    "type": "string",
                    "description": "String values to match for an HTTP cookie\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "value"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "methods"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match the path\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "paths"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "values"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts:NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of TCP ports. Allowed values are 1-65535\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ports"
            ]
        },
        "vcd:index/NsxtAlbVirtualServiceServicePort:NsxtAlbVirtualServiceServicePort": {
            "properties": {
                "endPort": {
                    "type": "integer",
                    "description": "Last port in the range\n"
                },
                "sslEnabled": {
                    "type": "boolean",
                    "description": "Defines if certificate should be used\n"
                },
                "startPort": {
                    "type": "integer",
                    "description": "Starting port in the range\n"
                },
                "type": {
                    "type": "string",
                    "description": "One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'\n"
                }
            },
            "type": "object",
            "required": [
                "startPort",
                "type"
            ]
        },
        "vcd:index/NsxtAppPortProfileAppPort:NsxtAppPortProfileAppPort": {
            "properties": {
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of ports or ranges\n"
                },
                "protocol": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "protocol"
            ]
        },
        "vcd:index/NsxtDistributedFirewallRule:NsxtDistributedFirewallRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic\n"
                },
                "appPortProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Application Port Profile IDs. Leaving it empty means 'Any'\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment that is shown next to rule in UI (VCD 10.3.2+)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description is not shown in UI\n"
                },
                "destinationGroupsExcluded": {
                    "type": "boolean",
                    "description": "Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defined if Firewall Rule is active\n"
                },
                "id": {
                    "type": "string",
                    "description": "Firewall Rule ID\n"
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines if matching traffic should be logged\n"
                },
                "name": {
                    "type": "string",
                    "description": "Firewall Rule name\n"
                },
                "networkContextProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Network Context Profile IDs. Leaving it empty means 'Any'\n"
                },
                "sourceGroupsExcluded": {
                    "type": "boolean",
                    "description": "Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)\n"
                },
                "sourceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "id",
                        "name"
                    ]
                }
            }
        },
        "vcd:index/NsxtDynamicSecurityGroupCriteria:NsxtDynamicSecurityGroupCriteria": {
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtDynamicSecurityGroupCriteriaRule:NsxtDynamicSecurityGroupCriteriaRule"
                    },
                    "description": "Up to 4 rules for matching VMs. List of rules are matched with boolean `AND`\noperation and all defines rules must match to include object. See Rule for rule\ndefinition structure.\n\n\n\u003ca id=\"rule\"\u003e\u003c/a\u003e\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtDynamicSecurityGroupCriteriaRule:NsxtDynamicSecurityGroupCriteriaRule": {
            "properties": {
                "operator": {
                    "type": "string",
                    "description": "Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of object matching 'VM_TAG' or 'VM_NAME'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Filter value\n"
                }
            },
            "type": "object",
            "required": [
                "operator",
                "type",
                "value"
            ]
        },
        "vcd:index/NsxtDynamicSecurityGroupMemberVm:NsxtDynamicSecurityGroupMemberVm": {
            "properties": {
                "vappId": {
                    "type": "string",
                    "description": "Parent vApp name (if exists) for member VM\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "Parent vApp ID (if exists) for member VM\n"
                },
                "vmId": {
                    "type": "string",
                    "description": "Member VM ID\n"
                },
                "vmName": {
                    "type": "string",
                    "description": "Member VM Name\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "vappId",
                        "vappName",
                        "vmId",
                        "vmName"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewayBgpIpPrefixListIpPrefix:NsxtEdgegatewayBgpIpPrefixListIpPrefix": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action 'PERMIT' or 'DENY'\n"
                },
                "greaterThanOrEqualTo": {
                    "type": "integer",
                    "description": "Greater than or equal to subnet mask\n"
                },
                "lessThanOrEqualTo": {
                    "type": "integer",
                    "description": "Less than or equal to subnet mask\n"
                },
                "network": {
                    "type": "string",
                    "description": "Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "network"
            ]
        },
        "vcd:index/NsxtEdgegatewayDnsConditionalForwarderZone:NsxtEdgegatewayDnsConditionalForwarderZone": {
            "properties": {
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of domain names on which conditional forwarding is based.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique ID of the forwarder zone.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the forwarder zone.\n"
                },
                "upstreamServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Servers to which DNS requests should be forwarded to.\n"
                }
            },
            "type": "object",
            "required": [
                "domainNames",
                "name",
                "upstreamServers"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "domainNames",
                        "id",
                        "name",
                        "upstreamServers"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewayDnsDefaultForwarderZone:NsxtEdgegatewayDnsDefaultForwarderZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique ID of the forwarder zone.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the forwarder zone.\n"
                },
                "upstreamServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Servers to which DNS requests should be forwarded to.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "upstreamServers"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name",
                        "upstreamServers"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewayExternalNetwork:NsxtEdgegatewayExternalNetwork": {
            "properties": {
                "allocatedIpCount": {
                    "type": "integer",
                    "description": "Number of allocated IPs\n"
                },
                "externalNetworkId": {
                    "type": "string",
                    "description": "An external network ID. **Note:** Data source [vcd.ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)\ncan be used to lookup ID by name.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway IP Address\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address exposed for an easy access without nesting.\n"
                }
            },
            "type": "object",
            "required": [
                "allocatedIpCount",
                "externalNetworkId",
                "gateway",
                "prefixLength"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allocatedIpCount",
                        "externalNetworkId",
                        "gateway",
                        "prefixLength",
                        "primaryIp"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewayL2VpnTunnelStretchedNetwork:NsxtEdgegatewayL2VpnTunnelStretchedNetwork": {
            "properties": {
                "networkId": {
                    "type": "string",
                    "description": "ID of the Org VDC network\n"
                },
                "tunnelId": {
                    "type": "integer",
                    "description": "Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.\n"
                }
            },
            "type": "object",
            "required": [
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "networkId",
                        "tunnelId"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewayStaticRouteNextHop:NsxtEdgegatewayStaticRouteNextHop": {
            "properties": {
                "adminDistance": {
                    "type": "integer",
                    "description": "Admin distance of next hop\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP Address of next hop\n"
                },
                "scope": {
                    "$ref": "#/types/vcd:index/NsxtEdgegatewayStaticRouteNextHopScope:NsxtEdgegatewayStaticRouteNextHopScope"
                }
            },
            "type": "object",
            "required": [
                "adminDistance",
                "ipAddress"
            ]
        },
        "vcd:index/NsxtEdgegatewayStaticRouteNextHopScope:NsxtEdgegatewayStaticRouteNextHopScope": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of Scope element\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for NSX-T Edge Gateway Static Route\n"
                },
                "type": {
                    "type": "string",
                    "description": "Scope type - One of 'NETWORK', 'SYSTEM_OWNED'\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewaySubnet:NsxtEdgegatewaySubnet": {
            "properties": {
                "allocatedIps": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnetAllocatedIp:NsxtEdgegatewaySubnetAllocatedIp"
                    },
                    "description": "Define one or more blocks to sub-allocate pools on the edge gateway\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address exposed for an easy access without nesting.\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "prefixLength"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allocatedIps",
                        "gateway",
                        "prefixLength"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewaySubnetAllocatedIp:NsxtEdgegatewaySubnetAllocatedIp": {
            "properties": {
                "endAddress": {
                    "type": "string"
                },
                "startAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NsxtEdgegatewaySubnetWithIpCount:NsxtEdgegatewaySubnetWithIpCount": {
            "properties": {
                "allocatedIpCount": {
                    "type": "integer",
                    "description": "Number of IP addresses to allocate\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address exposed for an easy access without nesting.\n"
                }
            },
            "type": "object",
            "required": [
                "allocatedIpCount",
                "gateway",
                "prefixLength"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allocatedIpCount",
                        "gateway",
                        "prefixLength",
                        "primaryIp"
                    ]
                }
            }
        },
        "vcd:index/NsxtEdgegatewaySubnetWithTotalIpCount:NsxtEdgegatewaySubnetWithTotalIpCount": {
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address exposed for an easy access without nesting.\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "prefixLength"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "gateway",
                        "prefixLength",
                        "primaryIp"
                    ]
                }
            }
        },
        "vcd:index/NsxtFirewallRule:NsxtFirewallRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Defines if the rule should 'ALLOW', 'DROP' or 'REJECT' matching traffic\n"
                },
                "appPortProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Application Port Profile IDs. Leaving it empty means 'Any'\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defined if Firewall Rule is active\n"
                },
                "id": {
                    "type": "string",
                    "description": "Firewall Rule ID\n"
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines if matching traffic should be logged\n"
                },
                "name": {
                    "type": "string",
                    "description": "Firewall Rule name\n"
                },
                "sourceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "direction",
                "ipProtocol",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "direction",
                        "id",
                        "ipProtocol",
                        "name"
                    ]
                }
            }
        },
        "vcd:index/NsxtIpsecVpnTunnelSecurityProfileCustomization:NsxtIpsecVpnTunnelSecurityProfileCustomization": {
            "properties": {
                "dpdProbeInternal": {
                    "type": "integer",
                    "description": "Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds\n"
                },
                "ikeDhGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21\n"
                },
                "ikeDigestAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512\n"
                },
                "ikeEncryptionAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512\n"
                },
                "ikeSaLifetime": {
                    "type": "integer",
                    "description": "Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish\n"
                },
                "ikeVersion": {
                    "type": "string",
                    "description": "IKE version one of IKE_V1, IKE_V2, IKE_FLEX\n"
                },
                "tunnelDfPolicy": {
                    "type": "string",
                    "description": "Policy for handling defragmentation bit. One of COPY, CLEAR\n"
                },
                "tunnelDhGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21\n"
                },
                "tunnelDigestAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512\n"
                },
                "tunnelEncryptionAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION\n"
                },
                "tunnelPfsEnabled": {
                    "type": "boolean",
                    "description": "Perfect Forward Secrecy Enabled or Disabled. Default (enabled)\n"
                },
                "tunnelSaLifetime": {
                    "type": "integer",
                    "description": "Security Association life time (in seconds)\n"
                }
            },
            "type": "object",
            "required": [
                "ikeDhGroups",
                "ikeEncryptionAlgorithms",
                "ikeVersion",
                "tunnelDhGroups",
                "tunnelEncryptionAlgorithms"
            ]
        },
        "vcd:index/NsxtNetworkDhcpBindingDhcpV4Config:NsxtNetworkDhcpBindingDhcpV4Config": {
            "properties": {
                "gatewayIpAddress": {
                    "type": "string",
                    "description": "IPv4 gateway address\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname for the DHCP client\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtNetworkDhcpBindingDhcpV6Config:NsxtNetworkDhcpBindingDhcpV6Config": {
            "properties": {
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of domain names\n"
                },
                "sntpServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of SNTP servers\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxtNetworkDhcpPool:NsxtNetworkDhcpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of DHCP pool IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of DHCP pool IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NsxtNetworkImportedSecondaryStaticIpPool:NsxtNetworkImportedSecondaryStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NsxtNetworkImportedStaticIpPool:NsxtNetworkImportedStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/NsxtSecurityGroupMemberVm:NsxtSecurityGroupMemberVm": {
            "properties": {
                "vappId": {
                    "type": "string",
                    "description": "Parent vApp name (if exists) for member VM\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "Parent vApp ID (if exists) for member VM\n"
                },
                "vmId": {
                    "type": "string",
                    "description": "Member VM ID\n"
                },
                "vmName": {
                    "type": "string",
                    "description": "Member VM Name\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "vappId",
                        "vappName",
                        "vmId",
                        "vmName"
                    ]
                }
            }
        },
        "vcd:index/NsxvDhcpRelayRelayAgent:NsxvDhcpRelayRelayAgent": {
            "properties": {
                "gatewayIpAddress": {
                    "type": "string",
                    "description": "Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Org network which is to be used for relaying DHCP message to specified servers\n"
                }
            },
            "type": "object",
            "required": [
                "networkName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "gatewayIpAddress",
                        "networkName"
                    ]
                }
            }
        },
        "vcd:index/NsxvDistributedFirewallRule:NsxvDistributedFirewallRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action of the rule (allow, deny)\n"
                },
                "applications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDistributedFirewallRuleApplication:NsxvDistributedFirewallRuleApplication"
                    },
                    "description": "Application definitions for this rule. An empty value means 'any'\n"
                },
                "appliedTos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDistributedFirewallRuleAppliedTo:NsxvDistributedFirewallRuleAppliedTo"
                    },
                    "description": "List of elements to which this rule applies\n"
                },
                "destinations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDistributedFirewallRuleDestination:NsxvDistributedFirewallRuleDestination"
                    },
                    "description": "List of destination traffic for this rule. An empty value means 'any'\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction of the rule (in, out, inout)\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Shows whether the NSX-V Distributed Firewall is enabled.\n"
                },
                "excludeDestination": {
                    "type": "boolean",
                    "description": "If true, the content of the destination elements is reversed\n"
                },
                "excludeSource": {
                    "type": "boolean",
                    "description": "If true, the content of the source elements is reversed\n"
                },
                "id": {
                    "type": "integer",
                    "description": "Firewall Rule ID\n"
                },
                "logged": {
                    "type": "boolean",
                    "description": "Whether the rule traffic is logged\n"
                },
                "name": {
                    "type": "string",
                    "description": "Firewall Rule name\n"
                },
                "packetType": {
                    "type": "string",
                    "description": "Packet type of the rule (any, ipv4, ipv6)\n"
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDistributedFirewallRuleSource:NsxvDistributedFirewallRuleSource"
                    },
                    "description": "List of source traffic for this rule. An empty value means 'any'\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "appliedTos",
                "direction"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "appliedTos",
                        "direction",
                        "id"
                    ]
                }
            }
        },
        "vcd:index/NsxvDistributedFirewallRuleApplication:NsxvDistributedFirewallRuleApplication": {
            "properties": {
                "destinationPort": {
                    "type": "string",
                    "description": "Destination port for this application. Leaving it empty means 'any' port\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of application (Application, ApplicationGroup)\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)\n"
                },
                "sourcePort": {
                    "type": "string",
                    "description": "Source port for this application. Leaving it empty means 'any' port\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of application\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the application\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxvDistributedFirewallRuleAppliedTo:NsxvDistributedFirewallRuleAppliedTo": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the applied-to entity\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the applied-to entity\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ]
        },
        "vcd:index/NsxvDistributedFirewallRuleDestination:NsxvDistributedFirewallRuleDestination": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the destination entity\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the destination entity\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ]
        },
        "vcd:index/NsxvDistributedFirewallRuleSource:NsxvDistributedFirewallRuleSource": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the source entity\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the source entity\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ]
        },
        "vcd:index/NsxvFirewallRuleDestination:NsxvFirewallRuleDestination": {
            "properties": {
                "exclude": {
                    "type": "boolean",
                    "description": "Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'\n"
                },
                "gatewayInterfaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "'vse', 'internal', 'external' or network name\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address, CIDR, an IP range, or the keyword 'any'\n"
                },
                "ipSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IP set names\n"
                },
                "orgNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of org network names\n"
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of VM IDs\n"
                }
            },
            "type": "object"
        },
        "vcd:index/NsxvFirewallRuleService:NsxvFirewallRuleService": {
            "properties": {
                "port": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string"
                },
                "sourcePort": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "port",
                        "protocol",
                        "sourcePort"
                    ]
                }
            }
        },
        "vcd:index/NsxvFirewallRuleSource:NsxvFirewallRuleSource": {
            "properties": {
                "exclude": {
                    "type": "boolean",
                    "description": "Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'\n"
                },
                "gatewayInterfaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "'vse', 'internal', 'external' or network name\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address, CIDR, an IP range, or the keyword 'any'\n"
                },
                "ipSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IP set names\n"
                },
                "orgNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of org network names\n"
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of VM IDs\n"
                }
            },
            "type": "object"
        },
        "vcd:index/OrgAccountLockout:OrgAccountLockout": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether account lockout is enabled or not\n"
                },
                "invalidLoginsBeforeLockout": {
                    "type": "integer",
                    "description": "Number of login attempts that will trigger an account lockout for the given user\n"
                },
                "lockoutIntervalMinutes": {
                    "type": "integer",
                    "description": "Once a user is locked out, they will not be able to log back in for this time period\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "invalidLoginsBeforeLockout",
                "lockoutIntervalMinutes"
            ]
        },
        "vcd:index/OrgLdapCustomSettings:OrgLdapCustomSettings": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "authentication method: one of SIMPLE, MD5DIGEST, NTLM\n"
                },
                "baseDistinguishedName": {
                    "type": "string",
                    "description": "LDAP search base\n"
                },
                "connectorType": {
                    "type": "string",
                    "description": "type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY\n"
                },
                "groupAttributes": {
                    "$ref": "#/types/vcd:index/OrgLdapCustomSettingsGroupAttributes:OrgLdapCustomSettingsGroupAttributes",
                    "description": "Group settings when `ldap_mode` is CUSTOM\n"
                },
                "isSsl": {
                    "type": "boolean",
                    "description": "True if the LDAP service requires an SSL connection\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed\n",
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "Port number for LDAP service\n"
                },
                "server": {
                    "type": "string",
                    "description": "host name or IP of the LDAP server\n"
                },
                "userAttributes": {
                    "$ref": "#/types/vcd:index/OrgLdapCustomSettingsUserAttributes:OrgLdapCustomSettingsUserAttributes",
                    "description": "User settings when `ldap_mode` is CUSTOM\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn=\"ldap-admin\", c=\"example\", dc=\"com\")\n"
                }
            },
            "type": "object",
            "required": [
                "authenticationMethod",
                "connectorType",
                "groupAttributes",
                "port",
                "server",
                "userAttributes"
            ]
        },
        "vcd:index/OrgLdapCustomSettingsGroupAttributes:OrgLdapCustomSettingsGroupAttributes": {
            "properties": {
                "groupBackLinkIdentifier": {
                    "type": "string",
                    "description": "LDAP group attribute used to identify a group member\n"
                },
                "groupMembershipIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute that identifies a group as a member of another group. For example, dn\n"
                },
                "membership": {
                    "type": "string",
                    "description": "LDAP attribute to use when getting the members of a group. For example, member\n"
                },
                "name": {
                    "type": "string",
                    "description": "LDAP attribute to use for the group name. For example, cn\n"
                },
                "objectClass": {
                    "type": "string",
                    "description": "LDAP objectClass of which imported groups are members. For example, group\n"
                },
                "uniqueIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute to use as the unique identifier for a group. For example, objectGuid\n"
                }
            },
            "type": "object",
            "required": [
                "groupMembershipIdentifier",
                "membership",
                "name",
                "objectClass",
                "uniqueIdentifier"
            ]
        },
        "vcd:index/OrgLdapCustomSettingsUserAttributes:OrgLdapCustomSettingsUserAttributes": {
            "properties": {
                "displayName": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's full name. For example, displayName\n"
                },
                "email": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's email address. For example, mail\n"
                },
                "givenName": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's given name. For example, givenName\n"
                },
                "groupBackLinkIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute that returns the identifiers of all the groups of which the user is a member\n"
                },
                "groupMembershipIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute that identifies a user as a member of a group. For example, dn\n"
                },
                "objectClass": {
                    "type": "string",
                    "description": "LDAP objectClass of which imported users are members. For example, user or person\n"
                },
                "surname": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's surname. For example, sn\n"
                },
                "telephone": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's telephone number. For example, telephoneNumber\n"
                },
                "uniqueIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute to use as the unique identifier for a user. For example, objectGuid\n"
                },
                "username": {
                    "type": "string",
                    "description": "LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName\n"
                }
            },
            "type": "object",
            "required": [
                "displayName",
                "email",
                "givenName",
                "groupMembershipIdentifier",
                "objectClass",
                "surname",
                "telephone",
                "uniqueIdentifier",
                "username"
            ]
        },
        "vcd:index/OrgMetadataEntry:OrgMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/OrgOidcClaimsMapping:OrgOidcClaimsMapping": {
            "properties": {
                "email": {
                    "type": "string",
                    "description": "Required if `wellknown_endpoint` doesn't give info about it\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "Required if `wellknown_endpoint` doesn't give info about it\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "Required if `wellknown_endpoint` doesn't give info about it\n"
                },
                "groups": {
                    "type": "string",
                    "description": "Optional\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Required if `wellknown_endpoint` doesn't give info about it\n"
                },
                "roles": {
                    "type": "string",
                    "description": "Optional\n"
                },
                "subject": {
                    "type": "string",
                    "description": "Required if `wellknown_endpoint` doesn't give info about it\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "email",
                        "firstName",
                        "fullName",
                        "groups",
                        "lastName",
                        "roles",
                        "subject"
                    ]
                }
            }
        },
        "vcd:index/OrgOidcKey:OrgOidcKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Algorithm used by the key. Can be `RSA` or `EC`\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The contents of a PEM file to create/update the key\n"
                },
                "expirationDate": {
                    "type": "string",
                    "description": "Expiration date for the key. The accepted format is `YYYY-MM-DD`, like `2077-12-31`\n"
                },
                "id": {
                    "type": "string",
                    "description": "Identifier of the key\n"
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "certificate",
                "id"
            ]
        },
        "vcd:index/OrgVappLease:OrgVappLease": {
            "properties": {
                "deleteOnStorageLeaseExpiration": {
                    "type": "boolean",
                    "description": "If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.\n"
                },
                "maximumRuntimeLeaseInSec": {
                    "type": "integer",
                    "description": "How long vApps can run before they are automatically stopped (in seconds). 0 means never expires\n"
                },
                "maximumStorageLeaseInSec": {
                    "type": "integer",
                    "description": "How long stopped vApps are available before being automatically cleaned up (in seconds). 0 means never expires\n"
                },
                "powerOffOnRuntimeLeaseExpiration": {
                    "type": "boolean",
                    "description": "When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires\n"
                }
            },
            "type": "object",
            "required": [
                "deleteOnStorageLeaseExpiration",
                "maximumRuntimeLeaseInSec",
                "maximumStorageLeaseInSec",
                "powerOffOnRuntimeLeaseExpiration"
            ]
        },
        "vcd:index/OrgVappTemplateLease:OrgVappTemplateLease": {
            "properties": {
                "deleteOnStorageLeaseExpiration": {
                    "type": "boolean",
                    "description": "If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted\n"
                },
                "maximumStorageLeaseInSec": {
                    "type": "integer",
                    "description": "How long vApp templates are available before being automatically cleaned up (in seconds). 0 means never expires\n"
                }
            },
            "type": "object",
            "required": [
                "deleteOnStorageLeaseExpiration",
                "maximumStorageLeaseInSec"
            ]
        },
        "vcd:index/OrgVdcAccessControlSharedWith:OrgVdcAccessControlSharedWith": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the user or group to which we are sharing. (Only `ReadOnly` is available)\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of a group which we are sharing with. Required if `user_id` is not set.\n"
                },
                "subjectName": {
                    "type": "string",
                    "description": "The name of the subject (group or user) which we are sharing with.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of a user which we are sharing with. Required if `group_id` is not set.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "subjectName"
                    ]
                }
            }
        },
        "vcd:index/OrgVdcComputeCapacity:OrgVdcComputeCapacity": {
            "properties": {
                "cpu": {
                    "$ref": "#/types/vcd:index/OrgVdcComputeCapacityCpu:OrgVdcComputeCapacityCpu"
                },
                "memory": {
                    "$ref": "#/types/vcd:index/OrgVdcComputeCapacityMemory:OrgVdcComputeCapacityMemory"
                }
            },
            "type": "object",
            "required": [
                "cpu",
                "memory"
            ]
        },
        "vcd:index/OrgVdcComputeCapacityCpu:OrgVdcComputeCapacityCpu": {
            "properties": {
                "allocated": {
                    "type": "integer",
                    "description": "Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).\n"
                },
                "reserved": {
                    "type": "integer"
                },
                "used": {
                    "type": "integer"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allocated",
                        "limit",
                        "reserved",
                        "used"
                    ]
                }
            }
        },
        "vcd:index/OrgVdcComputeCapacityMemory:OrgVdcComputeCapacityMemory": {
            "properties": {
                "allocated": {
                    "type": "integer",
                    "description": "Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).\n"
                },
                "reserved": {
                    "type": "integer"
                },
                "used": {
                    "type": "integer"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allocated",
                        "limit",
                        "reserved",
                        "used"
                    ]
                }
            }
        },
        "vcd:index/OrgVdcMetadataEntry:OrgVdcMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/OrgVdcStorageProfile:OrgVdcStorageProfile": {
            "properties": {
                "default": {
                    "type": "boolean",
                    "description": "True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if this VDC is enabled for use by the organization VDCs. Default is true.\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.\n"
                },
                "name": {
                    "type": "string",
                    "description": "VDC name\n"
                },
                "storageUsedInMb": {
                    "type": "integer",
                    "description": "Storage used in MB\n"
                }
            },
            "type": "object",
            "required": [
                "default",
                "limit",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "default",
                        "limit",
                        "name",
                        "storageUsedInMb"
                    ]
                }
            }
        },
        "vcd:index/OrgVdcTemplateComputeConfiguration:OrgVdcTemplateComputeConfiguration": {
            "properties": {
                "cpuAllocated": {
                    "type": "integer",
                    "description": "The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template. Minimum is 256MHz\n"
                },
                "cpuGuaranteed": {
                    "type": "integer",
                    "description": "The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. Minimum is 256MHz. 0 means unlimited\n"
                },
                "cpuSpeed": {
                    "type": "integer",
                    "description": "Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM. Minimum is 256MHz\n"
                },
                "elasticity": {
                    "type": "boolean",
                    "description": "True if compute capacity can grow or shrink based on demand\n"
                },
                "includeVmMemoryOverhead": {
                    "type": "boolean",
                    "description": "True if the instantiated VDC includes memory overhead into its accounting for admission control\n"
                },
                "memoryAllocated": {
                    "type": "integer",
                    "description": "The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template\n"
                },
                "memoryGuaranteed": {
                    "type": "integer",
                    "description": "The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The limit amount of Memory, in MB, of the VDC that is instantiated from this template. Minimum is 1024MB. 0 means unlimited\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cpuLimit",
                        "elasticity",
                        "includeVmMemoryOverhead"
                    ]
                }
            }
        },
        "vcd:index/OrgVdcTemplateEdgeGateway:OrgVdcTemplateEdgeGateway": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the Edge Gateway\n"
                },
                "ipAllocationCount": {
                    "type": "integer",
                    "description": "Allocated IPs for the Edge Gateway. Defaults to 0\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Edge Gateway\n"
                },
                "routedNetworkDescription": {
                    "type": "string",
                    "description": "Description of the routed network to create with the Edge Gateway\n"
                },
                "routedNetworkGatewayCidr": {
                    "type": "string",
                    "description": "CIDR of the Edge Gateway for the created routed network\n"
                },
                "routedNetworkName": {
                    "type": "string",
                    "description": "Name of the routed network to create with the Edge Gateway\n"
                },
                "staticIpPool": {
                    "$ref": "#/types/vcd:index/OrgVdcTemplateEdgeGatewayStaticIpPool:OrgVdcTemplateEdgeGatewayStaticIpPool",
                    "description": "**One block** with a single IP range (this is a constraint due to a bug in VCD 10.5+) that has two properties: `start_address`, the start address of the IP range;\n`end_address`, the end address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "routedNetworkGatewayCidr",
                "routedNetworkName"
            ]
        },
        "vcd:index/OrgVdcTemplateEdgeGatewayStaticIpPool:OrgVdcTemplateEdgeGatewayStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/OrgVdcTemplateProviderVdc:OrgVdcTemplateProviderVdc": {
            "properties": {
                "externalNetworkId": {
                    "type": "string",
                    "description": "ID of the Provider Gateway to use, can be obtained with\n[`vcd.ExternalNetworkV2` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)\n"
                },
                "gatewayEdgeClusterId": {
                    "type": "string",
                    "description": "ID of the Edge Cluster that the VDCs instantiated from this template will use with the Edge Gateway.\nCan be obtained with [`vcd.getNsxtEdgeCluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster).\nIf set, a `edge_gateway` block **must** be present in the VDC Template configuration (see below).\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the Provider VDC, can be obtained with\n[`vcd.ProviderVdc` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc)\n"
                },
                "servicesEdgeClusterId": {
                    "type": "string",
                    "description": "ID of the Edge Cluster that the VDCs instantiated from this template will use for services.\nCan be obtained with [`vcd.getNsxtEdgeCluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster)\n"
                }
            },
            "type": "object",
            "required": [
                "externalNetworkId",
                "id"
            ]
        },
        "vcd:index/OrgVdcTemplateStorageProfile:OrgVdcTemplateStorageProfile": {
            "properties": {
                "default": {
                    "type": "boolean",
                    "description": "True if this is default storage profile for the VDCs instantiated from this template. Only **one** block should have this set to `true`\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Storage limit for the VDCs instantiated from this template, in MB. 0 means unlimited\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Provider VDC storage profile to use for the VDCs instantiated from this template\n"
                }
            },
            "type": "object",
            "required": [
                "default",
                "limit",
                "name"
            ]
        },
        "vcd:index/ProviderIgnoreMetadataChange:ProviderIgnoreMetadataChange": {
            "properties": {
                "conflictAction": {
                    "type": "string"
                },
                "keyRegex": {
                    "type": "string",
                    "description": "Regular expression of the metadata entry keys to ignore. Either `key_regex` or `value_regex` is required\n"
                },
                "resourceName": {
                    "type": "string",
                    "description": "Ignores metadata from the specific entity in VCD named like this argument\n"
                },
                "resourceType": {
                    "type": "string",
                    "description": "Ignores metadata from the specific resource type\n"
                },
                "valueRegex": {
                    "type": "string",
                    "description": "Regular expression of the metadata entry values to ignore. Either `key_regex` or `value_regex` is required\n"
                }
            },
            "type": "object"
        },
        "vcd:index/ProviderVdcComputeCapacity:ProviderVdcComputeCapacity": {
            "properties": {
                "cpus": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ProviderVdcComputeCapacityCpus:ProviderVdcComputeCapacityCpus"
                    },
                    "description": "Single-element list with an indicator of CPU capacity available in the Provider VDC\n"
                },
                "isElastic": {
                    "type": "boolean",
                    "description": "True if compute capacity can grow or shrink based on demand\n"
                },
                "isHa": {
                    "type": "boolean",
                    "description": "True if compute capacity is highly available\n"
                },
                "memories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ProviderVdcComputeCapacityMemory:ProviderVdcComputeCapacityMemory"
                    },
                    "description": "Single-element list with an indicator of Memory capacity available in the Provider VDC\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cpus",
                        "isElastic",
                        "isHa",
                        "memories"
                    ]
                }
            }
        },
        "vcd:index/ProviderVdcComputeCapacityCpus:ProviderVdcComputeCapacityCpus": {
            "properties": {
                "allocation": {
                    "type": "integer",
                    "description": "Allocated CPU for this Provider VDC\n"
                },
                "overhead": {
                    "type": "integer",
                    "description": "CPU overhead for this Provider VDC\n"
                },
                "reserved": {
                    "type": "integer",
                    "description": "Reserved CPU for this Provider VDC\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total CPU for this Provider VDC\n"
                },
                "units": {
                    "type": "string",
                    "description": "Units for the CPU of this Provider VDC\n"
                },
                "used": {
                    "type": "integer",
                    "description": "Used CPU in this Provider VDC\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allocation",
                        "overhead",
                        "reserved",
                        "total",
                        "units",
                        "used"
                    ]
                }
            }
        },
        "vcd:index/ProviderVdcComputeCapacityMemory:ProviderVdcComputeCapacityMemory": {
            "properties": {
                "allocation": {
                    "type": "integer",
                    "description": "Allocated Memory for this Provider VDC\n"
                },
                "overhead": {
                    "type": "integer",
                    "description": "Memory overhead for this Provider VDC\n"
                },
                "reserved": {
                    "type": "integer",
                    "description": "Reserved Memory for this Provider VDC\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total Memory for this Provider VDC\n"
                },
                "units": {
                    "type": "string",
                    "description": "Units for the Memory of this Provider VDC\n"
                },
                "used": {
                    "type": "integer",
                    "description": "Used Memory in this Provider VDC\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allocation",
                        "overhead",
                        "reserved",
                        "total",
                        "units",
                        "used"
                    ]
                }
            }
        },
        "vcd:index/ProviderVdcMetadataEntry:ProviderVdcMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL. Defaults to false\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'. Defaults to 'MetadataStringValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'. Defaults to 'READWRITE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/RdeMetadataEntry:RdeMetadataEntry": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "Only meaningful for providers. Allows them to share entries with their tenants. Currently, accepted values are: `TENANT`, `PROVIDER`\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the metadata entry\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace of the metadata entry\n"
                },
                "persistent": {
                    "type": "boolean",
                    "description": "Persistent metadata entries can be copied over on some entity operation\n"
                },
                "readonly": {
                    "type": "boolean",
                    "description": "True if the metadata entry is read only\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "key",
                        "value"
                    ]
                }
            }
        },
        "vcd:index/RdeTypeHook:RdeTypeHook": {
            "properties": {
                "behaviorId": {
                    "type": "string",
                    "description": "Existing Behavior that will be automatically invoked when any RDE of this RDE Type triggers the event.\n"
                },
                "event": {
                    "type": "string",
                    "description": "Event that will invoke the Behavior, one of `PostCreate`, `PostUpdate`, `PreDelete`, `PostDelete`.\n"
                }
            },
            "type": "object",
            "required": [
                "behaviorId",
                "event"
            ]
        },
        "vcd:index/SolutionLandingZoneCatalog:SolutionLandingZoneCatalog": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Capability set for catalog\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of catalog\n"
                },
                "name": {
                    "type": "string",
                    "description": "Catalog Name\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "vcd:index/SolutionLandingZoneVdc:SolutionLandingZoneVdc": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Capability set for VDC\n"
                },
                "computePolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/SolutionLandingZoneVdcComputePolicy:SolutionLandingZoneVdcComputePolicy"
                    },
                    "description": "Structure for Compute Policy\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of VDC\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Defines if the entity should be considered as default\n"
                },
                "name": {
                    "type": "string",
                    "description": "VDC Name\n"
                },
                "orgVdcNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/SolutionLandingZoneVdcOrgVdcNetwork:SolutionLandingZoneVdcOrgVdcNetwork"
                    },
                    "description": "Structure for Org VDC Network\n"
                },
                "storagePolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/SolutionLandingZoneVdcStoragePolicy:SolutionLandingZoneVdcStoragePolicy"
                    },
                    "description": "Structure for Storage Policy\n"
                }
            },
            "type": "object",
            "required": [
                "computePolicies",
                "id",
                "isDefault",
                "orgVdcNetworks",
                "storagePolicies"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "computePolicies",
                        "id",
                        "isDefault",
                        "name",
                        "orgVdcNetworks",
                        "storagePolicies"
                    ]
                }
            }
        },
        "vcd:index/SolutionLandingZoneVdcComputePolicy:SolutionLandingZoneVdcComputePolicy": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of capabilities for Compute Policy\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of Compute Policy\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Boolean value that marks if this Compute Policy should be default\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Compute Policy\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "vcd:index/SolutionLandingZoneVdcOrgVdcNetwork:SolutionLandingZoneVdcOrgVdcNetwork": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of capabilities for Org VDC Network\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of Org VDC Network\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Boolean value that marks if this Org VDC Network should be default\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Org VDC Network\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "vcd:index/SolutionLandingZoneVdcStoragePolicy:SolutionLandingZoneVdcStoragePolicy": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of capabilities for Storage Policy\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of Storage Policy\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Boolean value that marks if this Storage Policy should be default\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Storage Policy\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "vcd:index/VappAccessControlSharedWith:VappAccessControlSharedWith": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the user or group to which we are sharing. (One of `ReadOnly`, `Change`, `FullControl`)\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of a group with which we are sharing. Required if `user_id` is not set.\n"
                },
                "subjectName": {
                    "type": "string",
                    "description": "the name of the subject (group or user) with which we are sharing.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of a user with which we are sharing. Required if `group_id` is not set.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "subjectName"
                    ]
                }
            }
        },
        "vcd:index/VappFirewallRulesRule:VappFirewallRulesRule": {
            "properties": {
                "destinationIp": {
                    "type": "string",
                    "description": "Destination IP address to which the rule applies. A value of `Any` matches any IP address.\n"
                },
                "destinationPort": {
                    "type": "string",
                    "description": "Destination port to which this rule applies.\n"
                },
                "destinationVmId": {
                    "type": "string",
                    "description": "Destination VM identifier\n"
                },
                "destinationVmIpType": {
                    "type": "string",
                    "description": "The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.\n"
                },
                "destinationVmNicId": {
                    "type": "integer",
                    "description": "Destination VM NIC ID to which this rule applies.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "'true' value will enable rule logging. Default is false\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable firewall. Default is `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Rule name\n"
                },
                "policy": {
                    "type": "string",
                    "description": "One of: `drop` (drop packets that match the rule), `allow` (allow packets that match the rule to pass through the firewall)\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Specify the protocols to which the rule should be applied. One of: `any`, `icmp`, `tcp`, `udp`, `tcp\u0026udp`\n"
                },
                "sourceIp": {
                    "type": "string",
                    "description": "Source IP address to which the rule applies. A value of `Any` matches any IP address.\n"
                },
                "sourcePort": {
                    "type": "string",
                    "description": "Source port to which this rule applies.\n"
                },
                "sourceVmId": {
                    "type": "string",
                    "description": "Source VM identifier\n"
                },
                "sourceVmIpType": {
                    "type": "string",
                    "description": "The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.\n"
                },
                "sourceVmNicId": {
                    "type": "integer",
                    "description": "Source VM NIC ID to which this rule applies.\n"
                }
            },
            "type": "object"
        },
        "vcd:index/VappLease:VappLease": {
            "properties": {
                "runtimeLeaseInSec": {
                    "type": "integer",
                    "description": "How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.\n"
                },
                "storageLeaseInSec": {
                    "type": "integer",
                    "description": "How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.\n"
                }
            },
            "type": "object",
            "required": [
                "runtimeLeaseInSec",
                "storageLeaseInSec"
            ]
        },
        "vcd:index/VappMetadataEntry:VappMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/VappNatRulesRule:VappNatRulesRule": {
            "properties": {
                "externalIp": {
                    "type": "string",
                    "description": "External IP address to forward to or External IP address to map to VM\n"
                },
                "externalPort": {
                    "type": "integer",
                    "description": "External port to forward.\n"
                },
                "forwardToPort": {
                    "type": "integer",
                    "description": "Internal port to forward.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the rule. Can be used to track syslog messages.\n"
                },
                "mappingMode": {
                    "type": "string",
                    "description": "Mapping mode. One of: `automatic`, `manual`\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Protocol to forward. One of: `TCP` (forward TCP packets), `UDP` (forward UDP packets), `TCP_UDP` (forward TCP and UDP packets).\n"
                },
                "vmId": {
                    "type": "string",
                    "description": "VM to which this rule applies.\n"
                },
                "vmNicId": {
                    "type": "integer",
                    "description": "VM NIC ID to which this rule applies.\n"
                }
            },
            "type": "object",
            "required": [
                "vmId",
                "vmNicId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "externalIp",
                        "id",
                        "vmId",
                        "vmNicId"
                    ]
                }
            }
        },
        "vcd:index/VappNetworkDhcpPool:VappNetworkDhcpPool": {
            "properties": {
                "defaultLeaseTime": {
                    "type": "integer"
                },
                "enabled": {
                    "type": "boolean"
                },
                "endAddress": {
                    "type": "string"
                },
                "maxLeaseTime": {
                    "type": "integer"
                },
                "startAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "startAddress"
            ]
        },
        "vcd:index/VappNetworkStaticIpPool:VappNetworkStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string"
                },
                "startAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ]
        },
        "vcd:index/VappStaticRoutingRule:VappStaticRoutingRule": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name for the static route.\n"
                },
                "networkCidr": {
                    "type": "string",
                    "description": "network specification in CIDR.\n"
                },
                "nextHopIp": {
                    "type": "string",
                    "description": "IP Address of Next Hop router/gateway.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "networkCidr",
                "nextHopIp"
            ]
        },
        "vcd:index/VappVmBootOptions:VappVmBootOptions": {
            "properties": {
                "bootDelay": {
                    "type": "integer",
                    "description": "Number of milliseconds to wait between powering-on and booting the VM\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired\n"
                },
                "efiSecureBoot": {
                    "type": "boolean",
                    "description": "If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.\n"
                },
                "enterBiosSetupOnNextBoot": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bootDelay",
                        "bootRetryDelay",
                        "bootRetryEnabled",
                        "efiSecureBoot"
                    ]
                }
            }
        },
        "vcd:index/VappVmCustomization:VappVmCustomization": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "Manually specify admin password\n",
                    "secret": true
                },
                "allowLocalAdminPassword": {
                    "type": "boolean",
                    "description": "Allow local administrator password\n"
                },
                "autoGeneratePassword": {
                    "type": "boolean",
                    "description": "Auto generate password\n"
                },
                "changeSid": {
                    "type": "boolean",
                    "description": "'true' value will change SID. Applicable only for Windows VMs\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "'true' value will enable guest customization. It may occur on first boot or when 'force' is used\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "'true' value will cause the VM to reboot on every 'apply' operation\n"
                },
                "initscript": {
                    "type": "string",
                    "description": "Script to run on initial boot or with customization.force=true set\n"
                },
                "joinDomain": {
                    "type": "boolean",
                    "description": "Enable this VM to join a domain\n"
                },
                "joinDomainAccountOu": {
                    "type": "string",
                    "description": "Account organizational unit for domain name join\n"
                },
                "joinDomainName": {
                    "type": "string",
                    "description": "Custom domain name for join\n"
                },
                "joinDomainPassword": {
                    "type": "string",
                    "description": "Password for custom domain name join\n",
                    "secret": true
                },
                "joinDomainUser": {
                    "type": "string",
                    "description": "Username for custom domain name join\n"
                },
                "joinOrgDomain": {
                    "type": "boolean",
                    "description": "Use organization's domain for joining\n"
                },
                "mustChangePasswordOnFirstLogin": {
                    "type": "boolean",
                    "description": "Require Administrator to change password on first login\n"
                },
                "numberOfAutoLogons": {
                    "type": "integer",
                    "description": "Number of times to log on automatically. '0' - disabled.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "adminPassword",
                        "allowLocalAdminPassword",
                        "autoGeneratePassword",
                        "changeSid",
                        "enabled",
                        "initscript",
                        "joinDomain",
                        "joinDomainAccountOu",
                        "joinDomainName",
                        "joinDomainPassword",
                        "joinDomainUser",
                        "joinOrgDomain",
                        "mustChangePasswordOnFirstLogin",
                        "numberOfAutoLogons"
                    ]
                }
            }
        },
        "vcd:index/VappVmDisk:VappVmDisk": {
            "properties": {
                "busNumber": {
                    "type": "string",
                    "description": "Bus number on which to place the disk controller\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "(*v2.7+*) Independent disk size in MB.\n"
                },
                "unitNumber": {
                    "type": "string",
                    "description": "Unit number (slot) on the bus specified by BusNumber\n"
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "name",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "busNumber",
                        "name",
                        "sizeInMb",
                        "unitNumber"
                    ]
                }
            }
        },
        "vcd:index/VappVmExtraConfig:VappVmExtraConfig": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key of the extra configuration item\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the extra configuration item is required\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the extra configuration item\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "required",
                        "value"
                    ]
                }
            }
        },
        "vcd:index/VappVmInternalDisk:VappVmInternalDisk": {
            "properties": {
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n"
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme\n"
                },
                "diskId": {
                    "type": "string",
                    "description": "The disk ID.\n"
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the default one\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Specifies whether the disk storage is pre-allocated or allocated on demand.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "busNumber",
                        "busType",
                        "diskId",
                        "iops",
                        "sizeInMb",
                        "storageProfile",
                        "thinProvisioned",
                        "unitNumber"
                    ]
                }
            }
        },
        "vcd:index/VappVmMetadataEntry:VappVmMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/VappVmNetwork:VappVmNetwork": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "It defines if NIC is connected or not.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL\n"
                },
                "ipAllocationMode": {
                    "type": "string",
                    "description": "IP address allocation mode. One of POOL, DHCP, MANUAL, NONE\n"
                },
                "isPrimary": {
                    "type": "boolean",
                    "description": "Set to true if network interface should be primary. First network card in the list will be primary by default\n"
                },
                "mac": {
                    "type": "string",
                    "description": "Mac address of network interface\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n"
                },
                "secondaryIp": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL\n"
                },
                "secondaryIpAllocationMode": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE\n"
                },
                "type": {
                    "type": "string",
                    "description": "Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAllocationMode",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "adapterType",
                        "ip",
                        "ipAllocationMode",
                        "isPrimary",
                        "mac",
                        "secondaryIp",
                        "secondaryIpAllocationMode",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/VappVmOverrideTemplateDisk:VappVmOverrideTemplateDisk": {
            "properties": {
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n",
                    "willReplaceOnChanges": true
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme\n",
                    "willReplaceOnChanges": true
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n",
                    "willReplaceOnChanges": true
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n",
                    "willReplaceOnChanges": true
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the default one\n",
                    "willReplaceOnChanges": true
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "busType",
                "sizeInMb",
                "unitNumber"
            ]
        },
        "vcd:index/VappVmSetExtraConfig:VappVmSetExtraConfig": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key of the extra configuration item\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/VdcGroupParticipatingOrgVdc:VdcGroupParticipatingOrgVdc": {
            "properties": {
                "faultDomainTag": {
                    "type": "string",
                    "description": "Represents the fault domain of a given organization VDC\n"
                },
                "isRemoteOrg": {
                    "type": "boolean",
                    "description": "Specifies whether the VDC is local to this VCD site\n"
                },
                "networkProviderScope": {
                    "type": "string",
                    "description": "Specifies the network provider scope of the VDC\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Organization VDC belongs\n"
                },
                "orgName": {
                    "type": "string",
                    "description": "Organization VDC belongs\n"
                },
                "siteId": {
                    "type": "string",
                    "description": "Site VDC belongs\n"
                },
                "siteName": {
                    "type": "string",
                    "description": "Site VDC belongs\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').\n"
                },
                "vdcId": {
                    "type": "string",
                    "description": "VDC ID\n"
                },
                "vdcName": {
                    "type": "string",
                    "description": "VDC name\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "faultDomainTag",
                        "isRemoteOrg",
                        "networkProviderScope",
                        "orgId",
                        "orgName",
                        "siteId",
                        "siteName",
                        "status",
                        "vdcId",
                        "vdcName"
                    ]
                }
            }
        },
        "vcd:index/VmBootOptions:VmBootOptions": {
            "properties": {
                "bootDelay": {
                    "type": "integer",
                    "description": "Number of milliseconds to wait between powering-on and booting the VM\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired\n"
                },
                "efiSecureBoot": {
                    "type": "boolean",
                    "description": "If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.\n"
                },
                "enterBiosSetupOnNextBoot": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bootDelay",
                        "bootRetryDelay",
                        "bootRetryEnabled",
                        "efiSecureBoot"
                    ]
                }
            }
        },
        "vcd:index/VmCustomization:VmCustomization": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "Manually specify admin password\n",
                    "secret": true
                },
                "allowLocalAdminPassword": {
                    "type": "boolean",
                    "description": "Allow local administrator password\n"
                },
                "autoGeneratePassword": {
                    "type": "boolean",
                    "description": "Auto generate password\n"
                },
                "changeSid": {
                    "type": "boolean",
                    "description": "'true' value will change SID. Applicable only for Windows VMs\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "'true' value will enable guest customization. It may occur on first boot or when 'force' is used\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "'true' value will cause the VM to reboot on every 'apply' operation\n"
                },
                "initscript": {
                    "type": "string",
                    "description": "Script to run on initial boot or with customization.force=true set\n"
                },
                "joinDomain": {
                    "type": "boolean",
                    "description": "Enable this VM to join a domain\n"
                },
                "joinDomainAccountOu": {
                    "type": "string",
                    "description": "Account organizational unit for domain name join\n"
                },
                "joinDomainName": {
                    "type": "string",
                    "description": "Custom domain name for join\n"
                },
                "joinDomainPassword": {
                    "type": "string",
                    "description": "Password for custom domain name join\n",
                    "secret": true
                },
                "joinDomainUser": {
                    "type": "string",
                    "description": "Username for custom domain name join\n"
                },
                "joinOrgDomain": {
                    "type": "boolean",
                    "description": "Use organization's domain for joining\n"
                },
                "mustChangePasswordOnFirstLogin": {
                    "type": "boolean",
                    "description": "Require Administrator to change password on first login\n"
                },
                "numberOfAutoLogons": {
                    "type": "integer",
                    "description": "Number of times to log on automatically. '0' - disabled.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "adminPassword",
                        "allowLocalAdminPassword",
                        "autoGeneratePassword",
                        "changeSid",
                        "enabled",
                        "initscript",
                        "joinDomain",
                        "joinDomainAccountOu",
                        "joinDomainName",
                        "joinDomainPassword",
                        "joinDomainUser",
                        "joinOrgDomain",
                        "mustChangePasswordOnFirstLogin",
                        "numberOfAutoLogons"
                    ]
                }
            }
        },
        "vcd:index/VmDisk:VmDisk": {
            "properties": {
                "busNumber": {
                    "type": "string",
                    "description": "Bus number on which to place the disk controller\n"
                },
                "name": {
                    "type": "string",
                    "description": "Independent disk name\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "unitNumber": {
                    "type": "string",
                    "description": "Unit number (slot) on the bus specified by BusNumber\n"
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "name",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "busNumber",
                        "name",
                        "sizeInMb",
                        "unitNumber"
                    ]
                }
            }
        },
        "vcd:index/VmExtraConfig:VmExtraConfig": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key of the extra configuration item\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the extra configuration item is required\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the extra configuration item\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "required",
                        "value"
                    ]
                }
            }
        },
        "vcd:index/VmInternalDisk:VmInternalDisk": {
            "properties": {
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n"
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme\n"
                },
                "diskId": {
                    "type": "string",
                    "description": "The disk ID.\n"
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the VM default one\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Specifies whether the disk storage is pre-allocated or allocated on demand.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "busNumber",
                        "busType",
                        "diskId",
                        "iops",
                        "sizeInMb",
                        "storageProfile",
                        "thinProvisioned",
                        "unitNumber"
                    ]
                }
            }
        },
        "vcd:index/VmMetadataEntry:VmMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry. Required if the metadata entry is not empty\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry. Required if the metadata entry is not empty\n"
                }
            },
            "type": "object"
        },
        "vcd:index/VmNetwork:VmNetwork": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "It defines if NIC is connected or not.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL\n"
                },
                "ipAllocationMode": {
                    "type": "string",
                    "description": "IP address allocation mode. One of POOL, DHCP, MANUAL, NONE\n"
                },
                "isPrimary": {
                    "type": "boolean",
                    "description": "Set to true if network interface should be primary. First network card in the list will be primary by default\n"
                },
                "mac": {
                    "type": "string",
                    "description": "Mac address of network interface\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the network this VM should connect to. Always required except for `type` `NONE`\n"
                },
                "secondaryIp": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL\n"
                },
                "secondaryIpAllocationMode": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE\n"
                },
                "type": {
                    "type": "string",
                    "description": "Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAllocationMode",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "adapterType",
                        "ip",
                        "ipAllocationMode",
                        "isPrimary",
                        "mac",
                        "secondaryIp",
                        "secondaryIpAllocationMode",
                        "type"
                    ]
                }
            }
        },
        "vcd:index/VmOverrideTemplateDisk:VmOverrideTemplateDisk": {
            "properties": {
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n",
                    "willReplaceOnChanges": true
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme\n",
                    "willReplaceOnChanges": true
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n",
                    "willReplaceOnChanges": true
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n",
                    "willReplaceOnChanges": true
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the VM default one\n",
                    "willReplaceOnChanges": true
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "busType",
                "sizeInMb",
                "unitNumber"
            ]
        },
        "vcd:index/VmSetExtraConfig:VmSetExtraConfig": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key of the extra configuration item\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/VmSizingPolicyCpu:VmSizingPolicyCpu": {
            "properties": {
                "coresPerSocket": {
                    "type": "string",
                    "description": "The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.\n",
                    "willReplaceOnChanges": true
                },
                "count": {
                    "type": "string",
                    "description": "Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.\n",
                    "willReplaceOnChanges": true
                },
                "limitInMhz": {
                    "type": "string",
                    "description": "Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited\n",
                    "willReplaceOnChanges": true
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n",
                    "willReplaceOnChanges": true
                },
                "speedInMhz": {
                    "type": "string",
                    "description": "Defines the vCPU speed of a core in MHz.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "vcd:index/VmSizingPolicyMemory:VmSizingPolicyMemory": {
            "properties": {
                "limitInMb": {
                    "type": "string",
                    "description": "Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.\n",
                    "willReplaceOnChanges": true
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n",
                    "willReplaceOnChanges": true
                },
                "sizeInMb": {
                    "type": "string",
                    "description": "Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "vcd:index/VmVgpuPolicyCpu:VmVgpuPolicyCpu": {
            "properties": {
                "coresPerSocket": {
                    "type": "string",
                    "description": "The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.\n",
                    "willReplaceOnChanges": true
                },
                "count": {
                    "type": "string",
                    "description": "Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.\n",
                    "willReplaceOnChanges": true
                },
                "limitInMhz": {
                    "type": "string",
                    "description": "Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited\n",
                    "willReplaceOnChanges": true
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n",
                    "willReplaceOnChanges": true
                },
                "speedInMhz": {
                    "type": "string",
                    "description": "Defines the vCPU speed of a core in MHz.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "vcd:index/VmVgpuPolicyMemory:VmVgpuPolicyMemory": {
            "properties": {
                "limitInMb": {
                    "type": "string",
                    "description": "Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.\n",
                    "willReplaceOnChanges": true
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n",
                    "willReplaceOnChanges": true
                },
                "sizeInMb": {
                    "type": "string",
                    "description": "Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "vcd:index/VmVgpuPolicyProviderVdcScope:VmVgpuPolicyProviderVdcScope": {
            "properties": {
                "clusterNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of vCenter cluster names on which the provider VDC is hosted. \nIf none are provided, the provider attempts to find one automatically. Can be fetched using `data.vcd_resource_pool.cluster_moref` attribute.\n"
                },
                "providerVdcId": {
                    "type": "string",
                    "description": "The ID of the provider VDC that should be in the scope.\n"
                },
                "vmGroupId": {
                    "type": "string",
                    "description": "Optional identifier for a VM group within the provider VDC scope.\n"
                }
            },
            "type": "object",
            "required": [
                "providerVdcId"
            ]
        },
        "vcd:index/VmVgpuPolicyVgpuProfile:VmVgpuPolicyVgpuProfile": {
            "properties": {
                "count": {
                    "type": "integer",
                    "description": "Specifies the number of vGPU profiles. Must be at least 1.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The identifier of the vGPU profile.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "count",
                "id"
            ]
        },
        "vcd:index/getCatalogAccessControlSharedWith:getCatalogAccessControlSharedWith": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the org, user, or group to which we are sharing. One of [ReadOnly, Change, FullControl] for users and groups, but just ReadOnly for Organizations\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "ID of the group to which we are sharing\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "ID of the Org to which we are sharing\n"
                },
                "subjectName": {
                    "type": "string",
                    "description": "Name of the subject (org, group, or user) with which we are sharing\n"
                },
                "userId": {
                    "type": "string",
                    "description": "ID of the user to which we are sharing\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "groupId",
                "orgId",
                "subjectName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCatalogFilter:getCatalogFilter": {
            "properties": {
                "date": {
                    "type": "string",
                    "description": "Search by date comparison ({\u003e|\u003e=|\u003c|\u003c=|==} yyyy-mm-dd[ hh[:mm[:ss]]])\n"
                },
                "earliest": {
                    "type": "boolean",
                    "description": "Retrieves the oldest item\n"
                },
                "latest": {
                    "type": "boolean",
                    "description": "Retrieves the newest item\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getCatalogFilterMetadata:getCatalogFilterMetadata"
                    },
                    "description": "(Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata.\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getCatalogFilterMetadata:getCatalogFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getCatalogItemFilter:getCatalogItemFilter": {
            "properties": {
                "date": {
                    "type": "string",
                    "description": "Search by date comparison ({\u003e|\u003e=|\u003c|\u003c=|==} yyyy-mm-dd[ hh[:mm[:ss]]])\n"
                },
                "earliest": {
                    "type": "boolean",
                    "description": "Retrieves the oldest item\n"
                },
                "latest": {
                    "type": "boolean",
                    "description": "Retrieves the newest item\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getCatalogItemFilterMetadata:getCatalogItemFilterMetadata"
                    },
                    "description": "Key value map of metadata assigned to the associated vApp template.\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getCatalogItemFilterMetadata:getCatalogItemFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getCatalogItemMetadataEntry:getCatalogItemMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCatalogMediaFilter:getCatalogMediaFilter": {
            "properties": {
                "date": {
                    "type": "string",
                    "description": "Search by date comparison ({\u003e|\u003e=|\u003c|\u003c=|==} yyyy-mm-dd[ hh[:mm[:ss]]])\n"
                },
                "earliest": {
                    "type": "boolean",
                    "description": "Retrieves the oldest item\n"
                },
                "latest": {
                    "type": "boolean",
                    "description": "Retrieves the newest item\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getCatalogMediaFilterMetadata:getCatalogMediaFilterMetadata"
                    },
                    "description": "metadata filter\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getCatalogMediaFilterMetadata:getCatalogMediaFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getCatalogMediaMetadataEntry:getCatalogMediaMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCatalogMetadataEntry:getCatalogMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCatalogVappTemplateFilter:getCatalogVappTemplateFilter": {
            "properties": {
                "date": {
                    "type": "string",
                    "description": "Search by date comparison ({\u003e|\u003e=|\u003c|\u003c=|==} yyyy-mm-dd[ hh[:mm[:ss]]])\n"
                },
                "earliest": {
                    "type": "boolean",
                    "description": "Retrieves the oldest item\n"
                },
                "latest": {
                    "type": "boolean",
                    "description": "Retrieves the newest item\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getCatalogVappTemplateFilterMetadata:getCatalogVappTemplateFilterMetadata"
                    },
                    "description": "(Deprecated) Use `metadata_entry` instead. Key/value map of metadata for the associated vApp template.\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getCatalogVappTemplateFilterMetadata:getCatalogVappTemplateFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getCatalogVappTemplateLease:getCatalogVappTemplateLease": {
            "properties": {
                "storageLeaseInSec": {
                    "type": "integer",
                    "description": "How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org allows).\n"
                }
            },
            "type": "object",
            "required": [
                "storageLeaseInSec"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCatalogVappTemplateMetadataEntry:getCatalogVappTemplateMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCseKubernetesClusterControlPlane:getCseKubernetesClusterControlPlane": {
            "properties": {
                "diskSizeGi": {
                    "type": "integer",
                    "description": "Disk size, in Gibibytes (Gi), of the control plane nodes\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP of the control plane\n"
                },
                "machineCount": {
                    "type": "integer",
                    "description": "The number of nodes that the control plane has\n"
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM Placement policy of the control plane nodes\n"
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM Sizing policy of the control plane nodes\n"
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Storage profile of the control plane nodes\n"
                }
            },
            "type": "object",
            "required": [
                "diskSizeGi",
                "ip",
                "machineCount",
                "placementPolicyId",
                "sizingPolicyId",
                "storageProfileId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCseKubernetesClusterDefaultStorageClass:getCseKubernetesClusterDefaultStorageClass": {
            "properties": {
                "filesystem": {
                    "type": "string",
                    "description": "Filesystem of the storage class, can be either 'ext4' or 'xfs'\n"
                },
                "name": {
                    "type": "string",
                    "description": "Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.\n"
                },
                "reclaimPolicy": {
                    "type": "string",
                    "description": "'delete' deletes the volume when the PersistentVolumeClaim is deleted. 'retain' does not, and the volume can be manually reclaimed\n"
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "ID of the storage profile used by the storage class\n"
                }
            },
            "type": "object",
            "required": [
                "filesystem",
                "name",
                "reclaimPolicy",
                "storageProfileId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCseKubernetesClusterEvent:getCseKubernetesClusterEvent": {
            "properties": {
                "details": {
                    "type": "string",
                    "description": "Details of the event\n"
                },
                "name": {
                    "type": "string",
                    "description": "Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.\n"
                },
                "occurredAt": {
                    "type": "string",
                    "description": "When the event happened\n"
                },
                "resourceId": {
                    "type": "string",
                    "description": "ID of the resource that caused the event\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the event, either 'event' or 'error'\n"
                }
            },
            "type": "object",
            "required": [
                "details",
                "name",
                "occurredAt",
                "resourceId",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getCseKubernetesClusterWorkerPool:getCseKubernetesClusterWorkerPool": {
            "properties": {
                "autoscalerMaxReplicas": {
                    "type": "integer",
                    "description": "Maximum replicas of the autoscaling capabilities of this worker pool\n"
                },
                "autoscalerMinReplicas": {
                    "type": "integer",
                    "description": "Minimum replicas of the autoscaling capabilities of this worker pool\n"
                },
                "diskSizeGi": {
                    "type": "integer",
                    "description": "Disk size, in Gibibytes (Gi), of the control plane nodes\n"
                },
                "machineCount": {
                    "type": "integer",
                    "description": "The number of nodes that this node pool has\n"
                },
                "name": {
                    "type": "string",
                    "description": "Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.\n"
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM Placement policy of the control plane nodes\n"
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM Sizing policy of the control plane nodes\n"
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Storage profile of the control plane nodes\n"
                },
                "vgpuPolicyId": {
                    "type": "string",
                    "description": "vGPU policy of the control plane nodes\n"
                }
            },
            "type": "object",
            "required": [
                "autoscalerMaxReplicas",
                "autoscalerMinReplicas",
                "diskSizeGi",
                "machineCount",
                "name",
                "placementPolicyId",
                "sizingPolicyId",
                "storageProfileId",
                "vgpuPolicyId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getDseRegistryConfigurationContainerRegistry:getDseRegistryConfigurationContainerRegistry": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Registry description\n"
                },
                "host": {
                    "type": "string",
                    "description": "Registry host\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for registry user\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username for registry access\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "host"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getEdgegatewayExternalNetwork:getEdgegatewayExternalNetwork": {
            "properties": {
                "enableRateLimit": {
                    "type": "boolean",
                    "description": "Enable rate limiting\n"
                },
                "incomingRateLimit": {
                    "type": "number",
                    "description": "Incoming rate limit (Mbps)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the edge gateway (optional when `filter` is used)\n"
                },
                "outgoingRateLimit": {
                    "type": "number",
                    "description": "Outgoing rate limit (Mbps)\n"
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getEdgegatewayExternalNetworkSubnet:getEdgegatewayExternalNetworkSubnet"
                    }
                }
            },
            "type": "object",
            "required": [
                "enableRateLimit",
                "incomingRateLimit",
                "name",
                "outgoingRateLimit",
                "subnets"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getEdgegatewayExternalNetworkSubnet:getEdgegatewayExternalNetworkSubnet": {
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address on the edge gateway - will be auto-assigned if not defined\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "Netmask address for a subnet\n"
                },
                "suballocatePools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getEdgegatewayExternalNetworkSubnetSuballocatePool:getEdgegatewayExternalNetworkSubnetSuballocatePool"
                    },
                    "description": "Define zero or more blocks to sub-allocate pools on the edge gateway\n"
                },
                "useForDefaultRoute": {
                    "type": "boolean",
                    "description": "Defines if this subnet should be used as default gateway for edge\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "ipAddress",
                "netmask",
                "suballocatePools",
                "useForDefaultRoute"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getEdgegatewayExternalNetworkSubnetSuballocatePool:getEdgegatewayExternalNetworkSubnetSuballocatePool": {
            "properties": {
                "endAddress": {
                    "type": "string"
                },
                "startAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getEdgegatewayFilter:getEdgegatewayFilter": {
            "properties": {
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getExternalNetworkIpScope:getExternalNetworkIpScope": {
            "properties": {
                "dns1": {
                    "type": "string",
                    "description": "Primary DNS server\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Secondary DNS server\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "DNS suffix\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway of the network\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "Network mask\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getExternalNetworkIpScopeStaticIpPool:getExternalNetworkIpScopeStaticIpPool"
                    },
                    "description": "IP ranges used for static pool allocation in the network\n"
                }
            },
            "type": "object",
            "required": [
                "dns1",
                "dns2",
                "dnsSuffix",
                "gateway",
                "netmask",
                "staticIpPools"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getExternalNetworkIpScopeStaticIpPool:getExternalNetworkIpScopeStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getExternalNetworkV2IpScope:getExternalNetworkV2IpScope": {
            "properties": {
                "dns1": {
                    "type": "string",
                    "description": "Primary DNS server\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Secondary DNS server\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "DNS suffix\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If subnet is enabled\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway of the network\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Network mask\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getExternalNetworkV2IpScopeStaticIpPool:getExternalNetworkV2IpScopeStaticIpPool"
                    },
                    "description": "IP ranges used for static pool allocation in the network\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "prefixLength"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getExternalNetworkV2IpScopeStaticIpPool:getExternalNetworkV2IpScopeStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getExternalNetworkV2NsxtNetwork:getExternalNetworkV2NsxtNetwork": {
            "properties": {
                "nsxtManagerId": {
                    "type": "string",
                    "description": "ID of NSX-T manager\n"
                },
                "nsxtSegmentName": {
                    "type": "string",
                    "description": "Name of NSX-T segment (for NSX-T segment backed external network)\n"
                },
                "nsxtTier0RouterId": {
                    "type": "string",
                    "description": "ID of NSX-T Tier-0 router (for T0 gateway backed external network)\n"
                }
            },
            "type": "object",
            "required": [
                "nsxtManagerId",
                "nsxtSegmentName",
                "nsxtTier0RouterId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getExternalNetworkV2VsphereNetwork:getExternalNetworkV2VsphereNetwork": {
            "properties": {
                "portgroupId": {
                    "type": "string",
                    "description": "The portgroup ID\n"
                },
                "vcenterId": {
                    "type": "string",
                    "description": "The vCenter server ID\n"
                }
            },
            "type": "object",
            "required": [
                "portgroupId",
                "vcenterId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getExternalNetworkVsphereNetwork:getExternalNetworkVsphereNetwork": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "external network name\n"
                },
                "type": {
                    "type": "string",
                    "description": "The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK\n"
                },
                "vcenter": {
                    "type": "string",
                    "description": "The vCenter server name\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "vcenter"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getIndependentDiskMetadataEntry:getIndependentDiskMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getIpSpaceCustomQuotaIpPrefixQuota:getIpSpaceCustomQuotaIpPrefixQuota": {
            "properties": {
                "prefixLength": {
                    "type": "string",
                    "description": "Prefix length\n"
                },
                "quota": {
                    "type": "string",
                    "description": "IP Prefix Quota\n"
                }
            },
            "type": "object",
            "required": [
                "prefixLength",
                "quota"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getIpSpaceIpPrefix:getIpSpaceIpPrefix": {
            "properties": {
                "defaultQuota": {
                    "type": "string",
                    "description": "Floating IP quota\n"
                },
                "prefixes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getIpSpaceIpPrefixPrefix:getIpSpaceIpPrefixPrefix"
                    },
                    "description": "IP Prefix\n"
                }
            },
            "type": "object",
            "required": [
                "defaultQuota",
                "prefixes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getIpSpaceIpPrefixPrefix:getIpSpaceIpPrefixPrefix": {
            "properties": {
                "firstIp": {
                    "type": "string",
                    "description": "First IP\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of IP Prefix\n"
                },
                "prefixCount": {
                    "type": "string",
                    "description": "Prefix count\n"
                },
                "prefixLength": {
                    "type": "string",
                    "description": "Prefix length\n"
                }
            },
            "type": "object",
            "required": [
                "firstIp",
                "id",
                "prefixCount",
                "prefixLength"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getIpSpaceIpRange:getIpSpaceIpRange": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of IP Range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "id",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getLbServerPoolMember:getLbServerPoolMember": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "Defines member state. One of enabled, drain, disabled.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Pool member id (formatted as member-xx, where xx is a number)\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address of member in server pool\n"
                },
                "maxConnections": {
                    "type": "integer",
                    "description": "The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released\n"
                },
                "minConnections": {
                    "type": "integer",
                    "description": "Minimum number of concurrent connections a member must always accept\n"
                },
                "monitorPort": {
                    "type": "integer",
                    "description": "Port at which the member is to receive health monitor requests. Can be the same as port\n"
                },
                "name": {
                    "type": "string",
                    "description": "Server Pool name for identifying the exact server pool\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port at which the member is to receive traffic from the load balancer\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Proportion of traffic this member is to handle. Must be an integer in the range 1-256\n"
                }
            },
            "type": "object",
            "required": [
                "condition",
                "id",
                "ipAddress",
                "maxConnections",
                "minConnections",
                "monitorPort",
                "name",
                "port",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkDirectFilter:getNetworkDirectFilter": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Search by IP. The value can be a regular expression\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNetworkDirectFilterMetadata:getNetworkDirectFilterMetadata"
                    },
                    "description": "metadata filter\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getNetworkDirectFilterMetadata:getNetworkDirectFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getNetworkDirectMetadataEntry:getNetworkDirectMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkIsolatedDhcpPool:getNetworkIsolatedDhcpPool": {
            "properties": {
                "defaultLeaseTime": {
                    "type": "integer",
                    "description": "The default DHCP lease time to use\n"
                },
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "maxLeaseTime": {
                    "type": "integer",
                    "description": "The maximum DHCP lease time to use\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "defaultLeaseTime",
                "endAddress",
                "maxLeaseTime",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkIsolatedFilter:getNetworkIsolatedFilter": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Search by IP. The value can be a regular expression\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNetworkIsolatedFilterMetadata:getNetworkIsolatedFilterMetadata"
                    },
                    "description": "metadata filter\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getNetworkIsolatedFilterMetadata:getNetworkIsolatedFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getNetworkIsolatedMetadataEntry:getNetworkIsolatedMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkIsolatedStaticIpPool:getNetworkIsolatedStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkIsolatedV2Filter:getNetworkIsolatedV2Filter": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Search by IP. The value can be a regular expression\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getNetworkIsolatedV2MetadataEntry:getNetworkIsolatedV2MetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkIsolatedV2SecondaryStaticIpPool:getNetworkIsolatedV2SecondaryStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkIsolatedV2StaticIpPool:getNetworkIsolatedV2StaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkPoolBacking:getNetworkPoolBacking": {
            "properties": {
                "distributedSwitches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNetworkPoolBackingDistributedSwitch:getNetworkPoolBackingDistributedSwitch"
                    },
                    "description": "Distributed switch backing\n"
                },
                "portGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNetworkPoolBackingPortGroup:getNetworkPoolBackingPortGroup"
                    },
                    "description": "Port Group backing\n"
                },
                "rangeIds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNetworkPoolBackingRangeId:getNetworkPoolBackingRangeId"
                    },
                    "description": "Distributed Switch ID ranges (used with VLAN backing)\n"
                },
                "transportZones": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNetworkPoolBackingTransportZone:getNetworkPoolBackingTransportZone"
                    },
                    "description": "Transport Zone Backing\n"
                }
            },
            "type": "object",
            "required": [
                "distributedSwitches",
                "portGroups",
                "rangeIds",
                "transportZones"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkPoolBackingDistributedSwitch:getNetworkPoolBackingDistributedSwitch": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Backing ID\n"
                },
                "name": {
                    "type": "string",
                    "description": "network pool name.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkPoolBackingPortGroup:getNetworkPoolBackingPortGroup": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Backing ID\n"
                },
                "name": {
                    "type": "string",
                    "description": "network pool name.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkPoolBackingRangeId:getNetworkPoolBackingRangeId": {
            "properties": {
                "endId": {
                    "type": "integer",
                    "description": "End of the IDs range\n"
                },
                "startId": {
                    "type": "integer",
                    "description": "Start of the IDs range\n"
                }
            },
            "type": "object",
            "required": [
                "endId",
                "startId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkPoolBackingTransportZone:getNetworkPoolBackingTransportZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Backing ID\n"
                },
                "name": {
                    "type": "string",
                    "description": "network pool name.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkRoutedDhcpPool:getNetworkRoutedDhcpPool": {
            "properties": {
                "defaultLeaseTime": {
                    "type": "integer",
                    "description": "The default DHCP lease time to use\n"
                },
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "maxLeaseTime": {
                    "type": "integer",
                    "description": "The maximum DHCP lease time to use\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "defaultLeaseTime",
                "endAddress",
                "maxLeaseTime",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkRoutedFilter:getNetworkRoutedFilter": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Search by IP. The value can be a regular expression\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNetworkRoutedFilterMetadata:getNetworkRoutedFilterMetadata"
                    },
                    "description": "metadata filter\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getNetworkRoutedFilterMetadata:getNetworkRoutedFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getNetworkRoutedMetadataEntry:getNetworkRoutedMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkRoutedStaticIpPool:getNetworkRoutedStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "The final address in the IP Range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "The first address in the IP Range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkRoutedV2Filter:getNetworkRoutedV2Filter": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Search by IP. The value can be a regular expression\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getNetworkRoutedV2MetadataEntry:getNetworkRoutedV2MetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkRoutedV2SecondaryStaticIpPool:getNetworkRoutedV2SecondaryStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNetworkRoutedV2StaticIpPool:getNetworkRoutedV2StaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbPoolHealthMonitor:getNsxtAlbPoolHealthMonitor": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of existing ALB Pool.\n"
                },
                "systemDefined": {
                    "type": "boolean"
                },
                "type": {
                    "type": "string",
                    "description": "Type of health monitor\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "systemDefined",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbPoolMember:getNsxtAlbPoolMember": {
            "properties": {
                "detailedHealthMessage": {
                    "type": "string",
                    "description": "Detailed health message\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Shows is the member is enabled or not\n"
                },
                "healthStatus": {
                    "type": "string",
                    "description": "Health status\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP Address of pool member\n"
                },
                "markedDownBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Marked down by provides a set of health monitors that marked the service down\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Service port\n"
                },
                "ratio": {
                    "type": "integer",
                    "description": "Load ratio\n"
                }
            },
            "type": "object",
            "required": [
                "detailedHealthMessage",
                "enabled",
                "healthStatus",
                "ipAddress",
                "markedDownBies",
                "port",
                "ratio"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbPoolPersistenceProfile:getNsxtAlbPoolPersistenceProfile": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of existing ALB Pool.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of persistence strategy\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of attribute based on persistence type\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRule:getNsxtAlbVirtualServiceHttpReqRulesRule": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleAction:getNsxtAlbVirtualServiceHttpReqRulesRuleAction"
                    },
                    "description": "Actions to perform with the rule that matches\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Defines if the rule is active or not\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines whether logging with headers on rule match is enabled or not\n"
                },
                "matchCriterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria"
                    },
                    "description": "Rule matching Criteria\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rule\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "active",
                "logging",
                "matchCriterias",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleAction:getNsxtAlbVirtualServiceHttpReqRulesRuleAction": {
            "properties": {
                "modifyHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeader:getNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeader"
                    },
                    "description": "A set of header modification rules\n"
                },
                "redirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirect:getNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirect"
                    },
                    "description": "Redirect request\n"
                },
                "rewriteUrls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrl:getNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrl"
                    },
                    "description": "URL rewrite rules\n"
                }
            },
            "type": "object",
            "required": [
                "modifyHeaders",
                "redirects",
                "rewriteUrls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeader:getNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeader": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "One of the following HTTP header actions\n"
                },
                "name": {
                    "type": "string",
                    "description": "HTTP header name\n"
                },
                "value": {
                    "type": "string",
                    "description": "HTTP header value\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirect:getNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirect": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Host to which redirect the request\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Path to which redirect the request\n"
                },
                "path": {
                    "type": "string",
                    "description": "Port to which redirect the request\n"
                },
                "port": {
                    "type": "string",
                    "description": "Port to which the request will be redirected\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "HTTP or HTTPS protocol\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "Redirect status code\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "keepQuery",
                "path",
                "port",
                "protocol",
                "statusCode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrl:getNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrl": {
            "properties": {
                "existingPath": {
                    "type": "string",
                    "description": "Path to use for the rewritten URL\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Host to use for the rewritten URL\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Whether or not to keep the existing query string when rewriting the URL\n"
                },
                "query": {
                    "type": "string",
                    "description": "Query string to use or append to the existing query string in the rewritten URL\n"
                }
            },
            "type": "object",
            "required": [
                "existingPath",
                "hostHeader",
                "keepQuery",
                "query"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria": {
            "properties": {
                "clientIpAddresses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress"
                    },
                    "description": "Client IP Address criteria\n"
                },
                "cookies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie"
                    },
                    "description": "Rule for matching cookie\n"
                },
                "httpMethods": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethod:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethod"
                    },
                    "description": "HTTP methods that are matched\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath"
                    },
                    "description": "HTTP request path that will be matched\n"
                },
                "protocolType": {
                    "type": "string",
                    "description": "Protocol to match - 'HTTP' or 'HTTPS'\n"
                },
                "queries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP request query strings to match\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader"
                    },
                    "description": "A set of rules for matching request headers\n"
                },
                "servicePorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePort:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePort"
                    },
                    "description": "Service Port criteria\n"
                }
            },
            "type": "object",
            "required": [
                "clientIpAddresses",
                "cookies",
                "httpMethods",
                "paths",
                "protocolType",
                "queries",
                "requestHeaders",
                "servicePorts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ipAddresses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching cookies in the HTTP request\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP cookie whose value is to be matched\n"
                },
                "value": {
                    "type": "string",
                    "description": "String values to match for an HTTP cookie\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethod:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethod": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for HTTP method matching in the HTTP request\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP methods that will be matched\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "methods"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching the path in the HTTP request URI\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match the path\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "paths"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "values"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePort:getNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePort": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for service port matching the HTTP request\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of TCP ports\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ports"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRule:getNsxtAlbVirtualServiceHttpRespRulesRule": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleAction:getNsxtAlbVirtualServiceHttpRespRulesRuleAction"
                    },
                    "description": "Actions to perform with the rule that matches\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Defines if the rule is active or not\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines whether logging with headers on rule match is enabled or not\n"
                },
                "matchCriterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria"
                    },
                    "description": "Rule matching Criteria\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rule\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "active",
                "logging",
                "matchCriterias",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleAction:getNsxtAlbVirtualServiceHttpRespRulesRuleAction": {
            "properties": {
                "modifyHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeader"
                    },
                    "description": "Modify header\n"
                },
                "rewriteLocationHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeader"
                    },
                    "description": "Rewrite location header\n"
                }
            },
            "type": "object",
            "required": [
                "modifyHeaders",
                "rewriteLocationHeaders"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeader": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "One of the following HTTP header actions\n"
                },
                "name": {
                    "type": "string",
                    "description": "HTTP header name\n"
                },
                "value": {
                    "type": "string",
                    "description": "HTTP header value\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeader": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Host to which redirect the request\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Path to which redirect the request\n"
                },
                "path": {
                    "type": "string",
                    "description": "Port to which redirect the request\n"
                },
                "port": {
                    "type": "string",
                    "description": "Port to which redirect the request\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "HTTP or HTTPS protocol\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "keepQuery",
                "path",
                "port",
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria": {
            "properties": {
                "clientIpAddresses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress"
                    },
                    "description": "Criteria for matching client IP Address\n"
                },
                "cookies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie"
                    },
                    "description": "Rule for matching cookie\n"
                },
                "httpMethods": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethod:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethod"
                    },
                    "description": "Criteria to match HTTP methods\n"
                },
                "locationHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader"
                    },
                    "description": "A matching criteria for Location header\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath"
                    },
                    "description": "Criteria for matching request paths\n"
                },
                "protocolType": {
                    "type": "string",
                    "description": "Protocol to match - 'HTTP' or 'HTTPS'\n"
                },
                "queries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP request query strings to match\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader"
                    },
                    "description": "A set of rules for matching request headers\n"
                },
                "responseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader"
                    },
                    "description": "A set of criteria to match response headers\n"
                },
                "servicePorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePort:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePort"
                    },
                    "description": "Criteria for matching service ports\n"
                },
                "statusCodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode"
                    },
                    "description": "HTTP Status code to match\n"
                }
            },
            "type": "object",
            "required": [
                "clientIpAddresses",
                "cookies",
                "httpMethods",
                "locationHeaders",
                "paths",
                "protocolType",
                "queries",
                "requestHeaders",
                "responseHeaders",
                "servicePorts",
                "statusCodes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ipAddresses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching cookies in the HTTP request\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP cookie whose value is to be matched\n"
                },
                "value": {
                    "type": "string",
                    "description": "String values to match for an HTTP cookie\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethod:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethod": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for HTTP methods matching the request\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP methods to match\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "methods"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching location header\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of values to match for criteria\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "values"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching the path in the HTTP request URI\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match the path\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "paths"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "values"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "values"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePort:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePort": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for service ports matching the HTTP request\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of TCP ports\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ports"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode:getNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for status code matching the HTTP request.\n"
                },
                "httpStatusCode": {
                    "type": "string",
                    "description": "HTTP status code or range of this rule matching\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "httpStatusCode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRule:getNsxtAlbVirtualServiceHttpSecRulesRule": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleAction:getNsxtAlbVirtualServiceHttpSecRulesRuleAction"
                    },
                    "description": "Actions to perform with the rule that matches\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Defines is the rule is active or not\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines whether to enable logging with headers on rule match or not\n"
                },
                "matchCriterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria"
                    },
                    "description": "Rule matching Criteria\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rule\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "active",
                "logging",
                "matchCriterias",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleAction:getNsxtAlbVirtualServiceHttpSecRulesRuleAction": {
            "properties": {
                "connections": {
                    "type": "string",
                    "description": "ALLOW or CLOSE connections\n"
                },
                "rateLimits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimit:getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimit"
                    },
                    "description": "Apply actions based on rate limits\n"
                },
                "redirectToHttps": {
                    "type": "string",
                    "description": "Port number that should be redirected to HTTPS\n"
                },
                "sendResponses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponse:getNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponse"
                    },
                    "description": "Send custom response\n"
                }
            },
            "type": "object",
            "required": [
                "connections",
                "rateLimits",
                "redirectToHttps",
                "sendResponses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimit:getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimit": {
            "properties": {
                "actionCloseConnection": {
                    "type": "boolean",
                    "description": "True if the connection should be closed\n"
                },
                "actionLocalResponses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponse:getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponse"
                    },
                    "description": "Send custom response\n"
                },
                "actionRedirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirect:getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirect"
                    },
                    "description": "Redirect request\n"
                },
                "count": {
                    "type": "string",
                    "description": "Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000\n"
                },
                "period": {
                    "type": "string",
                    "description": "Time value in seconds to enforce rate count. The period must be between 1 and 1000000000\n"
                }
            },
            "type": "object",
            "required": [
                "actionCloseConnection",
                "actionLocalResponses",
                "actionRedirects",
                "count",
                "period"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponse:getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponse": {
            "properties": {
                "content": {
                    "type": "string",
                    "description": "Base64 encoded content\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME type for the content\n"
                },
                "statusCode": {
                    "type": "string",
                    "description": "HTTP Status code to send\n"
                }
            },
            "type": "object",
            "required": [
                "content",
                "contentType",
                "statusCode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirect:getNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirect": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Host to which redirect the request. Default is the original host\n"
                },
                "keepQuery": {
                    "type": "boolean",
                    "description": "Path to which redirect the request. Default is the original path\n"
                },
                "path": {
                    "type": "string",
                    "description": "Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol\n"
                },
                "port": {
                    "type": "string",
                    "description": "Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "HTTP or HTTPS protocol\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "One of the redirect status codes - 301, 302, 307\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "keepQuery",
                "path",
                "port",
                "protocol",
                "statusCode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponse:getNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponse": {
            "properties": {
                "content": {
                    "type": "string",
                    "description": "Base64 encoded content\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME type for the content\n"
                },
                "statusCode": {
                    "type": "string",
                    "description": "HTTP Status code to send\n"
                }
            },
            "type": "object",
            "required": [
                "content",
                "contentType",
                "statusCode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria": {
            "properties": {
                "clientIpAddresses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress"
                    },
                    "description": "Client IP Address criteria\n"
                },
                "cookies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie"
                    },
                    "description": "Rule for matching cookie\n"
                },
                "httpMethods": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethod:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethod"
                    },
                    "description": "HTTP methods that are matched\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath"
                    },
                    "description": "HTTP request path that will be matched\n"
                },
                "protocolType": {
                    "type": "string",
                    "description": "Protocol to match - 'HTTP' or 'HTTPS'\n"
                },
                "queries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP request query strings to match\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader"
                    },
                    "description": "A set of rules for matching request headers\n"
                },
                "servicePorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePort:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePort"
                    },
                    "description": "Service Port criteria\n"
                }
            },
            "type": "object",
            "required": [
                "clientIpAddresses",
                "cookies",
                "httpMethods",
                "paths",
                "protocolType",
                "queries",
                "requestHeaders",
                "servicePorts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for IP address matching the HTTP request\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ipAddresses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching cookies in the HTTP request\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP cookie whose value is to be matched\n"
                },
                "value": {
                    "type": "string",
                    "description": "String values to match for an HTTP cookie\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethod:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethod": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for HTTP method matching in the HTTP request\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP methods that will be matched\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "methods"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching the path in the HTTP request URI\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match the path\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "paths"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for matching headers and cookies in the HTTP request amd response\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP header whose value is to be matched\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String values to match for an HTTP header\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "name",
                "values"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePort:getNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePort": {
            "properties": {
                "criteria": {
                    "type": "string",
                    "description": "Criteria to use for service port matching the HTTP request\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of TCP ports\n"
                }
            },
            "type": "object",
            "required": [
                "criteria",
                "ports"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceServicePort:getNsxtAlbVirtualServiceServicePort": {
            "properties": {
                "endPort": {
                    "type": "integer",
                    "description": "Last port in the range\n"
                },
                "sslEnabled": {
                    "type": "boolean",
                    "description": "Starting port in the range\n"
                },
                "startPort": {
                    "type": "integer",
                    "description": "Starting port in the range\n"
                },
                "type": {
                    "type": "string",
                    "description": "One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'\n"
                }
            },
            "type": "object",
            "required": [
                "endPort",
                "sslEnabled",
                "startPort",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtAppPortProfileAppPort:getNsxtAppPortProfileAppPort": {
            "properties": {
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of ports or ranges\n"
                },
                "protocol": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "ports",
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtDistributedFirewallRule:getNsxtDistributedFirewallRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic\n"
                },
                "appPortProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Application Port Profile IDs.'\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment that is shown next to rule in UI (VCD 10.3.2+)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description (not shown in UI)\n"
                },
                "destinationGroupsExcluded": {
                    "type": "boolean",
                    "description": "Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Destination Firewall Group IDs (IP Sets or Security Groups). Empty means 'Any'\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if Firewall Rule is active\n"
                },
                "id": {
                    "type": "string",
                    "description": "Firewall Rule ID\n"
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines if matching traffic should be logged\n"
                },
                "name": {
                    "type": "string",
                    "description": "Firewall Rule name\n"
                },
                "networkContextProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Network Context Profile IDs.\n"
                },
                "sourceGroupsExcluded": {
                    "type": "boolean",
                    "description": "Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)\n"
                },
                "sourceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Source Firewall Group IDs (IP Sets or Security Groups). Empty means 'Any'\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "appPortProfileIds",
                "comment",
                "description",
                "destinationGroupsExcluded",
                "destinationIds",
                "direction",
                "enabled",
                "id",
                "ipProtocol",
                "logging",
                "name",
                "networkContextProfileIds",
                "sourceGroupsExcluded",
                "sourceIds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtDynamicSecurityGroupCriteria:getNsxtDynamicSecurityGroupCriteria": {
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtDynamicSecurityGroupCriteriaRule:getNsxtDynamicSecurityGroupCriteriaRule"
                    },
                    "description": "Up to 4 rules can be used to define single criteria\n"
                }
            },
            "type": "object",
            "required": [
                "rules"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtDynamicSecurityGroupCriteriaRule:getNsxtDynamicSecurityGroupCriteriaRule": {
            "properties": {
                "operator": {
                    "type": "string",
                    "description": "Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of object matching 'VM_TAG' or 'VM_NAME'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Filter value\n"
                }
            },
            "type": "object",
            "required": [
                "operator",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtDynamicSecurityGroupMemberVm:getNsxtDynamicSecurityGroupMemberVm": {
            "properties": {
                "vappId": {
                    "type": "string",
                    "description": "Parent vApp name (if exists) for member VM\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "Parent vApp ID (if exists) for member VM\n"
                },
                "vmId": {
                    "type": "string",
                    "description": "Member VM ID\n"
                },
                "vmName": {
                    "type": "string",
                    "description": "Member VM Name\n"
                }
            },
            "type": "object",
            "required": [
                "vappId",
                "vappName",
                "vmId",
                "vmName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewayBgpIpPrefixListIpPrefix:getNsxtEdgegatewayBgpIpPrefixListIpPrefix": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action 'PERMIT' or 'DENY'\n"
                },
                "greaterThanOrEqualTo": {
                    "type": "integer",
                    "description": "Greater than or equal to (ge) subnet mask\n"
                },
                "lessThanOrEqualTo": {
                    "type": "integer",
                    "description": "Less than or equal to (le) subnet mask\n"
                },
                "network": {
                    "type": "string",
                    "description": "Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "greaterThanOrEqualTo",
                "lessThanOrEqualTo",
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewayDnsConditionalForwarderZone:getNsxtEdgegatewayDnsConditionalForwarderZone": {
            "properties": {
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of domain names on which conditional forwarding is based.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique ID of the forwarder zone.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the forwarder zone.\n"
                },
                "upstreamServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Servers to which DNS requests should be forwarded to.\n"
                }
            },
            "type": "object",
            "required": [
                "domainNames",
                "id",
                "name",
                "upstreamServers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewayDnsDefaultForwarderZone:getNsxtEdgegatewayDnsDefaultForwarderZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique ID of the forwarder zone.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the forwarder zone.\n"
                },
                "upstreamServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Servers to which DNS requests should be forwarded to.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name",
                "upstreamServers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewayExternalNetwork:getNsxtEdgegatewayExternalNetwork": {
            "properties": {
                "allocatedIpCount": {
                    "type": "integer",
                    "description": "Number of allocated IPs\n"
                },
                "externalNetworkId": {
                    "type": "string",
                    "description": "NSX-T Segment backed External Network ID\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway IP Address\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address for the Edge Gateway\n"
                }
            },
            "type": "object",
            "required": [
                "allocatedIpCount",
                "externalNetworkId",
                "gateway",
                "prefixLength",
                "primaryIp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewayL2VpnTunnelStretchedNetwork:getNsxtEdgegatewayL2VpnTunnelStretchedNetwork": {
            "properties": {
                "networkId": {
                    "type": "string",
                    "description": "ID of the Org VDC network\n"
                },
                "tunnelId": {
                    "type": "integer",
                    "description": "Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.\n"
                }
            },
            "type": "object",
            "required": [
                "networkId",
                "tunnelId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewayStaticRouteNextHop:getNsxtEdgegatewayStaticRouteNextHop": {
            "properties": {
                "adminDistance": {
                    "type": "integer",
                    "description": "Admin distance of next hop\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP Address of next hop\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtEdgegatewayStaticRouteNextHopScope:getNsxtEdgegatewayStaticRouteNextHopScope"
                    }
                }
            },
            "type": "object",
            "required": [
                "adminDistance",
                "ipAddress",
                "scopes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewayStaticRouteNextHopScope:getNsxtEdgegatewayStaticRouteNextHopScope": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of Scope element\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Static Route. **Note** names *can be duplicate* and one can use\n`network_cidr` to make filtering more precise\n"
                },
                "type": {
                    "type": "string",
                    "description": "Scope type - One of 'NETWORK', 'SYSTEM_OWNED'\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewaySubnet:getNsxtEdgegatewaySubnet": {
            "properties": {
                "allocatedIps": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxtEdgegatewaySubnetAllocatedIp:getNsxtEdgegatewaySubnetAllocatedIp"
                    },
                    "description": "One or more blocks to sub-allocate pools on the edge gateway\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "IP address on the edge gateway\n"
                }
            },
            "type": "object",
            "required": [
                "allocatedIps",
                "gateway",
                "prefixLength",
                "primaryIp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewaySubnetAllocatedIp:getNsxtEdgegatewaySubnetAllocatedIp": {
            "properties": {
                "endAddress": {
                    "type": "string"
                },
                "startAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewaySubnetWithIpCount:getNsxtEdgegatewaySubnetWithIpCount": {
            "properties": {
                "allocatedIpCount": {
                    "type": "integer",
                    "description": "Number of IP addresses to allocate\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address for the Edge Gateway - will be auto-assigned if not defined\n"
                }
            },
            "type": "object",
            "required": [
                "allocatedIpCount",
                "gateway",
                "prefixLength",
                "primaryIp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtEdgegatewaySubnetWithTotalIpCount:getNsxtEdgegatewaySubnetWithTotalIpCount": {
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "Gateway address for a subnet\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "Prefix length for a subnet (e.g. 24)\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address for the Edge Gateway\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "prefixLength",
                "primaryIp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtFirewallRule:getNsxtFirewallRule": {
            "properties": {
                "action": {
                    "type": "string"
                },
                "appPortProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Application Port Profile IDs. Leaving it empty means 'Any'\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'\n"
                },
                "direction": {
                    "type": "string",
                    "description": "IN OUT IN_OUT\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Firewall Rule name\n"
                },
                "id": {
                    "type": "string",
                    "description": "Firewall Rule ID\n"
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "IPV4,  IPV6, IPV4_IPV6\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Firewall Rule name\n"
                },
                "name": {
                    "type": "string",
                    "description": "Firewall Rule name\n"
                },
                "sourceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "appPortProfileIds",
                "destinationIds",
                "direction",
                "enabled",
                "id",
                "ipProtocol",
                "logging",
                "name",
                "sourceIds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtIpsecVpnTunnelSecurityProfileCustomization:getNsxtIpsecVpnTunnelSecurityProfileCustomization": {
            "properties": {
                "dpdProbeInternal": {
                    "type": "integer",
                    "description": "Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds\n"
                },
                "ikeDhGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21\n"
                },
                "ikeDigestAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512\n"
                },
                "ikeEncryptionAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512\n"
                },
                "ikeSaLifetime": {
                    "type": "integer",
                    "description": "Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish\n"
                },
                "ikeVersion": {
                    "type": "string",
                    "description": "IKE version one of IKE_V1, IKE_V2, IKE_FLEX\n"
                },
                "tunnelDfPolicy": {
                    "type": "string",
                    "description": "Policy for handling defragmentation bit. One of COPY, CLEAR\n"
                },
                "tunnelDhGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21\n"
                },
                "tunnelDigestAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512\n"
                },
                "tunnelEncryptionAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION\n"
                },
                "tunnelPfsEnabled": {
                    "type": "boolean",
                    "description": "Perfect Forward Secrecy Enabled or Disabled. Default (enabled)\n"
                },
                "tunnelSaLifetime": {
                    "type": "integer",
                    "description": "Security Association life time (in seconds)\n"
                }
            },
            "type": "object",
            "required": [
                "dpdProbeInternal",
                "ikeDhGroups",
                "ikeDigestAlgorithms",
                "ikeEncryptionAlgorithms",
                "ikeSaLifetime",
                "ikeVersion",
                "tunnelDfPolicy",
                "tunnelDhGroups",
                "tunnelDigestAlgorithms",
                "tunnelEncryptionAlgorithms",
                "tunnelPfsEnabled",
                "tunnelSaLifetime"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtNetworkDhcpBindingDhcpV4Config:getNsxtNetworkDhcpBindingDhcpV4Config": {
            "properties": {
                "gatewayIpAddress": {
                    "type": "string",
                    "description": "Gateway IP address to be used by the DHCP client\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname to be used by the DHCP client\n"
                }
            },
            "type": "object",
            "required": [
                "gatewayIpAddress",
                "hostname"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtNetworkDhcpBindingDhcpV6Config:getNsxtNetworkDhcpBindingDhcpV6Config": {
            "properties": {
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS servers to be used by the DHCP client\n"
                },
                "sntpServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of SNTP servers to be used by the DHCP client\n"
                }
            },
            "type": "object",
            "required": [
                "dnsServers",
                "sntpServers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtNetworkDhcpPool:getNsxtNetworkDhcpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of DHCP pool IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of DHCP pool IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtNetworkImportedFilter:getNsxtNetworkImportedFilter": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Search by IP. The value can be a regular expression\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getNsxtNetworkImportedSecondaryStaticIpPool:getNsxtNetworkImportedSecondaryStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtNetworkImportedStaticIpPool:getNsxtNetworkImportedStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxtSecurityGroupMemberVm:getNsxtSecurityGroupMemberVm": {
            "properties": {
                "vappId": {
                    "type": "string",
                    "description": "Parent vApp name (if exists) for member VM\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "Parent vApp ID (if exists) for member VM\n"
                },
                "vmId": {
                    "type": "string",
                    "description": "Member VM ID\n"
                },
                "vmName": {
                    "type": "string",
                    "description": "Member VM Name\n"
                }
            },
            "type": "object",
            "required": [
                "vappId",
                "vappName",
                "vmId",
                "vmName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvApplicationFinderObject:getNsxvApplicationFinderObject": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the object\n"
                },
                "type": {
                    "type": "string",
                    "description": "What kind of application we seek. One of `application`, `application_group`\n"
                },
                "value": {
                    "type": "string",
                    "description": "The identifier of the object\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvApplicationGroupApplication:getNsxvApplicationGroupApplication": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the application group\n"
                },
                "value": {
                    "type": "string",
                    "description": "The identifier of the application\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvDhcpRelayRelayAgent:getNsxvDhcpRelayRelayAgent": {
            "properties": {
                "gatewayIpAddress": {
                    "type": "string",
                    "description": "Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Org network which is to be used for relaying DHCP message to specified servers\n"
                }
            },
            "type": "object",
            "required": [
                "gatewayIpAddress",
                "networkName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvDistributedFirewallRule:getNsxvDistributedFirewallRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action of the rule (allow, deny)\n"
                },
                "applications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxvDistributedFirewallRuleApplication:getNsxvDistributedFirewallRuleApplication"
                    },
                    "description": "Application definitions for this rule. An empty value means 'any'\n"
                },
                "appliedTos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxvDistributedFirewallRuleAppliedTo:getNsxvDistributedFirewallRuleAppliedTo"
                    },
                    "description": "List of elements to which this rule applies\n"
                },
                "destinations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxvDistributedFirewallRuleDestination:getNsxvDistributedFirewallRuleDestination"
                    },
                    "description": "List of destination traffic for this rule. An empty value means 'any'\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction of the rule (in, out, inout)\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the rule is enabled\n"
                },
                "excludeDestination": {
                    "type": "boolean",
                    "description": "If true, the content of the destination elements is reversed\n"
                },
                "excludeSource": {
                    "type": "boolean",
                    "description": "If true, the content of the source elements is reversed\n"
                },
                "id": {
                    "type": "integer",
                    "description": "Firewall Rule ID\n"
                },
                "logged": {
                    "type": "boolean",
                    "description": "Whether the rule traffic is logged\n"
                },
                "name": {
                    "type": "string",
                    "description": "Firewall Rule name\n"
                },
                "packetType": {
                    "type": "string",
                    "description": "Packet type of the rule (any, ipv4, ipv6)\n"
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getNsxvDistributedFirewallRuleSource:getNsxvDistributedFirewallRuleSource"
                    },
                    "description": "List of source traffic for this rule. An empty value means 'any'\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "applications",
                "appliedTos",
                "destinations",
                "direction",
                "enabled",
                "excludeDestination",
                "excludeSource",
                "id",
                "logged",
                "name",
                "packetType",
                "sources"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvDistributedFirewallRuleApplication:getNsxvDistributedFirewallRuleApplication": {
            "properties": {
                "destinationPort": {
                    "type": "string",
                    "description": "Destination port for this application. Leaving it empty means 'any' port\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of application (Application, ApplicationGroup)\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)\n"
                },
                "sourcePort": {
                    "type": "string",
                    "description": "Source port for this application. Leaving it empty means 'any' port\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of application\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the application\n"
                }
            },
            "type": "object",
            "required": [
                "destinationPort",
                "name",
                "protocol",
                "sourcePort",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvDistributedFirewallRuleAppliedTo:getNsxvDistributedFirewallRuleAppliedTo": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the applied-to entity\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the applied-to entity\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvDistributedFirewallRuleDestination:getNsxvDistributedFirewallRuleDestination": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the destination entity\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the destination entity\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvDistributedFirewallRuleSource:getNsxvDistributedFirewallRuleSource": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the source entity\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the source entity\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvFirewallRuleDestination:getNsxvFirewallRuleDestination": {
            "properties": {
                "exclude": {
                    "type": "boolean",
                    "description": "Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'\n"
                },
                "gatewayInterfaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "'vse', 'internal', 'external' or network name\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address, CIDR, an IP range, or the keyword 'any'\n"
                },
                "ipSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IP set names\n"
                },
                "orgNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of org network names\n"
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of VM IDs\n"
                }
            },
            "type": "object",
            "required": [
                "exclude",
                "gatewayInterfaces",
                "ipAddresses",
                "ipSets",
                "orgNetworks",
                "vmIds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvFirewallRuleService:getNsxvFirewallRuleService": {
            "properties": {
                "port": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string"
                },
                "sourcePort": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "port",
                "protocol",
                "sourcePort"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getNsxvFirewallRuleSource:getNsxvFirewallRuleSource": {
            "properties": {
                "exclude": {
                    "type": "boolean",
                    "description": "Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'\n"
                },
                "gatewayInterfaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "'vse', 'internal', 'external' or network name\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address, CIDR, an IP range, or the keyword 'any'\n"
                },
                "ipSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IP set names\n"
                },
                "orgNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of org network names\n"
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of VM IDs\n"
                }
            },
            "type": "object",
            "required": [
                "exclude",
                "gatewayInterfaces",
                "ipAddresses",
                "ipSets",
                "orgNetworks",
                "vmIds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgAccountLockout:getOrgAccountLockout": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether account lockout is enabled or not\n"
                },
                "invalidLoginsBeforeLockout": {
                    "type": "integer",
                    "description": "Number of login attempts that will trigger an account lockout for the given user\n"
                },
                "lockoutIntervalMinutes": {
                    "type": "integer",
                    "description": "Once a user is locked out, they will not be able to log back in for this time period\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "invalidLoginsBeforeLockout",
                "lockoutIntervalMinutes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgLdapCustomSetting:getOrgLdapCustomSetting": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "authentication method: one of SIMPLE, MD5DIGEST, NTLM\n"
                },
                "baseDistinguishedName": {
                    "type": "string",
                    "description": "LDAP search base\n"
                },
                "connectorType": {
                    "type": "string",
                    "description": "type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY\n"
                },
                "groupAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getOrgLdapCustomSettingGroupAttribute:getOrgLdapCustomSettingGroupAttribute"
                    },
                    "description": "Custom settings when `ldap_mode` is CUSTOM\n"
                },
                "isSsl": {
                    "type": "boolean",
                    "description": "True if the LDAP service requires an SSL connection\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number for LDAP service\n"
                },
                "server": {
                    "type": "string",
                    "description": "host name or IP of the LDAP server\n"
                },
                "userAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getOrgLdapCustomSettingUserAttribute:getOrgLdapCustomSettingUserAttribute"
                    },
                    "description": "Custom settings when `ldap_mode` is CUSTOM\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn=\"ldap-admin\", c=\"example\", dc=\"com\")\n"
                }
            },
            "type": "object",
            "required": [
                "authenticationMethod",
                "baseDistinguishedName",
                "connectorType",
                "groupAttributes",
                "isSsl",
                "password",
                "port",
                "server",
                "userAttributes",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgLdapCustomSettingGroupAttribute:getOrgLdapCustomSettingGroupAttribute": {
            "properties": {
                "groupBackLinkIdentifier": {
                    "type": "string",
                    "description": "LDAP group attribute used to identify a group member\n"
                },
                "groupMembershipIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute that identifies a group as a member of another group. For example, dn\n"
                },
                "membership": {
                    "type": "string",
                    "description": "LDAP attribute to use when getting the members of a group. For example, member\n"
                },
                "name": {
                    "type": "string",
                    "description": "LDAP attribute to use for the group name. For example, cn\n"
                },
                "objectClass": {
                    "type": "string",
                    "description": "LDAP objectClass of which imported groups are members. For example, group\n"
                },
                "uniqueIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute to use as the unique identifier for a group. For example, objectGuid\n"
                }
            },
            "type": "object",
            "required": [
                "groupBackLinkIdentifier",
                "groupMembershipIdentifier",
                "membership",
                "name",
                "objectClass",
                "uniqueIdentifier"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgLdapCustomSettingUserAttribute:getOrgLdapCustomSettingUserAttribute": {
            "properties": {
                "displayName": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's full name. For example, displayName\n"
                },
                "email": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's email address. For example, mail\n"
                },
                "givenName": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's given name. For example, givenName\n"
                },
                "groupBackLinkIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute that returns the identifiers of all the groups of which the user is a member\n"
                },
                "groupMembershipIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute that identifies a user as a member of a group. For example, dn\n"
                },
                "objectClass": {
                    "type": "string",
                    "description": "LDAP objectClass of which imported users are members. For example, user or person\n"
                },
                "surname": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's surname. For example, sn\n"
                },
                "telephone": {
                    "type": "string",
                    "description": "LDAP attribute to use for the user's telephone number. For example, telephoneNumber\n"
                },
                "uniqueIdentifier": {
                    "type": "string",
                    "description": "LDAP attribute to use as the unique identifier for a user. For example, objectGuid\n"
                },
                "username": {
                    "type": "string",
                    "description": "LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName\n"
                }
            },
            "type": "object",
            "required": [
                "displayName",
                "email",
                "givenName",
                "groupBackLinkIdentifier",
                "groupMembershipIdentifier",
                "objectClass",
                "surname",
                "telephone",
                "uniqueIdentifier",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgMetadataEntry:getOrgMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgOidcClaimsMapping:getOrgOidcClaimsMapping": {
            "properties": {
                "email": {
                    "type": "string",
                    "description": "Email claim mapping\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name claim mapping\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "Full name claim mapping\n"
                },
                "groups": {
                    "type": "string",
                    "description": "Groups claim mapping\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name claim mapping\n"
                },
                "roles": {
                    "type": "string",
                    "description": "Roles claim mapping\n"
                },
                "subject": {
                    "type": "string",
                    "description": "Subject claim mapping\n"
                }
            },
            "type": "object",
            "required": [
                "email",
                "firstName",
                "fullName",
                "groups",
                "lastName",
                "roles",
                "subject"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgOidcKey:getOrgOidcKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Algorithm of the key\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate contents\n"
                },
                "expirationDate": {
                    "type": "string",
                    "description": "Expiration date for the certificate\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the key\n"
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "certificate",
                "expirationDate",
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVappLease:getOrgVappLease": {
            "properties": {
                "deleteOnStorageLeaseExpiration": {
                    "type": "boolean",
                    "description": "If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.\n"
                },
                "maximumRuntimeLeaseInSec": {
                    "type": "integer",
                    "description": "How long vApps can run before they are automatically stopped (in seconds)\n"
                },
                "maximumStorageLeaseInSec": {
                    "type": "integer",
                    "description": "How long stopped vApps are available before being automatically cleaned up (in seconds)\n"
                },
                "powerOffOnRuntimeLeaseExpiration": {
                    "type": "boolean",
                    "description": "When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires\n"
                }
            },
            "type": "object",
            "required": [
                "deleteOnStorageLeaseExpiration",
                "maximumRuntimeLeaseInSec",
                "maximumStorageLeaseInSec",
                "powerOffOnRuntimeLeaseExpiration"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVappTemplateLease:getOrgVappTemplateLease": {
            "properties": {
                "deleteOnStorageLeaseExpiration": {
                    "type": "boolean",
                    "description": "If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted\n"
                },
                "maximumStorageLeaseInSec": {
                    "type": "integer",
                    "description": "How long vApp templates are available before being automatically cleaned up (in seconds)\n"
                }
            },
            "type": "object",
            "required": [
                "deleteOnStorageLeaseExpiration",
                "maximumStorageLeaseInSec"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcComputeCapacity:getOrgVdcComputeCapacity": {
            "properties": {
                "cpus": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getOrgVdcComputeCapacityCpus:getOrgVdcComputeCapacityCpus"
                    }
                },
                "memories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getOrgVdcComputeCapacityMemory:getOrgVdcComputeCapacityMemory"
                    }
                }
            },
            "type": "object",
            "required": [
                "cpus",
                "memories"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcComputeCapacityCpus:getOrgVdcComputeCapacityCpus": {
            "properties": {
                "allocated": {
                    "type": "integer",
                    "description": "Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).\n"
                },
                "reserved": {
                    "type": "integer"
                },
                "used": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "allocated",
                "limit",
                "reserved",
                "used"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcComputeCapacityMemory:getOrgVdcComputeCapacityMemory": {
            "properties": {
                "allocated": {
                    "type": "integer",
                    "description": "Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).\n"
                },
                "reserved": {
                    "type": "integer"
                },
                "used": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "allocated",
                "limit",
                "reserved",
                "used"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcMetadataEntry:getOrgVdcMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcStorageProfile:getOrgVdcStorageProfile": {
            "properties": {
                "default": {
                    "type": "boolean",
                    "description": "True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if this storage profile is enabled for use in the VDC.\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Organization VDC name\n"
                },
                "storageUsedInMb": {
                    "type": "integer",
                    "description": "Storage used in MB\n"
                }
            },
            "type": "object",
            "required": [
                "default",
                "enabled",
                "limit",
                "name",
                "storageUsedInMb"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcTemplateComputeConfiguration:getOrgVdcTemplateComputeConfiguration": {
            "properties": {
                "cpuAllocated": {
                    "type": "integer",
                    "description": "The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template\n"
                },
                "cpuGuaranteed": {
                    "type": "integer",
                    "description": "The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. 0 means unlimited\n"
                },
                "cpuSpeed": {
                    "type": "integer",
                    "description": "Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM\n"
                },
                "elasticity": {
                    "type": "boolean",
                    "description": "True if compute capacity can grow or shrink based on demand\n"
                },
                "includeVmMemoryOverhead": {
                    "type": "boolean",
                    "description": "True if the instantiated VDC includes memory overhead into its accounting for admission control\n"
                },
                "memoryAllocated": {
                    "type": "integer",
                    "description": "The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template\n"
                },
                "memoryGuaranteed": {
                    "type": "integer",
                    "description": "The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The limit amount of Memory, in MB, of the VDC that is instantiated from this template. 0 means unlimited\n"
                }
            },
            "type": "object",
            "required": [
                "cpuAllocated",
                "cpuGuaranteed",
                "cpuLimit",
                "cpuSpeed",
                "elasticity",
                "includeVmMemoryOverhead",
                "memoryAllocated",
                "memoryGuaranteed",
                "memoryLimit"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcTemplateEdgeGateway:getOrgVdcTemplateEdgeGateway": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the Edge Gateway\n"
                },
                "ipAllocationCount": {
                    "type": "integer",
                    "description": "Storage used in MB\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the existing Organization VDC Template to read\n"
                },
                "routedNetworkDescription": {
                    "type": "string",
                    "description": "Description of the routed network to create with the Edge Gateway\n"
                },
                "routedNetworkGatewayCidr": {
                    "type": "string",
                    "description": "CIDR of the Edge Gateway for the routed network created with the Edge Gateway\n"
                },
                "routedNetworkName": {
                    "type": "string",
                    "description": "Name of the routed network to create with the Edge Gateway\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getOrgVdcTemplateEdgeGatewayStaticIpPool:getOrgVdcTemplateEdgeGatewayStaticIpPool"
                    },
                    "description": "IP ranges used for the network created with the Edge Gateway. Only required if the 'edge_gateway' block is used\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "ipAllocationCount",
                "name",
                "routedNetworkDescription",
                "routedNetworkGatewayCidr",
                "routedNetworkName",
                "staticIpPools"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcTemplateEdgeGatewayStaticIpPool:getOrgVdcTemplateEdgeGatewayStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string",
                    "description": "End address of the IP range\n"
                },
                "startAddress": {
                    "type": "string",
                    "description": "Start address of the IP range\n"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcTemplateProviderVdc:getOrgVdcTemplateProviderVdc": {
            "properties": {
                "externalNetworkId": {
                    "type": "string",
                    "description": "ID of the External network that the VDCs instantiated from this template use\n"
                },
                "gatewayEdgeClusterId": {
                    "type": "string",
                    "description": "ID of the Edge Cluster that the VDCs instantiated from this template use with the NSX-T Gateway\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of Provider VDC\n"
                },
                "servicesEdgeClusterId": {
                    "type": "string",
                    "description": "ID of the Edge Cluster that the VDCs instantiated from this template use for services\n"
                }
            },
            "type": "object",
            "required": [
                "externalNetworkId",
                "gatewayEdgeClusterId",
                "id",
                "servicesEdgeClusterId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getOrgVdcTemplateStorageProfile:getOrgVdcTemplateStorageProfile": {
            "properties": {
                "default": {
                    "type": "boolean",
                    "description": "True if this is default storage profile for the VDCs instantiated from this template\n"
                },
                "limit": {
                    "type": "integer",
                    "description": "Storage limit of the VDCs instantiated from this template, in Megabytes. 0 means unlimited\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the existing Organization VDC Template to read\n"
                }
            },
            "type": "object",
            "required": [
                "default",
                "limit",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getProviderVdcComputeCapacity:getProviderVdcComputeCapacity": {
            "properties": {
                "cpus": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getProviderVdcComputeCapacityCpus:getProviderVdcComputeCapacityCpus"
                    },
                    "description": "Single-element list with an indicator of CPU capacity available in the Provider VDC\n"
                },
                "isElastic": {
                    "type": "boolean",
                    "description": "True if compute capacity can grow or shrink based on demand\n"
                },
                "isHa": {
                    "type": "boolean",
                    "description": "True if compute capacity is highly available\n"
                },
                "memories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getProviderVdcComputeCapacityMemory:getProviderVdcComputeCapacityMemory"
                    },
                    "description": "Single-element list with an indicator of Memory capacity available in the Provider VDC\n"
                }
            },
            "type": "object",
            "required": [
                "cpus",
                "isElastic",
                "isHa",
                "memories"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getProviderVdcComputeCapacityCpus:getProviderVdcComputeCapacityCpus": {
            "properties": {
                "allocation": {
                    "type": "integer",
                    "description": "Allocated CPU for this Provider VDC\n"
                },
                "overhead": {
                    "type": "integer",
                    "description": "CPU overhead for this Provider VDC\n"
                },
                "reserved": {
                    "type": "integer",
                    "description": "Reserved CPU for this Provider VDC\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total CPU for this Provider VDC\n"
                },
                "units": {
                    "type": "string",
                    "description": "Units for the CPU of this Provider VDC\n"
                },
                "used": {
                    "type": "integer",
                    "description": "Used CPU in this Provider VDC\n"
                }
            },
            "type": "object",
            "required": [
                "allocation",
                "overhead",
                "reserved",
                "total",
                "units",
                "used"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getProviderVdcComputeCapacityMemory:getProviderVdcComputeCapacityMemory": {
            "properties": {
                "allocation": {
                    "type": "integer",
                    "description": "Allocated Memory for this Provider VDC\n"
                },
                "overhead": {
                    "type": "integer",
                    "description": "Memory overhead for this Provider VDC\n"
                },
                "reserved": {
                    "type": "integer",
                    "description": "Reserved Memory for this Provider VDC\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total Memory for this Provider VDC\n"
                },
                "units": {
                    "type": "string",
                    "description": "Units for the Memory of this Provider VDC\n"
                },
                "used": {
                    "type": "integer",
                    "description": "Used Memory in this Provider VDC\n"
                }
            },
            "type": "object",
            "required": [
                "allocation",
                "overhead",
                "reserved",
                "total",
                "units",
                "used"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getProviderVdcMetadataEntry:getProviderVdcMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getRdeMetadataEntry:getRdeMetadataEntry": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "Only meaningful for providers. Allows them to share entries with their tenants. One of: `TENANT`, `PROVIDER`\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the metadata entry\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace of the metadata entry\n"
                },
                "persistent": {
                    "type": "boolean",
                    "description": "Persistent metadata entries can be copied over on some entity operation\n"
                },
                "readonly": {
                    "type": "boolean",
                    "description": "True if the metadata entry is read only\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "id",
                "key",
                "namespace",
                "persistent",
                "readonly",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getRdeTypeHook:getRdeTypeHook": {
            "properties": {
                "behaviorId": {
                    "type": "string",
                    "description": "Existing Behavior that will be automatically invoked when the RDE of this RDE Type triggers the event\n"
                },
                "event": {
                    "type": "string",
                    "description": "Event that will invoke the Behavior, one of PostCreate, PostUpdate, PreDelete, PostDelete\n"
                }
            },
            "type": "object",
            "required": [
                "behaviorId",
                "event"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getResourceSchemaAttribute:getResourceSchemaAttribute": {
            "properties": {
                "computed": {
                    "type": "boolean",
                    "description": "whether the attribute is computed\n"
                },
                "description": {
                    "type": "string",
                    "description": "an optional description of the attribute\n"
                },
                "name": {
                    "type": "string",
                    "description": "An unique name to identify the data source\n"
                },
                "optional": {
                    "type": "boolean",
                    "description": "whether the attribute is optional\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "whether the attribute is required\n"
                },
                "sensitive": {
                    "type": "boolean",
                    "description": "whether the attribute is sensitive\n"
                },
                "type": {
                    "type": "string",
                    "description": "attribute type\n"
                }
            },
            "type": "object",
            "required": [
                "computed",
                "description",
                "name",
                "optional",
                "required",
                "sensitive",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getResourceSchemaBlockAttribute:getResourceSchemaBlockAttribute": {
            "properties": {
                "attributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getResourceSchemaBlockAttributeAttribute:getResourceSchemaBlockAttributeAttribute"
                    },
                    "description": "(Computed) Same composition of the simple `attributes` above.\n"
                },
                "name": {
                    "type": "string",
                    "description": "An unique name to identify the data source\n"
                },
                "nestingMode": {
                    "type": "string",
                    "description": "How the block is nested\n"
                }
            },
            "type": "object",
            "required": [
                "attributes",
                "name",
                "nestingMode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getResourceSchemaBlockAttributeAttribute:getResourceSchemaBlockAttributeAttribute": {
            "properties": {
                "computed": {
                    "type": "boolean",
                    "description": "whether the attribute is computed\n"
                },
                "description": {
                    "type": "string",
                    "description": "an optional description of the attribute\n"
                },
                "name": {
                    "type": "string",
                    "description": "An unique name to identify the data source\n"
                },
                "optional": {
                    "type": "boolean",
                    "description": "whether the attribute is optional\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "whether the attribute is required\n"
                },
                "sensitive": {
                    "type": "boolean",
                    "description": "whether the attribute is sensitive\n"
                },
                "type": {
                    "type": "string",
                    "description": "attribute type\n"
                }
            },
            "type": "object",
            "required": [
                "computed",
                "description",
                "name",
                "optional",
                "required",
                "sensitive",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getRightImpliedRight:getRightImpliedRight": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the implied right\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the right.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getSolutionLandingZoneCatalog:getSolutionLandingZoneCatalog": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Capability set for catalog\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of catalog\n"
                },
                "name": {
                    "type": "string",
                    "description": "Catalog Name\n"
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getSolutionLandingZoneVdc:getSolutionLandingZoneVdc": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of capabilities of the VDC\n"
                },
                "computePolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getSolutionLandingZoneVdcComputePolicy:getSolutionLandingZoneVdcComputePolicy"
                    },
                    "description": "Details of Compute Policy element\n"
                },
                "id": {
                    "type": "string",
                    "description": "VDC ID\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Defines if this VDC should be treated as the default one\n"
                },
                "name": {
                    "type": "string",
                    "description": "VDC Name\n"
                },
                "orgVdcNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getSolutionLandingZoneVdcOrgVdcNetwork:getSolutionLandingZoneVdcOrgVdcNetwork"
                    },
                    "description": "Details of Org VDC Network element\n"
                },
                "storagePolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getSolutionLandingZoneVdcStoragePolicy:getSolutionLandingZoneVdcStoragePolicy"
                    },
                    "description": "Details of Storage Policy element\n"
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "computePolicies",
                "id",
                "isDefault",
                "name",
                "orgVdcNetworks",
                "storagePolicies"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getSolutionLandingZoneVdcComputePolicy:getSolutionLandingZoneVdcComputePolicy": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of capabilities for Compute Policy\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of Compute Policy\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Boolean value that marks if this Compute Policy should be default\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Compute Policy\n"
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "id",
                "isDefault",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getSolutionLandingZoneVdcOrgVdcNetwork:getSolutionLandingZoneVdcOrgVdcNetwork": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of capabilities for Org VDC Network\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of Org VDC Network\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Boolean value that marks if this Org VDC Network should be default\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Org VDC Network\n"
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "id",
                "isDefault",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getSolutionLandingZoneVdcStoragePolicy:getSolutionLandingZoneVdcStoragePolicy": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of capabilities for Storage Policy\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of Storage Policy\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Boolean value that marks if this Storage Policy should be default\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Storage Policy\n"
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "id",
                "isDefault",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getStorageProfileIopsSetting:getStorageProfileIopsSetting": {
            "properties": {
                "defaultDiskIops": {
                    "type": "integer",
                    "description": "Value of 0 for disk IOPS means that no IOPS would be reserved or provisioned for that virtual disk\n"
                },
                "diskIopsPerGbMax": {
                    "type": "integer",
                    "description": "The maximum disk IOPs per GB value that this storage profile is permitted to deliver. A value of 0 means there is no per GB IOPS restriction\n"
                },
                "iopsLimit": {
                    "type": "integer",
                    "description": "Maximum number of IOPs that can be allocated for this profile. `0` means `maximum possible`\n"
                },
                "iopsLimitingEnabled": {
                    "type": "boolean",
                    "description": "True if this storage profile is IOPS-based placement enabled\n"
                },
                "maximumDiskIops": {
                    "type": "integer",
                    "description": "The maximum IOPS value that this storage profile is permitted to deliver. Value of 0 means this max setting is disabled and there is no max disk IOPS restriction\n"
                }
            },
            "type": "object",
            "required": [
                "defaultDiskIops",
                "diskIopsPerGbMax",
                "iopsLimit",
                "iopsLimitingEnabled",
                "maximumDiskIops"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getStorageProfileMetadataEntry:getStorageProfileMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getSubscribedCatalogFilter:getSubscribedCatalogFilter": {
            "properties": {
                "date": {
                    "type": "string",
                    "description": "Search by date comparison ({\u003e|\u003e=|\u003c|\u003c=|==} yyyy-mm-dd[ hh[:mm[:ss]]])\n"
                },
                "earliest": {
                    "type": "boolean",
                    "description": "Retrieves the oldest item\n"
                },
                "latest": {
                    "type": "boolean",
                    "description": "Retrieves the newest item\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/getSubscribedCatalogFilterMetadata:getSubscribedCatalogFilterMetadata"
                    },
                    "description": "Optional metadata of the catalog. This is inherited from the publishing catalog\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "Search by name with a regular expression\n"
                }
            },
            "type": "object"
        },
        "vcd:index/getSubscribedCatalogFilterMetadata:getSubscribedCatalogFilterMetadata": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "True if is a metadata@SYSTEM key\n"
                },
                "key": {
                    "type": "string",
                    "description": "Metadata key (field name)\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of metadata value (needed only if \"use_api_search\" is true)\n"
                },
                "useApiSearch": {
                    "type": "boolean",
                    "description": "If true, will search the vCD using native metadata query (without regular expressions)\n"
                },
                "value": {
                    "type": "string",
                    "description": "Metadata value (can be a regular expression if \"use_api_search\" is false)\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "vcd:index/getVappLease:getVappLease": {
            "properties": {
                "runtimeLeaseInSec": {
                    "type": "integer",
                    "description": "How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires.\n"
                },
                "storageLeaseInSec": {
                    "type": "integer",
                    "description": "How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires.\n"
                }
            },
            "type": "object",
            "required": [
                "runtimeLeaseInSec",
                "storageLeaseInSec"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappMetadataEntry:getVappMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappNetworkDhcpPool:getVappNetworkDhcpPool": {
            "properties": {
                "defaultLeaseTime": {
                    "type": "integer"
                },
                "enabled": {
                    "type": "boolean"
                },
                "endAddress": {
                    "type": "string"
                },
                "maxLeaseTime": {
                    "type": "integer"
                },
                "startAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "defaultLeaseTime",
                "enabled",
                "endAddress",
                "maxLeaseTime",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappNetworkStaticIpPool:getVappNetworkStaticIpPool": {
            "properties": {
                "endAddress": {
                    "type": "string"
                },
                "startAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endAddress",
                "startAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappVmBootOption:getVappVmBootOption": {
            "properties": {
                "bootDelay": {
                    "type": "integer",
                    "description": "Number of milliseconds to wait between powering-on and booting the VM\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired\n"
                },
                "efiSecureBoot": {
                    "type": "boolean",
                    "description": "If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.\n"
                },
                "enterBiosSetupOnNextBoot": {
                    "type": "boolean",
                    "description": "If set to true, the VM will enter BIOS setup on boot.\n"
                }
            },
            "type": "object",
            "required": [
                "bootDelay",
                "bootRetryDelay",
                "bootRetryEnabled",
                "efiSecureBoot",
                "enterBiosSetupOnNextBoot"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappVmCustomization:getVappVmCustomization": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "Manually specify admin password\n",
                    "secret": true
                },
                "allowLocalAdminPassword": {
                    "type": "boolean",
                    "description": "Allow local administrator password\n"
                },
                "autoGeneratePassword": {
                    "type": "boolean",
                    "description": "Auto generate password\n"
                },
                "changeSid": {
                    "type": "boolean",
                    "description": "'true' value will change SID. Applicable only for Windows VMs\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "'true' value will enable guest customization. It may occur on first boot or when 'force' is used\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "'true' value will cause the VM to reboot on every 'apply' operation\n"
                },
                "initscript": {
                    "type": "string",
                    "description": "Script to run on initial boot or with customization.force=true set\n"
                },
                "joinDomain": {
                    "type": "boolean",
                    "description": "Enable this VM to join a domain\n"
                },
                "joinDomainAccountOu": {
                    "type": "string",
                    "description": "Account organizational unit for domain name join\n"
                },
                "joinDomainName": {
                    "type": "string",
                    "description": "Custom domain name for join\n"
                },
                "joinDomainPassword": {
                    "type": "string",
                    "description": "Password for custom domain name join\n",
                    "secret": true
                },
                "joinDomainUser": {
                    "type": "string",
                    "description": "Username for custom domain name join\n"
                },
                "joinOrgDomain": {
                    "type": "boolean",
                    "description": "Use organization's domain for joining\n"
                },
                "mustChangePasswordOnFirstLogin": {
                    "type": "boolean",
                    "description": "Require Administrator to change password on first login\n"
                },
                "numberOfAutoLogons": {
                    "type": "integer",
                    "description": "Number of times to log on automatically\n"
                }
            },
            "type": "object",
            "required": [
                "adminPassword",
                "allowLocalAdminPassword",
                "autoGeneratePassword",
                "changeSid",
                "enabled",
                "force",
                "initscript",
                "joinDomain",
                "joinDomainAccountOu",
                "joinDomainName",
                "joinDomainPassword",
                "joinDomainUser",
                "joinOrgDomain",
                "mustChangePasswordOnFirstLogin",
                "numberOfAutoLogons"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappVmDisk:getVappVmDisk": {
            "properties": {
                "busNumber": {
                    "type": "string",
                    "description": "Bus number on which to place the disk controller\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "unitNumber": {
                    "type": "string",
                    "description": "Unit number (slot) on the bus specified by BusNumber\n"
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "name",
                "sizeInMb",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappVmExtraConfig:getVappVmExtraConfig": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key of the extra configuration item\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the extra configuration item is required\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the extra configuration item\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "required",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappVmInternalDisk:getVappVmInternalDisk": {
            "properties": {
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n"
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme\n"
                },
                "diskId": {
                    "type": "string",
                    "description": "The disk ID.\n"
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the VM default one\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Specifies whether the disk storage is pre-allocated or allocated on demand.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n"
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "busType",
                "diskId",
                "iops",
                "sizeInMb",
                "storageProfile",
                "thinProvisioned",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappVmMetadataEntry:getVappVmMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVappVmNetwork:getVappVmNetwork": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "It defines if NIC is connected or not.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP of the VM. Settings depend on `ip_allocation_mode`\n"
                },
                "ipAllocationMode": {
                    "type": "string",
                    "description": "IP address allocation mode.\n"
                },
                "isPrimary": {
                    "type": "boolean",
                    "description": "Set to true if network interface should be primary. First network card in the list will be primary by default\n"
                },
                "mac": {
                    "type": "string",
                    "description": "Mac address of network interface\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n"
                },
                "secondaryIp": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL\n"
                },
                "secondaryIpAllocationMode": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE\n"
                },
                "type": {
                    "type": "string",
                    "description": "Network type\n"
                }
            },
            "type": "object",
            "required": [
                "adapterType",
                "connected",
                "ip",
                "ipAllocationMode",
                "isPrimary",
                "mac",
                "name",
                "secondaryIp",
                "secondaryIpAllocationMode",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVdcGroupParticipatingOrgVdc:getVdcGroupParticipatingOrgVdc": {
            "properties": {
                "faultDomainTag": {
                    "type": "string",
                    "description": "Represents the fault domain of a given organization VDC\n"
                },
                "isRemoteOrg": {
                    "type": "boolean",
                    "description": "Specifies whether the VDC is local to this VCD site\n"
                },
                "networkProviderScope": {
                    "type": "string",
                    "description": "Specifies the network provider scope of the VDC\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Organization VDC belongs\n"
                },
                "orgName": {
                    "type": "string",
                    "description": "Organization VDC belongs\n"
                },
                "siteId": {
                    "type": "string",
                    "description": "Site VDC belongs\n"
                },
                "siteName": {
                    "type": "string",
                    "description": "Site VDC belongs\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status that the VDC can be in e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED')\n"
                },
                "vdcId": {
                    "type": "string",
                    "description": "VDC ID\n"
                },
                "vdcName": {
                    "type": "string",
                    "description": "VDC name\n"
                }
            },
            "type": "object",
            "required": [
                "faultDomainTag",
                "isRemoteOrg",
                "networkProviderScope",
                "orgId",
                "orgName",
                "siteId",
                "siteName",
                "status",
                "vdcId",
                "vdcName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmBootOption:getVmBootOption": {
            "properties": {
                "bootDelay": {
                    "type": "integer",
                    "description": "Number of milliseconds to wait between powering-on and booting the VM\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired\n"
                },
                "efiSecureBoot": {
                    "type": "boolean",
                    "description": "If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.\n"
                },
                "enterBiosSetupOnNextBoot": {
                    "type": "boolean",
                    "description": "If set to true, the VM will enter BIOS setup on boot.\n"
                }
            },
            "type": "object",
            "required": [
                "bootDelay",
                "bootRetryDelay",
                "bootRetryEnabled",
                "efiSecureBoot",
                "enterBiosSetupOnNextBoot"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmCustomization:getVmCustomization": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "Manually specify admin password\n",
                    "secret": true
                },
                "allowLocalAdminPassword": {
                    "type": "boolean",
                    "description": "Allow local administrator password\n"
                },
                "autoGeneratePassword": {
                    "type": "boolean",
                    "description": "Auto generate password\n"
                },
                "changeSid": {
                    "type": "boolean",
                    "description": "'true' value will change SID. Applicable only for Windows VMs\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "'true' value will enable guest customization. It may occur on first boot or when 'force' is used\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "'true' value will cause the VM to reboot on every 'apply' operation\n"
                },
                "initscript": {
                    "type": "string",
                    "description": "Script to run on initial boot or with customization.force=true set\n"
                },
                "joinDomain": {
                    "type": "boolean",
                    "description": "Enable this VM to join a domain\n"
                },
                "joinDomainAccountOu": {
                    "type": "string",
                    "description": "Account organizational unit for domain name join\n"
                },
                "joinDomainName": {
                    "type": "string",
                    "description": "Custom domain name for join\n"
                },
                "joinDomainPassword": {
                    "type": "string",
                    "description": "Password for custom domain name join\n",
                    "secret": true
                },
                "joinDomainUser": {
                    "type": "string",
                    "description": "Username for custom domain name join\n"
                },
                "joinOrgDomain": {
                    "type": "boolean",
                    "description": "Use organization's domain for joining\n"
                },
                "mustChangePasswordOnFirstLogin": {
                    "type": "boolean",
                    "description": "Require Administrator to change password on first login\n"
                },
                "numberOfAutoLogons": {
                    "type": "integer",
                    "description": "Number of times to log on automatically\n"
                }
            },
            "type": "object",
            "required": [
                "adminPassword",
                "allowLocalAdminPassword",
                "autoGeneratePassword",
                "changeSid",
                "enabled",
                "force",
                "initscript",
                "joinDomain",
                "joinDomainAccountOu",
                "joinDomainName",
                "joinDomainPassword",
                "joinDomainUser",
                "joinOrgDomain",
                "mustChangePasswordOnFirstLogin",
                "numberOfAutoLogons"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmDisk:getVmDisk": {
            "properties": {
                "busNumber": {
                    "type": "string",
                    "description": "Bus number on which to place the disk controller\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name or ID for the standalone VM in VDC\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "unitNumber": {
                    "type": "string",
                    "description": "Unit number (slot) on the bus specified by BusNumber\n"
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "name",
                "sizeInMb",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmExtraConfig:getVmExtraConfig": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key of the extra configuration item\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the extra configuration item is required\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the extra configuration item\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "required",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmInternalDisk:getVmInternalDisk": {
            "properties": {
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n"
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme\n"
                },
                "diskId": {
                    "type": "string",
                    "description": "The disk ID.\n"
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the VM default one\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Specifies whether the disk storage is pre-allocated or allocated on demand.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n"
                }
            },
            "type": "object",
            "required": [
                "busNumber",
                "busType",
                "diskId",
                "iops",
                "sizeInMb",
                "storageProfile",
                "thinProvisioned",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmMetadataEntry:getVmMetadataEntry": {
            "properties": {
                "isSystem": {
                    "type": "boolean",
                    "description": "Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key of this metadata entry\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'\n"
                },
                "userAccess": {
                    "type": "string",
                    "description": "User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of this metadata entry\n"
                }
            },
            "type": "object",
            "required": [
                "isSystem",
                "key",
                "type",
                "userAccess",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmNetwork:getVmNetwork": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "It defines if NIC is connected or not.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP of the VM. Settings depend on `ip_allocation_mode`\n"
                },
                "ipAllocationMode": {
                    "type": "string",
                    "description": "IP address allocation mode.\n"
                },
                "isPrimary": {
                    "type": "boolean",
                    "description": "Set to true if network interface should be primary. First network card in the list will be primary by default\n"
                },
                "mac": {
                    "type": "string",
                    "description": "Mac address of network interface\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name or ID for the standalone VM in VDC\n"
                },
                "secondaryIp": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL\n"
                },
                "secondaryIpAllocationMode": {
                    "type": "string",
                    "description": "Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE\n"
                },
                "type": {
                    "type": "string",
                    "description": "Network type\n"
                }
            },
            "type": "object",
            "required": [
                "adapterType",
                "connected",
                "ip",
                "ipAllocationMode",
                "isPrimary",
                "mac",
                "name",
                "secondaryIp",
                "secondaryIpAllocationMode",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmSizingPolicyCpus:getVmSizingPolicyCpus": {
            "properties": {
                "coresPerSocket": {
                    "type": "string",
                    "description": "The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.\n"
                },
                "count": {
                    "type": "string",
                    "description": "Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.\n"
                },
                "limitInMhz": {
                    "type": "string",
                    "description": "Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.\n"
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.\n"
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n"
                },
                "speedInMhz": {
                    "type": "string",
                    "description": "Defines the vCPU speed of a core in MHz.\n"
                }
            },
            "type": "object",
            "required": [
                "coresPerSocket",
                "count",
                "limitInMhz",
                "reservationGuarantee",
                "shares",
                "speedInMhz"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmSizingPolicyMemory:getVmSizingPolicyMemory": {
            "properties": {
                "limitInMb": {
                    "type": "string",
                    "description": "Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.\n"
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.\n"
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n"
                },
                "sizeInMb": {
                    "type": "string",
                    "description": "Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.\n"
                }
            },
            "type": "object",
            "required": [
                "limitInMb",
                "reservationGuarantee",
                "shares",
                "sizeInMb"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmVgpuPolicyCpus:getVmVgpuPolicyCpus": {
            "properties": {
                "coresPerSocket": {
                    "type": "string",
                    "description": "The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.\n"
                },
                "count": {
                    "type": "string",
                    "description": "Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.\n"
                },
                "limitInMhz": {
                    "type": "string",
                    "description": "Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.\n"
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.\n"
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n"
                },
                "speedInMhz": {
                    "type": "string",
                    "description": "Defines the vCPU speed of a core in MHz.\n"
                }
            },
            "type": "object",
            "required": [
                "coresPerSocket",
                "count",
                "limitInMhz",
                "reservationGuarantee",
                "shares",
                "speedInMhz"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmVgpuPolicyMemory:getVmVgpuPolicyMemory": {
            "properties": {
                "limitInMb": {
                    "type": "string",
                    "description": "Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.\n"
                },
                "reservationGuarantee": {
                    "type": "string",
                    "description": "Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.\n"
                },
                "shares": {
                    "type": "string",
                    "description": "Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.\n"
                },
                "sizeInMb": {
                    "type": "string",
                    "description": "Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.\n"
                }
            },
            "type": "object",
            "required": [
                "limitInMb",
                "reservationGuarantee",
                "shares",
                "sizeInMb"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmVgpuPolicyProviderVdcScope:getVmVgpuPolicyProviderVdcScope": {
            "properties": {
                "clusterNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of cluster names within the provider virtual data center.\n"
                },
                "providerVdcId": {
                    "type": "string",
                    "description": "Identifier for the provider virtual data center.\n"
                },
                "vmGroupId": {
                    "type": "string",
                    "description": "Identifier for a VM group within the provider VDC scope.\n"
                }
            },
            "type": "object",
            "required": [
                "clusterNames",
                "providerVdcId",
                "vmGroupId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:index/getVmVgpuPolicyVgpuProfile:getVmVgpuPolicyVgpuProfile": {
            "properties": {
                "count": {
                    "type": "integer",
                    "description": "Specifies the number of vGPU profiles.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The identifier of the vGPU profile.\n"
                }
            },
            "type": "object",
            "required": [
                "count",
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vcd:region/region:Region": {
            "type": "string",
            "enum": [
                {
                    "name": "here",
                    "value": "HERE"
                },
                {
                    "name": "overThere",
                    "value": "OVER_THERE"
                }
            ]
        }
    },
    "provider": {
        "description": "The provider type for the vcd package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "allowApiTokenFile": {
                "type": "boolean",
                "description": "Set this to true if you understand the security risks of using API token files and would like to suppress the warnings\n"
            },
            "allowServiceAccountTokenFile": {
                "type": "boolean",
                "description": "Set this to true if you understand the security risks of using Service Account token files and would like to suppress\nthe warnings\n"
            },
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VCDClient will permit unverifiable SSL certificates.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API token used instead of username/password for VCD API operations. (Requires VCD 10.3.1+)\n"
            },
            "apiTokenFile": {
                "type": "string",
                "description": "The API token file instead of username/password for VCD API operations. (Requires VCD 10.3.1+)\n"
            },
            "authType": {
                "type": "string",
                "description": "'integrated', 'saml_adfs', 'token', 'api_token', 'api_token_file' and 'service_account_token_file' are supported.\n'integrated' is default.\n"
            },
            "ignoreMetadataChanges": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vcd:index/ProviderIgnoreMetadataChange:ProviderIgnoreMetadataChange"
                },
                "description": "Defines a set of `metadata_entry` that need to be ignored by this provider. All filters on this attribute are computed\nwith a logical AND\n"
            },
            "importSeparator": {
                "type": "string"
            },
            "logging": {
                "type": "boolean",
                "description": "If set, it will enable logging of API requests and responses\n"
            },
            "loggingFile": {
                "type": "string",
                "description": "Defines the full name of the logging file for API calls (requires 'logging')\n"
            },
            "maxRetryTimeout": {
                "type": "integer",
                "description": "Max num seconds to wait for successful response when operating on resources within vCloud (defaults to 60)\n"
            },
            "org": {
                "type": "string",
                "description": "The VCD Org for API operations\n"
            },
            "password": {
                "type": "string",
                "description": "The user password for VCD API operations.\n"
            },
            "samlAdfsCookie": {
                "type": "string",
                "description": "Allows to specify custom cookie for ADFS server lookup. '{{.Org}}' is replaced by real Org - e.g. 'sso-preferred=yes;\nsso_redirect_org={{.Org}}'\n"
            },
            "samlAdfsRptId": {
                "type": "string",
                "description": "Allows to specify custom Relaying Party Trust Identifier for auth_type=saml_adfs\n"
            },
            "serviceAccountTokenFile": {
                "type": "string",
                "description": "The Service Account API token file instead of username/password for VCD API operations. (Requires VCD 10.4.0+)\n"
            },
            "sysorg": {
                "type": "string",
                "description": "The VCD Org for user authentication\n"
            },
            "token": {
                "type": "string",
                "description": "The token used instead of username/password for VCD API operations.\n"
            },
            "url": {
                "type": "string",
                "description": "The VCD url for VCD API operations.\n"
            },
            "user": {
                "type": "string",
                "description": "The user name for VCD API operations.\n"
            },
            "vdc": {
                "type": "string",
                "description": "The VDC for API operations\n"
            }
        },
        "required": [
            "org",
            "url"
        ],
        "inputProperties": {
            "allowApiTokenFile": {
                "type": "boolean",
                "description": "Set this to true if you understand the security risks of using API token files and would like to suppress the warnings\n"
            },
            "allowServiceAccountTokenFile": {
                "type": "boolean",
                "description": "Set this to true if you understand the security risks of using Service Account token files and would like to suppress\nthe warnings\n"
            },
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VCDClient will permit unverifiable SSL certificates.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API token used instead of username/password for VCD API operations. (Requires VCD 10.3.1+)\n"
            },
            "apiTokenFile": {
                "type": "string",
                "description": "The API token file instead of username/password for VCD API operations. (Requires VCD 10.3.1+)\n"
            },
            "authType": {
                "type": "string",
                "description": "'integrated', 'saml_adfs', 'token', 'api_token', 'api_token_file' and 'service_account_token_file' are supported.\n'integrated' is default.\n"
            },
            "ignoreMetadataChanges": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vcd:index/ProviderIgnoreMetadataChange:ProviderIgnoreMetadataChange"
                },
                "description": "Defines a set of `metadata_entry` that need to be ignored by this provider. All filters on this attribute are computed\nwith a logical AND\n"
            },
            "importSeparator": {
                "type": "string"
            },
            "logging": {
                "type": "boolean",
                "description": "If set, it will enable logging of API requests and responses\n"
            },
            "loggingFile": {
                "type": "string",
                "description": "Defines the full name of the logging file for API calls (requires 'logging')\n"
            },
            "maxRetryTimeout": {
                "type": "integer",
                "description": "Max num seconds to wait for successful response when operating on resources within vCloud (defaults to 60)\n"
            },
            "org": {
                "type": "string",
                "description": "The VCD Org for API operations\n"
            },
            "password": {
                "type": "string",
                "description": "The user password for VCD API operations.\n"
            },
            "samlAdfsCookie": {
                "type": "string",
                "description": "Allows to specify custom cookie for ADFS server lookup. '{{.Org}}' is replaced by real Org - e.g. 'sso-preferred=yes;\nsso_redirect_org={{.Org}}'\n"
            },
            "samlAdfsRptId": {
                "type": "string",
                "description": "Allows to specify custom Relaying Party Trust Identifier for auth_type=saml_adfs\n"
            },
            "serviceAccountTokenFile": {
                "type": "string",
                "description": "The Service Account API token file instead of username/password for VCD API operations. (Requires VCD 10.4.0+)\n"
            },
            "sysorg": {
                "type": "string",
                "description": "The VCD Org for user authentication\n"
            },
            "token": {
                "type": "string",
                "description": "The token used instead of username/password for VCD API operations.\n"
            },
            "url": {
                "type": "string",
                "description": "The VCD url for VCD API operations.\n"
            },
            "user": {
                "type": "string",
                "description": "The user name for VCD API operations.\n"
            },
            "vdc": {
                "type": "string",
                "description": "The VDC for API operations\n"
            }
        },
        "requiredInputs": [
            "org",
            "url"
        ]
    },
    "resources": {
        "vcd:index/apiFilter:ApiFilter": {
            "properties": {
                "externalEndpointId": {
                    "type": "string",
                    "description": "ID of the [External Endpoint](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/external_endpoint) where this API Filter will process the requests to\n"
                },
                "urlMatcherPattern": {
                    "type": "string",
                    "description": "Request URL pattern, written as a regular expression. This argument cannot exceed 1024 characters.\nIn most cases, it should end with `.*` (it is like a suffix) which specifies that all the parts of the URL coming after (like parameters) will be redirected to an external endpoint.\nIt is important to note that in the case of `url_matcher_scope=EXT_UI_TENANT`, the tenant name is not part of the pattern, it will match the request after the tenant name - if request\nis *\"/ext-ui/tenant/testOrg/custom/test\"*, the pattern will match against */custom/test*\n"
                },
                "urlMatcherScope": {
                    "type": "string",
                    "description": "Allowed values are `EXT_API`, `EXT_UI_PROVIDER`, `EXT_UI_TENANT` corresponding to\n*/ext-api*, */ext-ui/provider*, */ext-ui/tenant/\u003ctenant-name\u003e*\n"
                }
            },
            "required": [
                "externalEndpointId",
                "urlMatcherPattern",
                "urlMatcherScope"
            ],
            "inputProperties": {
                "externalEndpointId": {
                    "type": "string",
                    "description": "ID of the [External Endpoint](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/external_endpoint) where this API Filter will process the requests to\n"
                },
                "urlMatcherPattern": {
                    "type": "string",
                    "description": "Request URL pattern, written as a regular expression. This argument cannot exceed 1024 characters.\nIn most cases, it should end with `.*` (it is like a suffix) which specifies that all the parts of the URL coming after (like parameters) will be redirected to an external endpoint.\nIt is important to note that in the case of `url_matcher_scope=EXT_UI_TENANT`, the tenant name is not part of the pattern, it will match the request after the tenant name - if request\nis *\"/ext-ui/tenant/testOrg/custom/test\"*, the pattern will match against */custom/test*\n"
                },
                "urlMatcherScope": {
                    "type": "string",
                    "description": "Allowed values are `EXT_API`, `EXT_UI_PROVIDER`, `EXT_UI_TENANT` corresponding to\n*/ext-api*, */ext-ui/provider*, */ext-ui/tenant/\u003ctenant-name\u003e*\n"
                }
            },
            "requiredInputs": [
                "externalEndpointId",
                "urlMatcherPattern",
                "urlMatcherScope"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiFilter resources.\n",
                "properties": {
                    "externalEndpointId": {
                        "type": "string",
                        "description": "ID of the [External Endpoint](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/external_endpoint) where this API Filter will process the requests to\n"
                    },
                    "urlMatcherPattern": {
                        "type": "string",
                        "description": "Request URL pattern, written as a regular expression. This argument cannot exceed 1024 characters.\nIn most cases, it should end with `.*` (it is like a suffix) which specifies that all the parts of the URL coming after (like parameters) will be redirected to an external endpoint.\nIt is important to note that in the case of `url_matcher_scope=EXT_UI_TENANT`, the tenant name is not part of the pattern, it will match the request after the tenant name - if request\nis *\"/ext-ui/tenant/testOrg/custom/test\"*, the pattern will match against */custom/test*\n"
                    },
                    "urlMatcherScope": {
                        "type": "string",
                        "description": "Allowed values are `EXT_API`, `EXT_UI_PROVIDER`, `EXT_UI_TENANT` corresponding to\n*/ext-api*, */ext-ui/provider*, */ext-ui/tenant/\u003ctenant-name\u003e*\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/apiToken:ApiToken": {
            "properties": {
                "allowTokenFile": {
                    "type": "boolean",
                    "description": "An additional check that the user is aware that the file contains\nSENSITIVE information. Must be set to `true` or it will return a validation error.\n"
                },
                "fileName": {
                    "type": "string",
                    "description": "The name of the file which will be created containing the API token\n"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name of the API token for a specific user.\n"
                }
            },
            "required": [
                "allowTokenFile",
                "fileName",
                "name"
            ],
            "inputProperties": {
                "allowTokenFile": {
                    "type": "boolean",
                    "description": "An additional check that the user is aware that the file contains\nSENSITIVE information. Must be set to `true` or it will return a validation error.\n",
                    "willReplaceOnChanges": true
                },
                "fileName": {
                    "type": "string",
                    "description": "The name of the file which will be created containing the API token\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The unique name of the API token for a specific user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "allowTokenFile",
                "fileName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiToken resources.\n",
                "properties": {
                    "allowTokenFile": {
                        "type": "boolean",
                        "description": "An additional check that the user is aware that the file contains\nSENSITIVE information. Must be set to `true` or it will return a validation error.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileName": {
                        "type": "string",
                        "description": "The name of the file which will be created containing the API token\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The unique name of the API token for a specific user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/catalog:Catalog": {
            "properties": {
                "cacheEnabled": {
                    "type": "boolean",
                    "description": "Enable early catalog export to optimize synchronization. Default is `false`. It is recommended to set it to `true` when publishing the catalog.\n"
                },
                "catalogVersion": {
                    "type": "integer",
                    "description": "(*v3.6+*) Version number from this catalog.\n"
                },
                "created": {
                    "type": "string",
                    "description": "(*v3.6+*) Date and time of catalog creation\n"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "When destroying use `delete_force=true` with `delete_recursive=true` to remove a catalog and any objects it contains, regardless of their state. Default is `false`\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "When destroying use `delete_recursive=true` to remove the catalog and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of catalog\n"
                },
                "href": {
                    "type": "string",
                    "description": "Catalog HREF\n"
                },
                "isLocal": {
                    "type": "boolean",
                    "description": "(*v3.8.1+*) Indicates if this catalog was created in the current organization.\n"
                },
                "isPublished": {
                    "type": "boolean",
                    "description": "(*v3.6+*) Indicates if this catalog is shared to all organizations.\n"
                },
                "isShared": {
                    "type": "boolean",
                    "description": "(*v3.6+*) Indicates if the catalog is shared.\n"
                },
                "mediaItemLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v3.8+*) List of media item names in this catalog, in alphabetical order.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogMetadataEntry:CatalogMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Catalog name\n"
                },
                "numberOfMedia": {
                    "type": "integer",
                    "description": "(*v3.6+*) Number of media items available in this catalog.\n"
                },
                "numberOfVappTemplates": {
                    "type": "integer",
                    "description": "(*v3.6+*) Number of vApp templates available in this catalog.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations. \nWhen using a catalog shared from another organization, this field must have the name of that one, not the current one.\nIf you don't know the name of the sharing org, and put the current one, an error message will list the possible names.\n"
                },
                "ownerName": {
                    "type": "string",
                    "description": "(*v3.6+*) Owner of the catalog.\n"
                },
                "password": {
                    "type": "string",
                    "description": "An optional password to access the catalog. Only ASCII characters are allowed in a valid password.\n",
                    "secret": true
                },
                "preserveIdentityInformation": {
                    "type": "boolean",
                    "description": "Enable include BIOS UUIDs and MAC addresses in the downloaded OVF package. Preserving the identity information limits the portability of the package, and you should use it only when necessary. Default is `false`.\n"
                },
                "publishEnabled": {
                    "type": "boolean",
                    "description": "Enable allows to publish a catalog externally to make its vApp templates and media files available for subscription by organizations outside the Cloud Director installation. Default is `false`.\n"
                },
                "publishSubscriptionType": {
                    "type": "string",
                    "description": "(*v3.6+*) Shows if the catalog is `PUBLISHED`, if it is a subscription from another one (`SUBSCRIBED`), or none of those (`UNPUBLISHED`).\n"
                },
                "publishSubscriptionUrl": {
                    "type": "string",
                    "description": "(*v3.8+*) URL to which other catalogs can subscribe.\n"
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Allows to set specific storage profile to be used for catalog. **Note.** Data\nsource [vcd.getStorageProfile](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/storage_profile) can help to lookup storage profile ID.\n"
                },
                "vappTemplateLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v3.8+*) List of vApp template names in this catalog, in alphabetical order.\n"
                }
            },
            "required": [
                "catalogVersion",
                "created",
                "href",
                "isLocal",
                "isPublished",
                "isShared",
                "mediaItemLists",
                "metadata",
                "metadataEntries",
                "name",
                "numberOfMedia",
                "numberOfVappTemplates",
                "ownerName",
                "password",
                "publishSubscriptionType",
                "publishSubscriptionUrl",
                "vappTemplateLists"
            ],
            "inputProperties": {
                "cacheEnabled": {
                    "type": "boolean",
                    "description": "Enable early catalog export to optimize synchronization. Default is `false`. It is recommended to set it to `true` when publishing the catalog.\n"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "When destroying use `delete_force=true` with `delete_recursive=true` to remove a catalog and any objects it contains, regardless of their state. Default is `false`\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "When destroying use `delete_recursive=true` to remove the catalog and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of catalog\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogMetadataEntry:CatalogMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Catalog name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations. \nWhen using a catalog shared from another organization, this field must have the name of that one, not the current one.\nIf you don't know the name of the sharing org, and put the current one, an error message will list the possible names.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "An optional password to access the catalog. Only ASCII characters are allowed in a valid password.\n",
                    "secret": true
                },
                "preserveIdentityInformation": {
                    "type": "boolean",
                    "description": "Enable include BIOS UUIDs and MAC addresses in the downloaded OVF package. Preserving the identity information limits the portability of the package, and you should use it only when necessary. Default is `false`.\n"
                },
                "publishEnabled": {
                    "type": "boolean",
                    "description": "Enable allows to publish a catalog externally to make its vApp templates and media files available for subscription by organizations outside the Cloud Director installation. Default is `false`.\n"
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Allows to set specific storage profile to be used for catalog. **Note.** Data\nsource [vcd.getStorageProfile](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/storage_profile) can help to lookup storage profile ID.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Catalog resources.\n",
                "properties": {
                    "cacheEnabled": {
                        "type": "boolean",
                        "description": "Enable early catalog export to optimize synchronization. Default is `false`. It is recommended to set it to `true` when publishing the catalog.\n"
                    },
                    "catalogVersion": {
                        "type": "integer",
                        "description": "(*v3.6+*) Version number from this catalog.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "(*v3.6+*) Date and time of catalog creation\n"
                    },
                    "deleteForce": {
                        "type": "boolean",
                        "description": "When destroying use `delete_force=true` with `delete_recursive=true` to remove a catalog and any objects it contains, regardless of their state. Default is `false`\n"
                    },
                    "deleteRecursive": {
                        "type": "boolean",
                        "description": "When destroying use `delete_recursive=true` to remove the catalog and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of catalog\n"
                    },
                    "href": {
                        "type": "string",
                        "description": "Catalog HREF\n"
                    },
                    "isLocal": {
                        "type": "boolean",
                        "description": "(*v3.8.1+*) Indicates if this catalog was created in the current organization.\n"
                    },
                    "isPublished": {
                        "type": "boolean",
                        "description": "(*v3.6+*) Indicates if this catalog is shared to all organizations.\n"
                    },
                    "isShared": {
                        "type": "boolean",
                        "description": "(*v3.6+*) Indicates if the catalog is shared.\n"
                    },
                    "mediaItemLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v3.8+*) List of media item names in this catalog, in alphabetical order.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/CatalogMetadataEntry:CatalogMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Catalog name\n"
                    },
                    "numberOfMedia": {
                        "type": "integer",
                        "description": "(*v3.6+*) Number of media items available in this catalog.\n"
                    },
                    "numberOfVappTemplates": {
                        "type": "integer",
                        "description": "(*v3.6+*) Number of vApp templates available in this catalog.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations. \nWhen using a catalog shared from another organization, this field must have the name of that one, not the current one.\nIf you don't know the name of the sharing org, and put the current one, an error message will list the possible names.\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerName": {
                        "type": "string",
                        "description": "(*v3.6+*) Owner of the catalog.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "An optional password to access the catalog. Only ASCII characters are allowed in a valid password.\n",
                        "secret": true
                    },
                    "preserveIdentityInformation": {
                        "type": "boolean",
                        "description": "Enable include BIOS UUIDs and MAC addresses in the downloaded OVF package. Preserving the identity information limits the portability of the package, and you should use it only when necessary. Default is `false`.\n"
                    },
                    "publishEnabled": {
                        "type": "boolean",
                        "description": "Enable allows to publish a catalog externally to make its vApp templates and media files available for subscription by organizations outside the Cloud Director installation. Default is `false`.\n"
                    },
                    "publishSubscriptionType": {
                        "type": "string",
                        "description": "(*v3.6+*) Shows if the catalog is `PUBLISHED`, if it is a subscription from another one (`SUBSCRIBED`), or none of those (`UNPUBLISHED`).\n"
                    },
                    "publishSubscriptionUrl": {
                        "type": "string",
                        "description": "(*v3.8+*) URL to which other catalogs can subscribe.\n"
                    },
                    "storageProfileId": {
                        "type": "string",
                        "description": "Allows to set specific storage profile to be used for catalog. **Note.** Data\nsource [vcd.getStorageProfile](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/storage_profile) can help to lookup storage profile ID.\n"
                    },
                    "vappTemplateLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v3.8+*) List of vApp template names in this catalog, in alphabetical order.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/catalogAccessControl:CatalogAccessControl": {
            "properties": {
                "catalogId": {
                    "type": "string",
                    "description": "A unique identifier for the Catalog.\n"
                },
                "everyoneAccessLevel": {
                    "type": "string",
                    "description": "Access level when the Catalog is shared with everyone (it can only be set to\n`ReadOnly`). Required if `shared_with_everyone` is set.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the Catalog belongs. Optional if defined at provider level.\n"
                },
                "readOnlySharedWithAllOrgs": {
                    "type": "boolean",
                    "description": "If true, the catalog is shared as read-only with all organizations.\n"
                },
                "sharedWithEveryone": {
                    "type": "boolean",
                    "description": "Whether the Catalog is shared with everyone. If any `shared_with` blocks are included,\nthis property must be set to `false`.\n"
                },
                "sharedWiths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogAccessControlSharedWith:CatalogAccessControlSharedWith"
                    },
                    "description": "one or more blocks defining a subject (one of Organization, User, or Group) to which we are sharing. \nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is true.\n"
                }
            },
            "required": [
                "catalogId",
                "readOnlySharedWithAllOrgs",
                "sharedWithEveryone"
            ],
            "inputProperties": {
                "catalogId": {
                    "type": "string",
                    "description": "A unique identifier for the Catalog.\n",
                    "willReplaceOnChanges": true
                },
                "everyoneAccessLevel": {
                    "type": "string",
                    "description": "Access level when the Catalog is shared with everyone (it can only be set to\n`ReadOnly`). Required if `shared_with_everyone` is set.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the Catalog belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "readOnlySharedWithAllOrgs": {
                    "type": "boolean",
                    "description": "If true, the catalog is shared as read-only with all organizations.\n"
                },
                "sharedWithEveryone": {
                    "type": "boolean",
                    "description": "Whether the Catalog is shared with everyone. If any `shared_with` blocks are included,\nthis property must be set to `false`.\n"
                },
                "sharedWiths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogAccessControlSharedWith:CatalogAccessControlSharedWith"
                    },
                    "description": "one or more blocks defining a subject (one of Organization, User, or Group) to which we are sharing. \nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is true.\n"
                }
            },
            "requiredInputs": [
                "catalogId",
                "sharedWithEveryone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CatalogAccessControl resources.\n",
                "properties": {
                    "catalogId": {
                        "type": "string",
                        "description": "A unique identifier for the Catalog.\n",
                        "willReplaceOnChanges": true
                    },
                    "everyoneAccessLevel": {
                        "type": "string",
                        "description": "Access level when the Catalog is shared with everyone (it can only be set to\n`ReadOnly`). Required if `shared_with_everyone` is set.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the Catalog belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "readOnlySharedWithAllOrgs": {
                        "type": "boolean",
                        "description": "If true, the catalog is shared as read-only with all organizations.\n"
                    },
                    "sharedWithEveryone": {
                        "type": "boolean",
                        "description": "Whether the Catalog is shared with everyone. If any `shared_with` blocks are included,\nthis property must be set to `false`.\n"
                    },
                    "sharedWiths": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/CatalogAccessControlSharedWith:CatalogAccessControlSharedWith"
                        },
                        "description": "one or more blocks defining a subject (one of Organization, User, or Group) to which we are sharing. \nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is true.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/catalogItem:CatalogItem": {
            "properties": {
                "catalog": {
                    "type": "string",
                    "description": "The name of the catalog where to upload OVA file\n"
                },
                "catalogItemMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead.  Key value map of metadata to assign to the Catalog Item\n\n\u003e This resource handles metadata in the following way: `metadata` attribute assigns metadata to the associated **vApp Template**.\n`metadata_entry` attribute assigns metadata to the **Catalog Item**. `catalog_item_metadata` is deprecated and should not be used.\n\n\u003ca id=\"metadata\"\u003e\u003c/a\u003e\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "created": {
                    "type": "string",
                    "description": "Time stamp of when the item was created\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of item\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of metadata to assign to the associated vApp Template\n"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogItemMetadataEntry:CatalogItemMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign to the Catalog Item. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Item name in catalog\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "ovaPath": {
                    "type": "string",
                    "description": "Absolute or relative path to file to upload\n"
                },
                "ovfUrl": {
                    "type": "string",
                    "description": "URL to OVF file. Only OVF (not OVA) files are supported by VCD uploading by URL\n"
                },
                "showUploadProgress": {
                    "type": "boolean",
                    "description": "Default false. Allows seeing upload progress. (See note below)\n"
                },
                "uploadPieceSize": {
                    "type": "integer",
                    "description": "Size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB.\n"
                }
            },
            "required": [
                "catalog",
                "catalogItemMetadata",
                "created",
                "metadataEntries",
                "name"
            ],
            "inputProperties": {
                "catalog": {
                    "type": "string",
                    "description": "The name of the catalog where to upload OVA file\n",
                    "willReplaceOnChanges": true
                },
                "catalogItemMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead.  Key value map of metadata to assign to the Catalog Item\n\n\u003e This resource handles metadata in the following way: `metadata` attribute assigns metadata to the associated **vApp Template**.\n`metadata_entry` attribute assigns metadata to the **Catalog Item**. `catalog_item_metadata` is deprecated and should not be used.\n\n\u003ca id=\"metadata\"\u003e\u003c/a\u003e\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "description": {
                    "type": "string",
                    "description": "Description of item\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of metadata to assign to the associated vApp Template\n"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogItemMetadataEntry:CatalogItemMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign to the Catalog Item. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Item name in catalog\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "ovaPath": {
                    "type": "string",
                    "description": "Absolute or relative path to file to upload\n",
                    "willReplaceOnChanges": true
                },
                "ovfUrl": {
                    "type": "string",
                    "description": "URL to OVF file. Only OVF (not OVA) files are supported by VCD uploading by URL\n",
                    "willReplaceOnChanges": true
                },
                "showUploadProgress": {
                    "type": "boolean",
                    "description": "Default false. Allows seeing upload progress. (See note below)\n"
                },
                "uploadPieceSize": {
                    "type": "integer",
                    "description": "Size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB.\n"
                }
            },
            "requiredInputs": [
                "catalog"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CatalogItem resources.\n",
                "properties": {
                    "catalog": {
                        "type": "string",
                        "description": "The name of the catalog where to upload OVA file\n",
                        "willReplaceOnChanges": true
                    },
                    "catalogItemMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead.  Key value map of metadata to assign to the Catalog Item\n\n\u003e This resource handles metadata in the following way: `metadata` attribute assigns metadata to the associated **vApp Template**.\n`metadata_entry` attribute assigns metadata to the **Catalog Item**. `catalog_item_metadata` is deprecated and should not be used.\n\n\u003ca id=\"metadata\"\u003e\u003c/a\u003e\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "created": {
                        "type": "string",
                        "description": "Time stamp of when the item was created\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of item\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key value map of metadata to assign to the associated vApp Template\n"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/CatalogItemMetadataEntry:CatalogItemMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign to the Catalog Item. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Item name in catalog\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ovaPath": {
                        "type": "string",
                        "description": "Absolute or relative path to file to upload\n",
                        "willReplaceOnChanges": true
                    },
                    "ovfUrl": {
                        "type": "string",
                        "description": "URL to OVF file. Only OVF (not OVA) files are supported by VCD uploading by URL\n",
                        "willReplaceOnChanges": true
                    },
                    "showUploadProgress": {
                        "type": "boolean",
                        "description": "Default false. Allows seeing upload progress. (See note below)\n"
                    },
                    "uploadPieceSize": {
                        "type": "integer",
                        "description": "Size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/catalogMedia:CatalogMedia": {
            "properties": {
                "catalog": {
                    "type": "string",
                    "description": "The name of the catalog where to upload media file. It's mandatory if `catalog_id` is not used.\n",
                    "deprecationMessage": "Use catalog_id instead"
                },
                "catalogId": {
                    "type": "string",
                    "description": "The ID of the catalog where to upload media file. It's mandatory if `catalog` field is not used.\n"
                },
                "catalogItemId": {
                    "type": "string",
                    "description": "Catalog Item ID of this media item\n"
                },
                "creationDate": {
                    "type": "string",
                    "description": "(Computed) returns creation date\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of media file\n"
                },
                "isIso": {
                    "type": "boolean",
                    "description": "(Computed) returns True if this media file is ISO\n"
                },
                "isPublished": {
                    "type": "boolean",
                    "description": "(Computed) returns True if this media file is in a published catalog\n"
                },
                "mediaPath": {
                    "type": "string",
                    "description": "Absolute or relative path to file to upload\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogMediaMetadataEntry:CatalogMediaMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Media file name in catalog\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "ownerName": {
                    "type": "string",
                    "description": "(Computed) returns owner name\n"
                },
                "showUploadProgress": {
                    "type": "boolean",
                    "description": "Default false. Allows to see upload progress. (See note below)\n"
                },
                "size": {
                    "type": "integer",
                    "description": "(Computed) returns media storage in Bytes\n"
                },
                "status": {
                    "type": "string",
                    "description": "(Computed) returns media status\n"
                },
                "storageProfileName": {
                    "type": "string",
                    "description": "(Computed) returns storage profile name\n"
                },
                "uploadAnyFile": {
                    "type": "boolean",
                    "description": "If `true`, allows uploading any file type. With the default `false`, we can only upload `.ISO` files.\n"
                },
                "uploadPieceSize": {
                    "type": "integer",
                    "description": "size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB.\n"
                }
            },
            "required": [
                "catalog",
                "catalogId",
                "catalogItemId",
                "creationDate",
                "isIso",
                "isPublished",
                "metadata",
                "metadataEntries",
                "name",
                "org",
                "ownerName",
                "size",
                "status",
                "storageProfileName"
            ],
            "inputProperties": {
                "catalog": {
                    "type": "string",
                    "description": "The name of the catalog where to upload media file. It's mandatory if `catalog_id` is not used.\n",
                    "deprecationMessage": "Use catalog_id instead",
                    "willReplaceOnChanges": true
                },
                "catalogId": {
                    "type": "string",
                    "description": "The ID of the catalog where to upload media file. It's mandatory if `catalog` field is not used.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Description of media file\n",
                    "willReplaceOnChanges": true
                },
                "mediaPath": {
                    "type": "string",
                    "description": "Absolute or relative path to file to upload\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogMediaMetadataEntry:CatalogMediaMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Media file name in catalog\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "showUploadProgress": {
                    "type": "boolean",
                    "description": "Default false. Allows to see upload progress. (See note below)\n"
                },
                "uploadAnyFile": {
                    "type": "boolean",
                    "description": "If `true`, allows uploading any file type. With the default `false`, we can only upload `.ISO` files.\n"
                },
                "uploadPieceSize": {
                    "type": "integer",
                    "description": "size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CatalogMedia resources.\n",
                "properties": {
                    "catalog": {
                        "type": "string",
                        "description": "The name of the catalog where to upload media file. It's mandatory if `catalog_id` is not used.\n",
                        "deprecationMessage": "Use catalog_id instead",
                        "willReplaceOnChanges": true
                    },
                    "catalogId": {
                        "type": "string",
                        "description": "The ID of the catalog where to upload media file. It's mandatory if `catalog` field is not used.\n",
                        "willReplaceOnChanges": true
                    },
                    "catalogItemId": {
                        "type": "string",
                        "description": "Catalog Item ID of this media item\n"
                    },
                    "creationDate": {
                        "type": "string",
                        "description": "(Computed) returns creation date\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of media file\n",
                        "willReplaceOnChanges": true
                    },
                    "isIso": {
                        "type": "boolean",
                        "description": "(Computed) returns True if this media file is ISO\n"
                    },
                    "isPublished": {
                        "type": "boolean",
                        "description": "(Computed) returns True if this media file is in a published catalog\n"
                    },
                    "mediaPath": {
                        "type": "string",
                        "description": "Absolute or relative path to file to upload\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/CatalogMediaMetadataEntry:CatalogMediaMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Media file name in catalog\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerName": {
                        "type": "string",
                        "description": "(Computed) returns owner name\n"
                    },
                    "showUploadProgress": {
                        "type": "boolean",
                        "description": "Default false. Allows to see upload progress. (See note below)\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "(Computed) returns media storage in Bytes\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "(Computed) returns media status\n"
                    },
                    "storageProfileName": {
                        "type": "string",
                        "description": "(Computed) returns storage profile name\n"
                    },
                    "uploadAnyFile": {
                        "type": "boolean",
                        "description": "If `true`, allows uploading any file type. With the default `false`, we can only upload `.ISO` files.\n"
                    },
                    "uploadPieceSize": {
                        "type": "integer",
                        "description": "size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/catalogVappTemplate:CatalogVappTemplate": {
            "properties": {
                "captureVapp": {
                    "$ref": "#/types/vcd:index/CatalogVappTemplateCaptureVapp:CatalogVappTemplateCaptureVapp",
                    "description": "A configuration block to create template from existing\nvApp (Standalone VM or vApp)\n"
                },
                "catalogId": {
                    "type": "string",
                    "description": "ID of the Catalog where to upload the OVA file\n"
                },
                "catalogItemId": {
                    "type": "string",
                    "description": "Catalog Item ID\n"
                },
                "created": {
                    "type": "string",
                    "description": "Timestamp of when the vApp Template was created\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the vApp Template. Not to be used with `ovf_url` when target OVA has a description\n"
                },
                "inheritedMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map that contains metadata that is automatically added by VCD (10.5.1+) and provides details on the origin of the VM\n"
                },
                "lease": {
                    "$ref": "#/types/vcd:index/CatalogVappTemplateLease:CatalogVappTemplateLease",
                    "description": "The information about the vApp Template lease. It includes the field below. When this section is\nincluded, the field is mandatory. If lease value is higher than the one allowed for the whole Org, we get an error\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key/value map of metadata to assign to the associated vApp Template\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogVappTemplateMetadataEntry:CatalogVappTemplateMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "vApp Template name in Catalog\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "ovaPath": {
                    "type": "string",
                    "description": "Absolute or relative path to file to upload\n"
                },
                "ovfUrl": {
                    "type": "string",
                    "description": "URL to OVF file. Only OVF (not OVA) files are supported by VCD uploading by URL\n"
                },
                "uploadPieceSize": {
                    "type": "integer",
                    "description": "Size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB\n"
                },
                "vdcId": {
                    "type": "string",
                    "description": "The VDC ID to which this vApp Template belongs\n"
                },
                "vmNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of VM names within the vApp template\n"
                }
            },
            "required": [
                "catalogId",
                "catalogItemId",
                "created",
                "description",
                "inheritedMetadata",
                "lease",
                "metadata",
                "metadataEntries",
                "name",
                "vdcId",
                "vmNames"
            ],
            "inputProperties": {
                "captureVapp": {
                    "$ref": "#/types/vcd:index/CatalogVappTemplateCaptureVapp:CatalogVappTemplateCaptureVapp",
                    "description": "A configuration block to create template from existing\nvApp (Standalone VM or vApp)\n"
                },
                "catalogId": {
                    "type": "string",
                    "description": "ID of the Catalog where to upload the OVA file\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Description of the vApp Template. Not to be used with `ovf_url` when target OVA has a description\n"
                },
                "lease": {
                    "$ref": "#/types/vcd:index/CatalogVappTemplateLease:CatalogVappTemplateLease",
                    "description": "The information about the vApp Template lease. It includes the field below. When this section is\nincluded, the field is mandatory. If lease value is higher than the one allowed for the whole Org, we get an error\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key/value map of metadata to assign to the associated vApp Template\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CatalogVappTemplateMetadataEntry:CatalogVappTemplateMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "vApp Template name in Catalog\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "ovaPath": {
                    "type": "string",
                    "description": "Absolute or relative path to file to upload\n",
                    "willReplaceOnChanges": true
                },
                "ovfUrl": {
                    "type": "string",
                    "description": "URL to OVF file. Only OVF (not OVA) files are supported by VCD uploading by URL\n",
                    "willReplaceOnChanges": true
                },
                "uploadPieceSize": {
                    "type": "integer",
                    "description": "Size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB\n"
                }
            },
            "requiredInputs": [
                "catalogId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CatalogVappTemplate resources.\n",
                "properties": {
                    "captureVapp": {
                        "$ref": "#/types/vcd:index/CatalogVappTemplateCaptureVapp:CatalogVappTemplateCaptureVapp",
                        "description": "A configuration block to create template from existing\nvApp (Standalone VM or vApp)\n"
                    },
                    "catalogId": {
                        "type": "string",
                        "description": "ID of the Catalog where to upload the OVA file\n",
                        "willReplaceOnChanges": true
                    },
                    "catalogItemId": {
                        "type": "string",
                        "description": "Catalog Item ID\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "Timestamp of when the vApp Template was created\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the vApp Template. Not to be used with `ovf_url` when target OVA has a description\n"
                    },
                    "inheritedMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map that contains metadata that is automatically added by VCD (10.5.1+) and provides details on the origin of the VM\n"
                    },
                    "lease": {
                        "$ref": "#/types/vcd:index/CatalogVappTemplateLease:CatalogVappTemplateLease",
                        "description": "The information about the vApp Template lease. It includes the field below. When this section is\nincluded, the field is mandatory. If lease value is higher than the one allowed for the whole Org, we get an error\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key/value map of metadata to assign to the associated vApp Template\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/CatalogVappTemplateMetadataEntry:CatalogVappTemplateMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "vApp Template name in Catalog\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ovaPath": {
                        "type": "string",
                        "description": "Absolute or relative path to file to upload\n",
                        "willReplaceOnChanges": true
                    },
                    "ovfUrl": {
                        "type": "string",
                        "description": "URL to OVF file. Only OVF (not OVA) files are supported by VCD uploading by URL\n",
                        "willReplaceOnChanges": true
                    },
                    "uploadPieceSize": {
                        "type": "integer",
                        "description": "Size in MB for splitting upload size. It can possibly impact upload performance. Default 1MB\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The VDC ID to which this vApp Template belongs\n"
                    },
                    "vmNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of VM names within the vApp template\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/clonedVapp:ClonedVapp": {
            "properties": {
                "deleteSource": {
                    "type": "boolean",
                    "description": "A boolean value of `true` or `false` stating if the source entity should be deleted after creation.\nA source vApp can only be deleted if it is fully powered off.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the vApp, up to 256 characters.\n"
                },
                "href": {
                    "type": "string",
                    "description": "(Computed) The vApp Hyper Reference.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the vApp\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this vApp should be powered on. Default is `false`.\n"
                },
                "sourceId": {
                    "type": "string",
                    "description": "The ID of the source to use.\n"
                },
                "sourceType": {
                    "type": "string",
                    "description": "The type of the source to use: one of `template` or `vapp`.\n"
                },
                "status": {
                    "type": "integer",
                    "description": "(Computed) The vApp status as a numeric code.\n"
                },
                "statusText": {
                    "type": "string",
                    "description": "(Computed) The vApp status as text.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vmLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Computed) The list of VM names included in this vApp, in alphabetic order.\n"
                }
            },
            "required": [
                "href",
                "name",
                "sourceId",
                "sourceType",
                "status",
                "statusText",
                "vmLists"
            ],
            "inputProperties": {
                "deleteSource": {
                    "type": "boolean",
                    "description": "A boolean value of `true` or `false` stating if the source entity should be deleted after creation.\nA source vApp can only be deleted if it is fully powered off.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the vApp, up to 256 characters.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the vApp\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this vApp should be powered on. Default is `false`.\n",
                    "willReplaceOnChanges": true
                },
                "sourceId": {
                    "type": "string",
                    "description": "The ID of the source to use.\n",
                    "willReplaceOnChanges": true
                },
                "sourceType": {
                    "type": "string",
                    "description": "The type of the source to use: one of `template` or `vapp`.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "sourceId",
                "sourceType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClonedVapp resources.\n",
                "properties": {
                    "deleteSource": {
                        "type": "boolean",
                        "description": "A boolean value of `true` or `false` stating if the source entity should be deleted after creation.\nA source vApp can only be deleted if it is fully powered off.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description for the vApp, up to 256 characters.\n",
                        "willReplaceOnChanges": true
                    },
                    "href": {
                        "type": "string",
                        "description": "(Computed) The vApp Hyper Reference.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the vApp\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "powerOn": {
                        "type": "boolean",
                        "description": "A boolean value stating if this vApp should be powered on. Default is `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceId": {
                        "type": "string",
                        "description": "The ID of the source to use.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceType": {
                        "type": "string",
                        "description": "The type of the source to use: one of `template` or `vapp`.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "integer",
                        "description": "(Computed) The vApp status as a numeric code.\n"
                    },
                    "statusText": {
                        "type": "string",
                        "description": "(Computed) The vApp status as text.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vmLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The list of VM names included in this vApp, in alphabetic order.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/cseKubernetesCluster:CseKubernetesCluster": {
            "properties": {
                "apiTokenFile": {
                    "type": "string",
                    "description": "Must be a file generated by [`vcd.ApiToken` resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_token),\nor a file that follows the same formatting, that stores the API token used to create and manage the cluster,\nowned by the user specified in `owner`. Be careful about this file, as it contains sensitive information\n"
                },
                "autoRepairOnErrors": {
                    "type": "boolean",
                    "description": "If errors occur before the Kubernetes cluster becomes available, and this argument is `true`,\nCSE Server will automatically attempt to repair the cluster. Defaults to `false`.\nSince CSE 4.1.1, when the cluster is available/provisioned, this flag is set automatically to false.\n"
                },
                "capvcdVersion": {
                    "type": "string",
                    "description": "The version of CAPVCD used by this cluster\n"
                },
                "clusterResourceSetBindings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The cluster resource set bindings of this cluster\n"
                },
                "controlPlane": {
                    "$ref": "#/types/vcd:index/CseKubernetesClusterControlPlane:CseKubernetesClusterControlPlane",
                    "description": "See **Control Plane**\n"
                },
                "cpiVersion": {
                    "type": "string",
                    "description": "The version of the Cloud Provider Interface used by this cluster\n"
                },
                "cseVersion": {
                    "type": "string",
                    "description": "Specifies the CSE version to use. Accepted versions: `4.1.0`, `4.1.1` (also for *4.1.1a*),\n`4.2.0`, `4.2.1`, `4.2.2` (VCD Provider *v3.14.1+*) and `4.2.3` (VCD Provider *v3.14.1+*)\n"
                },
                "csiVersion": {
                    "type": "string",
                    "description": "The version of the Container Storage Interface used by this cluster\n"
                },
                "defaultStorageClass": {
                    "$ref": "#/types/vcd:index/CseKubernetesClusterDefaultStorageClass:CseKubernetesClusterDefaultStorageClass",
                    "description": "See **Default Storage Class**\n"
                },
                "events": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CseKubernetesClusterEvent:CseKubernetesClusterEvent"
                    },
                    "description": "A set of events that happened during the Kubernetes cluster lifecycle. They're ordered from most recent to least. Each event has:\n"
                },
                "kubeconfig": {
                    "type": "string",
                    "description": "The ready-to-use Kubeconfig file **contents** as a raw string. Only available when `state=provisioned`\n",
                    "secret": true
                },
                "kubernetesTemplateId": {
                    "type": "string",
                    "description": "The ID of the vApp Template that corresponds to a Kubernetes template OVA\n"
                },
                "kubernetesVersion": {
                    "type": "string",
                    "description": "The version of Kubernetes installed in this cluster\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or \"-\",\nstart with an alphabetic character, end with an alphanumeric, and contain at most 31 characters\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The ID of the network that the Kubernetes cluster will use\n"
                },
                "nodeHealthCheck": {
                    "type": "boolean",
                    "description": "After the Kubernetes cluster becomes available, nodes that become unhealthy will be\nremediated according to unhealthy node conditions and remediation rules. Defaults to `false`\n"
                },
                "operationsTimeoutMinutes": {
                    "type": "integer",
                    "description": "The time, in minutes, to wait for the cluster operations to be successfully completed. For example, during cluster\ncreation, it should be in `provisioned`state before the timeout is reached, otherwise the operation will return an\nerror. For cluster deletion, this timeoutspecifies the time to wait until the cluster is completely deleted. Setting\nthis argument to `0` means to wait indefinitely\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization that will host the Kubernetes cluster, optional if defined in the provider configuration\n"
                },
                "owner": {
                    "type": "string",
                    "description": "The user that creates the cluster and owns the API token specified in `api_token`.\nIt must have the `Kubernetes Cluster Author` role that was created during CSE installation.\nIf not specified, it assumes it's the user from the provider configuration\n\n\u003e Versions 4.2.2 and 4.2.3 should not use the System administrator for the `owner` nor `api_token_file`, as stated in their\n[release notes](https://docs.vmware.com/en/VMware-Cloud-Director-Container-Service-Extension/4.2.2/rn/vmware-cloud-director-container-service-extension-422-release-notes/index.html#Known%20Issues),\nthere is an existing issue that prevents the cluster to be created.\n"
                },
                "podsCidr": {
                    "type": "string",
                    "description": "A CIDR block for the pods to use. Defaults to `100.96.0.0/11`\n"
                },
                "runtime": {
                    "type": "string",
                    "description": "Specifies the Kubernetes runtime to use. Defaults to `tkg` (Tanzu Kubernetes Grid)\n"
                },
                "servicesCidr": {
                    "type": "string",
                    "description": "A CIDR block for the services to use. Defaults to `100.64.0.0/13`\n"
                },
                "sshPublicKey": {
                    "type": "string",
                    "description": "The SSH public key used to log in into the cluster nodes\n"
                },
                "state": {
                    "type": "string",
                    "description": "The Kubernetes cluster status, can be `provisioning` when it is being created, `provisioned` when it was successfully\ncreated and ready to use, or `error` when an error occurred. `provisioning` can only be obtained when a timeout happens during\ncluster creation. `error` can only be obtained either with a timeout or when `auto_repair_on_errors=false`.\n"
                },
                "supportedUpgrades": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of vApp Template names that can be fetched with a\n[`vcd.CatalogVappTemplate` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) to upgrade the cluster.\n"
                },
                "tkgProductVersion": {
                    "type": "string",
                    "description": "The version of TKG installed in this cluster\n"
                },
                "vdcId": {
                    "type": "string",
                    "description": "The ID of the VDC that hosts the Kubernetes cluster\n"
                },
                "virtualIpSubnet": {
                    "type": "string",
                    "description": "A virtual IP subnet for the cluster\n"
                },
                "workerPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CseKubernetesClusterWorkerPool:CseKubernetesClusterWorkerPool"
                    },
                    "description": "See **Worker Pools**\n"
                }
            },
            "required": [
                "autoRepairOnErrors",
                "capvcdVersion",
                "clusterResourceSetBindings",
                "controlPlane",
                "cpiVersion",
                "cseVersion",
                "csiVersion",
                "events",
                "kubeconfig",
                "kubernetesTemplateId",
                "kubernetesVersion",
                "name",
                "networkId",
                "state",
                "supportedUpgrades",
                "tkgProductVersion",
                "vdcId",
                "workerPools"
            ],
            "inputProperties": {
                "apiTokenFile": {
                    "type": "string",
                    "description": "Must be a file generated by [`vcd.ApiToken` resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_token),\nor a file that follows the same formatting, that stores the API token used to create and manage the cluster,\nowned by the user specified in `owner`. Be careful about this file, as it contains sensitive information\n"
                },
                "autoRepairOnErrors": {
                    "type": "boolean",
                    "description": "If errors occur before the Kubernetes cluster becomes available, and this argument is `true`,\nCSE Server will automatically attempt to repair the cluster. Defaults to `false`.\nSince CSE 4.1.1, when the cluster is available/provisioned, this flag is set automatically to false.\n"
                },
                "controlPlane": {
                    "$ref": "#/types/vcd:index/CseKubernetesClusterControlPlane:CseKubernetesClusterControlPlane",
                    "description": "See **Control Plane**\n"
                },
                "cseVersion": {
                    "type": "string",
                    "description": "Specifies the CSE version to use. Accepted versions: `4.1.0`, `4.1.1` (also for *4.1.1a*),\n`4.2.0`, `4.2.1`, `4.2.2` (VCD Provider *v3.14.1+*) and `4.2.3` (VCD Provider *v3.14.1+*)\n"
                },
                "defaultStorageClass": {
                    "$ref": "#/types/vcd:index/CseKubernetesClusterDefaultStorageClass:CseKubernetesClusterDefaultStorageClass",
                    "description": "See **Default Storage Class**\n"
                },
                "kubernetesTemplateId": {
                    "type": "string",
                    "description": "The ID of the vApp Template that corresponds to a Kubernetes template OVA\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or \"-\",\nstart with an alphabetic character, end with an alphanumeric, and contain at most 31 characters\n",
                    "willReplaceOnChanges": true
                },
                "networkId": {
                    "type": "string",
                    "description": "The ID of the network that the Kubernetes cluster will use\n",
                    "willReplaceOnChanges": true
                },
                "nodeHealthCheck": {
                    "type": "boolean",
                    "description": "After the Kubernetes cluster becomes available, nodes that become unhealthy will be\nremediated according to unhealthy node conditions and remediation rules. Defaults to `false`\n"
                },
                "operationsTimeoutMinutes": {
                    "type": "integer",
                    "description": "The time, in minutes, to wait for the cluster operations to be successfully completed. For example, during cluster\ncreation, it should be in `provisioned`state before the timeout is reached, otherwise the operation will return an\nerror. For cluster deletion, this timeoutspecifies the time to wait until the cluster is completely deleted. Setting\nthis argument to `0` means to wait indefinitely\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization that will host the Kubernetes cluster, optional if defined in the provider configuration\n",
                    "willReplaceOnChanges": true
                },
                "owner": {
                    "type": "string",
                    "description": "The user that creates the cluster and owns the API token specified in `api_token`.\nIt must have the `Kubernetes Cluster Author` role that was created during CSE installation.\nIf not specified, it assumes it's the user from the provider configuration\n\n\u003e Versions 4.2.2 and 4.2.3 should not use the System administrator for the `owner` nor `api_token_file`, as stated in their\n[release notes](https://docs.vmware.com/en/VMware-Cloud-Director-Container-Service-Extension/4.2.2/rn/vmware-cloud-director-container-service-extension-422-release-notes/index.html#Known%20Issues),\nthere is an existing issue that prevents the cluster to be created.\n",
                    "willReplaceOnChanges": true
                },
                "podsCidr": {
                    "type": "string",
                    "description": "A CIDR block for the pods to use. Defaults to `100.96.0.0/11`\n"
                },
                "runtime": {
                    "type": "string",
                    "description": "Specifies the Kubernetes runtime to use. Defaults to `tkg` (Tanzu Kubernetes Grid)\n",
                    "willReplaceOnChanges": true
                },
                "servicesCidr": {
                    "type": "string",
                    "description": "A CIDR block for the services to use. Defaults to `100.64.0.0/13`\n"
                },
                "sshPublicKey": {
                    "type": "string",
                    "description": "The SSH public key used to log in into the cluster nodes\n",
                    "willReplaceOnChanges": true
                },
                "vdcId": {
                    "type": "string",
                    "description": "The ID of the VDC that hosts the Kubernetes cluster\n",
                    "willReplaceOnChanges": true
                },
                "virtualIpSubnet": {
                    "type": "string",
                    "description": "A virtual IP subnet for the cluster\n"
                },
                "workerPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/CseKubernetesClusterWorkerPool:CseKubernetesClusterWorkerPool"
                    },
                    "description": "See **Worker Pools**\n"
                }
            },
            "requiredInputs": [
                "controlPlane",
                "cseVersion",
                "kubernetesTemplateId",
                "networkId",
                "vdcId",
                "workerPools"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CseKubernetesCluster resources.\n",
                "properties": {
                    "apiTokenFile": {
                        "type": "string",
                        "description": "Must be a file generated by [`vcd.ApiToken` resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_token),\nor a file that follows the same formatting, that stores the API token used to create and manage the cluster,\nowned by the user specified in `owner`. Be careful about this file, as it contains sensitive information\n"
                    },
                    "autoRepairOnErrors": {
                        "type": "boolean",
                        "description": "If errors occur before the Kubernetes cluster becomes available, and this argument is `true`,\nCSE Server will automatically attempt to repair the cluster. Defaults to `false`.\nSince CSE 4.1.1, when the cluster is available/provisioned, this flag is set automatically to false.\n"
                    },
                    "capvcdVersion": {
                        "type": "string",
                        "description": "The version of CAPVCD used by this cluster\n"
                    },
                    "clusterResourceSetBindings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The cluster resource set bindings of this cluster\n"
                    },
                    "controlPlane": {
                        "$ref": "#/types/vcd:index/CseKubernetesClusterControlPlane:CseKubernetesClusterControlPlane",
                        "description": "See **Control Plane**\n"
                    },
                    "cpiVersion": {
                        "type": "string",
                        "description": "The version of the Cloud Provider Interface used by this cluster\n"
                    },
                    "cseVersion": {
                        "type": "string",
                        "description": "Specifies the CSE version to use. Accepted versions: `4.1.0`, `4.1.1` (also for *4.1.1a*),\n`4.2.0`, `4.2.1`, `4.2.2` (VCD Provider *v3.14.1+*) and `4.2.3` (VCD Provider *v3.14.1+*)\n"
                    },
                    "csiVersion": {
                        "type": "string",
                        "description": "The version of the Container Storage Interface used by this cluster\n"
                    },
                    "defaultStorageClass": {
                        "$ref": "#/types/vcd:index/CseKubernetesClusterDefaultStorageClass:CseKubernetesClusterDefaultStorageClass",
                        "description": "See **Default Storage Class**\n"
                    },
                    "events": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/CseKubernetesClusterEvent:CseKubernetesClusterEvent"
                        },
                        "description": "A set of events that happened during the Kubernetes cluster lifecycle. They're ordered from most recent to least. Each event has:\n"
                    },
                    "kubeconfig": {
                        "type": "string",
                        "description": "The ready-to-use Kubeconfig file **contents** as a raw string. Only available when `state=provisioned`\n",
                        "secret": true
                    },
                    "kubernetesTemplateId": {
                        "type": "string",
                        "description": "The ID of the vApp Template that corresponds to a Kubernetes template OVA\n"
                    },
                    "kubernetesVersion": {
                        "type": "string",
                        "description": "The version of Kubernetes installed in this cluster\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or \"-\",\nstart with an alphabetic character, end with an alphanumeric, and contain at most 31 characters\n",
                        "willReplaceOnChanges": true
                    },
                    "networkId": {
                        "type": "string",
                        "description": "The ID of the network that the Kubernetes cluster will use\n",
                        "willReplaceOnChanges": true
                    },
                    "nodeHealthCheck": {
                        "type": "boolean",
                        "description": "After the Kubernetes cluster becomes available, nodes that become unhealthy will be\nremediated according to unhealthy node conditions and remediation rules. Defaults to `false`\n"
                    },
                    "operationsTimeoutMinutes": {
                        "type": "integer",
                        "description": "The time, in minutes, to wait for the cluster operations to be successfully completed. For example, during cluster\ncreation, it should be in `provisioned`state before the timeout is reached, otherwise the operation will return an\nerror. For cluster deletion, this timeoutspecifies the time to wait until the cluster is completely deleted. Setting\nthis argument to `0` means to wait indefinitely\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization that will host the Kubernetes cluster, optional if defined in the provider configuration\n",
                        "willReplaceOnChanges": true
                    },
                    "owner": {
                        "type": "string",
                        "description": "The user that creates the cluster and owns the API token specified in `api_token`.\nIt must have the `Kubernetes Cluster Author` role that was created during CSE installation.\nIf not specified, it assumes it's the user from the provider configuration\n\n\u003e Versions 4.2.2 and 4.2.3 should not use the System administrator for the `owner` nor `api_token_file`, as stated in their\n[release notes](https://docs.vmware.com/en/VMware-Cloud-Director-Container-Service-Extension/4.2.2/rn/vmware-cloud-director-container-service-extension-422-release-notes/index.html#Known%20Issues),\nthere is an existing issue that prevents the cluster to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "podsCidr": {
                        "type": "string",
                        "description": "A CIDR block for the pods to use. Defaults to `100.96.0.0/11`\n"
                    },
                    "runtime": {
                        "type": "string",
                        "description": "Specifies the Kubernetes runtime to use. Defaults to `tkg` (Tanzu Kubernetes Grid)\n",
                        "willReplaceOnChanges": true
                    },
                    "servicesCidr": {
                        "type": "string",
                        "description": "A CIDR block for the services to use. Defaults to `100.64.0.0/13`\n"
                    },
                    "sshPublicKey": {
                        "type": "string",
                        "description": "The SSH public key used to log in into the cluster nodes\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "The Kubernetes cluster status, can be `provisioning` when it is being created, `provisioned` when it was successfully\ncreated and ready to use, or `error` when an error occurred. `provisioning` can only be obtained when a timeout happens during\ncluster creation. `error` can only be obtained either with a timeout or when `auto_repair_on_errors=false`.\n"
                    },
                    "supportedUpgrades": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of vApp Template names that can be fetched with a\n[`vcd.CatalogVappTemplate` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) to upgrade the cluster.\n"
                    },
                    "tkgProductVersion": {
                        "type": "string",
                        "description": "The version of TKG installed in this cluster\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of the VDC that hosts the Kubernetes cluster\n",
                        "willReplaceOnChanges": true
                    },
                    "virtualIpSubnet": {
                        "type": "string",
                        "description": "A virtual IP subnet for the cluster\n"
                    },
                    "workerPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/CseKubernetesClusterWorkerPool:CseKubernetesClusterWorkerPool"
                        },
                        "description": "See **Worker Pools**\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/dseRegistryConfiguration:DseRegistryConfiguration": {
            "properties": {
                "chartRepository": {
                    "type": "string",
                    "description": "Chart repository for Helm based images\n"
                },
                "compatibleVersionConstraints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of version constrains that this Data Solution defines\n"
                },
                "containerRegistries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/DseRegistryConfigurationContainerRegistry:DseRegistryConfigurationContainerRegistry"
                    },
                    "description": "Only applies to `VCD Data Solutions` configuration. Specifies\ncredentials that can be used to authenticate to repositories. See Container Registry\nConfiguration \n\n\n\u003ca id=\"container-registry\"\u003e\u003c/a\u003e\n"
                },
                "defaultChartRepository": {
                    "type": "string",
                    "description": "Default chart repository as provided by Data Solution\n"
                },
                "defaultPackageName": {
                    "type": "string",
                    "description": "Default package name as provided by Data Solution\n"
                },
                "defaultRepository": {
                    "type": "string",
                    "description": "Default container repository as provided by Data Solution\n"
                },
                "defaultVersion": {
                    "type": "string",
                    "description": "Default package version as provided by Data Solution\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of Data Solution as it appears in repository configuration\n"
                },
                "packageName": {
                    "type": "string",
                    "description": "Helm package name. Only for Helm based images\n"
                },
                "packageRepository": {
                    "type": "string",
                    "description": "Package repository for container based images\n"
                },
                "rdeState": {
                    "type": "string",
                    "description": "State of parent Runtime Defined Entity (RDE)\n"
                },
                "requiresVersionCompatibility": {
                    "type": "boolean",
                    "description": "Boolean flag as defined in Data Solution\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of repository settings. It can be one of `PackageRepository`, `ChartRepository`\n"
                },
                "useDefaultValues": {
                    "type": "boolean",
                    "description": "Defines if repository settings should be inherited from Data\nSolution itself. Default `false`\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of package to use. Required when `use_default_values` is not used.\n"
                }
            },
            "required": [
                "chartRepository",
                "compatibleVersionConstraints",
                "defaultChartRepository",
                "defaultPackageName",
                "defaultRepository",
                "defaultVersion",
                "name",
                "packageName",
                "packageRepository",
                "rdeState",
                "requiresVersionCompatibility",
                "type",
                "version"
            ],
            "inputProperties": {
                "chartRepository": {
                    "type": "string",
                    "description": "Chart repository for Helm based images\n"
                },
                "containerRegistries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/DseRegistryConfigurationContainerRegistry:DseRegistryConfigurationContainerRegistry"
                    },
                    "description": "Only applies to `VCD Data Solutions` configuration. Specifies\ncredentials that can be used to authenticate to repositories. See Container Registry\nConfiguration \n\n\n\u003ca id=\"container-registry\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of Data Solution as it appears in repository configuration\n",
                    "willReplaceOnChanges": true
                },
                "packageName": {
                    "type": "string",
                    "description": "Helm package name. Only for Helm based images\n"
                },
                "packageRepository": {
                    "type": "string",
                    "description": "Package repository for container based images\n"
                },
                "useDefaultValues": {
                    "type": "boolean",
                    "description": "Defines if repository settings should be inherited from Data\nSolution itself. Default `false`\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of package to use. Required when `use_default_values` is not used.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DseRegistryConfiguration resources.\n",
                "properties": {
                    "chartRepository": {
                        "type": "string",
                        "description": "Chart repository for Helm based images\n"
                    },
                    "compatibleVersionConstraints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of version constrains that this Data Solution defines\n"
                    },
                    "containerRegistries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/DseRegistryConfigurationContainerRegistry:DseRegistryConfigurationContainerRegistry"
                        },
                        "description": "Only applies to `VCD Data Solutions` configuration. Specifies\ncredentials that can be used to authenticate to repositories. See Container Registry\nConfiguration \n\n\n\u003ca id=\"container-registry\"\u003e\u003c/a\u003e\n"
                    },
                    "defaultChartRepository": {
                        "type": "string",
                        "description": "Default chart repository as provided by Data Solution\n"
                    },
                    "defaultPackageName": {
                        "type": "string",
                        "description": "Default package name as provided by Data Solution\n"
                    },
                    "defaultRepository": {
                        "type": "string",
                        "description": "Default container repository as provided by Data Solution\n"
                    },
                    "defaultVersion": {
                        "type": "string",
                        "description": "Default package version as provided by Data Solution\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of Data Solution as it appears in repository configuration\n",
                        "willReplaceOnChanges": true
                    },
                    "packageName": {
                        "type": "string",
                        "description": "Helm package name. Only for Helm based images\n"
                    },
                    "packageRepository": {
                        "type": "string",
                        "description": "Package repository for container based images\n"
                    },
                    "rdeState": {
                        "type": "string",
                        "description": "State of parent Runtime Defined Entity (RDE)\n"
                    },
                    "requiresVersionCompatibility": {
                        "type": "boolean",
                        "description": "Boolean flag as defined in Data Solution\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of repository settings. It can be one of `PackageRepository`, `ChartRepository`\n"
                    },
                    "useDefaultValues": {
                        "type": "boolean",
                        "description": "Defines if repository settings should be inherited from Data\nSolution itself. Default `false`\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "Version of package to use. Required when `use_default_values` is not used.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/dseSolutionPublish:DseSolutionPublish": {
            "properties": {
                "confluentLicenseKey": {
                    "type": "string",
                    "description": "Required for `Confluent Platform` Data Solution if . One of\n`confluent_license_type` is set to `With License`.\n"
                },
                "confluentLicenseType": {
                    "type": "string",
                    "description": "Required for `Confluent Platform` Data Solution. One of\n`With License`, `No License`.\n"
                },
                "dataSolutionId": {
                    "type": "string",
                    "description": "ID of Data Solution\n"
                },
                "dsOrgConfigId": {
                    "type": "string",
                    "description": "Data Solution Org Configuration ID (only available for `Confluent Platform`\nwhich has additional licensing configuration)\n"
                },
                "dsoAclId": {
                    "type": "string",
                    "description": "Data Solutions Operator ACL ID\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Organization ID\n"
                },
                "templateAclIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Data Solution Instance Template ACL IDs\n"
                }
            },
            "required": [
                "dataSolutionId",
                "dsOrgConfigId",
                "dsoAclId",
                "orgId",
                "templateAclIds"
            ],
            "inputProperties": {
                "confluentLicenseKey": {
                    "type": "string",
                    "description": "Required for `Confluent Platform` Data Solution if . One of\n`confluent_license_type` is set to `With License`.\n",
                    "willReplaceOnChanges": true
                },
                "confluentLicenseType": {
                    "type": "string",
                    "description": "Required for `Confluent Platform` Data Solution. One of\n`With License`, `No License`.\n",
                    "willReplaceOnChanges": true
                },
                "dataSolutionId": {
                    "type": "string",
                    "description": "ID of Data Solution\n",
                    "willReplaceOnChanges": true
                },
                "orgId": {
                    "type": "string",
                    "description": "Organization ID\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "dataSolutionId",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DseSolutionPublish resources.\n",
                "properties": {
                    "confluentLicenseKey": {
                        "type": "string",
                        "description": "Required for `Confluent Platform` Data Solution if . One of\n`confluent_license_type` is set to `With License`.\n",
                        "willReplaceOnChanges": true
                    },
                    "confluentLicenseType": {
                        "type": "string",
                        "description": "Required for `Confluent Platform` Data Solution. One of\n`With License`, `No License`.\n",
                        "willReplaceOnChanges": true
                    },
                    "dataSolutionId": {
                        "type": "string",
                        "description": "ID of Data Solution\n",
                        "willReplaceOnChanges": true
                    },
                    "dsOrgConfigId": {
                        "type": "string",
                        "description": "Data Solution Org Configuration ID (only available for `Confluent Platform`\nwhich has additional licensing configuration)\n"
                    },
                    "dsoAclId": {
                        "type": "string",
                        "description": "Data Solutions Operator ACL ID\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Organization ID\n",
                        "willReplaceOnChanges": true
                    },
                    "templateAclIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of Data Solution Instance Template ACL IDs\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/edgegateway:Edgegateway": {
            "properties": {
                "configuration": {
                    "type": "string",
                    "description": "Configuration of the vShield edge VM for this gateway. One of: `compact`, `full` (\"Large\"), `x-large`, `full4` (\"Quad Large\").\n"
                },
                "defaultExternalNetworkIp": {
                    "type": "string",
                    "description": "(*v2.6+*) - IP address of edge gateway used for default network\n"
                },
                "description": {
                    "type": "string"
                },
                "distributedRouting": {
                    "type": "boolean",
                    "description": "If advanced networking enabled, also enable distributed\nrouting. Default is `false`.\n"
                },
                "externalNetworkIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v2.6+*) - A list of IP addresses assigned to edge gateway interfaces\nconnected to external networks.\n"
                },
                "externalNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayExternalNetwork:EdgegatewayExternalNetwork"
                    },
                    "description": "One or more blocks defining external networks, their\nsubnets, IP addresses and  IP pool suballocation attached to edge gateway interfaces. Details are\nin external network block below.\n"
                },
                "fipsModeEnabled": {
                    "type": "boolean",
                    "description": "When FIPS mode is enabled, any secure communication to or from\nthe NSX Edge uses cryptographic algorithms or protocols that are allowed by United States Federal\nInformation Processing Standards (FIPS). FIPS mode turns on the cipher suites that comply with\nFIPS. Default is `false`. **Note:** to use FIPS mode it must be enabled in vCD system settings.\n"
                },
                "fwDefaultRuleAction": {
                    "type": "string",
                    "description": "Default firewall rule (last in the processing order) action.\nOne of `accept` or `deny`. Default `deny`.\n\n\u003ca id=\"external-network\"\u003e\u003c/a\u003e\n"
                },
                "fwDefaultRuleLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enable default firewall rule (last in the processing \norder) logging. Default `false`.\n"
                },
                "fwEnabled": {
                    "type": "boolean",
                    "description": "Enable firewall. Default `true`. **Note:** Disabling Firewall will also\ndisable NAT and other NAT dependent features like Load Balancer.\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable high availability on this edge gateway. Default is `false`.\n"
                },
                "lbAccelerationEnabled": {
                    "type": "boolean",
                    "description": "Enable to configure the load balancer to use the faster L4\nengine rather than L7 engine. The L4 TCP VIP is processed before the edge gateway firewall so no\n`allow` firewall rule is required. Default is `false`. **Note:** L7 VIPs for HTTP and HTTPS are\nprocessed after the firewall, so when Acceleration Enabled is not selected, an edge gateway firewall\nrule must exist to allow access to the L7 VIP for those protocols. When Acceleration Enabled is\nselected and the server pool is in non-transparent mode, an SNAT rule is added, so you must ensure\nthat the firewall is enabled on the edge gateway.\n"
                },
                "lbEnabled": {
                    "type": "boolean",
                    "description": "Enable load balancing. Default is `false`.\n"
                },
                "lbLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enables the edge gateway load balancer to collect traffic logs.\nDefault is `false`.\n"
                },
                "lbLoglevel": {
                    "type": "string",
                    "description": "Choose the severity of events to be logged. One of `emergency`,\n`alert`, `critical`, `error`, `warning`, `notice`, `info`, `debug`\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the edge gateway.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n"
                },
                "useDefaultRouteForDnsRelay": {
                    "type": "boolean",
                    "description": "When default route is set, it will be used for\ngateways' default routing and DNS forwarding. Default is `false`.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC that owns the edge gateway. Optional if defined at provider level.\n"
                }
            },
            "required": [
                "configuration",
                "defaultExternalNetworkIp",
                "externalNetworks",
                "externalNetworkIps",
                "name",
                "useDefaultRouteForDnsRelay"
            ],
            "inputProperties": {
                "configuration": {
                    "type": "string",
                    "description": "Configuration of the vShield edge VM for this gateway. One of: `compact`, `full` (\"Large\"), `x-large`, `full4` (\"Quad Large\").\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "distributedRouting": {
                    "type": "boolean",
                    "description": "If advanced networking enabled, also enable distributed\nrouting. Default is `false`.\n",
                    "willReplaceOnChanges": true
                },
                "externalNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayExternalNetwork:EdgegatewayExternalNetwork"
                    },
                    "description": "One or more blocks defining external networks, their\nsubnets, IP addresses and  IP pool suballocation attached to edge gateway interfaces. Details are\nin external network block below.\n",
                    "willReplaceOnChanges": true
                },
                "fipsModeEnabled": {
                    "type": "boolean",
                    "description": "When FIPS mode is enabled, any secure communication to or from\nthe NSX Edge uses cryptographic algorithms or protocols that are allowed by United States Federal\nInformation Processing Standards (FIPS). FIPS mode turns on the cipher suites that comply with\nFIPS. Default is `false`. **Note:** to use FIPS mode it must be enabled in vCD system settings.\n",
                    "willReplaceOnChanges": true
                },
                "fwDefaultRuleAction": {
                    "type": "string",
                    "description": "Default firewall rule (last in the processing order) action.\nOne of `accept` or `deny`. Default `deny`.\n\n\u003ca id=\"external-network\"\u003e\u003c/a\u003e\n"
                },
                "fwDefaultRuleLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enable default firewall rule (last in the processing \norder) logging. Default `false`.\n"
                },
                "fwEnabled": {
                    "type": "boolean",
                    "description": "Enable firewall. Default `true`. **Note:** Disabling Firewall will also\ndisable NAT and other NAT dependent features like Load Balancer.\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable high availability on this edge gateway. Default is `false`.\n",
                    "willReplaceOnChanges": true
                },
                "lbAccelerationEnabled": {
                    "type": "boolean",
                    "description": "Enable to configure the load balancer to use the faster L4\nengine rather than L7 engine. The L4 TCP VIP is processed before the edge gateway firewall so no\n`allow` firewall rule is required. Default is `false`. **Note:** L7 VIPs for HTTP and HTTPS are\nprocessed after the firewall, so when Acceleration Enabled is not selected, an edge gateway firewall\nrule must exist to allow access to the L7 VIP for those protocols. When Acceleration Enabled is\nselected and the server pool is in non-transparent mode, an SNAT rule is added, so you must ensure\nthat the firewall is enabled on the edge gateway.\n"
                },
                "lbEnabled": {
                    "type": "boolean",
                    "description": "Enable load balancing. Default is `false`.\n"
                },
                "lbLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enables the edge gateway load balancer to collect traffic logs.\nDefault is `false`.\n"
                },
                "lbLoglevel": {
                    "type": "string",
                    "description": "Choose the severity of events to be logged. One of `emergency`,\n`alert`, `critical`, `error`, `warning`, `notice`, `info`, `debug`\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the edge gateway.\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "useDefaultRouteForDnsRelay": {
                    "type": "boolean",
                    "description": "When default route is set, it will be used for\ngateways' default routing and DNS forwarding. Default is `false`.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC that owns the edge gateway. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configuration",
                "externalNetworks"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Edgegateway resources.\n",
                "properties": {
                    "configuration": {
                        "type": "string",
                        "description": "Configuration of the vShield edge VM for this gateway. One of: `compact`, `full` (\"Large\"), `x-large`, `full4` (\"Quad Large\").\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultExternalNetworkIp": {
                        "type": "string",
                        "description": "(*v2.6+*) - IP address of edge gateway used for default network\n"
                    },
                    "description": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "distributedRouting": {
                        "type": "boolean",
                        "description": "If advanced networking enabled, also enable distributed\nrouting. Default is `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "externalNetworkIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v2.6+*) - A list of IP addresses assigned to edge gateway interfaces\nconnected to external networks.\n"
                    },
                    "externalNetworks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/EdgegatewayExternalNetwork:EdgegatewayExternalNetwork"
                        },
                        "description": "One or more blocks defining external networks, their\nsubnets, IP addresses and  IP pool suballocation attached to edge gateway interfaces. Details are\nin external network block below.\n",
                        "willReplaceOnChanges": true
                    },
                    "fipsModeEnabled": {
                        "type": "boolean",
                        "description": "When FIPS mode is enabled, any secure communication to or from\nthe NSX Edge uses cryptographic algorithms or protocols that are allowed by United States Federal\nInformation Processing Standards (FIPS). FIPS mode turns on the cipher suites that comply with\nFIPS. Default is `false`. **Note:** to use FIPS mode it must be enabled in vCD system settings.\n",
                        "willReplaceOnChanges": true
                    },
                    "fwDefaultRuleAction": {
                        "type": "string",
                        "description": "Default firewall rule (last in the processing order) action.\nOne of `accept` or `deny`. Default `deny`.\n\n\u003ca id=\"external-network\"\u003e\u003c/a\u003e\n"
                    },
                    "fwDefaultRuleLoggingEnabled": {
                        "type": "boolean",
                        "description": "Enable default firewall rule (last in the processing \norder) logging. Default `false`.\n"
                    },
                    "fwEnabled": {
                        "type": "boolean",
                        "description": "Enable firewall. Default `true`. **Note:** Disabling Firewall will also\ndisable NAT and other NAT dependent features like Load Balancer.\n"
                    },
                    "haEnabled": {
                        "type": "boolean",
                        "description": "Enable high availability on this edge gateway. Default is `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "lbAccelerationEnabled": {
                        "type": "boolean",
                        "description": "Enable to configure the load balancer to use the faster L4\nengine rather than L7 engine. The L4 TCP VIP is processed before the edge gateway firewall so no\n`allow` firewall rule is required. Default is `false`. **Note:** L7 VIPs for HTTP and HTTPS are\nprocessed after the firewall, so when Acceleration Enabled is not selected, an edge gateway firewall\nrule must exist to allow access to the L7 VIP for those protocols. When Acceleration Enabled is\nselected and the server pool is in non-transparent mode, an SNAT rule is added, so you must ensure\nthat the firewall is enabled on the edge gateway.\n"
                    },
                    "lbEnabled": {
                        "type": "boolean",
                        "description": "Enable load balancing. Default is `false`.\n"
                    },
                    "lbLoggingEnabled": {
                        "type": "boolean",
                        "description": "Enables the edge gateway load balancer to collect traffic logs.\nDefault is `false`.\n"
                    },
                    "lbLoglevel": {
                        "type": "string",
                        "description": "Choose the severity of events to be logged. One of `emergency`,\n`alert`, `critical`, `error`, `warning`, `notice`, `info`, `debug`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the edge gateway.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "useDefaultRouteForDnsRelay": {
                        "type": "boolean",
                        "description": "When default route is set, it will be used for\ngateways' default routing and DNS forwarding. Default is `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC that owns the edge gateway. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/edgegatewaySettings:EdgegatewaySettings": {
            "properties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The edge gateway ID. (Required if `edge_gateway_name` is not set)\n"
                },
                "edgeGatewayName": {
                    "type": "string",
                    "description": "A unique name for the edge gateway. (Required if `edge_gateway_id` is not set)\n"
                },
                "fwDefaultRuleAction": {
                    "type": "string",
                    "description": "Default firewall rule (last in the processing order) action.\nOne of `accept` or `deny`. Default `deny`.\n"
                },
                "fwDefaultRuleLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enable default firewall rule (last in the processing \norder) logging. Default `false`.\n"
                },
                "fwEnabled": {
                    "type": "boolean",
                    "description": "Enable firewall. Default `true`.\n"
                },
                "lbAccelerationEnabled": {
                    "type": "boolean",
                    "description": "Enable to configure the load balancer.\n"
                },
                "lbEnabled": {
                    "type": "boolean",
                    "description": "Enable load balancing. Default is `false`.\n"
                },
                "lbLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enables the edge gateway load balancer to collect traffic logs.\nDefault is `false`. Note: **only System administrators can change this property**. It is ignored by API for Org users.\n"
                },
                "lbLoglevel": {
                    "type": "string",
                    "description": "Choose the severity of events to be logged. One of `emergency`,\n`alert`, `critical`, `error`, `warning`, `notice`, `info`, `debug`. Note: **only System administrators can change this property**. It is ignored by API for Org users.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC that owns the edge gateway. Optional if defined at provider level.\n"
                }
            },
            "required": [
                "edgeGatewayId",
                "edgeGatewayName"
            ],
            "inputProperties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The edge gateway ID. (Required if `edge_gateway_name` is not set)\n"
                },
                "edgeGatewayName": {
                    "type": "string",
                    "description": "A unique name for the edge gateway. (Required if `edge_gateway_id` is not set)\n"
                },
                "fwDefaultRuleAction": {
                    "type": "string",
                    "description": "Default firewall rule (last in the processing order) action.\nOne of `accept` or `deny`. Default `deny`.\n"
                },
                "fwDefaultRuleLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enable default firewall rule (last in the processing \norder) logging. Default `false`.\n"
                },
                "fwEnabled": {
                    "type": "boolean",
                    "description": "Enable firewall. Default `true`.\n"
                },
                "lbAccelerationEnabled": {
                    "type": "boolean",
                    "description": "Enable to configure the load balancer.\n"
                },
                "lbEnabled": {
                    "type": "boolean",
                    "description": "Enable load balancing. Default is `false`.\n"
                },
                "lbLoggingEnabled": {
                    "type": "boolean",
                    "description": "Enables the edge gateway load balancer to collect traffic logs.\nDefault is `false`. Note: **only System administrators can change this property**. It is ignored by API for Org users.\n"
                },
                "lbLoglevel": {
                    "type": "string",
                    "description": "Choose the severity of events to be logged. One of `emergency`,\n`alert`, `critical`, `error`, `warning`, `notice`, `info`, `debug`. Note: **only System administrators can change this property**. It is ignored by API for Org users.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC that owns the edge gateway. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgegatewaySettings resources.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The edge gateway ID. (Required if `edge_gateway_name` is not set)\n"
                    },
                    "edgeGatewayName": {
                        "type": "string",
                        "description": "A unique name for the edge gateway. (Required if `edge_gateway_id` is not set)\n"
                    },
                    "fwDefaultRuleAction": {
                        "type": "string",
                        "description": "Default firewall rule (last in the processing order) action.\nOne of `accept` or `deny`. Default `deny`.\n"
                    },
                    "fwDefaultRuleLoggingEnabled": {
                        "type": "boolean",
                        "description": "Enable default firewall rule (last in the processing \norder) logging. Default `false`.\n"
                    },
                    "fwEnabled": {
                        "type": "boolean",
                        "description": "Enable firewall. Default `true`.\n"
                    },
                    "lbAccelerationEnabled": {
                        "type": "boolean",
                        "description": "Enable to configure the load balancer.\n"
                    },
                    "lbEnabled": {
                        "type": "boolean",
                        "description": "Enable load balancing. Default is `false`.\n"
                    },
                    "lbLoggingEnabled": {
                        "type": "boolean",
                        "description": "Enables the edge gateway load balancer to collect traffic logs.\nDefault is `false`. Note: **only System administrators can change this property**. It is ignored by API for Org users.\n"
                    },
                    "lbLoglevel": {
                        "type": "string",
                        "description": "Choose the severity of events to be logged. One of `emergency`,\n`alert`, `critical`, `error`, `warning`, `notice`, `info`, `debug`. Note: **only System administrators can change this property**. It is ignored by API for Org users.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC that owns the edge gateway. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/edgegatewayVpn:EdgegatewayVpn": {
            "description": "Provides a VMware Cloud Director IPsec VPN. This can be used to create,\nmodify, and delete VPN settings and rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst vpn = new vcd.EdgegatewayVpn(\"vpn\", {\n    edgeGateway: \"Internet_01(nti0000bi2_123-456-2)\",\n    name: \"west-to-east\",\n    description: \"Description\",\n    encryptionProtocol: \"AES256\",\n    mtu: 1400,\n    peerId: \"64.121.123.11\",\n    peerIpAddress: \"64.121.123.11\",\n    localId: \"64.121.123.10\",\n    localIpAddress: \"64.121.123.10\",\n    sharedSecret: \"***********************\",\n    peerSubnets: [\n        {\n            peerSubnetName: \"DMZ_WEST\",\n            peerSubnetGateway: \"10.0.10.1\",\n            peerSubnetMask: \"255.255.255.0\",\n        },\n        {\n            peerSubnetName: \"WEB_WEST\",\n            peerSubnetGateway: \"10.0.20.1\",\n            peerSubnetMask: \"255.255.255.0\",\n        },\n    ],\n    localSubnets: [\n        {\n            localSubnetName: \"DMZ_EAST\",\n            localSubnetGateway: \"10.0.1.1\",\n            localSubnetMask: \"255.255.255.0\",\n        },\n        {\n            localSubnetName: \"WEB_EAST\",\n            localSubnetGateway: \"10.0.22.1\",\n            localSubnetMask: \"255.255.255.0\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nvpn = vcd.EdgegatewayVpn(\"vpn\",\n    edge_gateway=\"Internet_01(nti0000bi2_123-456-2)\",\n    name=\"west-to-east\",\n    description=\"Description\",\n    encryption_protocol=\"AES256\",\n    mtu=1400,\n    peer_id=\"64.121.123.11\",\n    peer_ip_address=\"64.121.123.11\",\n    local_id=\"64.121.123.10\",\n    local_ip_address=\"64.121.123.10\",\n    shared_secret=\"***********************\",\n    peer_subnets=[\n        {\n            \"peer_subnet_name\": \"DMZ_WEST\",\n            \"peer_subnet_gateway\": \"10.0.10.1\",\n            \"peer_subnet_mask\": \"255.255.255.0\",\n        },\n        {\n            \"peer_subnet_name\": \"WEB_WEST\",\n            \"peer_subnet_gateway\": \"10.0.20.1\",\n            \"peer_subnet_mask\": \"255.255.255.0\",\n        },\n    ],\n    local_subnets=[\n        {\n            \"local_subnet_name\": \"DMZ_EAST\",\n            \"local_subnet_gateway\": \"10.0.1.1\",\n            \"local_subnet_mask\": \"255.255.255.0\",\n        },\n        {\n            \"local_subnet_name\": \"WEB_EAST\",\n            \"local_subnet_gateway\": \"10.0.22.1\",\n            \"local_subnet_mask\": \"255.255.255.0\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vpn = new Vcd.EdgegatewayVpn(\"vpn\", new()\n    {\n        EdgeGateway = \"Internet_01(nti0000bi2_123-456-2)\",\n        Name = \"west-to-east\",\n        Description = \"Description\",\n        EncryptionProtocol = \"AES256\",\n        Mtu = 1400,\n        PeerId = \"64.121.123.11\",\n        PeerIpAddress = \"64.121.123.11\",\n        LocalId = \"64.121.123.10\",\n        LocalIpAddress = \"64.121.123.10\",\n        SharedSecret = \"***********************\",\n        PeerSubnets = new[]\n        {\n            new Vcd.Inputs.EdgegatewayVpnPeerSubnetArgs\n            {\n                PeerSubnetName = \"DMZ_WEST\",\n                PeerSubnetGateway = \"10.0.10.1\",\n                PeerSubnetMask = \"255.255.255.0\",\n            },\n            new Vcd.Inputs.EdgegatewayVpnPeerSubnetArgs\n            {\n                PeerSubnetName = \"WEB_WEST\",\n                PeerSubnetGateway = \"10.0.20.1\",\n                PeerSubnetMask = \"255.255.255.0\",\n            },\n        },\n        LocalSubnets = new[]\n        {\n            new Vcd.Inputs.EdgegatewayVpnLocalSubnetArgs\n            {\n                LocalSubnetName = \"DMZ_EAST\",\n                LocalSubnetGateway = \"10.0.1.1\",\n                LocalSubnetMask = \"255.255.255.0\",\n            },\n            new Vcd.Inputs.EdgegatewayVpnLocalSubnetArgs\n            {\n                LocalSubnetName = \"WEB_EAST\",\n                LocalSubnetGateway = \"10.0.22.1\",\n                LocalSubnetMask = \"255.255.255.0\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.NewEdgegatewayVpn(ctx, \"vpn\", \u0026vcd.EdgegatewayVpnArgs{\n\t\t\tEdgeGateway:        pulumi.String(\"Internet_01(nti0000bi2_123-456-2)\"),\n\t\t\tName:               pulumi.String(\"west-to-east\"),\n\t\t\tDescription:        pulumi.String(\"Description\"),\n\t\t\tEncryptionProtocol: pulumi.String(\"AES256\"),\n\t\t\tMtu:                pulumi.Int(1400),\n\t\t\tPeerId:             pulumi.String(\"64.121.123.11\"),\n\t\t\tPeerIpAddress:      pulumi.String(\"64.121.123.11\"),\n\t\t\tLocalId:            pulumi.String(\"64.121.123.10\"),\n\t\t\tLocalIpAddress:     pulumi.String(\"64.121.123.10\"),\n\t\t\tSharedSecret:       pulumi.String(\"***********************\"),\n\t\t\tPeerSubnets: vcd.EdgegatewayVpnPeerSubnetArray{\n\t\t\t\t\u0026vcd.EdgegatewayVpnPeerSubnetArgs{\n\t\t\t\t\tPeerSubnetName:    pulumi.String(\"DMZ_WEST\"),\n\t\t\t\t\tPeerSubnetGateway: pulumi.String(\"10.0.10.1\"),\n\t\t\t\t\tPeerSubnetMask:    pulumi.String(\"255.255.255.0\"),\n\t\t\t\t},\n\t\t\t\t\u0026vcd.EdgegatewayVpnPeerSubnetArgs{\n\t\t\t\t\tPeerSubnetName:    pulumi.String(\"WEB_WEST\"),\n\t\t\t\t\tPeerSubnetGateway: pulumi.String(\"10.0.20.1\"),\n\t\t\t\t\tPeerSubnetMask:    pulumi.String(\"255.255.255.0\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLocalSubnets: vcd.EdgegatewayVpnLocalSubnetArray{\n\t\t\t\t\u0026vcd.EdgegatewayVpnLocalSubnetArgs{\n\t\t\t\t\tLocalSubnetName:    pulumi.String(\"DMZ_EAST\"),\n\t\t\t\t\tLocalSubnetGateway: pulumi.String(\"10.0.1.1\"),\n\t\t\t\t\tLocalSubnetMask:    pulumi.String(\"255.255.255.0\"),\n\t\t\t\t},\n\t\t\t\t\u0026vcd.EdgegatewayVpnLocalSubnetArgs{\n\t\t\t\t\tLocalSubnetName:    pulumi.String(\"WEB_EAST\"),\n\t\t\t\t\tLocalSubnetGateway: pulumi.String(\"10.0.22.1\"),\n\t\t\t\t\tLocalSubnetMask:    pulumi.String(\"255.255.255.0\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.EdgegatewayVpn;\nimport com.pulumi.vcd.EdgegatewayVpnArgs;\nimport com.pulumi.vcd.inputs.EdgegatewayVpnPeerSubnetArgs;\nimport com.pulumi.vcd.inputs.EdgegatewayVpnLocalSubnetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vpn = new EdgegatewayVpn(\"vpn\", EdgegatewayVpnArgs.builder()\n            .edgeGateway(\"Internet_01(nti0000bi2_123-456-2)\")\n            .name(\"west-to-east\")\n            .description(\"Description\")\n            .encryptionProtocol(\"AES256\")\n            .mtu(1400)\n            .peerId(\"64.121.123.11\")\n            .peerIpAddress(\"64.121.123.11\")\n            .localId(\"64.121.123.10\")\n            .localIpAddress(\"64.121.123.10\")\n            .sharedSecret(\"***********************\")\n            .peerSubnets(            \n                EdgegatewayVpnPeerSubnetArgs.builder()\n                    .peerSubnetName(\"DMZ_WEST\")\n                    .peerSubnetGateway(\"10.0.10.1\")\n                    .peerSubnetMask(\"255.255.255.0\")\n                    .build(),\n                EdgegatewayVpnPeerSubnetArgs.builder()\n                    .peerSubnetName(\"WEB_WEST\")\n                    .peerSubnetGateway(\"10.0.20.1\")\n                    .peerSubnetMask(\"255.255.255.0\")\n                    .build())\n            .localSubnets(            \n                EdgegatewayVpnLocalSubnetArgs.builder()\n                    .localSubnetName(\"DMZ_EAST\")\n                    .localSubnetGateway(\"10.0.1.1\")\n                    .localSubnetMask(\"255.255.255.0\")\n                    .build(),\n                EdgegatewayVpnLocalSubnetArgs.builder()\n                    .localSubnetName(\"WEB_EAST\")\n                    .localSubnetGateway(\"10.0.22.1\")\n                    .localSubnetMask(\"255.255.255.0\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vpn:\n    type: vcd:EdgegatewayVpn\n    properties:\n      edgeGateway: Internet_01(nti0000bi2_123-456-2)\n      name: west-to-east\n      description: Description\n      encryptionProtocol: AES256\n      mtu: 1400\n      peerId: 64.121.123.11\n      peerIpAddress: 64.121.123.11\n      localId: 64.121.123.10\n      localIpAddress: 64.121.123.10\n      sharedSecret: '***********************'\n      peerSubnets:\n        - peerSubnetName: DMZ_WEST\n          peerSubnetGateway: 10.0.10.1\n          peerSubnetMask: 255.255.255.0\n        - peerSubnetName: WEB_WEST\n          peerSubnetGateway: 10.0.20.1\n          peerSubnetMask: 255.255.255.0\n      localSubnets:\n        - localSubnetName: DMZ_EAST\n          localSubnetGateway: 10.0.1.1\n          localSubnetMask: 255.255.255.0\n        - localSubnetName: WEB_EAST\n          localSubnetGateway: 10.0.22.1\n          localSubnetMask: 255.255.255.0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Local Subnets\n\nEach Local Subnet supports the following attributes:\n\n* `local_subnet_name` - (Required) Name of the local subnet\n* `local_subnet_gateway` - (Required) Gateway of the local subnet\n* `local_subnet_mask` - (Required) Subnet mask of the local subnet\n\n\u003ca id=\"peersubnets\"\u003e\u003c/a\u003e\n## Peer Subnets\n\nEach Peer Subnet supports the following attributes:\n\n* `peer_subnet_name` - (Required) Name of the peer subnet\n* `peer_subnet_gateway` - (Required) Gateway of the peer subnet\n* `peer_subnet_mask` - (Required) Subnet mask of the peer subnet\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the VPN\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the Firewall Rules\n"
                },
                "encryptionProtocol": {
                    "type": "string",
                    "description": "E.g. `AES256`\n"
                },
                "localId": {
                    "type": "string",
                    "description": "Local ID\n"
                },
                "localIpAddress": {
                    "type": "string",
                    "description": "Local IP Address\n"
                },
                "localSubnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayVpnLocalSubnet:EdgegatewayVpnLocalSubnet"
                    },
                    "description": "List of Local Subnets see Local Subnets below for details.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU setting\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VPN\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "peerId": {
                    "type": "string",
                    "description": "Peer ID\n"
                },
                "peerIpAddress": {
                    "type": "string",
                    "description": "Peer IP Address\n"
                },
                "peerSubnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayVpnPeerSubnet:EdgegatewayVpnPeerSubnet"
                    },
                    "description": "List of Peer Subnets see Peer Subnets below for details.\n"
                },
                "sharedSecret": {
                    "type": "string",
                    "description": "Shared Secret\n",
                    "secret": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n\n\u003ca id=\"localsubnets\"\u003e\u003c/a\u003e\n"
                }
            },
            "required": [
                "edgeGateway",
                "encryptionProtocol",
                "localId",
                "localIpAddress",
                "mtu",
                "name",
                "peerId",
                "peerIpAddress",
                "sharedSecret"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the VPN\n",
                    "willReplaceOnChanges": true
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the Firewall Rules\n",
                    "willReplaceOnChanges": true
                },
                "encryptionProtocol": {
                    "type": "string",
                    "description": "E.g. `AES256`\n",
                    "willReplaceOnChanges": true
                },
                "localId": {
                    "type": "string",
                    "description": "Local ID\n",
                    "willReplaceOnChanges": true
                },
                "localIpAddress": {
                    "type": "string",
                    "description": "Local IP Address\n",
                    "willReplaceOnChanges": true
                },
                "localSubnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayVpnLocalSubnet:EdgegatewayVpnLocalSubnet"
                    },
                    "description": "List of Local Subnets see Local Subnets below for details.\n",
                    "willReplaceOnChanges": true
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU setting\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VPN\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "peerId": {
                    "type": "string",
                    "description": "Peer ID\n",
                    "willReplaceOnChanges": true
                },
                "peerIpAddress": {
                    "type": "string",
                    "description": "Peer IP Address\n",
                    "willReplaceOnChanges": true
                },
                "peerSubnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/EdgegatewayVpnPeerSubnet:EdgegatewayVpnPeerSubnet"
                    },
                    "description": "List of Peer Subnets see Peer Subnets below for details.\n",
                    "willReplaceOnChanges": true
                },
                "sharedSecret": {
                    "type": "string",
                    "description": "Shared Secret\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n\n\u003ca id=\"localsubnets\"\u003e\u003c/a\u003e\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "encryptionProtocol",
                "localId",
                "localIpAddress",
                "mtu",
                "peerId",
                "peerIpAddress",
                "sharedSecret"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgegatewayVpn resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the VPN\n",
                        "willReplaceOnChanges": true
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which to apply the Firewall Rules\n",
                        "willReplaceOnChanges": true
                    },
                    "encryptionProtocol": {
                        "type": "string",
                        "description": "E.g. `AES256`\n",
                        "willReplaceOnChanges": true
                    },
                    "localId": {
                        "type": "string",
                        "description": "Local ID\n",
                        "willReplaceOnChanges": true
                    },
                    "localIpAddress": {
                        "type": "string",
                        "description": "Local IP Address\n",
                        "willReplaceOnChanges": true
                    },
                    "localSubnets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/EdgegatewayVpnLocalSubnet:EdgegatewayVpnLocalSubnet"
                        },
                        "description": "List of Local Subnets see Local Subnets below for details.\n",
                        "willReplaceOnChanges": true
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The MTU setting\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VPN\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "peerId": {
                        "type": "string",
                        "description": "Peer ID\n",
                        "willReplaceOnChanges": true
                    },
                    "peerIpAddress": {
                        "type": "string",
                        "description": "Peer IP Address\n",
                        "willReplaceOnChanges": true
                    },
                    "peerSubnets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/EdgegatewayVpnPeerSubnet:EdgegatewayVpnPeerSubnet"
                        },
                        "description": "List of Peer Subnets see Peer Subnets below for details.\n",
                        "willReplaceOnChanges": true
                    },
                    "sharedSecret": {
                        "type": "string",
                        "description": "Shared Secret\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n\n\u003ca id=\"localsubnets\"\u003e\u003c/a\u003e\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/externalEndpoint:ExternalEndpoint": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the External Endpoint\n"
                },
                "disableOnRemoval": {
                    "type": "boolean",
                    "description": "Whether the External Endpoint should be disabled before a delete operation, to flawlessly remove it even if it is enabled.\nIt is `false` by default\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the External Endpoint is enabled or not. **Must be `false` before removing this resource**, otherwise deletion will fail.\nTo disable it automatically on removal, set `disable_on_removal=true` (see below)\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "The endpoint which requests will be redirected to. Must use HTTPS protocol\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "The vendor name of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n"
                }
            },
            "required": [
                "enabled",
                "name",
                "rootUrl",
                "vendor",
                "version"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the External Endpoint\n"
                },
                "disableOnRemoval": {
                    "type": "boolean",
                    "description": "Whether the External Endpoint should be disabled before a delete operation, to flawlessly remove it even if it is enabled.\nIt is `false` by default\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the External Endpoint is enabled or not. **Must be `false` before removing this resource**, otherwise deletion will fail.\nTo disable it automatically on removal, set `disable_on_removal=true` (see below)\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n",
                    "willReplaceOnChanges": true
                },
                "rootUrl": {
                    "type": "string",
                    "description": "The endpoint which requests will be redirected to. Must use HTTPS protocol\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "The vendor name of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "string",
                    "description": "The version of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "rootUrl",
                "vendor",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalEndpoint resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the External Endpoint\n"
                    },
                    "disableOnRemoval": {
                        "type": "boolean",
                        "description": "Whether the External Endpoint should be disabled before a delete operation, to flawlessly remove it even if it is enabled.\nIt is `false` by default\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the External Endpoint is enabled or not. **Must be `false` before removing this resource**, otherwise deletion will fail.\nTo disable it automatically on removal, set `disable_on_removal=true` (see below)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n",
                        "willReplaceOnChanges": true
                    },
                    "rootUrl": {
                        "type": "string",
                        "description": "The endpoint which requests will be redirected to. Must use HTTPS protocol\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor name of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the External Endpoint. The combination of `vendor` + `name` + `version` must be unique. Can't be modified after creation\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/externalNetwork:ExternalNetwork": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Network friendly description\n"
                },
                "ipScopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkIpScope:ExternalNetworkIpScope"
                    },
                    "description": "A list of IP scopes for the network.  See IP Scope below for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "retainNetInfoAcrossDeployments": {
                    "type": "boolean",
                    "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Default is false.\n\n\u003ca id=\"ipscope\"\u003e\u003c/a\u003e\n"
                },
                "vsphereNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkVsphereNetwork:ExternalNetworkVsphereNetwork"
                    },
                    "description": "A list of DV_PORTGROUP or NETWORK objects names that back this network. Each referenced DV_PORTGROUP or NETWORK must exist on a vCenter server registered with the system.  See vSphere Network below for details.\n"
                }
            },
            "required": [
                "ipScopes",
                "name",
                "vsphereNetworks"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Network friendly description\n",
                    "willReplaceOnChanges": true
                },
                "ipScopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkIpScope:ExternalNetworkIpScope"
                    },
                    "description": "A list of IP scopes for the network.  See IP Scope below for details.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n",
                    "willReplaceOnChanges": true
                },
                "retainNetInfoAcrossDeployments": {
                    "type": "boolean",
                    "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Default is false.\n\n\u003ca id=\"ipscope\"\u003e\u003c/a\u003e\n",
                    "willReplaceOnChanges": true
                },
                "vsphereNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkVsphereNetwork:ExternalNetworkVsphereNetwork"
                    },
                    "description": "A list of DV_PORTGROUP or NETWORK objects names that back this network. Each referenced DV_PORTGROUP or NETWORK must exist on a vCenter server registered with the system.  See vSphere Network below for details.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ipScopes",
                "vsphereNetworks"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalNetwork resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Network friendly description\n",
                        "willReplaceOnChanges": true
                    },
                    "ipScopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/ExternalNetworkIpScope:ExternalNetworkIpScope"
                        },
                        "description": "A list of IP scopes for the network.  See IP Scope below for details.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n",
                        "willReplaceOnChanges": true
                    },
                    "retainNetInfoAcrossDeployments": {
                        "type": "boolean",
                        "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Default is false.\n\n\u003ca id=\"ipscope\"\u003e\u003c/a\u003e\n",
                        "willReplaceOnChanges": true
                    },
                    "vsphereNetworks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/ExternalNetworkVsphereNetwork:ExternalNetworkVsphereNetwork"
                        },
                        "description": "A list of DV_PORTGROUP or NETWORK objects names that back this network. Each referenced DV_PORTGROUP or NETWORK must exist on a vCenter server registered with the system.  See vSphere Network below for details.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/externalNetworkV2:ExternalNetworkV2": {
            "properties": {
                "dedicatedOrgId": {
                    "type": "string",
                    "description": "An Org ID that this network should be\ndedicated to. Only applicable when `use_ip_spaces=true`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Network friendly description\n"
                },
                "ipScopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkV2IpScope:ExternalNetworkV2IpScope"
                    },
                    "description": "One or more IP scopes for the network. See IP Scope below for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "natAndFirewallServiceIntention": {
                    "type": "string",
                    "description": "Configure intentions for\nNAT and Firewall rule configuration:\n* `EDGE_GATEWAY` - Allow management of NAT and firewall rules only on Edge Gateways. This is the\ndefault behavior.\n* `PROVIDER_GATEWAY` - Allow management of NAT and firewall rules only on Provider Gateways.\n* `PROVIDER_AND_EDGE_GATEWAY` - Allow management of NAT and firewall rules on both the Provider and\nEdge gateways.\n"
                },
                "nsxtNetwork": {
                    "$ref": "#/types/vcd:index/ExternalNetworkV2NsxtNetwork:ExternalNetworkV2NsxtNetwork",
                    "description": "NSX-T network definition. See NSX-T Network below for details.\n"
                },
                "routeAdvertisementIntention": {
                    "type": "string",
                    "description": "Configure intentions for\nOrg VDC network Route Advertisement:\n* `IP_SPACE_UPLINKS_ADVERTISED_STRICT` - All networks within IP Space associated with IP Space\nUplink will be advertised by default. This can be changed on an individual network level later,\nif necessary. All other networks outside of IP Spaces associated with IP Space Uplinks cannot be\nconfigured to be advertised. This is the default behavior.\n* `IP_SPACE_UPLINKS_ADVERTISED_FLEXIBLE` - All networks within IP Space associated with IP Space\nUplink will be advertised by default. This can be changed on an individual network level later,\nif necessary. All other networks outside of IP Spaces associated with IP Space Uplinks are not\nadvertised by default but can be configured to be advertised after creation.\n* `ALL_NETWORKS_ADVERTISED` - All networks, regardless on whether they fall inside of any IP Spaces\nassociated with IP Space Uplinks, will be advertised by default. This can be changed on an\nindividual network level later, if necessary.\n\n\u003ca id=\"ipscope\"\u003e\u003c/a\u003e\n"
                },
                "useIpSpaces": {
                    "type": "boolean",
                    "description": "Defines if the network uses IP Spaces. Do\nnot specify `ip_scope` when using IP Spaces. (default `false`)\n"
                },
                "vsphereNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkV2VsphereNetwork:ExternalNetworkV2VsphereNetwork"
                    },
                    "description": "One or more blocks of vSphere Network..\n"
                }
            },
            "required": [
                "dedicatedOrgId",
                "name",
                "natAndFirewallServiceIntention",
                "routeAdvertisementIntention"
            ],
            "inputProperties": {
                "dedicatedOrgId": {
                    "type": "string",
                    "description": "An Org ID that this network should be\ndedicated to. Only applicable when `use_ip_spaces=true`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Network friendly description\n"
                },
                "ipScopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkV2IpScope:ExternalNetworkV2IpScope"
                    },
                    "description": "One or more IP scopes for the network. See IP Scope below for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "natAndFirewallServiceIntention": {
                    "type": "string",
                    "description": "Configure intentions for\nNAT and Firewall rule configuration:\n* `EDGE_GATEWAY` - Allow management of NAT and firewall rules only on Edge Gateways. This is the\ndefault behavior.\n* `PROVIDER_GATEWAY` - Allow management of NAT and firewall rules only on Provider Gateways.\n* `PROVIDER_AND_EDGE_GATEWAY` - Allow management of NAT and firewall rules on both the Provider and\nEdge gateways.\n"
                },
                "nsxtNetwork": {
                    "$ref": "#/types/vcd:index/ExternalNetworkV2NsxtNetwork:ExternalNetworkV2NsxtNetwork",
                    "description": "NSX-T network definition. See NSX-T Network below for details.\n",
                    "willReplaceOnChanges": true
                },
                "routeAdvertisementIntention": {
                    "type": "string",
                    "description": "Configure intentions for\nOrg VDC network Route Advertisement:\n* `IP_SPACE_UPLINKS_ADVERTISED_STRICT` - All networks within IP Space associated with IP Space\nUplink will be advertised by default. This can be changed on an individual network level later,\nif necessary. All other networks outside of IP Spaces associated with IP Space Uplinks cannot be\nconfigured to be advertised. This is the default behavior.\n* `IP_SPACE_UPLINKS_ADVERTISED_FLEXIBLE` - All networks within IP Space associated with IP Space\nUplink will be advertised by default. This can be changed on an individual network level later,\nif necessary. All other networks outside of IP Spaces associated with IP Space Uplinks are not\nadvertised by default but can be configured to be advertised after creation.\n* `ALL_NETWORKS_ADVERTISED` - All networks, regardless on whether they fall inside of any IP Spaces\nassociated with IP Space Uplinks, will be advertised by default. This can be changed on an\nindividual network level later, if necessary.\n\n\u003ca id=\"ipscope\"\u003e\u003c/a\u003e\n"
                },
                "useIpSpaces": {
                    "type": "boolean",
                    "description": "Defines if the network uses IP Spaces. Do\nnot specify `ip_scope` when using IP Spaces. (default `false`)\n",
                    "willReplaceOnChanges": true
                },
                "vsphereNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ExternalNetworkV2VsphereNetwork:ExternalNetworkV2VsphereNetwork"
                    },
                    "description": "One or more blocks of vSphere Network..\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalNetworkV2 resources.\n",
                "properties": {
                    "dedicatedOrgId": {
                        "type": "string",
                        "description": "An Org ID that this network should be\ndedicated to. Only applicable when `use_ip_spaces=true`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Network friendly description\n"
                    },
                    "ipScopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/ExternalNetworkV2IpScope:ExternalNetworkV2IpScope"
                        },
                        "description": "One or more IP scopes for the network. See IP Scope below for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n"
                    },
                    "natAndFirewallServiceIntention": {
                        "type": "string",
                        "description": "Configure intentions for\nNAT and Firewall rule configuration:\n* `EDGE_GATEWAY` - Allow management of NAT and firewall rules only on Edge Gateways. This is the\ndefault behavior.\n* `PROVIDER_GATEWAY` - Allow management of NAT and firewall rules only on Provider Gateways.\n* `PROVIDER_AND_EDGE_GATEWAY` - Allow management of NAT and firewall rules on both the Provider and\nEdge gateways.\n"
                    },
                    "nsxtNetwork": {
                        "$ref": "#/types/vcd:index/ExternalNetworkV2NsxtNetwork:ExternalNetworkV2NsxtNetwork",
                        "description": "NSX-T network definition. See NSX-T Network below for details.\n",
                        "willReplaceOnChanges": true
                    },
                    "routeAdvertisementIntention": {
                        "type": "string",
                        "description": "Configure intentions for\nOrg VDC network Route Advertisement:\n* `IP_SPACE_UPLINKS_ADVERTISED_STRICT` - All networks within IP Space associated with IP Space\nUplink will be advertised by default. This can be changed on an individual network level later,\nif necessary. All other networks outside of IP Spaces associated with IP Space Uplinks cannot be\nconfigured to be advertised. This is the default behavior.\n* `IP_SPACE_UPLINKS_ADVERTISED_FLEXIBLE` - All networks within IP Space associated with IP Space\nUplink will be advertised by default. This can be changed on an individual network level later,\nif necessary. All other networks outside of IP Spaces associated with IP Space Uplinks are not\nadvertised by default but can be configured to be advertised after creation.\n* `ALL_NETWORKS_ADVERTISED` - All networks, regardless on whether they fall inside of any IP Spaces\nassociated with IP Space Uplinks, will be advertised by default. This can be changed on an\nindividual network level later, if necessary.\n\n\u003ca id=\"ipscope\"\u003e\u003c/a\u003e\n"
                    },
                    "useIpSpaces": {
                        "type": "boolean",
                        "description": "Defines if the network uses IP Spaces. Do\nnot specify `ip_scope` when using IP Spaces. (default `false`)\n",
                        "willReplaceOnChanges": true
                    },
                    "vsphereNetworks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/ExternalNetworkV2VsphereNetwork:ExternalNetworkV2VsphereNetwork"
                        },
                        "description": "One or more blocks of vSphere Network..\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/globalRole:GlobalRole": {
            "properties": {
                "bundleKey": {
                    "type": "string",
                    "description": "Key used for internationalization\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the global role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the global role.\n"
                },
                "publishToAllTenants": {
                    "type": "boolean",
                    "description": "When true, publishes the global role to all tenants\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Whether this global role is read-only\n"
                },
                "rights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of rights assigned to this role\n"
                },
                "tenants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of tenants to which this global role gets published. Ignored if `publish_to_all_tenants` is true.\n"
                }
            },
            "required": [
                "bundleKey",
                "description",
                "name",
                "publishToAllTenants",
                "readOnly",
                "tenants"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the global role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the global role.\n"
                },
                "publishToAllTenants": {
                    "type": "boolean",
                    "description": "When true, publishes the global role to all tenants\n"
                },
                "rights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of rights assigned to this role\n"
                },
                "tenants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of tenants to which this global role gets published. Ignored if `publish_to_all_tenants` is true.\n"
                }
            },
            "requiredInputs": [
                "description",
                "publishToAllTenants"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GlobalRole resources.\n",
                "properties": {
                    "bundleKey": {
                        "type": "string",
                        "description": "Key used for internationalization\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the global role\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the global role.\n"
                    },
                    "publishToAllTenants": {
                        "type": "boolean",
                        "description": "When true, publishes the global role to all tenants\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "Whether this global role is read-only\n"
                    },
                    "rights": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of rights assigned to this role\n"
                    },
                    "tenants": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of tenants to which this global role gets published. Ignored if `publish_to_all_tenants` is true.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/independentDisk:IndependentDisk": {
            "properties": {
                "attachedVmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Computed, *v3.6+*) IDs of VM which are using the disk\n"
                },
                "busSubType": {
                    "type": "string",
                    "description": "Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`\n"
                },
                "busType": {
                    "type": "string",
                    "description": "Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off\n"
                },
                "datastoreName": {
                    "type": "string",
                    "description": "(Computed) Data store name. Readable only for system user.\n"
                },
                "description": {
                    "type": "string",
                    "description": "independent disk description\n"
                },
                "encrypted": {
                    "type": "boolean",
                    "description": "(Computed, *v3.6+* and VCD 10.2+) True if disk is encrypted\n"
                },
                "iops": {
                    "type": "integer",
                    "description": "(Computed) IOPS request for the created disk\n"
                },
                "isAttached": {
                    "type": "boolean",
                    "description": "(Computed) True if the disk is already attached\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this independent disk.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IndependentDiskMetadataEntry:IndependentDiskMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Disk name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "ownerName": {
                    "type": "string",
                    "description": "(Computed) The owner name of the disk\n"
                },
                "sharingType": {
                    "type": "string",
                    "description": "This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "Size of disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "The name of storage profile where disk will be created\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "(Computed, *v3.6+* and VCD 10.2+) The UUID of this named disk's device backing\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "attachedVmIds",
                "busSubType",
                "busType",
                "datastoreName",
                "encrypted",
                "iops",
                "isAttached",
                "metadata",
                "metadataEntries",
                "name",
                "ownerName",
                "sharingType",
                "sizeInMb",
                "storageProfile",
                "uuid"
            ],
            "inputProperties": {
                "busSubType": {
                    "type": "string",
                    "description": "Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`\n",
                    "willReplaceOnChanges": true
                },
                "busType": {
                    "type": "string",
                    "description": "Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "independent disk description\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this independent disk.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IndependentDiskMetadataEntry:IndependentDiskMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Disk name\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "sharingType": {
                    "type": "string",
                    "description": "This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`\n",
                    "willReplaceOnChanges": true
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "Size of disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "The name of storage profile where disk will be created\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "sizeInMb"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IndependentDisk resources.\n",
                "properties": {
                    "attachedVmIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed, *v3.6+*) IDs of VM which are using the disk\n"
                    },
                    "busSubType": {
                        "type": "string",
                        "description": "Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`\n",
                        "willReplaceOnChanges": true
                    },
                    "busType": {
                        "type": "string",
                        "description": "Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off\n",
                        "willReplaceOnChanges": true
                    },
                    "datastoreName": {
                        "type": "string",
                        "description": "(Computed) Data store name. Readable only for system user.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "independent disk description\n"
                    },
                    "encrypted": {
                        "type": "boolean",
                        "description": "(Computed, *v3.6+* and VCD 10.2+) True if disk is encrypted\n"
                    },
                    "iops": {
                        "type": "integer",
                        "description": "(Computed) IOPS request for the created disk\n"
                    },
                    "isAttached": {
                        "type": "boolean",
                        "description": "(Computed) True if the disk is already attached\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this independent disk.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/IndependentDiskMetadataEntry:IndependentDiskMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Disk name\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerName": {
                        "type": "string",
                        "description": "(Computed) The owner name of the disk\n"
                    },
                    "sharingType": {
                        "type": "string",
                        "description": "This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`\n",
                        "willReplaceOnChanges": true
                    },
                    "sizeInMb": {
                        "type": "integer",
                        "description": "Size of disk in MB.\n"
                    },
                    "storageProfile": {
                        "type": "string",
                        "description": "The name of storage profile where disk will be created\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "(Computed, *v3.6+* and VCD 10.2+) The UUID of this named disk's device backing\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/insertedMedia:InsertedMedia": {
            "description": "Provides a VMware Cloud Director resource for inserting or ejecting media (ISO) file for the VM. Create this resource for inserting the media, and destroy it for ejecting.\n\nSupported in provider *v2.0+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myInsertedMedia = new vcd.InsertedMedia(\"myInsertedMedia\", {\n    org: \"my-org\",\n    vdc: \"my-vcd\",\n    catalog: \"my-catalog\",\n    name: \"my-iso\",\n    vappName: \"my-vApp\",\n    vmName: \"my-VM\",\n    ejectForce: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_inserted_media = vcd.InsertedMedia(\"myInsertedMedia\",\n    org=\"my-org\",\n    vdc=\"my-vcd\",\n    catalog=\"my-catalog\",\n    name=\"my-iso\",\n    vapp_name=\"my-vApp\",\n    vm_name=\"my-VM\",\n    eject_force=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myInsertedMedia = new Vcd.InsertedMedia(\"myInsertedMedia\", new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vcd\",\n        Catalog = \"my-catalog\",\n        Name = \"my-iso\",\n        VappName = \"my-vApp\",\n        VmName = \"my-VM\",\n        EjectForce = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.NewInsertedMedia(ctx, \"myInsertedMedia\", \u0026vcd.InsertedMediaArgs{\n\t\t\tOrg:        pulumi.String(\"my-org\"),\n\t\t\tVdc:        pulumi.String(\"my-vcd\"),\n\t\t\tCatalog:    pulumi.String(\"my-catalog\"),\n\t\t\tName:       pulumi.String(\"my-iso\"),\n\t\t\tVappName:   pulumi.String(\"my-vApp\"),\n\t\t\tVmName:     pulumi.String(\"my-VM\"),\n\t\t\tEjectForce: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.InsertedMedia;\nimport com.pulumi.vcd.InsertedMediaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myInsertedMedia = new InsertedMedia(\"myInsertedMedia\", InsertedMediaArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vcd\")\n            .catalog(\"my-catalog\")\n            .name(\"my-iso\")\n            .vappName(\"my-vApp\")\n            .vmName(\"my-VM\")\n            .ejectForce(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myInsertedMedia:\n    type: vcd:InsertedMedia\n    properties:\n      org: my-org\n      vdc: my-vcd\n      catalog: my-catalog\n      name: my-iso\n      vappName: my-vApp\n      vmName: my-VM\n      ejectForce: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "catalog": {
                    "type": "string",
                    "description": "The name of the catalog where to find media file\n"
                },
                "ejectForce": {
                    "type": "boolean",
                    "description": "Allows to pass answer to question in vCD\n\"The guest operating system has locked the CD-ROM door and is probably using the CD-ROM.\nDisconnect anyway (and override the lock)?\"\nwhen ejecting from a VM which is powered on. True means \"Yes\" as answer to question. Default is `true`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Media file name in catalog which will be inserted to VM\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The name of vApp to find\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vmName": {
                    "type": "string",
                    "description": "The name of VM to be used to insert media file\n"
                }
            },
            "required": [
                "catalog",
                "name",
                "vappName",
                "vmName"
            ],
            "inputProperties": {
                "catalog": {
                    "type": "string",
                    "description": "The name of the catalog where to find media file\n",
                    "willReplaceOnChanges": true
                },
                "ejectForce": {
                    "type": "boolean",
                    "description": "Allows to pass answer to question in vCD\n\"The guest operating system has locked the CD-ROM door and is probably using the CD-ROM.\nDisconnect anyway (and override the lock)?\"\nwhen ejecting from a VM which is powered on. True means \"Yes\" as answer to question. Default is `true`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Media file name in catalog which will be inserted to VM\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "vappName": {
                    "type": "string",
                    "description": "The name of vApp to find\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "vmName": {
                    "type": "string",
                    "description": "The name of VM to be used to insert media file\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "catalog",
                "vappName",
                "vmName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InsertedMedia resources.\n",
                "properties": {
                    "catalog": {
                        "type": "string",
                        "description": "The name of the catalog where to find media file\n",
                        "willReplaceOnChanges": true
                    },
                    "ejectForce": {
                        "type": "boolean",
                        "description": "Allows to pass answer to question in vCD\n\"The guest operating system has locked the CD-ROM door and is probably using the CD-ROM.\nDisconnect anyway (and override the lock)?\"\nwhen ejecting from a VM which is powered on. True means \"Yes\" as answer to question. Default is `true`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Media file name in catalog which will be inserted to VM\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The name of vApp to find\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vmName": {
                        "type": "string",
                        "description": "The name of VM to be used to insert media file\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/ipSpace:IpSpace": {
            "properties": {
                "defaultFirewallRuleCreationEnabled": {
                    "type": "boolean",
                    "description": "Defines whether\ndefault firewall rule creation should be enabled\n"
                },
                "defaultNoSnatRuleCreationEnabled": {
                    "type": "boolean",
                    "description": "Defines whether NO SNAT\nrule creation should be enabled\n"
                },
                "defaultSnatRuleCreationEnabled": {
                    "type": "boolean",
                    "description": "Defines whether SNAT rule\ncreation should be enabled\n\n\u003ca id=\"ipspace-ip-range\"\u003e\u003c/a\u003e\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of IP Space\n"
                },
                "externalScope": {
                    "type": "string",
                    "description": "The external scope defines the total span of IP addresses to which the IP\nspace has access, for example the internet or a WAN.\n"
                },
                "internalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The internal scope of an IP space is a list of CIDR notations that\ndefines the exact span of IP addresses in which all ranges and blocks must be contained in.\n"
                },
                "ipPrefixes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IpSpaceIpPrefix:IpSpaceIpPrefix"
                    },
                    "description": "One or more IP prefixes (blocks) ip_prefix\n"
                },
                "ipRangeQuota": {
                    "type": "string",
                    "description": "If you entered at least one IP Range\n(ip_range), enter a number of floating IP addresses to allocate individually.\n`-1` is unlimited, while `0` means that no IPs can be allocated.\n"
                },
                "ipRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IpSpaceIpRange:IpSpaceIpRange"
                    },
                    "description": "One or more ip_range for floating IP address\nallocation. (Floating IP addresses are just IP addresses taken from the defined range)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for IP Space\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Required for `PRIVATE` type\n"
                },
                "routeAdvertisementEnabled": {
                    "type": "boolean",
                    "description": "Toggle on the route advertisement option to\nenable advertising networks with IP prefixes from this IP space (default `false`)\n"
                },
                "type": {
                    "type": "string",
                    "description": "One of `PUBLIC`, `SHARED_SERVICES`, `PRIVATE`\n* `PUBLIC` - A public IP space is *used by multiple organizations* and is *controlled by the service\nprovider* through a quota-based system.\n* `SHARED_SERVICES` - An IP space for services and management networks that are required in the\ntenant space, but as a service provider, you don't want to expose it to organizations in your\nenvironment. The main difference from `PUBLIC` network is that IPs cannot be allocated by tenants.\n* `PRIVATE` - Private IP spaces are dedicated to a single tenant - a private IP space is used by\nonly one organization that is specified during the space creation. For this organization, IP\nconsumption is unlimited.\n"
                }
            },
            "required": [
                "internalScopes",
                "ipRangeQuota",
                "name",
                "type"
            ],
            "inputProperties": {
                "defaultFirewallRuleCreationEnabled": {
                    "type": "boolean",
                    "description": "Defines whether\ndefault firewall rule creation should be enabled\n"
                },
                "defaultNoSnatRuleCreationEnabled": {
                    "type": "boolean",
                    "description": "Defines whether NO SNAT\nrule creation should be enabled\n"
                },
                "defaultSnatRuleCreationEnabled": {
                    "type": "boolean",
                    "description": "Defines whether SNAT rule\ncreation should be enabled\n\n\u003ca id=\"ipspace-ip-range\"\u003e\u003c/a\u003e\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of IP Space\n"
                },
                "externalScope": {
                    "type": "string",
                    "description": "The external scope defines the total span of IP addresses to which the IP\nspace has access, for example the internet or a WAN.\n"
                },
                "internalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The internal scope of an IP space is a list of CIDR notations that\ndefines the exact span of IP addresses in which all ranges and blocks must be contained in.\n"
                },
                "ipPrefixes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IpSpaceIpPrefix:IpSpaceIpPrefix"
                    },
                    "description": "One or more IP prefixes (blocks) ip_prefix\n"
                },
                "ipRangeQuota": {
                    "type": "string",
                    "description": "If you entered at least one IP Range\n(ip_range), enter a number of floating IP addresses to allocate individually.\n`-1` is unlimited, while `0` means that no IPs can be allocated.\n"
                },
                "ipRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IpSpaceIpRange:IpSpaceIpRange"
                    },
                    "description": "One or more ip_range for floating IP address\nallocation. (Floating IP addresses are just IP addresses taken from the defined range)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for IP Space\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Required for `PRIVATE` type\n"
                },
                "routeAdvertisementEnabled": {
                    "type": "boolean",
                    "description": "Toggle on the route advertisement option to\nenable advertising networks with IP prefixes from this IP space (default `false`)\n"
                },
                "type": {
                    "type": "string",
                    "description": "One of `PUBLIC`, `SHARED_SERVICES`, `PRIVATE`\n* `PUBLIC` - A public IP space is *used by multiple organizations* and is *controlled by the service\nprovider* through a quota-based system.\n* `SHARED_SERVICES` - An IP space for services and management networks that are required in the\ntenant space, but as a service provider, you don't want to expose it to organizations in your\nenvironment. The main difference from `PUBLIC` network is that IPs cannot be allocated by tenants.\n* `PRIVATE` - Private IP spaces are dedicated to a single tenant - a private IP space is used by\nonly one organization that is specified during the space creation. For this organization, IP\nconsumption is unlimited.\n"
                }
            },
            "requiredInputs": [
                "internalScopes",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpSpace resources.\n",
                "properties": {
                    "defaultFirewallRuleCreationEnabled": {
                        "type": "boolean",
                        "description": "Defines whether\ndefault firewall rule creation should be enabled\n"
                    },
                    "defaultNoSnatRuleCreationEnabled": {
                        "type": "boolean",
                        "description": "Defines whether NO SNAT\nrule creation should be enabled\n"
                    },
                    "defaultSnatRuleCreationEnabled": {
                        "type": "boolean",
                        "description": "Defines whether SNAT rule\ncreation should be enabled\n\n\u003ca id=\"ipspace-ip-range\"\u003e\u003c/a\u003e\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of IP Space\n"
                    },
                    "externalScope": {
                        "type": "string",
                        "description": "The external scope defines the total span of IP addresses to which the IP\nspace has access, for example the internet or a WAN.\n"
                    },
                    "internalScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The internal scope of an IP space is a list of CIDR notations that\ndefines the exact span of IP addresses in which all ranges and blocks must be contained in.\n"
                    },
                    "ipPrefixes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/IpSpaceIpPrefix:IpSpaceIpPrefix"
                        },
                        "description": "One or more IP prefixes (blocks) ip_prefix\n"
                    },
                    "ipRangeQuota": {
                        "type": "string",
                        "description": "If you entered at least one IP Range\n(ip_range), enter a number of floating IP addresses to allocate individually.\n`-1` is unlimited, while `0` means that no IPs can be allocated.\n"
                    },
                    "ipRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/IpSpaceIpRange:IpSpaceIpRange"
                        },
                        "description": "One or more ip_range for floating IP address\nallocation. (Floating IP addresses are just IP addresses taken from the defined range)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for IP Space\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Required for `PRIVATE` type\n"
                    },
                    "routeAdvertisementEnabled": {
                        "type": "boolean",
                        "description": "Toggle on the route advertisement option to\nenable advertising networks with IP prefixes from this IP space (default `false`)\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "One of `PUBLIC`, `SHARED_SERVICES`, `PRIVATE`\n* `PUBLIC` - A public IP space is *used by multiple organizations* and is *controlled by the service\nprovider* through a quota-based system.\n* `SHARED_SERVICES` - An IP space for services and management networks that are required in the\ntenant space, but as a service provider, you don't want to expose it to organizations in your\nenvironment. The main difference from `PUBLIC` network is that IPs cannot be allocated by tenants.\n* `PRIVATE` - Private IP spaces are dedicated to a single tenant - a private IP space is used by\nonly one organization that is specified during the space creation. For this organization, IP\nconsumption is unlimited.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/ipSpaceCustomQuota:IpSpaceCustomQuota": {
            "properties": {
                "ipPrefixQuotas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IpSpaceCustomQuotaIpPrefixQuota:IpSpaceCustomQuotaIpPrefixQuota"
                    },
                    "description": "IP Prefix Quota set in ip_prefix_quota blocks.\nWill inherit the default Quota set in `vcd.IpSpace` if not set\n\n\u003e The resource `vcd.IpSpaceCustomQuota` can only be created for an Org after an NSX-T Edge\nGateway backed by Provider Gateway is created within the Org. An explicit `depends_on` constraint\nfor an Edge Gateway to exist might be required. (See the example.)\n\n\u003ca id=\"ip-prefix-quota\"\u003e\u003c/a\u003e\n"
                },
                "ipRangeQuota": {
                    "type": "string",
                    "description": "Floating IP Quota. Will inherit the default Quota set in\n`vcd.IpSpace` if not set\n"
                },
                "ipSpaceId": {
                    "type": "string",
                    "description": "IP Space ID to set Custom Quotas\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Organization ID, for which the Quota should be customized\n"
                }
            },
            "required": [
                "ipSpaceId",
                "orgId"
            ],
            "inputProperties": {
                "ipPrefixQuotas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/IpSpaceCustomQuotaIpPrefixQuota:IpSpaceCustomQuotaIpPrefixQuota"
                    },
                    "description": "IP Prefix Quota set in ip_prefix_quota blocks.\nWill inherit the default Quota set in `vcd.IpSpace` if not set\n\n\u003e The resource `vcd.IpSpaceCustomQuota` can only be created for an Org after an NSX-T Edge\nGateway backed by Provider Gateway is created within the Org. An explicit `depends_on` constraint\nfor an Edge Gateway to exist might be required. (See the example.)\n\n\u003ca id=\"ip-prefix-quota\"\u003e\u003c/a\u003e\n"
                },
                "ipRangeQuota": {
                    "type": "string",
                    "description": "Floating IP Quota. Will inherit the default Quota set in\n`vcd.IpSpace` if not set\n"
                },
                "ipSpaceId": {
                    "type": "string",
                    "description": "IP Space ID to set Custom Quotas\n",
                    "willReplaceOnChanges": true
                },
                "orgId": {
                    "type": "string",
                    "description": "Organization ID, for which the Quota should be customized\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ipSpaceId",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpSpaceCustomQuota resources.\n",
                "properties": {
                    "ipPrefixQuotas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/IpSpaceCustomQuotaIpPrefixQuota:IpSpaceCustomQuotaIpPrefixQuota"
                        },
                        "description": "IP Prefix Quota set in ip_prefix_quota blocks.\nWill inherit the default Quota set in `vcd.IpSpace` if not set\n\n\u003e The resource `vcd.IpSpaceCustomQuota` can only be created for an Org after an NSX-T Edge\nGateway backed by Provider Gateway is created within the Org. An explicit `depends_on` constraint\nfor an Edge Gateway to exist might be required. (See the example.)\n\n\u003ca id=\"ip-prefix-quota\"\u003e\u003c/a\u003e\n"
                    },
                    "ipRangeQuota": {
                        "type": "string",
                        "description": "Floating IP Quota. Will inherit the default Quota set in\n`vcd.IpSpace` if not set\n"
                    },
                    "ipSpaceId": {
                        "type": "string",
                        "description": "IP Space ID to set Custom Quotas\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Organization ID, for which the Quota should be customized\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/ipSpaceIpAllocation:IpSpaceIpAllocation": {
            "properties": {
                "allocationDate": {
                    "type": "string",
                    "description": "allocation date in formated as `2023-06-07T09:57:58.721Z` (ISO 8601)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Can only be set when `usage_state=USED_MANUAL`\n\n\u003e IP Allocation resources can be created only if there is a NSX-T Edge Gateway\n(`vcd.NsxtEdgegateway`) that is backed by the Provider Gateway (`vcd.ExternalNetworkV2`) with IP\nSpace Uplinks (`vcd.IpSpaceUplink`). Attempting to allocate IP Addresses before having an\nEdge Gateway withing VDC will return errors of type `This operation is denied`.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "convenience field. For `type=IP_PREFIX` it will contain only the IP from CIDR returned\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address or CIDR\n"
                },
                "ipSpaceId": {
                    "type": "string",
                    "description": "IP Space ID to use for IP Allocations\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Org ID in which the IP is allocated\n"
                },
                "prefixLength": {
                    "type": "string",
                    "description": "Required when `type=IP_PREFIX`\n"
                },
                "type": {
                    "type": "string",
                    "description": "One of `FLOATING_IP`, `IP_PREFIX`\n* `FLOATING_IP` - allocates single IP from defined ranges in IP Space\n* `IP_PREFIX` - allocates subnets. **Note** field `prefix_length` is required to allocate IP\nPrefix\n"
                },
                "usageState": {
                    "type": "string",
                    "description": "(Optional) Only used with manual reservations. Value `USED_MANUAL`\nenables manual IP reservation. Value `UNUSED` is set to release manual allocation of IP.\n"
                },
                "usedById": {
                    "type": "string",
                    "description": "contains entity ID that is using the IP if `usage_state=USED`\n"
                },
                "value": {
                    "type": "string",
                    "description": "An option to request a specific IP or subnet from IP Space.\n**Note:** This field does not support IP ranges because it would cause multiple allocations\ncreated in one resource. Please use multiple resource instances to allocate IP ranges.\n"
                }
            },
            "required": [
                "allocationDate",
                "description",
                "ip",
                "ipAddress",
                "orgId",
                "prefixLength",
                "type",
                "usageState",
                "usedById"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Can only be set when `usage_state=USED_MANUAL`\n\n\u003e IP Allocation resources can be created only if there is a NSX-T Edge Gateway\n(`vcd.NsxtEdgegateway`) that is backed by the Provider Gateway (`vcd.ExternalNetworkV2`) with IP\nSpace Uplinks (`vcd.IpSpaceUplink`). Attempting to allocate IP Addresses before having an\nEdge Gateway withing VDC will return errors of type `This operation is denied`.\n"
                },
                "ipSpaceId": {
                    "type": "string",
                    "description": "IP Space ID to use for IP Allocations\n",
                    "willReplaceOnChanges": true
                },
                "orgId": {
                    "type": "string",
                    "description": "Org ID in which the IP is allocated\n",
                    "willReplaceOnChanges": true
                },
                "prefixLength": {
                    "type": "string",
                    "description": "Required when `type=IP_PREFIX`\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "One of `FLOATING_IP`, `IP_PREFIX`\n* `FLOATING_IP` - allocates single IP from defined ranges in IP Space\n* `IP_PREFIX` - allocates subnets. **Note** field `prefix_length` is required to allocate IP\nPrefix\n",
                    "willReplaceOnChanges": true
                },
                "usageState": {
                    "type": "string",
                    "description": "(Optional) Only used with manual reservations. Value `USED_MANUAL`\nenables manual IP reservation. Value `UNUSED` is set to release manual allocation of IP.\n"
                },
                "value": {
                    "type": "string",
                    "description": "An option to request a specific IP or subnet from IP Space.\n**Note:** This field does not support IP ranges because it would cause multiple allocations\ncreated in one resource. Please use multiple resource instances to allocate IP ranges.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "orgId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpSpaceIpAllocation resources.\n",
                "properties": {
                    "allocationDate": {
                        "type": "string",
                        "description": "allocation date in formated as `2023-06-07T09:57:58.721Z` (ISO 8601)\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Can only be set when `usage_state=USED_MANUAL`\n\n\u003e IP Allocation resources can be created only if there is a NSX-T Edge Gateway\n(`vcd.NsxtEdgegateway`) that is backed by the Provider Gateway (`vcd.ExternalNetworkV2`) with IP\nSpace Uplinks (`vcd.IpSpaceUplink`). Attempting to allocate IP Addresses before having an\nEdge Gateway withing VDC will return errors of type `This operation is denied`.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "convenience field. For `type=IP_PREFIX` it will contain only the IP from CIDR returned\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "IP address or CIDR\n"
                    },
                    "ipSpaceId": {
                        "type": "string",
                        "description": "IP Space ID to use for IP Allocations\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Org ID in which the IP is allocated\n",
                        "willReplaceOnChanges": true
                    },
                    "prefixLength": {
                        "type": "string",
                        "description": "Required when `type=IP_PREFIX`\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "One of `FLOATING_IP`, `IP_PREFIX`\n* `FLOATING_IP` - allocates single IP from defined ranges in IP Space\n* `IP_PREFIX` - allocates subnets. **Note** field `prefix_length` is required to allocate IP\nPrefix\n",
                        "willReplaceOnChanges": true
                    },
                    "usageState": {
                        "type": "string",
                        "description": "(Optional) Only used with manual reservations. Value `USED_MANUAL`\nenables manual IP reservation. Value `UNUSED` is set to release manual allocation of IP.\n"
                    },
                    "usedById": {
                        "type": "string",
                        "description": "contains entity ID that is using the IP if `usage_state=USED`\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "An option to request a specific IP or subnet from IP Space.\n**Note:** This field does not support IP ranges because it would cause multiple allocations\ncreated in one resource. Please use multiple resource instances to allocate IP ranges.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/ipSpaceUplink:IpSpaceUplink": {
            "properties": {
                "associatedInterfaceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Tier-0 Router Interfaces to associate with this uplink\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for IP Space Uplink\n"
                },
                "externalNetworkId": {
                    "type": "string",
                    "description": "External Network ID For IP Space Uplink configuration\n"
                },
                "ipSpaceId": {
                    "type": "string",
                    "description": "IP Space ID configuration\n"
                },
                "ipSpaceType": {
                    "type": "string",
                    "description": "Backing IP Space type\n"
                },
                "name": {
                    "type": "string",
                    "description": "A tenant facing name for IP Space Uplink\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of IP Space Uplink\n"
                }
            },
            "required": [
                "externalNetworkId",
                "ipSpaceId",
                "ipSpaceType",
                "name",
                "status"
            ],
            "inputProperties": {
                "associatedInterfaceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Tier-0 Router Interfaces to associate with this uplink\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for IP Space Uplink\n"
                },
                "externalNetworkId": {
                    "type": "string",
                    "description": "External Network ID For IP Space Uplink configuration\n",
                    "willReplaceOnChanges": true
                },
                "ipSpaceId": {
                    "type": "string",
                    "description": "IP Space ID configuration\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A tenant facing name for IP Space Uplink\n"
                }
            },
            "requiredInputs": [
                "externalNetworkId",
                "ipSpaceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpSpaceUplink resources.\n",
                "properties": {
                    "associatedInterfaceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of Tier-0 Router Interfaces to associate with this uplink\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description for IP Space Uplink\n"
                    },
                    "externalNetworkId": {
                        "type": "string",
                        "description": "External Network ID For IP Space Uplink configuration\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSpaceId": {
                        "type": "string",
                        "description": "IP Space ID configuration\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSpaceType": {
                        "type": "string",
                        "description": "Backing IP Space type\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A tenant facing name for IP Space Uplink\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of IP Space Uplink\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/lbAppProfile:LbAppProfile": {
            "properties": {
                "cookieMode": {
                    "type": "string",
                    "description": "The mode by which the cookie should be inserted. One of 'insert', \n'prefix', or 'appsession'\n"
                },
                "cookieName": {
                    "type": "string",
                    "description": "Used to uniquely identify the session the first time a client accesses\nthe site. The load balancer refers to this cookie when connecting subsequent requests in the\nsession, so that they all go to the same virtual server. Only applies for\n`persistence_mechanism` 'cookie'\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the application profile is to be created\n"
                },
                "enablePoolSideSsl": {
                    "type": "boolean",
                    "description": "Enable to define the certificate, CAs, or CRLs used to\nauthenticate the load balancer from the server side. **Note:** This resource does not currently\nsupport attaching Pool and Virtual Server certificates therefore this toggle only enables it. To\nmake it fully work certificates must be currently attached manually.\n"
                },
                "enableSslPassthrough": {
                    "type": "boolean",
                    "description": "Enable SSL authentication to be passed through to the\nvirtual server. Otherwise SSL authentication takes place at the destination address\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "Length of time in seconds that persistence stays in effect\n"
                },
                "httpRedirectUrl": {
                    "type": "string",
                    "description": "The URL to which traffic that arrives at the destination address\nshould be redirected. Only applies for types `http` and `https`\n"
                },
                "insertXForwardedHttpHeader": {
                    "type": "boolean",
                    "description": "Enables 'X-Forwarded-For' header for identifying\nthe originating IP address of a client connecting to a Web server through the load balancer.\nOnly applies for types `http` and `https`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Application profile name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "persistenceMechanism": {
                    "type": "string",
                    "description": "Persistence mechanism for the profile. One of 'cookie',\n'ssl-sessionid', 'sourceip'\n"
                },
                "type": {
                    "type": "string",
                    "description": "Protocol type used to send requests to the server. One of `tcp`, `udp`,\n`http`, or `https`\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "edgeGateway",
                "name",
                "type"
            ],
            "inputProperties": {
                "cookieMode": {
                    "type": "string",
                    "description": "The mode by which the cookie should be inserted. One of 'insert', \n'prefix', or 'appsession'\n"
                },
                "cookieName": {
                    "type": "string",
                    "description": "Used to uniquely identify the session the first time a client accesses\nthe site. The load balancer refers to this cookie when connecting subsequent requests in the\nsession, so that they all go to the same virtual server. Only applies for\n`persistence_mechanism` 'cookie'\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the application profile is to be created\n",
                    "willReplaceOnChanges": true
                },
                "enablePoolSideSsl": {
                    "type": "boolean",
                    "description": "Enable to define the certificate, CAs, or CRLs used to\nauthenticate the load balancer from the server side. **Note:** This resource does not currently\nsupport attaching Pool and Virtual Server certificates therefore this toggle only enables it. To\nmake it fully work certificates must be currently attached manually.\n"
                },
                "enableSslPassthrough": {
                    "type": "boolean",
                    "description": "Enable SSL authentication to be passed through to the\nvirtual server. Otherwise SSL authentication takes place at the destination address\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "Length of time in seconds that persistence stays in effect\n"
                },
                "httpRedirectUrl": {
                    "type": "string",
                    "description": "The URL to which traffic that arrives at the destination address\nshould be redirected. Only applies for types `http` and `https`\n"
                },
                "insertXForwardedHttpHeader": {
                    "type": "boolean",
                    "description": "Enables 'X-Forwarded-For' header for identifying\nthe originating IP address of a client connecting to a Web server through the load balancer.\nOnly applies for types `http` and `https`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Application profile name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "persistenceMechanism": {
                    "type": "string",
                    "description": "Persistence mechanism for the profile. One of 'cookie',\n'ssl-sessionid', 'sourceip'\n"
                },
                "type": {
                    "type": "string",
                    "description": "Protocol type used to send requests to the server. One of `tcp`, `udp`,\n`http`, or `https`\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LbAppProfile resources.\n",
                "properties": {
                    "cookieMode": {
                        "type": "string",
                        "description": "The mode by which the cookie should be inserted. One of 'insert', \n'prefix', or 'appsession'\n"
                    },
                    "cookieName": {
                        "type": "string",
                        "description": "Used to uniquely identify the session the first time a client accesses\nthe site. The load balancer refers to this cookie when connecting subsequent requests in the\nsession, so that they all go to the same virtual server. Only applies for\n`persistence_mechanism` 'cookie'\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the application profile is to be created\n",
                        "willReplaceOnChanges": true
                    },
                    "enablePoolSideSsl": {
                        "type": "boolean",
                        "description": "Enable to define the certificate, CAs, or CRLs used to\nauthenticate the load balancer from the server side. **Note:** This resource does not currently\nsupport attaching Pool and Virtual Server certificates therefore this toggle only enables it. To\nmake it fully work certificates must be currently attached manually.\n"
                    },
                    "enableSslPassthrough": {
                        "type": "boolean",
                        "description": "Enable SSL authentication to be passed through to the\nvirtual server. Otherwise SSL authentication takes place at the destination address\n"
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "Length of time in seconds that persistence stays in effect\n"
                    },
                    "httpRedirectUrl": {
                        "type": "string",
                        "description": "The URL to which traffic that arrives at the destination address\nshould be redirected. Only applies for types `http` and `https`\n"
                    },
                    "insertXForwardedHttpHeader": {
                        "type": "boolean",
                        "description": "Enables 'X-Forwarded-For' header for identifying\nthe originating IP address of a client connecting to a Web server through the load balancer.\nOnly applies for types `http` and `https`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Application profile name\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "persistenceMechanism": {
                        "type": "string",
                        "description": "Persistence mechanism for the profile. One of 'cookie',\n'ssl-sessionid', 'sourceip'\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Protocol type used to send requests to the server. One of `tcp`, `udp`,\n`http`, or `https`\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/lbAppRule:LbAppRule": {
            "properties": {
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the application rule is to be created\n"
                },
                "name": {
                    "type": "string",
                    "description": "Application rule name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "script": {
                    "type": "string",
                    "description": "The script for the application rule. Note - you may find HEREDOC useful to pass multiline strings\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "edgeGateway",
                "name",
                "script"
            ],
            "inputProperties": {
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the application rule is to be created\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Application rule name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "script": {
                    "type": "string",
                    "description": "The script for the application rule. Note - you may find HEREDOC useful to pass multiline strings\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "script"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LbAppRule resources.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the application rule is to be created\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Application rule name\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "script": {
                        "type": "string",
                        "description": "The script for the application rule. Note - you may find HEREDOC useful to pass multiline strings\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/lbServerPool:LbServerPool": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Server Pool load balancing method. Can be one of `ip-hash`, `round-robin`, `uri`, `leastconn`, `url`, or `httpheader`\n"
                },
                "algorithmParameters": {
                    "type": "string",
                    "description": "Valid only when `algorithm` is `httpheader` or `url`. The `httpheader` algorithm\nparameter has one option `headerName=\u003cname\u003e` while the `url` algorithm parameter has option `urlParam=\u003curl\u003e`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Server Pool description\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the server pool is to be created\n"
                },
                "enableTransparency": {
                    "type": "boolean",
                    "description": "When transparency is `false` (default) backend servers see the IP address of the\ntraffic source as the internal IP address of the load balancer. When it is `true` the source IP address is the actual IP\naddress of the client and the edge gateway must be set as the default gateway to ensure that return packets go through\nthe edge gateway.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/LbServerPoolMember:LbServerPoolMember"
                    },
                    "description": "A block to define server pool members. Multiple can be used. See Member and \nexample for usage details.\n\n\n\u003ca id=\"member\"\u003e\u003c/a\u003e\n"
                },
                "monitorId": {
                    "type": "string",
                    "description": "`vcd.LbServiceMonitor` resource `id` to attach to server pool for health check parameters\n"
                },
                "name": {
                    "type": "string",
                    "description": "Server Pool name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "algorithm",
                "edgeGateway",
                "name"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Server Pool load balancing method. Can be one of `ip-hash`, `round-robin`, `uri`, `leastconn`, `url`, or `httpheader`\n"
                },
                "algorithmParameters": {
                    "type": "string",
                    "description": "Valid only when `algorithm` is `httpheader` or `url`. The `httpheader` algorithm\nparameter has one option `headerName=\u003cname\u003e` while the `url` algorithm parameter has option `urlParam=\u003curl\u003e`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Server Pool description\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the server pool is to be created\n",
                    "willReplaceOnChanges": true
                },
                "enableTransparency": {
                    "type": "boolean",
                    "description": "When transparency is `false` (default) backend servers see the IP address of the\ntraffic source as the internal IP address of the load balancer. When it is `true` the source IP address is the actual IP\naddress of the client and the edge gateway must be set as the default gateway to ensure that return packets go through\nthe edge gateway.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/LbServerPoolMember:LbServerPoolMember"
                    },
                    "description": "A block to define server pool members. Multiple can be used. See Member and \nexample for usage details.\n\n\n\u003ca id=\"member\"\u003e\u003c/a\u003e\n"
                },
                "monitorId": {
                    "type": "string",
                    "description": "`vcd.LbServiceMonitor` resource `id` to attach to server pool for health check parameters\n"
                },
                "name": {
                    "type": "string",
                    "description": "Server Pool name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "algorithm",
                "edgeGateway"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LbServerPool resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Server Pool load balancing method. Can be one of `ip-hash`, `round-robin`, `uri`, `leastconn`, `url`, or `httpheader`\n"
                    },
                    "algorithmParameters": {
                        "type": "string",
                        "description": "Valid only when `algorithm` is `httpheader` or `url`. The `httpheader` algorithm\nparameter has one option `headerName=\u003cname\u003e` while the `url` algorithm parameter has option `urlParam=\u003curl\u003e`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Server Pool description\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the server pool is to be created\n",
                        "willReplaceOnChanges": true
                    },
                    "enableTransparency": {
                        "type": "boolean",
                        "description": "When transparency is `false` (default) backend servers see the IP address of the\ntraffic source as the internal IP address of the load balancer. When it is `true` the source IP address is the actual IP\naddress of the client and the edge gateway must be set as the default gateway to ensure that return packets go through\nthe edge gateway.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/LbServerPoolMember:LbServerPoolMember"
                        },
                        "description": "A block to define server pool members. Multiple can be used. See Member and \nexample for usage details.\n\n\n\u003ca id=\"member\"\u003e\u003c/a\u003e\n"
                    },
                    "monitorId": {
                        "type": "string",
                        "description": "`vcd.LbServiceMonitor` resource `id` to attach to server pool for health check parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Server Pool name\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/lbServiceMonitor:LbServiceMonitor": {
            "properties": {
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the service monitor is to be created\n"
                },
                "expected": {
                    "type": "string",
                    "description": "For types `http` and `https`. String that the monitor expects to match in the status line of \nthe HTTP or HTTPS response (for example, `HTTP/1.1`)\n"
                },
                "extension": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of advanced monitor parameters as key=value pairs (i.e. `max-age=SECONDS`, `invert-regex`)\n**Note**: When you need a value of `key` only format just set value to empty string (i.e. `linespan = \"\"`)\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "Interval in seconds at which a server is to be monitored using the specified Method.\nDefaults to 10\n"
                },
                "maxRetries": {
                    "type": "integer",
                    "description": "Number of times the specified monitoring Method must fail sequentially before the server is\ndeclared down. Defaults to 3\n"
                },
                "method": {
                    "type": "string",
                    "description": "For types `http` and `https`. Select http method to be used to detect server status. One of\nOPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT\n"
                },
                "name": {
                    "type": "string",
                    "description": "Service Monitor name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "receive": {
                    "type": "string",
                    "description": "For types `http`,  `https`, and `udp`. The string to be matched in the response content.\n**Note**: When `expected` is not matched, the monitor does not try to match the Receive content\n"
                },
                "send": {
                    "type": "string",
                    "description": "For types `http`,  `https`, and `udp`. The data to be sent.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "Maximum time in seconds within which a response from the server must be received. Defaults to 15\n"
                },
                "type": {
                    "type": "string",
                    "description": "Select the way in which you want to send the health check request to the server  `http`, `https`, \n`tcp`, `icmp`, or `udp`. Depending on the type selected, the remaining attributes are allowed or not\n"
                },
                "url": {
                    "type": "string",
                    "description": "For types `http` and `https`. URL to be used in the server status request\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "edgeGateway",
                "name",
                "type"
            ],
            "inputProperties": {
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the service monitor is to be created\n",
                    "willReplaceOnChanges": true
                },
                "expected": {
                    "type": "string",
                    "description": "For types `http` and `https`. String that the monitor expects to match in the status line of \nthe HTTP or HTTPS response (for example, `HTTP/1.1`)\n"
                },
                "extension": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of advanced monitor parameters as key=value pairs (i.e. `max-age=SECONDS`, `invert-regex`)\n**Note**: When you need a value of `key` only format just set value to empty string (i.e. `linespan = \"\"`)\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "Interval in seconds at which a server is to be monitored using the specified Method.\nDefaults to 10\n"
                },
                "maxRetries": {
                    "type": "integer",
                    "description": "Number of times the specified monitoring Method must fail sequentially before the server is\ndeclared down. Defaults to 3\n"
                },
                "method": {
                    "type": "string",
                    "description": "For types `http` and `https`. Select http method to be used to detect server status. One of\nOPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT\n"
                },
                "name": {
                    "type": "string",
                    "description": "Service Monitor name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "receive": {
                    "type": "string",
                    "description": "For types `http`,  `https`, and `udp`. The string to be matched in the response content.\n**Note**: When `expected` is not matched, the monitor does not try to match the Receive content\n"
                },
                "send": {
                    "type": "string",
                    "description": "For types `http`,  `https`, and `udp`. The data to be sent.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "Maximum time in seconds within which a response from the server must be received. Defaults to 15\n"
                },
                "type": {
                    "type": "string",
                    "description": "Select the way in which you want to send the health check request to the server  `http`, `https`, \n`tcp`, `icmp`, or `udp`. Depending on the type selected, the remaining attributes are allowed or not\n"
                },
                "url": {
                    "type": "string",
                    "description": "For types `http` and `https`. URL to be used in the server status request\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LbServiceMonitor resources.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the service monitor is to be created\n",
                        "willReplaceOnChanges": true
                    },
                    "expected": {
                        "type": "string",
                        "description": "For types `http` and `https`. String that the monitor expects to match in the status line of \nthe HTTP or HTTPS response (for example, `HTTP/1.1`)\n"
                    },
                    "extension": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of advanced monitor parameters as key=value pairs (i.e. `max-age=SECONDS`, `invert-regex`)\n**Note**: When you need a value of `key` only format just set value to empty string (i.e. `linespan = \"\"`)\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "Interval in seconds at which a server is to be monitored using the specified Method.\nDefaults to 10\n"
                    },
                    "maxRetries": {
                        "type": "integer",
                        "description": "Number of times the specified monitoring Method must fail sequentially before the server is\ndeclared down. Defaults to 3\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "For types `http` and `https`. Select http method to be used to detect server status. One of\nOPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Service Monitor name\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "receive": {
                        "type": "string",
                        "description": "For types `http`,  `https`, and `udp`. The string to be matched in the response content.\n**Note**: When `expected` is not matched, the monitor does not try to match the Receive content\n"
                    },
                    "send": {
                        "type": "string",
                        "description": "For types `http`,  `https`, and `udp`. The data to be sent.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Maximum time in seconds within which a response from the server must be received. Defaults to 15\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Select the way in which you want to send the health check request to the server  `http`, `https`, \n`tcp`, `icmp`, or `udp`. Depending on the type selected, the remaining attributes are allowed or not\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "For types `http` and `https`. URL to be used in the server status request\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/lbVirtualServer:LbVirtualServer": {
            "properties": {
                "appProfileId": {
                    "type": "string",
                    "description": "Application profile ID to be associated with the virtual server\n"
                },
                "appRuleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of attached application rule IDs\n"
                },
                "connectionLimit": {
                    "type": "integer",
                    "description": "Maximum concurrent connections that the virtual server can process\n"
                },
                "connectionRateLimit": {
                    "type": "integer",
                    "description": "Maximum incoming new connection requests per second\n"
                },
                "description": {
                    "type": "string",
                    "description": "Virtual server description\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the virtual server is to be\ncreated\n"
                },
                "enableAcceleration": {
                    "type": "boolean",
                    "description": "Defines if the virtual server uses acceleration. Default\n`false`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the virtual server is enabled. Default `true`\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Set the IP address that the load balancer listens on\n"
                },
                "name": {
                    "type": "string",
                    "description": "Virtual server name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port number that the load balancer listens on\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Select the protocol that the virtual server accepts. One of `tcp`, `udp`,\n`http`, or `https` **Note**: You must select the same protocol used by the selected\n**Application Profile**\n"
                },
                "serverPoolId": {
                    "type": "string",
                    "description": "The server pool that the load balancer will use\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "edgeGateway",
                "ipAddress",
                "name",
                "port",
                "protocol"
            ],
            "inputProperties": {
                "appProfileId": {
                    "type": "string",
                    "description": "Application profile ID to be associated with the virtual server\n"
                },
                "appRuleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of attached application rule IDs\n"
                },
                "connectionLimit": {
                    "type": "integer",
                    "description": "Maximum concurrent connections that the virtual server can process\n"
                },
                "connectionRateLimit": {
                    "type": "integer",
                    "description": "Maximum incoming new connection requests per second\n"
                },
                "description": {
                    "type": "string",
                    "description": "Virtual server description\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which the virtual server is to be\ncreated\n",
                    "willReplaceOnChanges": true
                },
                "enableAcceleration": {
                    "type": "boolean",
                    "description": "Defines if the virtual server uses acceleration. Default\n`false`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the virtual server is enabled. Default `true`\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Set the IP address that the load balancer listens on\n"
                },
                "name": {
                    "type": "string",
                    "description": "Virtual server name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "integer",
                    "description": "The port number that the load balancer listens on\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Select the protocol that the virtual server accepts. One of `tcp`, `udp`,\n`http`, or `https` **Note**: You must select the same protocol used by the selected\n**Application Profile**\n"
                },
                "serverPoolId": {
                    "type": "string",
                    "description": "The server pool that the load balancer will use\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "ipAddress",
                "port",
                "protocol"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LbVirtualServer resources.\n",
                "properties": {
                    "appProfileId": {
                        "type": "string",
                        "description": "Application profile ID to be associated with the virtual server\n"
                    },
                    "appRuleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of attached application rule IDs\n"
                    },
                    "connectionLimit": {
                        "type": "integer",
                        "description": "Maximum concurrent connections that the virtual server can process\n"
                    },
                    "connectionRateLimit": {
                        "type": "integer",
                        "description": "Maximum incoming new connection requests per second\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Virtual server description\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the virtual server is to be\ncreated\n",
                        "willReplaceOnChanges": true
                    },
                    "enableAcceleration": {
                        "type": "boolean",
                        "description": "Defines if the virtual server uses acceleration. Default\n`false`\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Defines if the virtual server is enabled. Default `true`\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Set the IP address that the load balancer listens on\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Virtual server name\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port number that the load balancer listens on\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Select the protocol that the virtual server accepts. One of `tcp`, `udp`,\n`http`, or `https` **Note**: You must select the same protocol used by the selected\n**Application Profile**\n"
                    },
                    "serverPoolId": {
                        "type": "string",
                        "description": "The server pool that the load balancer will use\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/libraryCertificate:LibraryCertificate": {
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "Alias of certificate\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Certificate content\n"
                },
                "description": {
                    "type": "string",
                    "description": "Certificate description\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Certificate private key\n",
                    "secret": true
                },
                "privateKeyPassphrase": {
                    "type": "string",
                    "description": "Certificate private pass phrase\n",
                    "secret": true
                }
            },
            "required": [
                "alias",
                "certificate"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "Alias of certificate\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Certificate content\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Certificate description\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "Certificate private key\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "privateKeyPassphrase": {
                    "type": "string",
                    "description": "Certificate private pass phrase\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "alias",
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LibraryCertificate resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "Alias of certificate\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Certificate content\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "Certificate description\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Certificate private key\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "privateKeyPassphrase": {
                        "type": "string",
                        "description": "Certificate private pass phrase\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/multisiteOrgAssociation:MultisiteOrgAssociation": {
            "properties": {
                "associatedOrgId": {
                    "type": "string",
                    "description": "ID of the remote org associated with the current one.\n"
                },
                "associatedOrgName": {
                    "type": "string",
                    "description": "The name of the associated org.\n"
                },
                "associatedSiteId": {
                    "type": "string",
                    "description": "ID of the remote site to which the associated org belongs.\n"
                },
                "associationData": {
                    "type": "string",
                    "description": "Data produced from another org, needed to associate to this org from another one.\n(Used instead of `associated_data_file`)\n"
                },
                "associationDataFile": {
                    "type": "string",
                    "description": "Name of the file containing the data used to associate to this org from another one.\n(Used instead of `associated_data`). This file can be created (by the other org administrator) using the data source `vcd.getMultisiteOrgData`.\n"
                },
                "connectionTimeoutMins": {
                    "type": "integer",
                    "description": "How many minutes to keep checking for connection (0=no check)\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the current organization where we start the association with a remote one.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the association (one of `ASYMMETRIC`, `ACTIVE`, `UNREACHABLE`, `ERROR`)\n"
                }
            },
            "required": [
                "associatedOrgId",
                "associatedOrgName",
                "associatedSiteId",
                "orgId",
                "status"
            ],
            "inputProperties": {
                "associatedOrgId": {
                    "type": "string",
                    "description": "ID of the remote org associated with the current one.\n"
                },
                "associationData": {
                    "type": "string",
                    "description": "Data produced from another org, needed to associate to this org from another one.\n(Used instead of `associated_data_file`)\n",
                    "willReplaceOnChanges": true
                },
                "associationDataFile": {
                    "type": "string",
                    "description": "Name of the file containing the data used to associate to this org from another one.\n(Used instead of `associated_data`). This file can be created (by the other org administrator) using the data source `vcd.getMultisiteOrgData`.\n",
                    "willReplaceOnChanges": true
                },
                "connectionTimeoutMins": {
                    "type": "integer",
                    "description": "How many minutes to keep checking for connection (0=no check)\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the current organization where we start the association with a remote one.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MultisiteOrgAssociation resources.\n",
                "properties": {
                    "associatedOrgId": {
                        "type": "string",
                        "description": "ID of the remote org associated with the current one.\n"
                    },
                    "associatedOrgName": {
                        "type": "string",
                        "description": "The name of the associated org.\n"
                    },
                    "associatedSiteId": {
                        "type": "string",
                        "description": "ID of the remote site to which the associated org belongs.\n"
                    },
                    "associationData": {
                        "type": "string",
                        "description": "Data produced from another org, needed to associate to this org from another one.\n(Used instead of `associated_data_file`)\n",
                        "willReplaceOnChanges": true
                    },
                    "associationDataFile": {
                        "type": "string",
                        "description": "Name of the file containing the data used to associate to this org from another one.\n(Used instead of `associated_data`). This file can be created (by the other org administrator) using the data source `vcd.getMultisiteOrgData`.\n",
                        "willReplaceOnChanges": true
                    },
                    "connectionTimeoutMins": {
                        "type": "integer",
                        "description": "How many minutes to keep checking for connection (0=no check)\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the current organization where we start the association with a remote one.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the association (one of `ASYMMETRIC`, `ACTIVE`, `UNREACHABLE`, `ERROR`)\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/multisiteSiteAssociation:MultisiteSiteAssociation": {
            "properties": {
                "associatedSiteHref": {
                    "type": "string",
                    "description": "URL of the associated site\n"
                },
                "associatedSiteId": {
                    "type": "string",
                    "description": "ID of the remote site associated with the current one.\n"
                },
                "associatedSiteName": {
                    "type": "string",
                    "description": "The name of the associated site.\n"
                },
                "associationData": {
                    "type": "string",
                    "description": "Data produced from another site, needed to associate to this site from another one.\n(Used instead of `associated_data_file`)\n"
                },
                "associationDataFile": {
                    "type": "string",
                    "description": "Name of the file containing the data used to associate to this site from another one.\n(Used instead of `associated_data`). This file can be created (by the other site administrator) using the data source `vcd.getMultisiteSiteData`.\n"
                },
                "connectionTimeoutMins": {
                    "type": "integer",
                    "description": "How many minutes we wait for the association to be complete. (0 = no check) \nThis property is only used during update, and should not be used until both sides of the association have been completed.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the association (one of `ASYMMETRIC`, `ACTIVE`, `UNREACHABLE`, `ERROR`)\n"
                }
            },
            "required": [
                "associatedSiteHref",
                "associatedSiteId",
                "associatedSiteName",
                "status"
            ],
            "inputProperties": {
                "associationData": {
                    "type": "string",
                    "description": "Data produced from another site, needed to associate to this site from another one.\n(Used instead of `associated_data_file`)\n",
                    "willReplaceOnChanges": true
                },
                "associationDataFile": {
                    "type": "string",
                    "description": "Name of the file containing the data used to associate to this site from another one.\n(Used instead of `associated_data`). This file can be created (by the other site administrator) using the data source `vcd.getMultisiteSiteData`.\n",
                    "willReplaceOnChanges": true
                },
                "connectionTimeoutMins": {
                    "type": "integer",
                    "description": "How many minutes we wait for the association to be complete. (0 = no check) \nThis property is only used during update, and should not be used until both sides of the association have been completed.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MultisiteSiteAssociation resources.\n",
                "properties": {
                    "associatedSiteHref": {
                        "type": "string",
                        "description": "URL of the associated site\n"
                    },
                    "associatedSiteId": {
                        "type": "string",
                        "description": "ID of the remote site associated with the current one.\n"
                    },
                    "associatedSiteName": {
                        "type": "string",
                        "description": "The name of the associated site.\n"
                    },
                    "associationData": {
                        "type": "string",
                        "description": "Data produced from another site, needed to associate to this site from another one.\n(Used instead of `associated_data_file`)\n",
                        "willReplaceOnChanges": true
                    },
                    "associationDataFile": {
                        "type": "string",
                        "description": "Name of the file containing the data used to associate to this site from another one.\n(Used instead of `associated_data`). This file can be created (by the other site administrator) using the data source `vcd.getMultisiteSiteData`.\n",
                        "willReplaceOnChanges": true
                    },
                    "connectionTimeoutMins": {
                        "type": "integer",
                        "description": "How many minutes we wait for the association to be complete. (0 = no check) \nThis property is only used during update, and should not be used until both sides of the association have been completed.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the association (one of `ASYMMETRIC`, `ACTIVE`, `UNREACHABLE`, `ERROR`)\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/networkDirect:NetworkDirect": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "externalNetwork": {
                    "type": "string",
                    "description": "The name of the external network.\n"
                },
                "externalNetworkDns1": {
                    "type": "string",
                    "description": "(Computed) returns the first DNS from the external network\n"
                },
                "externalNetworkDns2": {
                    "type": "string",
                    "description": "(Computed) returns the second DNS from the external network\n"
                },
                "externalNetworkDnsSuffix": {
                    "type": "string",
                    "description": "(Computed) returns the DNS suffix from the external network\n"
                },
                "externalNetworkGateway": {
                    "type": "string",
                    "description": "(Computed) returns the gateway from the external network\n"
                },
                "externalNetworkNetmask": {
                    "type": "string",
                    "description": "(Computed) returns the netmask from the external network\n"
                },
                "href": {
                    "type": "string",
                    "description": "Network Hypertext Reference\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkDirectMetadataEntry:NetworkDirectMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n"
                },
                "shared": {
                    "type": "boolean",
                    "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "externalNetwork",
                "externalNetworkDns1",
                "externalNetworkDns2",
                "externalNetworkDnsSuffix",
                "externalNetworkGateway",
                "externalNetworkNetmask",
                "href",
                "metadata",
                "metadataEntries",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "externalNetwork": {
                    "type": "string",
                    "description": "The name of the external network.\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkDirectMetadataEntry:NetworkDirectMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "shared": {
                    "type": "boolean",
                    "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "externalNetwork"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkDirect resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the network\n"
                    },
                    "externalNetwork": {
                        "type": "string",
                        "description": "The name of the external network.\n",
                        "willReplaceOnChanges": true
                    },
                    "externalNetworkDns1": {
                        "type": "string",
                        "description": "(Computed) returns the first DNS from the external network\n"
                    },
                    "externalNetworkDns2": {
                        "type": "string",
                        "description": "(Computed) returns the second DNS from the external network\n"
                    },
                    "externalNetworkDnsSuffix": {
                        "type": "string",
                        "description": "(Computed) returns the DNS suffix from the external network\n"
                    },
                    "externalNetworkGateway": {
                        "type": "string",
                        "description": "(Computed) returns the gateway from the external network\n"
                    },
                    "externalNetworkNetmask": {
                        "type": "string",
                        "description": "(Computed) returns the netmask from the external network\n"
                    },
                    "href": {
                        "type": "string",
                        "description": "Network Hypertext Reference\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkDirectMetadataEntry:NetworkDirectMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "shared": {
                        "type": "boolean",
                        "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/networkIsolated:NetworkIsolated": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dhcpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedDhcpPool:NetworkIsolatedDhcpPool"
                    },
                    "description": "A range of IPs to issue to virtual machines that don't\nhave a static IP; see IP Pools below for details.\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network\n"
                },
                "href": {
                    "type": "string",
                    "description": "Network Hyper Reference\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedMetadataEntry:NetworkIsolatedMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "The netmask for the new network. Defaults to `255.255.255.0`\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n"
                },
                "shared": {
                    "type": "boolean",
                    "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedStaticIpPool:NetworkIsolatedStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "href",
                "metadata",
                "metadataEntries",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dhcpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedDhcpPool:NetworkIsolatedDhcpPool"
                    },
                    "description": "A range of IPs to issue to virtual machines that don't\nhave a static IP; see IP Pools below for details.\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedMetadataEntry:NetworkIsolatedMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "The netmask for the new network. Defaults to `255.255.255.0`\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "shared": {
                    "type": "boolean",
                    "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedStaticIpPool:NetworkIsolatedStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkIsolated resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the network\n"
                    },
                    "dhcpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkIsolatedDhcpPool:NetworkIsolatedDhcpPool"
                        },
                        "description": "A range of IPs to issue to virtual machines that don't\nhave a static IP; see IP Pools below for details.\n"
                    },
                    "dns1": {
                        "type": "string",
                        "description": "First DNS server to use.\n"
                    },
                    "dns2": {
                        "type": "string",
                        "description": "Second DNS server to use.\n"
                    },
                    "dnsSuffix": {
                        "type": "string",
                        "description": "A FQDN for the virtual machines on this network\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The gateway for this network\n",
                        "willReplaceOnChanges": true
                    },
                    "href": {
                        "type": "string",
                        "description": "Network Hyper Reference\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkIsolatedMetadataEntry:NetworkIsolatedMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n"
                    },
                    "netmask": {
                        "type": "string",
                        "description": "The netmask for the new network. Defaults to `255.255.255.0`\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "shared": {
                        "type": "boolean",
                        "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                    },
                    "staticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkIsolatedStaticIpPool:NetworkIsolatedStaticIpPool"
                        },
                        "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/networkIsolatedV2:NetworkIsolatedV2": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "dualStackEnabled": {
                    "type": "boolean",
                    "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                },
                "guestVlanAllowed": {
                    "type": "boolean",
                    "description": "Set to `true` if network should allow guest VLAN tagging.\nDefault `false`.\n"
                },
                "isShared": {
                    "type": "boolean",
                    "description": "**NSX-V only.** Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network. **Not supported** if the network belongs to a VDC Group.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedV2MetadataEntry:NetworkIsolatedV2MetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful \nwhen connected as sysadmin working across different organisations\n"
                },
                "ownerId": {
                    "type": "string",
                    "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                },
                "secondaryGateway": {
                    "type": "string",
                    "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n"
                },
                "secondaryPrefixLength": {
                    "type": "string",
                    "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n"
                },
                "secondaryStaticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedV2SecondaryStaticIpPool:NetworkIsolatedV2SecondaryStaticIpPool"
                    },
                    "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedV2StaticIpPool:NetworkIsolatedV2StaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                    "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                }
            },
            "required": [
                "gateway",
                "isShared",
                "metadata",
                "metadataEntries",
                "name",
                "ownerId",
                "prefixLength",
                "vdc"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "dualStackEnabled": {
                    "type": "boolean",
                    "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                },
                "guestVlanAllowed": {
                    "type": "boolean",
                    "description": "Set to `true` if network should allow guest VLAN tagging.\nDefault `false`.\n"
                },
                "isShared": {
                    "type": "boolean",
                    "description": "**NSX-V only.** Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network. **Not supported** if the network belongs to a VDC Group.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedV2MetadataEntry:NetworkIsolatedV2MetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful \nwhen connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "ownerId": {
                    "type": "string",
                    "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                },
                "secondaryGateway": {
                    "type": "string",
                    "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n",
                    "willReplaceOnChanges": true
                },
                "secondaryPrefixLength": {
                    "type": "string",
                    "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n",
                    "willReplaceOnChanges": true
                },
                "secondaryStaticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedV2SecondaryStaticIpPool:NetworkIsolatedV2SecondaryStaticIpPool"
                    },
                    "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkIsolatedV2StaticIpPool:NetworkIsolatedV2StaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                    "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                }
            },
            "requiredInputs": [
                "gateway",
                "prefixLength"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkIsolatedV2 resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the network\n"
                    },
                    "dns1": {
                        "type": "string",
                        "description": "First DNS server to use.\n"
                    },
                    "dns2": {
                        "type": "string",
                        "description": "Second DNS server to use.\n"
                    },
                    "dnsSuffix": {
                        "type": "string",
                        "description": "A FQDN for the virtual machines on this network\n"
                    },
                    "dualStackEnabled": {
                        "type": "boolean",
                        "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                    },
                    "guestVlanAllowed": {
                        "type": "boolean",
                        "description": "Set to `true` if network should allow guest VLAN tagging.\nDefault `false`.\n"
                    },
                    "isShared": {
                        "type": "boolean",
                        "description": "**NSX-V only.** Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network. **Not supported** if the network belongs to a VDC Group.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkIsolatedV2MetadataEntry:NetworkIsolatedV2MetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful \nwhen connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                    },
                    "prefixLength": {
                        "type": "integer",
                        "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                    },
                    "secondaryGateway": {
                        "type": "string",
                        "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n",
                        "willReplaceOnChanges": true
                    },
                    "secondaryPrefixLength": {
                        "type": "string",
                        "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n",
                        "willReplaceOnChanges": true
                    },
                    "secondaryStaticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkIsolatedV2SecondaryStaticIpPool:NetworkIsolatedV2SecondaryStaticIpPool"
                        },
                        "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                    },
                    "staticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkIsolatedV2StaticIpPool:NetworkIsolatedV2StaticIpPool"
                        },
                        "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/networkPool:NetworkPool": {
            "properties": {
                "backing": {
                    "$ref": "#/types/vcd:index/NetworkPoolBacking:NetworkPoolBacking",
                    "description": "The components used by the network pool. See Backing below for details\n"
                },
                "backingSelectionConstraint": {
                    "type": "string",
                    "description": "Define how the backing components are considered. It should be one of the following:\n* `use-explicit-name` (Default) The backing components must be named explicitly;\n* `use-when-only-one` The automatically selected backing component will be used if there is only one available;\n* `use-first-available` Use the first available backing component.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the network pool\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique name of network pool\n"
                },
                "networkProviderId": {
                    "type": "string",
                    "description": "Id of the network provider (either vCenter or NSX-T manager)\n"
                },
                "networkProviderName": {
                    "type": "string",
                    "description": "Name of the network provider\n"
                },
                "networkProviderType": {
                    "type": "string",
                    "description": "Type of network provider\n"
                },
                "promiscuousMode": {
                    "type": "boolean",
                    "description": "Whether the network pool is in promiscuous mode\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the network pool\n"
                },
                "totalBackingsCount": {
                    "type": "integer",
                    "description": "Total number of backings\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)\n"
                },
                "usedBackingsCount": {
                    "type": "integer",
                    "description": "Number of used backings\n"
                }
            },
            "required": [
                "backing",
                "name",
                "networkProviderId",
                "networkProviderName",
                "networkProviderType",
                "promiscuousMode",
                "status",
                "totalBackingsCount",
                "type",
                "usedBackingsCount"
            ],
            "inputProperties": {
                "backing": {
                    "$ref": "#/types/vcd:index/NetworkPoolBacking:NetworkPoolBacking",
                    "description": "The components used by the network pool. See Backing below for details\n"
                },
                "backingSelectionConstraint": {
                    "type": "string",
                    "description": "Define how the backing components are considered. It should be one of the following:\n* `use-explicit-name` (Default) The backing components must be named explicitly;\n* `use-when-only-one` The automatically selected backing component will be used if there is only one available;\n* `use-first-available` Use the first available backing component.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the network pool\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique name of network pool\n"
                },
                "networkProviderId": {
                    "type": "string",
                    "description": "Id of the network provider (either vCenter or NSX-T manager)\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "networkProviderId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPool resources.\n",
                "properties": {
                    "backing": {
                        "$ref": "#/types/vcd:index/NetworkPoolBacking:NetworkPoolBacking",
                        "description": "The components used by the network pool. See Backing below for details\n"
                    },
                    "backingSelectionConstraint": {
                        "type": "string",
                        "description": "Define how the backing components are considered. It should be one of the following:\n* `use-explicit-name` (Default) The backing components must be named explicitly;\n* `use-when-only-one` The automatically selected backing component will be used if there is only one available;\n* `use-first-available` Use the first available backing component.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the network pool\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Unique name of network pool\n"
                    },
                    "networkProviderId": {
                        "type": "string",
                        "description": "Id of the network provider (either vCenter or NSX-T manager)\n",
                        "willReplaceOnChanges": true
                    },
                    "networkProviderName": {
                        "type": "string",
                        "description": "Name of the network provider\n"
                    },
                    "networkProviderType": {
                        "type": "string",
                        "description": "Type of network provider\n"
                    },
                    "promiscuousMode": {
                        "type": "boolean",
                        "description": "Whether the network pool is in promiscuous mode\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the network pool\n"
                    },
                    "totalBackingsCount": {
                        "type": "integer",
                        "description": "Total number of backings\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)\n",
                        "willReplaceOnChanges": true
                    },
                    "usedBackingsCount": {
                        "type": "integer",
                        "description": "Number of used backings\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/networkRouted:NetworkRouted": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dhcpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedDhcpPool:NetworkRoutedDhcpPool"
                    },
                    "description": "A range of IPs to issue to virtual machines that don't\nhave a static IP; see IP Pools below for details.\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network\n"
                },
                "href": {
                    "type": "string",
                    "description": "Network Hypertext Reference\n"
                },
                "interfaceType": {
                    "type": "string",
                    "description": "An interface for the network. One of `internal` (default), `subinterface`, \n`distributed` (requires the edge gateway to support distributed networks)\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedMetadataEntry:NetworkRoutedMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "The netmask for the new network. Defaults to `255.255.255.0`\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n"
                },
                "shared": {
                    "type": "boolean",
                    "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedStaticIpPool:NetworkRoutedStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "edgeGateway",
                "href",
                "metadata",
                "metadataEntries",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dhcpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedDhcpPool:NetworkRoutedDhcpPool"
                    },
                    "description": "A range of IPs to issue to virtual machines that don't\nhave a static IP; see IP Pools below for details.\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway\n",
                    "willReplaceOnChanges": true
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network\n",
                    "willReplaceOnChanges": true
                },
                "interfaceType": {
                    "type": "string",
                    "description": "An interface for the network. One of `internal` (default), `subinterface`, \n`distributed` (requires the edge gateway to support distributed networks)\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedMetadataEntry:NetworkRoutedMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "The netmask for the new network. Defaults to `255.255.255.0`\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "shared": {
                    "type": "boolean",
                    "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedStaticIpPool:NetworkRoutedStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkRouted resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the network\n"
                    },
                    "dhcpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkRoutedDhcpPool:NetworkRoutedDhcpPool"
                        },
                        "description": "A range of IPs to issue to virtual machines that don't\nhave a static IP; see IP Pools below for details.\n"
                    },
                    "dns1": {
                        "type": "string",
                        "description": "First DNS server to use.\n"
                    },
                    "dns2": {
                        "type": "string",
                        "description": "Second DNS server to use.\n"
                    },
                    "dnsSuffix": {
                        "type": "string",
                        "description": "A FQDN for the virtual machines on this network\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway\n",
                        "willReplaceOnChanges": true
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The gateway for this network\n",
                        "willReplaceOnChanges": true
                    },
                    "href": {
                        "type": "string",
                        "description": "Network Hypertext Reference\n"
                    },
                    "interfaceType": {
                        "type": "string",
                        "description": "An interface for the network. One of `internal` (default), `subinterface`, \n`distributed` (requires the edge gateway to support distributed networks)\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkRoutedMetadataEntry:NetworkRoutedMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n"
                    },
                    "netmask": {
                        "type": "string",
                        "description": "The netmask for the new network. Defaults to `255.255.255.0`\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "shared": {
                        "type": "boolean",
                        "description": "Defines if this network is shared between multiple VDCs\nin the Org.  Defaults to `false`.\n"
                    },
                    "staticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkRoutedStaticIpPool:NetworkRoutedStaticIpPool"
                        },
                        "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/networkRoutedV2:NetworkRoutedV2": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "dualStackEnabled": {
                    "type": "boolean",
                    "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-V or NSX-T)\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                },
                "guestVlanAllowed": {
                    "type": "boolean",
                    "description": "Set to `true` if network should allow guest VLAN tagging.\nDefault `false`.\n"
                },
                "interfaceType": {
                    "type": "string",
                    "description": "An interface for the network. One of `internal` (default),\n`subinterface`, `distributed`, `non_distributed` (requires the Edge Gateway to support distributed\nnetworks). NSX-T supports only `internal` and `non_distributed` (*v3.14+*, requires Edge Gateway\nto have [non-distributed routing\nenabled](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_edgegateway#non_distributed_routing_enabled)).\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network. **Not supported** if the owner edge gateway belongs to a VDC Group.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedV2MetadataEntry:NetworkRoutedV2MetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n"
                },
                "ownerId": {
                    "type": "string",
                    "description": "ID of VDC or VDC Group\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                },
                "routeAdvertisementEnabled": {
                    "type": "boolean",
                    "description": "Enables route advertising for\nthis network. **Note** This requires Edge Gateway to use IP Spaces and IP Space *must have* route\nadvertisement\nenabled.\n"
                },
                "secondaryGateway": {
                    "type": "string",
                    "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n"
                },
                "secondaryPrefixLength": {
                    "type": "string",
                    "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n"
                },
                "secondaryStaticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedV2SecondaryStaticIpPool:NetworkRoutedV2SecondaryStaticIpPool"
                    },
                    "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedV2StaticIpPool:NetworkRoutedV2StaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use. *v3.6+* inherits parent VDC or VDC Group\nfrom `edge_gateway_id`)\n",
                    "deprecationMessage": "'vdc' is deprecated and ineffective. Routed networks will inherit VDC setting from parent Edge Gateway"
                }
            },
            "required": [
                "edgeGatewayId",
                "gateway",
                "metadata",
                "metadataEntries",
                "name",
                "ownerId",
                "prefixLength",
                "vdc"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "dualStackEnabled": {
                    "type": "boolean",
                    "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-V or NSX-T)\n",
                    "willReplaceOnChanges": true
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                },
                "guestVlanAllowed": {
                    "type": "boolean",
                    "description": "Set to `true` if network should allow guest VLAN tagging.\nDefault `false`.\n"
                },
                "interfaceType": {
                    "type": "string",
                    "description": "An interface for the network. One of `internal` (default),\n`subinterface`, `distributed`, `non_distributed` (requires the Edge Gateway to support distributed\nnetworks). NSX-T supports only `internal` and `non_distributed` (*v3.14+*, requires Edge Gateway\nto have [non-distributed routing\nenabled](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_edgegateway#non_distributed_routing_enabled)).\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network. **Not supported** if the owner edge gateway belongs to a VDC Group.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedV2MetadataEntry:NetworkRoutedV2MetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                },
                "routeAdvertisementEnabled": {
                    "type": "boolean",
                    "description": "Enables route advertising for\nthis network. **Note** This requires Edge Gateway to use IP Spaces and IP Space *must have* route\nadvertisement\nenabled.\n"
                },
                "secondaryGateway": {
                    "type": "string",
                    "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n",
                    "willReplaceOnChanges": true
                },
                "secondaryPrefixLength": {
                    "type": "string",
                    "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n",
                    "willReplaceOnChanges": true
                },
                "secondaryStaticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedV2SecondaryStaticIpPool:NetworkRoutedV2SecondaryStaticIpPool"
                    },
                    "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NetworkRoutedV2StaticIpPool:NetworkRoutedV2StaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use. *v3.6+* inherits parent VDC or VDC Group\nfrom `edge_gateway_id`)\n",
                    "deprecationMessage": "'vdc' is deprecated and ineffective. Routed networks will inherit VDC setting from parent Edge Gateway"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "gateway",
                "prefixLength"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkRoutedV2 resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the network\n"
                    },
                    "dns1": {
                        "type": "string",
                        "description": "First DNS server to use.\n"
                    },
                    "dns2": {
                        "type": "string",
                        "description": "Second DNS server to use.\n"
                    },
                    "dnsSuffix": {
                        "type": "string",
                        "description": "A FQDN for the virtual machines on this network\n"
                    },
                    "dualStackEnabled": {
                        "type": "boolean",
                        "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-V or NSX-T)\n",
                        "willReplaceOnChanges": true
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                    },
                    "guestVlanAllowed": {
                        "type": "boolean",
                        "description": "Set to `true` if network should allow guest VLAN tagging.\nDefault `false`.\n"
                    },
                    "interfaceType": {
                        "type": "string",
                        "description": "An interface for the network. One of `internal` (default),\n`subinterface`, `distributed`, `non_distributed` (requires the Edge Gateway to support distributed\nnetworks). NSX-T supports only `internal` and `non_distributed` (*v3.14+*, requires Edge Gateway\nto have [non-distributed routing\nenabled](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_edgegateway#non_distributed_routing_enabled)).\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this network. **Not supported** if the owner edge gateway belongs to a VDC Group.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkRoutedV2MetadataEntry:NetworkRoutedV2MetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "ID of VDC or VDC Group\n"
                    },
                    "prefixLength": {
                        "type": "integer",
                        "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                    },
                    "routeAdvertisementEnabled": {
                        "type": "boolean",
                        "description": "Enables route advertising for\nthis network. **Note** This requires Edge Gateway to use IP Spaces and IP Space *must have* route\nadvertisement\nenabled.\n"
                    },
                    "secondaryGateway": {
                        "type": "string",
                        "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n",
                        "willReplaceOnChanges": true
                    },
                    "secondaryPrefixLength": {
                        "type": "string",
                        "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n",
                        "willReplaceOnChanges": true
                    },
                    "secondaryStaticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkRoutedV2SecondaryStaticIpPool:NetworkRoutedV2SecondaryStaticIpPool"
                        },
                        "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                    },
                    "staticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NetworkRoutedV2StaticIpPool:NetworkRoutedV2StaticIpPool"
                        },
                        "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use. *v3.6+* inherits parent VDC or VDC Group\nfrom `edge_gateway_id`)\n",
                        "deprecationMessage": "'vdc' is deprecated and ineffective. Routed networks will inherit VDC setting from parent Edge Gateway"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbCloud:NsxtAlbCloud": {
            "properties": {
                "controllerId": {
                    "type": "string",
                    "description": "ALB Controller ID\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Cloud\n"
                },
                "healthMessage": {
                    "type": "string",
                    "description": "DetailedHealthMessage contains detailed message on the health of the Cloud\n"
                },
                "healthStatus": {
                    "type": "string",
                    "description": "HealthStatus contains status of the Load Balancer Cloud. Possible values are:\n* UP - The cloud is healthy and ready to enable Load Balancer for an Edge Gateway\n* DOWN - The cloud is in a failure state. Enabling Load balancer on an Edge Gateway may not be possible\n* RUNNING - The cloud is currently processing. An example is if it's enabling a Load Balancer for an Edge Gateway\n* UNAVAILABLE - The cloud is unavailable\n* UNKNOWN - The cloud state is unknown\n"
                },
                "importableCloudId": {
                    "type": "string",
                    "description": "Importable Cloud ID. Can be looked up using `vcd.getNsxtAlbImportableCloud` data\nsource\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Cloud\n"
                },
                "networkPoolId": {
                    "type": "string",
                    "description": "Network pool ID for ALB Cloud. Can be looked up using `vcd.getNsxtAlbImportableCloud` data\nsource\n"
                },
                "networkPoolName": {
                    "type": "string",
                    "description": "Network Pool Name used by the Cloud\n"
                }
            },
            "required": [
                "controllerId",
                "healthMessage",
                "healthStatus",
                "importableCloudId",
                "name",
                "networkPoolId",
                "networkPoolName"
            ],
            "inputProperties": {
                "controllerId": {
                    "type": "string",
                    "description": "ALB Controller ID\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Cloud\n",
                    "willReplaceOnChanges": true
                },
                "importableCloudId": {
                    "type": "string",
                    "description": "Importable Cloud ID. Can be looked up using `vcd.getNsxtAlbImportableCloud` data\nsource\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Cloud\n",
                    "willReplaceOnChanges": true
                },
                "networkPoolId": {
                    "type": "string",
                    "description": "Network pool ID for ALB Cloud. Can be looked up using `vcd.getNsxtAlbImportableCloud` data\nsource\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "controllerId",
                "importableCloudId",
                "networkPoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbCloud resources.\n",
                "properties": {
                    "controllerId": {
                        "type": "string",
                        "description": "ALB Controller ID\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description ALB Cloud\n",
                        "willReplaceOnChanges": true
                    },
                    "healthMessage": {
                        "type": "string",
                        "description": "DetailedHealthMessage contains detailed message on the health of the Cloud\n"
                    },
                    "healthStatus": {
                        "type": "string",
                        "description": "HealthStatus contains status of the Load Balancer Cloud. Possible values are:\n* UP - The cloud is healthy and ready to enable Load Balancer for an Edge Gateway\n* DOWN - The cloud is in a failure state. Enabling Load balancer on an Edge Gateway may not be possible\n* RUNNING - The cloud is currently processing. An example is if it's enabling a Load Balancer for an Edge Gateway\n* UNAVAILABLE - The cloud is unavailable\n* UNKNOWN - The cloud state is unknown\n"
                    },
                    "importableCloudId": {
                        "type": "string",
                        "description": "Importable Cloud ID. Can be looked up using `vcd.getNsxtAlbImportableCloud` data\nsource\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for ALB Cloud\n",
                        "willReplaceOnChanges": true
                    },
                    "networkPoolId": {
                        "type": "string",
                        "description": "Network pool ID for ALB Cloud. Can be looked up using `vcd.getNsxtAlbImportableCloud` data\nsource\n",
                        "willReplaceOnChanges": true
                    },
                    "networkPoolName": {
                        "type": "string",
                        "description": "Network Pool Name used by the Cloud\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbController:NsxtAlbController": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Controller\n"
                },
                "licenseType": {
                    "type": "string",
                    "description": "License type of ALB Controller (`ENTERPRISE` or `BASIC`)\n\n\u003e The attribute `license_type` must not be used in VCD 10.4+, it is replaced by [nsxt_alb_service_engine_group](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_service_engine_group) and [nsxt_alb_settings](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_settings) attribute `supported_feature_set`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Controller\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password for ALB Controller. Password will not be refreshed.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The URL of ALB Controller\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username for ALB Controller\n"
                },
                "version": {
                    "type": "string",
                    "description": "ALB Controller version (e.g. 20.1.3)\n"
                }
            },
            "required": [
                "name",
                "password",
                "url",
                "username",
                "version"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Controller\n"
                },
                "licenseType": {
                    "type": "string",
                    "description": "License type of ALB Controller (`ENTERPRISE` or `BASIC`)\n\n\u003e The attribute `license_type` must not be used in VCD 10.4+, it is replaced by [nsxt_alb_service_engine_group](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_service_engine_group) and [nsxt_alb_settings](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_settings) attribute `supported_feature_set`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Controller\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password for ALB Controller. Password will not be refreshed.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The URL of ALB Controller\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username for ALB Controller\n"
                }
            },
            "requiredInputs": [
                "password",
                "url",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbController resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description ALB Controller\n"
                    },
                    "licenseType": {
                        "type": "string",
                        "description": "License type of ALB Controller (`ENTERPRISE` or `BASIC`)\n\n\u003e The attribute `license_type` must not be used in VCD 10.4+, it is replaced by [nsxt_alb_service_engine_group](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_service_engine_group) and [nsxt_alb_settings](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_settings) attribute `supported_feature_set`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for ALB Controller\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The password for ALB Controller. Password will not be refreshed.\n",
                        "secret": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of ALB Controller\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username for ALB Controller\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "ALB Controller version (e.g. 20.1.3)\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbEdgegatewayServiceEngineGroup:NsxtAlbEdgegatewayServiceEngineGroup": {
            "properties": {
                "deployedVirtualServices": {
                    "type": "integer",
                    "description": "Number of deployed Virtual Services on this Service Engine Group.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source.\n"
                },
                "maxVirtualServices": {
                    "type": "integer",
                    "description": "Maximum amount of Virtual Services to run on this Service Engine Group. **Only for\nShared Service Engine Groups**.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n"
                },
                "reservedVirtualServices": {
                    "type": "string",
                    "description": "Number of reserved Virtual Services for this Edge Gateway. **Only for Shared\nService Engine Groups.**\n"
                },
                "serviceEngineGroupId": {
                    "type": "string",
                    "description": "An ID of NSX-T Service Engine Group. Can be looked up using\n[vcd.NsxtAlbServiceEngineGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_alb_service_engine_group) data\nsource.\n"
                },
                "serviceEngineGroupName": {
                    "type": "string",
                    "description": "Service Engine Group Name which is attached to NSX-T Edge Gateway\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "required": [
                "deployedVirtualServices",
                "edgeGatewayId",
                "maxVirtualServices",
                "reservedVirtualServices",
                "serviceEngineGroupId",
                "serviceEngineGroupName",
                "vdc"
            ],
            "inputProperties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source.\n",
                    "willReplaceOnChanges": true
                },
                "maxVirtualServices": {
                    "type": "integer",
                    "description": "Maximum amount of Virtual Services to run on this Service Engine Group. **Only for\nShared Service Engine Groups**.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "reservedVirtualServices": {
                    "type": "string",
                    "description": "Number of reserved Virtual Services for this Edge Gateway. **Only for Shared\nService Engine Groups.**\n"
                },
                "serviceEngineGroupId": {
                    "type": "string",
                    "description": "An ID of NSX-T Service Engine Group. Can be looked up using\n[vcd.NsxtAlbServiceEngineGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_alb_service_engine_group) data\nsource.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "serviceEngineGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbEdgegatewayServiceEngineGroup resources.\n",
                "properties": {
                    "deployedVirtualServices": {
                        "type": "integer",
                        "description": "Number of deployed Virtual Services on this Service Engine Group.\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxVirtualServices": {
                        "type": "integer",
                        "description": "Maximum amount of Virtual Services to run on this Service Engine Group. **Only for\nShared Service Engine Groups**.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "reservedVirtualServices": {
                        "type": "string",
                        "description": "Number of reserved Virtual Services for this Edge Gateway. **Only for Shared\nService Engine Groups.**\n"
                    },
                    "serviceEngineGroupId": {
                        "type": "string",
                        "description": "An ID of NSX-T Service Engine Group. Can be looked up using\n[vcd.NsxtAlbServiceEngineGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_alb_service_engine_group) data\nsource.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceEngineGroupName": {
                        "type": "string",
                        "description": "Service Engine Group Name which is attached to NSX-T Edge Gateway\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbPool:NsxtAlbPool": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Optional algorithm for choosing pool members (default `LEAST_CONNECTIONS`). Other options\ncontain `ROUND_ROBIN`, `CONSISTENT_HASH` (uses Source IP Address hash), `FASTEST_RESPONSE`, `LEAST_LOAD`,\n`FEWEST_SERVERS`, `RANDOM`, `FEWEST_TASKS`, `CORE_AFFINITY`\n"
                },
                "associatedVirtualServiceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of associated Virtual Service IDs\n"
                },
                "associatedVirtualServices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of associated Virtual Service names\n"
                },
                "caCertificateIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of CA Certificates to be used when validating certificates presented by the\npool members. Can be looked up using\n[vcd.LibraryCertificate](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/library_certificate) data source\n"
                },
                "cnCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether to check the common name of the certificate presented by the pool\nmember\n"
                },
                "defaultPort": {
                    "type": "integer",
                    "description": "Default Port defines destination server port used by the traffic sent to the member\n(default `80`)\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Pool\n"
                },
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of domain names which will be used to verify the common names or subject alternative\nnames presented by the pool member certificates. It is performed only when common name check `cn_check_enabled` is\nenabled\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Boolean value if ALB Pool should be enabled (default `true`)\n"
                },
                "enabledMemberCount": {
                    "type": "integer",
                    "description": "Number of enabled members defined in the Pool\n"
                },
                "gracefulTimeoutPeriod": {
                    "type": "integer",
                    "description": "Maximum time in minutes to gracefully disable pool member (default `1`). Special\nvalues are `0` (immediate) and `-1` (infinite)\n"
                },
                "healthMessage": {
                    "type": "string",
                    "description": "Health message of ALB Pool\n"
                },
                "healthMonitors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbPoolHealthMonitor:NsxtAlbPoolHealthMonitor"
                    },
                    "description": "A block to define health monitor. Multiple can be used. See Health\nmonitor and example for usage details.\n\n\u003ca id=\"member-block\"\u003e\u003c/a\u003e\n"
                },
                "memberCount": {
                    "type": "integer",
                    "description": "Total number of members defined in the Pool\n"
                },
                "memberGroupId": {
                    "type": "string",
                    "description": "A reference to NSX-T IP Set (`vcd.NsxtIpSet`).\n**Note** only one of `member`, `member_group_id` can be specified.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbPoolMember:NsxtAlbPoolMember"
                    },
                    "description": "A block to define pool members. Multiple can be used. See\nMember and example for usage details. **Note** only one of `member`,\n`member_group_id` can be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Pool\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "passiveMonitoringEnabled": {
                    "type": "boolean",
                    "description": "defines if client traffic should be used to check if pool member is up or down\n(default `true`)\n"
                },
                "persistenceProfile": {
                    "$ref": "#/types/vcd:index/NsxtAlbPoolPersistenceProfile:NsxtAlbPoolPersistenceProfile",
                    "description": "Persistence profile will ensure that the same user sticks to the same server for a\ndesired duration of time. If the persistence profile is unmanaged by Cloud Director, updates that leave the values\nunchanged will continue to use the same unmanaged profile. Any changes made to the persistence profile will cause\nCloud Director to switch the pool to a profile managed by Cloud Director. See Persistence\nprofile and example for usage details.\n"
                },
                "sslEnabled": {
                    "type": "boolean",
                    "description": "Enables SSL - Will be turned on automatically when CA certificates are used\n"
                },
                "upMemberCount": {
                    "type": "integer",
                    "description": "Number of members defined in the Pool that are accepting traffic\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "required": [
                "associatedVirtualServiceIds",
                "associatedVirtualServices",
                "edgeGatewayId",
                "enabledMemberCount",
                "healthMessage",
                "memberCount",
                "name",
                "sslEnabled",
                "upMemberCount",
                "vdc"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Optional algorithm for choosing pool members (default `LEAST_CONNECTIONS`). Other options\ncontain `ROUND_ROBIN`, `CONSISTENT_HASH` (uses Source IP Address hash), `FASTEST_RESPONSE`, `LEAST_LOAD`,\n`FEWEST_SERVERS`, `RANDOM`, `FEWEST_TASKS`, `CORE_AFFINITY`\n"
                },
                "caCertificateIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of CA Certificates to be used when validating certificates presented by the\npool members. Can be looked up using\n[vcd.LibraryCertificate](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/library_certificate) data source\n"
                },
                "cnCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether to check the common name of the certificate presented by the pool\nmember\n"
                },
                "defaultPort": {
                    "type": "integer",
                    "description": "Default Port defines destination server port used by the traffic sent to the member\n(default `80`)\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Pool\n"
                },
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of domain names which will be used to verify the common names or subject alternative\nnames presented by the pool member certificates. It is performed only when common name check `cn_check_enabled` is\nenabled\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Boolean value if ALB Pool should be enabled (default `true`)\n"
                },
                "gracefulTimeoutPeriod": {
                    "type": "integer",
                    "description": "Maximum time in minutes to gracefully disable pool member (default `1`). Special\nvalues are `0` (immediate) and `-1` (infinite)\n"
                },
                "healthMonitors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbPoolHealthMonitor:NsxtAlbPoolHealthMonitor"
                    },
                    "description": "A block to define health monitor. Multiple can be used. See Health\nmonitor and example for usage details.\n\n\u003ca id=\"member-block\"\u003e\u003c/a\u003e\n"
                },
                "memberGroupId": {
                    "type": "string",
                    "description": "A reference to NSX-T IP Set (`vcd.NsxtIpSet`).\n**Note** only one of `member`, `member_group_id` can be specified.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbPoolMember:NsxtAlbPoolMember"
                    },
                    "description": "A block to define pool members. Multiple can be used. See\nMember and example for usage details. **Note** only one of `member`,\n`member_group_id` can be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Pool\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "passiveMonitoringEnabled": {
                    "type": "boolean",
                    "description": "defines if client traffic should be used to check if pool member is up or down\n(default `true`)\n"
                },
                "persistenceProfile": {
                    "$ref": "#/types/vcd:index/NsxtAlbPoolPersistenceProfile:NsxtAlbPoolPersistenceProfile",
                    "description": "Persistence profile will ensure that the same user sticks to the same server for a\ndesired duration of time. If the persistence profile is unmanaged by Cloud Director, updates that leave the values\nunchanged will continue to use the same unmanaged profile. Any changes made to the persistence profile will cause\nCloud Director to switch the pool to a profile managed by Cloud Director. See Persistence\nprofile and example for usage details.\n"
                },
                "sslEnabled": {
                    "type": "boolean",
                    "description": "Enables SSL - Will be turned on automatically when CA certificates are used\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "requiredInputs": [
                "edgeGatewayId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbPool resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Optional algorithm for choosing pool members (default `LEAST_CONNECTIONS`). Other options\ncontain `ROUND_ROBIN`, `CONSISTENT_HASH` (uses Source IP Address hash), `FASTEST_RESPONSE`, `LEAST_LOAD`,\n`FEWEST_SERVERS`, `RANDOM`, `FEWEST_TASKS`, `CORE_AFFINITY`\n"
                    },
                    "associatedVirtualServiceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of associated Virtual Service IDs\n"
                    },
                    "associatedVirtualServices": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of associated Virtual Service names\n"
                    },
                    "caCertificateIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of CA Certificates to be used when validating certificates presented by the\npool members. Can be looked up using\n[vcd.LibraryCertificate](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/library_certificate) data source\n"
                    },
                    "cnCheckEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether to check the common name of the certificate presented by the pool\nmember\n"
                    },
                    "defaultPort": {
                        "type": "integer",
                        "description": "Default Port defines destination server port used by the traffic sent to the member\n(default `80`)\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description ALB Pool\n"
                    },
                    "domainNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of domain names which will be used to verify the common names or subject alternative\nnames presented by the pool member certificates. It is performed only when common name check `cn_check_enabled` is\nenabled\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Boolean value if ALB Pool should be enabled (default `true`)\n"
                    },
                    "enabledMemberCount": {
                        "type": "integer",
                        "description": "Number of enabled members defined in the Pool\n"
                    },
                    "gracefulTimeoutPeriod": {
                        "type": "integer",
                        "description": "Maximum time in minutes to gracefully disable pool member (default `1`). Special\nvalues are `0` (immediate) and `-1` (infinite)\n"
                    },
                    "healthMessage": {
                        "type": "string",
                        "description": "Health message of ALB Pool\n"
                    },
                    "healthMonitors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtAlbPoolHealthMonitor:NsxtAlbPoolHealthMonitor"
                        },
                        "description": "A block to define health monitor. Multiple can be used. See Health\nmonitor and example for usage details.\n\n\u003ca id=\"member-block\"\u003e\u003c/a\u003e\n"
                    },
                    "memberCount": {
                        "type": "integer",
                        "description": "Total number of members defined in the Pool\n"
                    },
                    "memberGroupId": {
                        "type": "string",
                        "description": "A reference to NSX-T IP Set (`vcd.NsxtIpSet`).\n**Note** only one of `member`, `member_group_id` can be specified.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtAlbPoolMember:NsxtAlbPoolMember"
                        },
                        "description": "A block to define pool members. Multiple can be used. See\nMember and example for usage details. **Note** only one of `member`,\n`member_group_id` can be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for ALB Pool\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "passiveMonitoringEnabled": {
                        "type": "boolean",
                        "description": "defines if client traffic should be used to check if pool member is up or down\n(default `true`)\n"
                    },
                    "persistenceProfile": {
                        "$ref": "#/types/vcd:index/NsxtAlbPoolPersistenceProfile:NsxtAlbPoolPersistenceProfile",
                        "description": "Persistence profile will ensure that the same user sticks to the same server for a\ndesired duration of time. If the persistence profile is unmanaged by Cloud Director, updates that leave the values\nunchanged will continue to use the same unmanaged profile. Any changes made to the persistence profile will cause\nCloud Director to switch the pool to a profile managed by Cloud Director. See Persistence\nprofile and example for usage details.\n"
                    },
                    "sslEnabled": {
                        "type": "boolean",
                        "description": "Enables SSL - Will be turned on automatically when CA certificates are used\n"
                    },
                    "upMemberCount": {
                        "type": "integer",
                        "description": "Number of members defined in the Pool that are accepting traffic\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbServiceEngineGroup:NsxtAlbServiceEngineGroup": {
            "properties": {
                "albCloudId": {
                    "type": "string",
                    "description": "A reference ALB Cloud. Can be looked up using `vcd.NsxtAlbCloud` resource or data\nsource\n"
                },
                "deployedVirtualServices": {
                    "type": "integer",
                    "description": "Number of deployed virtual services\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Service Engine Group\n"
                },
                "haMode": {
                    "type": "string",
                    "description": "defines High Availability Mode for Service Engine Group. One off:\n* ELASTIC_N_PLUS_M_BUFFER - Service Engines will scale out to N active nodes with M nodes as buffer.\n* ELASTIC_ACTIVE_ACTIVE - Active-Active with scale out.\n* LEGACY_ACTIVE_STANDBY - Traditional single Active-Standby configuration\n"
                },
                "importableServiceEngineGroupName": {
                    "type": "string",
                    "description": "Name of available Service Engine Group in ALB\n"
                },
                "maxVirtualServices": {
                    "type": "integer",
                    "description": "Maximum number of virtual services this ALB Service Engine Group can run\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Service Engine Group\n"
                },
                "overallocated": {
                    "type": "boolean",
                    "description": "Boolean value stating if there are more deployed virtual services than allocated ones\n"
                },
                "reservationModel": {
                    "type": "string",
                    "description": "Definition if the Service Engine Group is `DEDICATED` or `SHARED`\n"
                },
                "reservedVirtualServices": {
                    "type": "integer",
                    "description": "Number of reserved virtual services\n"
                },
                "supportedFeatureSet": {
                    "type": "string",
                    "description": "Feature set of this ALB Service Engine Group (`STANDARD` or `PREMIUM`)\n\n\u003e The attribute `supported_feature_set` must not be used in VCD versions lower than 10.4. Starting with 10.4, it replaces `license_type` field in [nsxt_alb_controller](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_controller).\n"
                },
                "syncOnRefresh": {
                    "type": "boolean",
                    "description": "Boolean value that shows if sync should be performed on every refresh\n"
                }
            },
            "required": [
                "albCloudId",
                "deployedVirtualServices",
                "haMode",
                "importableServiceEngineGroupName",
                "maxVirtualServices",
                "name",
                "reservationModel",
                "reservedVirtualServices",
                "supportedFeatureSet"
            ],
            "inputProperties": {
                "albCloudId": {
                    "type": "string",
                    "description": "A reference ALB Cloud. Can be looked up using `vcd.NsxtAlbCloud` resource or data\nsource\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Service Engine Group\n"
                },
                "importableServiceEngineGroupName": {
                    "type": "string",
                    "description": "Name of available Service Engine Group in ALB\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Service Engine Group\n"
                },
                "overallocated": {
                    "type": "boolean",
                    "description": "Boolean value stating if there are more deployed virtual services than allocated ones\n"
                },
                "reservationModel": {
                    "type": "string",
                    "description": "Definition if the Service Engine Group is `DEDICATED` or `SHARED`\n"
                },
                "supportedFeatureSet": {
                    "type": "string",
                    "description": "Feature set of this ALB Service Engine Group (`STANDARD` or `PREMIUM`)\n\n\u003e The attribute `supported_feature_set` must not be used in VCD versions lower than 10.4. Starting with 10.4, it replaces `license_type` field in [nsxt_alb_controller](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_controller).\n"
                },
                "syncOnRefresh": {
                    "type": "boolean",
                    "description": "Boolean value that shows if sync should be performed on every refresh\n"
                }
            },
            "requiredInputs": [
                "albCloudId",
                "importableServiceEngineGroupName",
                "reservationModel"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbServiceEngineGroup resources.\n",
                "properties": {
                    "albCloudId": {
                        "type": "string",
                        "description": "A reference ALB Cloud. Can be looked up using `vcd.NsxtAlbCloud` resource or data\nsource\n",
                        "willReplaceOnChanges": true
                    },
                    "deployedVirtualServices": {
                        "type": "integer",
                        "description": "Number of deployed virtual services\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description ALB Service Engine Group\n"
                    },
                    "haMode": {
                        "type": "string",
                        "description": "defines High Availability Mode for Service Engine Group. One off:\n* ELASTIC_N_PLUS_M_BUFFER - Service Engines will scale out to N active nodes with M nodes as buffer.\n* ELASTIC_ACTIVE_ACTIVE - Active-Active with scale out.\n* LEGACY_ACTIVE_STANDBY - Traditional single Active-Standby configuration\n"
                    },
                    "importableServiceEngineGroupName": {
                        "type": "string",
                        "description": "Name of available Service Engine Group in ALB\n",
                        "willReplaceOnChanges": true
                    },
                    "maxVirtualServices": {
                        "type": "integer",
                        "description": "Maximum number of virtual services this ALB Service Engine Group can run\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for ALB Service Engine Group\n"
                    },
                    "overallocated": {
                        "type": "boolean",
                        "description": "Boolean value stating if there are more deployed virtual services than allocated ones\n"
                    },
                    "reservationModel": {
                        "type": "string",
                        "description": "Definition if the Service Engine Group is `DEDICATED` or `SHARED`\n"
                    },
                    "reservedVirtualServices": {
                        "type": "integer",
                        "description": "Number of reserved virtual services\n"
                    },
                    "supportedFeatureSet": {
                        "type": "string",
                        "description": "Feature set of this ALB Service Engine Group (`STANDARD` or `PREMIUM`)\n\n\u003e The attribute `supported_feature_set` must not be used in VCD versions lower than 10.4. Starting with 10.4, it replaces `license_type` field in [nsxt_alb_controller](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_controller).\n"
                    },
                    "syncOnRefresh": {
                        "type": "boolean",
                        "description": "Boolean value that shows if sync should be performed on every refresh\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbSettings:NsxtAlbSettings": {
            "properties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n"
                },
                "ipv6ServiceNetworkSpecification": {
                    "type": "string",
                    "description": "The IPv6 network\ndefinition in CIDR format which will be used by Load Balancer service in the Edge Gateway. All the\nload balancer service engines associated with the Service Engine Group will be attached to this\nnetwork. This field cannot be updated\n\n\u003e IPv4 service network will be used if both the `service_network_specification` and\n`ipv6_service_network_specification` properties are unset. If both are set, it will still be one\nservice network with a dual IPv4 and IPv6 stack. If only `ipv6_service_network_specification` is\nused, then only IPv6 will be used.\n\n\u003e The attribute `supported_feature_set` must not be used in VCD versions lower than 10.4. Starting with 10.4, it replaces `license_type` field in [nsxt_alb_controller](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_controller).\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Boolean value `true` or `false` if ALB is enabled. **Note** Delete operation of this resource\nwill set it to `false`\n"
                },
                "isTransparentModeEnabled": {
                    "type": "boolean",
                    "description": "When enabled, it allows to\nconfigure Preserve Client IP on a Virtual Service\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n"
                },
                "serviceNetworkSpecification": {
                    "type": "string",
                    "description": "Gateway CIDR format which will be used by Load\nBalancer service. All the load balancer service engines associated with the Service Engine Group\nwill be attached to this network. The subnet prefix length must be 25. If nothing is set and\n`ipv6_service_network_specification` is not used, the **default is 192.168.255.125/25**. This\nfield cannot be updated\n"
                },
                "supportedFeatureSet": {
                    "type": "string",
                    "description": "Feature set of this Edge Gateway if ALB is enabled (`STANDARD` or `PREMIUM`)\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "required": [
                "edgeGatewayId",
                "ipv6ServiceNetworkSpecification",
                "isActive",
                "isTransparentModeEnabled",
                "serviceNetworkSpecification",
                "supportedFeatureSet",
                "vdc"
            ],
            "inputProperties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                    "willReplaceOnChanges": true
                },
                "ipv6ServiceNetworkSpecification": {
                    "type": "string",
                    "description": "The IPv6 network\ndefinition in CIDR format which will be used by Load Balancer service in the Edge Gateway. All the\nload balancer service engines associated with the Service Engine Group will be attached to this\nnetwork. This field cannot be updated\n\n\u003e IPv4 service network will be used if both the `service_network_specification` and\n`ipv6_service_network_specification` properties are unset. If both are set, it will still be one\nservice network with a dual IPv4 and IPv6 stack. If only `ipv6_service_network_specification` is\nused, then only IPv6 will be used.\n\n\u003e The attribute `supported_feature_set` must not be used in VCD versions lower than 10.4. Starting with 10.4, it replaces `license_type` field in [nsxt_alb_controller](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_controller).\n",
                    "willReplaceOnChanges": true
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Boolean value `true` or `false` if ALB is enabled. **Note** Delete operation of this resource\nwill set it to `false`\n"
                },
                "isTransparentModeEnabled": {
                    "type": "boolean",
                    "description": "When enabled, it allows to\nconfigure Preserve Client IP on a Virtual Service\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "serviceNetworkSpecification": {
                    "type": "string",
                    "description": "Gateway CIDR format which will be used by Load\nBalancer service. All the load balancer service engines associated with the Service Engine Group\nwill be attached to this network. The subnet prefix length must be 25. If nothing is set and\n`ipv6_service_network_specification` is not used, the **default is 192.168.255.125/25**. This\nfield cannot be updated\n",
                    "willReplaceOnChanges": true
                },
                "supportedFeatureSet": {
                    "type": "string",
                    "description": "Feature set of this Edge Gateway if ALB is enabled (`STANDARD` or `PREMIUM`)\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "isActive"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbSettings resources.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "ipv6ServiceNetworkSpecification": {
                        "type": "string",
                        "description": "The IPv6 network\ndefinition in CIDR format which will be used by Load Balancer service in the Edge Gateway. All the\nload balancer service engines associated with the Service Engine Group will be attached to this\nnetwork. This field cannot be updated\n\n\u003e IPv4 service network will be used if both the `service_network_specification` and\n`ipv6_service_network_specification` properties are unset. If both are set, it will still be one\nservice network with a dual IPv4 and IPv6 stack. If only `ipv6_service_network_specification` is\nused, then only IPv6 will be used.\n\n\u003e The attribute `supported_feature_set` must not be used in VCD versions lower than 10.4. Starting with 10.4, it replaces `license_type` field in [nsxt_alb_controller](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_controller).\n",
                        "willReplaceOnChanges": true
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Boolean value `true` or `false` if ALB is enabled. **Note** Delete operation of this resource\nwill set it to `false`\n"
                    },
                    "isTransparentModeEnabled": {
                        "type": "boolean",
                        "description": "When enabled, it allows to\nconfigure Preserve Client IP on a Virtual Service\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceNetworkSpecification": {
                        "type": "string",
                        "description": "Gateway CIDR format which will be used by Load\nBalancer service. All the load balancer service engines associated with the Service Engine Group\nwill be attached to this network. The subnet prefix length must be 25. If nothing is set and\n`ipv6_service_network_specification` is not used, the **default is 192.168.255.125/25**. This\nfield cannot be updated\n",
                        "willReplaceOnChanges": true
                    },
                    "supportedFeatureSet": {
                        "type": "string",
                        "description": "Feature set of this Edge Gateway if ALB is enabled (`STANDARD` or `PREMIUM`)\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbVirtualService:NsxtAlbVirtualService": {
            "properties": {
                "applicationProfileType": {
                    "type": "string",
                    "description": "One of `HTTP`, `HTTPS`, `L4`, `L4_TLS`.\n"
                },
                "caCertificateId": {
                    "type": "string",
                    "description": "ID reference of CA certificate. Required when `application_profile_type` is `HTTPS`\nor `L4_TLS`\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Virtual Service\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Virtual Service is enabled or disabled (default true)\n"
                },
                "ipv6VirtualIpAddress": {
                    "type": "string",
                    "description": "IPv6 Address for the service to listen on.\n"
                },
                "isTransparentModeEnabled": {
                    "type": "boolean",
                    "description": "Preserves Client IP on a\nVirtual Service. **Note** - the following criteria must be matched to make transparent mode work:\n* ALB Pool membership must be configured in Group mode\n* Backing Avi Service Engine Group must be in Legacy Active Standby mode\n\n\u003ca id=\"service-port-block\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Virtual Service\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "poolId": {
                    "type": "string",
                    "description": "A reference to ALB Pool. Can be looked up using `vcd.NsxtAlbPool` resource or data\nsource\n"
                },
                "serviceEngineGroupId": {
                    "type": "string",
                    "description": "A reference to ALB Service Engine Group. Can be looked up using\n`vcd.NsxtAlbEdgegatewayServiceEngineGroup` resource or data source\n"
                },
                "servicePorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceServicePort:NsxtAlbVirtualServiceServicePort"
                    },
                    "description": "A block to define port, port range and traffic type. Multiple can be used. See\nservice_port and example for usage details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                },
                "virtualIpAddress": {
                    "type": "string",
                    "description": "IP Address for the service to listen on.\n"
                }
            },
            "required": [
                "applicationProfileType",
                "edgeGatewayId",
                "isTransparentModeEnabled",
                "name",
                "poolId",
                "serviceEngineGroupId",
                "vdc",
                "virtualIpAddress"
            ],
            "inputProperties": {
                "applicationProfileType": {
                    "type": "string",
                    "description": "One of `HTTP`, `HTTPS`, `L4`, `L4_TLS`.\n"
                },
                "caCertificateId": {
                    "type": "string",
                    "description": "ID reference of CA certificate. Required when `application_profile_type` is `HTTPS`\nor `L4_TLS`\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description ALB Virtual Service\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Virtual Service is enabled or disabled (default true)\n"
                },
                "ipv6VirtualIpAddress": {
                    "type": "string",
                    "description": "IPv6 Address for the service to listen on.\n"
                },
                "isTransparentModeEnabled": {
                    "type": "boolean",
                    "description": "Preserves Client IP on a\nVirtual Service. **Note** - the following criteria must be matched to make transparent mode work:\n* ALB Pool membership must be configured in Group mode\n* Backing Avi Service Engine Group must be in Legacy Active Standby mode\n\n\u003ca id=\"service-port-block\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for ALB Virtual Service\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "poolId": {
                    "type": "string",
                    "description": "A reference to ALB Pool. Can be looked up using `vcd.NsxtAlbPool` resource or data\nsource\n",
                    "willReplaceOnChanges": true
                },
                "serviceEngineGroupId": {
                    "type": "string",
                    "description": "A reference to ALB Service Engine Group. Can be looked up using\n`vcd.NsxtAlbEdgegatewayServiceEngineGroup` resource or data source\n",
                    "willReplaceOnChanges": true
                },
                "servicePorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceServicePort:NsxtAlbVirtualServiceServicePort"
                    },
                    "description": "A block to define port, port range and traffic type. Multiple can be used. See\nservice_port and example for usage details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                },
                "virtualIpAddress": {
                    "type": "string",
                    "description": "IP Address for the service to listen on.\n"
                }
            },
            "requiredInputs": [
                "applicationProfileType",
                "edgeGatewayId",
                "poolId",
                "serviceEngineGroupId",
                "virtualIpAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbVirtualService resources.\n",
                "properties": {
                    "applicationProfileType": {
                        "type": "string",
                        "description": "One of `HTTP`, `HTTPS`, `L4`, `L4_TLS`.\n"
                    },
                    "caCertificateId": {
                        "type": "string",
                        "description": "ID reference of CA certificate. Required when `application_profile_type` is `HTTPS`\nor `L4_TLS`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description ALB Virtual Service\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Virtual Service is enabled or disabled (default true)\n"
                    },
                    "ipv6VirtualIpAddress": {
                        "type": "string",
                        "description": "IPv6 Address for the service to listen on.\n"
                    },
                    "isTransparentModeEnabled": {
                        "type": "boolean",
                        "description": "Preserves Client IP on a\nVirtual Service. **Note** - the following criteria must be matched to make transparent mode work:\n* ALB Pool membership must be configured in Group mode\n* Backing Avi Service Engine Group must be in Legacy Active Standby mode\n\n\u003ca id=\"service-port-block\"\u003e\u003c/a\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for ALB Virtual Service\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "poolId": {
                        "type": "string",
                        "description": "A reference to ALB Pool. Can be looked up using `vcd.NsxtAlbPool` resource or data\nsource\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceEngineGroupId": {
                        "type": "string",
                        "description": "A reference to ALB Service Engine Group. Can be looked up using\n`vcd.NsxtAlbEdgegatewayServiceEngineGroup` resource or data source\n",
                        "willReplaceOnChanges": true
                    },
                    "servicePorts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceServicePort:NsxtAlbVirtualServiceServicePort"
                        },
                        "description": "A block to define port, port range and traffic type. Multiple can be used. See\nservice_port and example for usage details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    },
                    "virtualIpAddress": {
                        "type": "string",
                        "description": "IP Address for the service to listen on.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbVirtualServiceHttpReqRules:NsxtAlbVirtualServiceHttpReqRules": {
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRule:NsxtAlbVirtualServiceHttpReqRulesRule"
                    },
                    "description": "One or more rule blocks with matching criteria and actions.\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                },
                "virtualServiceId": {
                    "type": "string",
                    "description": "An ID of existing ALB Virtual Service.\n"
                }
            },
            "required": [
                "rules",
                "virtualServiceId"
            ],
            "inputProperties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRule:NsxtAlbVirtualServiceHttpReqRulesRule"
                    },
                    "description": "One or more rule blocks with matching criteria and actions.\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                },
                "virtualServiceId": {
                    "type": "string",
                    "description": "An ID of existing ALB Virtual Service.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "rules",
                "virtualServiceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbVirtualServiceHttpReqRules resources.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpReqRulesRule:NsxtAlbVirtualServiceHttpReqRulesRule"
                        },
                        "description": "One or more rule blocks with matching criteria and actions.\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                    },
                    "virtualServiceId": {
                        "type": "string",
                        "description": "An ID of existing ALB Virtual Service.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbVirtualServiceHttpRespRules:NsxtAlbVirtualServiceHttpRespRules": {
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRule:NsxtAlbVirtualServiceHttpRespRulesRule"
                    },
                    "description": "One or more rule blocks with matching criteria and actions.\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                },
                "virtualServiceId": {
                    "type": "string",
                    "description": "An ID of existing ALB Virtual Service.\n"
                }
            },
            "required": [
                "rules",
                "virtualServiceId"
            ],
            "inputProperties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRule:NsxtAlbVirtualServiceHttpRespRulesRule"
                    },
                    "description": "One or more rule blocks with matching criteria and actions.\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                },
                "virtualServiceId": {
                    "type": "string",
                    "description": "An ID of existing ALB Virtual Service.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "rules",
                "virtualServiceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbVirtualServiceHttpRespRules resources.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpRespRulesRule:NsxtAlbVirtualServiceHttpRespRulesRule"
                        },
                        "description": "One or more rule blocks with matching criteria and actions.\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                    },
                    "virtualServiceId": {
                        "type": "string",
                        "description": "An ID of existing ALB Virtual Service.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAlbVirtualServiceHttpSecRules:NsxtAlbVirtualServiceHttpSecRules": {
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRule:NsxtAlbVirtualServiceHttpSecRulesRule"
                    },
                    "description": "One or more rule blocks with matching criteria and actions.\n\n\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                },
                "virtualServiceId": {
                    "type": "string",
                    "description": "An ID of existing ALB Virtual Service.\n"
                }
            },
            "required": [
                "rules",
                "virtualServiceId"
            ],
            "inputProperties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRule:NsxtAlbVirtualServiceHttpSecRulesRule"
                    },
                    "description": "One or more rule blocks with matching criteria and actions.\n\n\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                },
                "virtualServiceId": {
                    "type": "string",
                    "description": "An ID of existing ALB Virtual Service.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "rules",
                "virtualServiceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAlbVirtualServiceHttpSecRules resources.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtAlbVirtualServiceHttpSecRulesRule:NsxtAlbVirtualServiceHttpSecRulesRule"
                        },
                        "description": "One or more rule blocks with matching criteria and actions.\n\n\n\n\u003ca id=\"rule-block\"\u003e\u003c/a\u003e\n"
                    },
                    "virtualServiceId": {
                        "type": "string",
                        "description": "An ID of existing ALB Virtual Service.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtAppPortProfile:NsxtAppPortProfile": {
            "properties": {
                "appPorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAppPortProfileAppPort:NsxtAppPortProfileAppPort"
                    },
                    "description": "At least one block of Application Port definition\n\n\n\u003ca id=\"app-port\"\u003e\u003c/a\u003e\n"
                },
                "contextId": {
                    "type": "string",
                    "description": "ID of NSX-T Manager, VDC or VDC Group. Replaces deprecated fields `vdc`\nand `nsxt_manager_id`. It accepts VDC, VDC Group or NSX-T Manager ID.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Application Port Profile description\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for Security Group\n"
                },
                "nsxtManagerId": {
                    "type": "string",
                    "description": "Required only when `scope` is `PROVIDER`. Deprecated\nand replaced by `context_id`\n",
                    "deprecationMessage": "Deprecated in favor of 'context_id'"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Application Port Profile scope - `PROVIDER`, `TENANT`\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\nDeprecated and replaced by `context_id`\n",
                    "deprecationMessage": "Deprecated in favor of 'context_id'"
                }
            },
            "required": [
                "appPorts",
                "contextId",
                "name",
                "nsxtManagerId",
                "scope",
                "vdc"
            ],
            "inputProperties": {
                "appPorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtAppPortProfileAppPort:NsxtAppPortProfileAppPort"
                    },
                    "description": "At least one block of Application Port definition\n\n\n\u003ca id=\"app-port\"\u003e\u003c/a\u003e\n"
                },
                "contextId": {
                    "type": "string",
                    "description": "ID of NSX-T Manager, VDC or VDC Group. Replaces deprecated fields `vdc`\nand `nsxt_manager_id`. It accepts VDC, VDC Group or NSX-T Manager ID.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Application Port Profile description\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for Security Group\n"
                },
                "nsxtManagerId": {
                    "type": "string",
                    "description": "Required only when `scope` is `PROVIDER`. Deprecated\nand replaced by `context_id`\n",
                    "deprecationMessage": "Deprecated in favor of 'context_id'"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "scope": {
                    "type": "string",
                    "description": "Application Port Profile scope - `PROVIDER`, `TENANT`\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\nDeprecated and replaced by `context_id`\n",
                    "deprecationMessage": "Deprecated in favor of 'context_id'"
                }
            },
            "requiredInputs": [
                "appPorts",
                "scope"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtAppPortProfile resources.\n",
                "properties": {
                    "appPorts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtAppPortProfileAppPort:NsxtAppPortProfileAppPort"
                        },
                        "description": "At least one block of Application Port definition\n\n\n\u003ca id=\"app-port\"\u003e\u003c/a\u003e\n"
                    },
                    "contextId": {
                        "type": "string",
                        "description": "ID of NSX-T Manager, VDC or VDC Group. Replaces deprecated fields `vdc`\nand `nsxt_manager_id`. It accepts VDC, VDC Group or NSX-T Manager ID.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Application Port Profile description\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for Security Group\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "Required only when `scope` is `PROVIDER`. Deprecated\nand replaced by `context_id`\n",
                        "deprecationMessage": "Deprecated in favor of 'context_id'"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "scope": {
                        "type": "string",
                        "description": "Application Port Profile scope - `PROVIDER`, `TENANT`\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\nDeprecated and replaced by `context_id`\n",
                        "deprecationMessage": "Deprecated in favor of 'context_id'"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtDistributedFirewall:NsxtDistributedFirewall": {
            "properties": {
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtDistributedFirewallRule:NsxtDistributedFirewallRule"
                    },
                    "description": "One or more blocks with Firewall Rule definitions. **Order**\ndefines firewall rule precedence\n\n\u003ca id=\"firewall-rule\"\u003e\u003c/a\u003e\n"
                },
                "vdcGroupId": {
                    "type": "string",
                    "description": "The ID of VDC Group to manage Distributed Firewall in. Can be looked\nup using `vcd.VdcGroup` resource or data source.\n"
                }
            },
            "required": [
                "rules",
                "vdcGroupId"
            ],
            "inputProperties": {
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtDistributedFirewallRule:NsxtDistributedFirewallRule"
                    },
                    "description": "One or more blocks with Firewall Rule definitions. **Order**\ndefines firewall rule precedence\n\n\u003ca id=\"firewall-rule\"\u003e\u003c/a\u003e\n"
                },
                "vdcGroupId": {
                    "type": "string",
                    "description": "The ID of VDC Group to manage Distributed Firewall in. Can be looked\nup using `vcd.VdcGroup` resource or data source.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "rules",
                "vdcGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtDistributedFirewall resources.\n",
                "properties": {
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtDistributedFirewallRule:NsxtDistributedFirewallRule"
                        },
                        "description": "One or more blocks with Firewall Rule definitions. **Order**\ndefines firewall rule precedence\n\n\u003ca id=\"firewall-rule\"\u003e\u003c/a\u003e\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "The ID of VDC Group to manage Distributed Firewall in. Can be looked\nup using `vcd.VdcGroup` resource or data source.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtDistributedFirewallRule:NsxtDistributedFirewallRule": {
            "properties": {
                "aboveRuleId": {
                    "type": "string",
                    "description": "ID of an existing `vcd.NsxtDistributedFirewallRule` entry, above\nwhich the newly created firewall rule will be positioned. **Note.** By default, new rule will be\ncreated at the bottom of the list\n\n\u003e When activating Distributed Firewall with resource\n[`vcd.VdcGroup`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vdc_group), there is a default firewall\nrule created which can make inconvenient to use this resource. For that reason, resource\n[`vcd.VdcGroup`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vdc_group) has a parameter\n`remove_default_firewall_rule` which can remove default firewall rule.\n"
                },
                "action": {
                    "type": "string",
                    "description": "Defines if it should `ALLOW`, `DROP`, `REJECT` traffic. `REJECT` is only\nsupported in VCD 10.2.2+\n"
                },
                "appPortProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An optional set of Application Port Profiles.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment field shown in UI\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of firewall rule (not shown in UI)\n"
                },
                "destinationGroupsExcluded": {
                    "type": "boolean",
                    "description": "reverses value of `destination_ids` for\nthe rule to match everything except specified IDs.\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of source object Firewall Groups (`IP Sets` or `Security\ngroups`). Leaving it empty matches `Any` (all)\n"
                },
                "direction": {
                    "type": "string",
                    "description": "One of `IN`, `OUT`, or `IN_OUT`. (default `IN_OUT`)\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabled (default `true`)\n"
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "One of `IPV4`,  `IPV6`, or `IPV4_IPV6` (default `IPV4_IPV6`)\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines if logging for this rule is enabled (default `false`)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Explanatory name for firewall rule (uniqueness not enforced)\n"
                },
                "networkContextProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An optional set of Network Context Profiles. Can be\nlooked up using `vcd.getNsxtNetworkContextProfile` data source.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "sourceGroupsExcluded": {
                    "type": "boolean",
                    "description": "reverses value of `source_ids` for the rule to\nmatch everything except specified IDs.\n"
                },
                "sourceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of source object Firewall Groups (`IP Sets` or `Security groups`).\nLeaving it empty matches `Any` (all)\n"
                },
                "vdcGroupId": {
                    "type": "string",
                    "description": "The ID of VDC Group to manage Distributed Firewall in. Can be looked\nup using `vcd.VdcGroup` resource or data source.\n"
                }
            },
            "required": [
                "action",
                "name",
                "vdcGroupId"
            ],
            "inputProperties": {
                "aboveRuleId": {
                    "type": "string",
                    "description": "ID of an existing `vcd.NsxtDistributedFirewallRule` entry, above\nwhich the newly created firewall rule will be positioned. **Note.** By default, new rule will be\ncreated at the bottom of the list\n\n\u003e When activating Distributed Firewall with resource\n[`vcd.VdcGroup`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vdc_group), there is a default firewall\nrule created which can make inconvenient to use this resource. For that reason, resource\n[`vcd.VdcGroup`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vdc_group) has a parameter\n`remove_default_firewall_rule` which can remove default firewall rule.\n",
                    "willReplaceOnChanges": true
                },
                "action": {
                    "type": "string",
                    "description": "Defines if it should `ALLOW`, `DROP`, `REJECT` traffic. `REJECT` is only\nsupported in VCD 10.2.2+\n"
                },
                "appPortProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An optional set of Application Port Profiles.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment field shown in UI\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of firewall rule (not shown in UI)\n"
                },
                "destinationGroupsExcluded": {
                    "type": "boolean",
                    "description": "reverses value of `destination_ids` for\nthe rule to match everything except specified IDs.\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of source object Firewall Groups (`IP Sets` or `Security\ngroups`). Leaving it empty matches `Any` (all)\n"
                },
                "direction": {
                    "type": "string",
                    "description": "One of `IN`, `OUT`, or `IN_OUT`. (default `IN_OUT`)\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabled (default `true`)\n"
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "One of `IPV4`,  `IPV6`, or `IPV4_IPV6` (default `IPV4_IPV6`)\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Defines if logging for this rule is enabled (default `false`)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Explanatory name for firewall rule (uniqueness not enforced)\n"
                },
                "networkContextProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An optional set of Network Context Profiles. Can be\nlooked up using `vcd.getNsxtNetworkContextProfile` data source.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "sourceGroupsExcluded": {
                    "type": "boolean",
                    "description": "reverses value of `source_ids` for the rule to\nmatch everything except specified IDs.\n"
                },
                "sourceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of source object Firewall Groups (`IP Sets` or `Security groups`).\nLeaving it empty matches `Any` (all)\n"
                },
                "vdcGroupId": {
                    "type": "string",
                    "description": "The ID of VDC Group to manage Distributed Firewall in. Can be looked\nup using `vcd.VdcGroup` resource or data source.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "action",
                "vdcGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtDistributedFirewallRule resources.\n",
                "properties": {
                    "aboveRuleId": {
                        "type": "string",
                        "description": "ID of an existing `vcd.NsxtDistributedFirewallRule` entry, above\nwhich the newly created firewall rule will be positioned. **Note.** By default, new rule will be\ncreated at the bottom of the list\n\n\u003e When activating Distributed Firewall with resource\n[`vcd.VdcGroup`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vdc_group), there is a default firewall\nrule created which can make inconvenient to use this resource. For that reason, resource\n[`vcd.VdcGroup`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vdc_group) has a parameter\n`remove_default_firewall_rule` which can remove default firewall rule.\n",
                        "willReplaceOnChanges": true
                    },
                    "action": {
                        "type": "string",
                        "description": "Defines if it should `ALLOW`, `DROP`, `REJECT` traffic. `REJECT` is only\nsupported in VCD 10.2.2+\n"
                    },
                    "appPortProfileIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An optional set of Application Port Profiles.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Comment field shown in UI\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of firewall rule (not shown in UI)\n"
                    },
                    "destinationGroupsExcluded": {
                        "type": "boolean",
                        "description": "reverses value of `destination_ids` for\nthe rule to match everything except specified IDs.\n"
                    },
                    "destinationIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of source object Firewall Groups (`IP Sets` or `Security\ngroups`). Leaving it empty matches `Any` (all)\n"
                    },
                    "direction": {
                        "type": "string",
                        "description": "One of `IN`, `OUT`, or `IN_OUT`. (default `IN_OUT`)\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Defines if the rule is enabled (default `true`)\n"
                    },
                    "ipProtocol": {
                        "type": "string",
                        "description": "One of `IPV4`,  `IPV6`, or `IPV4_IPV6` (default `IPV4_IPV6`)\n"
                    },
                    "logging": {
                        "type": "boolean",
                        "description": "Defines if logging for this rule is enabled (default `false`)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Explanatory name for firewall rule (uniqueness not enforced)\n"
                    },
                    "networkContextProfileIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An optional set of Network Context Profiles. Can be\nlooked up using `vcd.getNsxtNetworkContextProfile` data source.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceGroupsExcluded": {
                        "type": "boolean",
                        "description": "reverses value of `source_ids` for the rule to\nmatch everything except specified IDs.\n"
                    },
                    "sourceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of source object Firewall Groups (`IP Sets` or `Security groups`).\nLeaving it empty matches `Any` (all)\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "The ID of VDC Group to manage Distributed Firewall in. Can be looked\nup using `vcd.VdcGroup` resource or data source.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtDynamicSecurityGroup:NsxtDynamicSecurityGroup": {
            "properties": {
                "criterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtDynamicSecurityGroupCriteria:NsxtDynamicSecurityGroupCriteria"
                    },
                    "description": "Up to 3 criteria for matching VMs. List of criteria is matched with boolean\n`OR` operation and matching any of defined criteria will include objects. Each `criteria` can\ncontains up to 4 `rule` definitions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the Dynamic Security Group\n"
                },
                "memberVms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtDynamicSecurityGroupMemberVm:NsxtDynamicSecurityGroupMemberVm"
                    },
                    "description": "A set of member VMs (if exist). see Member VMs below for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for Dynamic Security Group\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "vdcGroupId": {
                    "type": "string",
                    "description": "VDC Group ID for Dynamic Security Group creation.\n"
                }
            },
            "required": [
                "memberVms",
                "name",
                "vdcGroupId"
            ],
            "inputProperties": {
                "criterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtDynamicSecurityGroupCriteria:NsxtDynamicSecurityGroupCriteria"
                    },
                    "description": "Up to 3 criteria for matching VMs. List of criteria is matched with boolean\n`OR` operation and matching any of defined criteria will include objects. Each `criteria` can\ncontains up to 4 `rule` definitions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the Dynamic Security Group\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for Dynamic Security Group\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "vdcGroupId": {
                    "type": "string",
                    "description": "VDC Group ID for Dynamic Security Group creation.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "vdcGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtDynamicSecurityGroup resources.\n",
                "properties": {
                    "criterias": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtDynamicSecurityGroupCriteria:NsxtDynamicSecurityGroupCriteria"
                        },
                        "description": "Up to 3 criteria for matching VMs. List of criteria is matched with boolean\n`OR` operation and matching any of defined criteria will include objects. Each `criteria` can\ncontains up to 4 `rule` definitions.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the Dynamic Security Group\n"
                    },
                    "memberVms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtDynamicSecurityGroupMemberVm:NsxtDynamicSecurityGroupMemberVm"
                        },
                        "description": "A set of member VMs (if exist). see Member VMs below for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for Dynamic Security Group\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "VDC Group ID for Dynamic Security Group creation.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegateway:NsxtEdgegateway": {
            "properties": {
                "dedicateExternalNetwork": {
                    "type": "boolean",
                    "description": "Dedicating the external network will enable Route Advertisement for this Edge Gateway. Default `false`.\n"
                },
                "deploymentMode": {
                    "type": "string",
                    "description": "`ACTIVE_STANDBY` (default) or\n`DISTRIBUTED_ONLY` (VCD 10.6+). Distributed-only does not provide services that run on service\nrouter such as firewalling, NAT, VPN, DNS forwarding or static routes, instead, the distributed\nnature guarantees high north-south data throughput.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A unique name for the edge gateway.\n"
                },
                "edgeClusterId": {
                    "type": "string",
                    "description": "Specific Edge Cluster ID if required\n"
                },
                "externalNetworkAllocatedIpCount": {
                    "type": "integer",
                    "description": "Total allocated IP count in attached NSX-T Segment backed\nexternal networks\n"
                },
                "externalNetworkId": {
                    "type": "string",
                    "description": "An external network ID. **Note:** Data source [vcd.ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)\ncan be used to lookup ID by name.\n"
                },
                "externalNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayExternalNetwork:NsxtEdgegatewayExternalNetwork"
                    },
                    "description": "attaches NSX-T Segment backed External\nNetworks with a given configuration block. It *does not\nsupport IP Spaces*.\n"
                },
                "ipCountReadLimit": {
                    "type": "integer",
                    "description": "Sets a limit of IPs to count for\n`used_ip_count` and `unused_ip_count` attributes to avoid exhausting compute resource while\ncounting IPs in large IPv6 subnets. It does not affect operation of Edge Gateway configuration,\nonly IP count reporting. Defaults to `1000000`, update is a no-op, but will affect newly read\ndata. While it is unlikely that a single Edge Gateway can effectively manage more IPs, one can\nspecify `0` for *unlimited* value.\n\n\u003ca id=\"ip-allocation-modes\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the edge gateway.\n"
                },
                "nonDistributedRoutingEnabled": {
                    "type": "boolean",
                    "description": "Non-Distributed routing will allow\ntenants the option of connecting Org Vdc networks to the Service\nRouter. This would\nforce all VM traffic through the service router for that network. Default `false`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n"
                },
                "ownerId": {
                    "type": "string",
                    "description": "The ID of VDC or VDC Group. **Note:** Data sources\n[vcd.VdcGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/vdc_group) or\n[vcd.OrgVdc](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org_vdc) can be used to lookup IDs by\nname.\n\n\u003e Only one of `vdc` or `owner_id` can be specified. `owner_id` takes precedence over `vdc`\ndefinition at provider level.\n\n\u003e When a VDC Group ID is specified in `owner_id` field, the Edge Gateway will be created in VDC\n(random member of VDC Group or specified in `starting_vdc_id`). Main use case of `starting_vdc_id`\nis to pick egress traffic origin for multi datacenter VDC Groups.\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "Primary IP address exposed for an easy access without nesting.\n"
                },
                "startingVdcId": {
                    "type": "string",
                    "description": "If `owner_id` is a VDC Group, by default Edge\nGateway will be created in random member VDC and moved to destination VDC Group. This field allows\nto specify initial VDC for Edge Gateway (this can define Egress location of traffic in the VDC\nGroup) **Note:** It can only be used when `owner_id` is a VDC Group.\n"
                },
                "subnetWithIpCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnetWithIpCount:NsxtEdgegatewaySubnetWithIpCount"
                    },
                    "description": "One or more\nsubnets defined for Edge Gateway. One of `subnet`,\n`subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent network is\nbacked by *IP Spaces*. Read more in IP allocation modes section.\n"
                },
                "subnetWithTotalIpCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnetWithTotalIpCount:NsxtEdgegatewaySubnetWithTotalIpCount"
                    },
                    "description": "One or more\nsubnets defined for Edge Gateway. One of `subnet`,\n`subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent network is\nbacked by *IP Spaces*. Read more in IP allocation modes section.\n"
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnet:NsxtEdgegatewaySubnet"
                    },
                    "description": "One or more subnets defined for Edge Gateway. One of\n`subnet`, `subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent\nnetwork is backed by *IP Spaces*. Read more in IP allocation modes section.\n"
                },
                "totalAllocatedIpCount": {
                    "type": "integer",
                    "description": "Required with `subnet_with_total_ip_count`. It is\n**read-only** attribute with other other allocation models `subnet` and `subnet_with_ip_count`.\n**Note**. It sets or reports IP count *only for NSX-T Tier 0 backed external network Uplink*.\n"
                },
                "unusedIpCount": {
                    "type": "integer",
                    "description": "Unused IP count in this Edge Gateway (for all uplinks). **Note**: it is not\nexposed when using IP Spaces.\n"
                },
                "useIpSpaces": {
                    "type": "boolean",
                    "description": "Boolean value that hints if the NSX-T Edge Gateway uses IP Spaces\n"
                },
                "usedIpCount": {
                    "type": "integer",
                    "description": "Used IP count in this Edge Gateway (for all uplinks). **Note**: it is not\nexposed when using IP Spaces.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "**Deprecated** in favor of `owner_id`. The name of VDC that owns the edge\ngateway. Can be inherited from `provider` configuration if not defined here.\n",
                    "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                }
            },
            "required": [
                "deploymentMode",
                "edgeClusterId",
                "externalNetworkAllocatedIpCount",
                "externalNetworkId",
                "name",
                "nonDistributedRoutingEnabled",
                "ownerId",
                "primaryIp",
                "subnets",
                "subnetWithIpCounts",
                "subnetWithTotalIpCounts",
                "totalAllocatedIpCount",
                "unusedIpCount",
                "useIpSpaces",
                "usedIpCount",
                "vdc"
            ],
            "inputProperties": {
                "dedicateExternalNetwork": {
                    "type": "boolean",
                    "description": "Dedicating the external network will enable Route Advertisement for this Edge Gateway. Default `false`.\n"
                },
                "deploymentMode": {
                    "type": "string",
                    "description": "`ACTIVE_STANDBY` (default) or\n`DISTRIBUTED_ONLY` (VCD 10.6+). Distributed-only does not provide services that run on service\nrouter such as firewalling, NAT, VPN, DNS forwarding or static routes, instead, the distributed\nnature guarantees high north-south data throughput.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A unique name for the edge gateway.\n"
                },
                "edgeClusterId": {
                    "type": "string",
                    "description": "Specific Edge Cluster ID if required\n"
                },
                "externalNetworkId": {
                    "type": "string",
                    "description": "An external network ID. **Note:** Data source [vcd.ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)\ncan be used to lookup ID by name.\n"
                },
                "externalNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayExternalNetwork:NsxtEdgegatewayExternalNetwork"
                    },
                    "description": "attaches NSX-T Segment backed External\nNetworks with a given configuration block. It *does not\nsupport IP Spaces*.\n"
                },
                "ipCountReadLimit": {
                    "type": "integer",
                    "description": "Sets a limit of IPs to count for\n`used_ip_count` and `unused_ip_count` attributes to avoid exhausting compute resource while\ncounting IPs in large IPv6 subnets. It does not affect operation of Edge Gateway configuration,\nonly IP count reporting. Defaults to `1000000`, update is a no-op, but will affect newly read\ndata. While it is unlikely that a single Edge Gateway can effectively manage more IPs, one can\nspecify `0` for *unlimited* value.\n\n\u003ca id=\"ip-allocation-modes\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the edge gateway.\n"
                },
                "nonDistributedRoutingEnabled": {
                    "type": "boolean",
                    "description": "Non-Distributed routing will allow\ntenants the option of connecting Org Vdc networks to the Service\nRouter. This would\nforce all VM traffic through the service router for that network. Default `false`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "ownerId": {
                    "type": "string",
                    "description": "The ID of VDC or VDC Group. **Note:** Data sources\n[vcd.VdcGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/vdc_group) or\n[vcd.OrgVdc](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org_vdc) can be used to lookup IDs by\nname.\n\n\u003e Only one of `vdc` or `owner_id` can be specified. `owner_id` takes precedence over `vdc`\ndefinition at provider level.\n\n\u003e When a VDC Group ID is specified in `owner_id` field, the Edge Gateway will be created in VDC\n(random member of VDC Group or specified in `starting_vdc_id`). Main use case of `starting_vdc_id`\nis to pick egress traffic origin for multi datacenter VDC Groups.\n"
                },
                "startingVdcId": {
                    "type": "string",
                    "description": "If `owner_id` is a VDC Group, by default Edge\nGateway will be created in random member VDC and moved to destination VDC Group. This field allows\nto specify initial VDC for Edge Gateway (this can define Egress location of traffic in the VDC\nGroup) **Note:** It can only be used when `owner_id` is a VDC Group.\n"
                },
                "subnetWithIpCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnetWithIpCount:NsxtEdgegatewaySubnetWithIpCount"
                    },
                    "description": "One or more\nsubnets defined for Edge Gateway. One of `subnet`,\n`subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent network is\nbacked by *IP Spaces*. Read more in IP allocation modes section.\n"
                },
                "subnetWithTotalIpCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnetWithTotalIpCount:NsxtEdgegatewaySubnetWithTotalIpCount"
                    },
                    "description": "One or more\nsubnets defined for Edge Gateway. One of `subnet`,\n`subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent network is\nbacked by *IP Spaces*. Read more in IP allocation modes section.\n"
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnet:NsxtEdgegatewaySubnet"
                    },
                    "description": "One or more subnets defined for Edge Gateway. One of\n`subnet`, `subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent\nnetwork is backed by *IP Spaces*. Read more in IP allocation modes section.\n"
                },
                "totalAllocatedIpCount": {
                    "type": "integer",
                    "description": "Required with `subnet_with_total_ip_count`. It is\n**read-only** attribute with other other allocation models `subnet` and `subnet_with_ip_count`.\n**Note**. It sets or reports IP count *only for NSX-T Tier 0 backed external network Uplink*.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "**Deprecated** in favor of `owner_id`. The name of VDC that owns the edge\ngateway. Can be inherited from `provider` configuration if not defined here.\n",
                    "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                }
            },
            "requiredInputs": [
                "externalNetworkId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegateway resources.\n",
                "properties": {
                    "dedicateExternalNetwork": {
                        "type": "boolean",
                        "description": "Dedicating the external network will enable Route Advertisement for this Edge Gateway. Default `false`.\n"
                    },
                    "deploymentMode": {
                        "type": "string",
                        "description": "`ACTIVE_STANDBY` (default) or\n`DISTRIBUTED_ONLY` (VCD 10.6+). Distributed-only does not provide services that run on service\nrouter such as firewalling, NAT, VPN, DNS forwarding or static routes, instead, the distributed\nnature guarantees high north-south data throughput.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A unique name for the edge gateway.\n"
                    },
                    "edgeClusterId": {
                        "type": "string",
                        "description": "Specific Edge Cluster ID if required\n"
                    },
                    "externalNetworkAllocatedIpCount": {
                        "type": "integer",
                        "description": "Total allocated IP count in attached NSX-T Segment backed\nexternal networks\n"
                    },
                    "externalNetworkId": {
                        "type": "string",
                        "description": "An external network ID. **Note:** Data source [vcd.ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)\ncan be used to lookup ID by name.\n"
                    },
                    "externalNetworks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewayExternalNetwork:NsxtEdgegatewayExternalNetwork"
                        },
                        "description": "attaches NSX-T Segment backed External\nNetworks with a given configuration block. It *does not\nsupport IP Spaces*.\n"
                    },
                    "ipCountReadLimit": {
                        "type": "integer",
                        "description": "Sets a limit of IPs to count for\n`used_ip_count` and `unused_ip_count` attributes to avoid exhausting compute resource while\ncounting IPs in large IPv6 subnets. It does not affect operation of Edge Gateway configuration,\nonly IP count reporting. Defaults to `1000000`, update is a no-op, but will affect newly read\ndata. While it is unlikely that a single Edge Gateway can effectively manage more IPs, one can\nspecify `0` for *unlimited* value.\n\n\u003ca id=\"ip-allocation-modes\"\u003e\u003c/a\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the edge gateway.\n"
                    },
                    "nonDistributedRoutingEnabled": {
                        "type": "boolean",
                        "description": "Non-Distributed routing will allow\ntenants the option of connecting Org Vdc networks to the Service\nRouter. This would\nforce all VM traffic through the service router for that network. Default `false`.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "The ID of VDC or VDC Group. **Note:** Data sources\n[vcd.VdcGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/vdc_group) or\n[vcd.OrgVdc](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org_vdc) can be used to lookup IDs by\nname.\n\n\u003e Only one of `vdc` or `owner_id` can be specified. `owner_id` takes precedence over `vdc`\ndefinition at provider level.\n\n\u003e When a VDC Group ID is specified in `owner_id` field, the Edge Gateway will be created in VDC\n(random member of VDC Group or specified in `starting_vdc_id`). Main use case of `starting_vdc_id`\nis to pick egress traffic origin for multi datacenter VDC Groups.\n"
                    },
                    "primaryIp": {
                        "type": "string",
                        "description": "Primary IP address exposed for an easy access without nesting.\n"
                    },
                    "startingVdcId": {
                        "type": "string",
                        "description": "If `owner_id` is a VDC Group, by default Edge\nGateway will be created in random member VDC and moved to destination VDC Group. This field allows\nto specify initial VDC for Edge Gateway (this can define Egress location of traffic in the VDC\nGroup) **Note:** It can only be used when `owner_id` is a VDC Group.\n"
                    },
                    "subnetWithIpCounts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnetWithIpCount:NsxtEdgegatewaySubnetWithIpCount"
                        },
                        "description": "One or more\nsubnets defined for Edge Gateway. One of `subnet`,\n`subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent network is\nbacked by *IP Spaces*. Read more in IP allocation modes section.\n"
                    },
                    "subnetWithTotalIpCounts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnetWithTotalIpCount:NsxtEdgegatewaySubnetWithTotalIpCount"
                        },
                        "description": "One or more\nsubnets defined for Edge Gateway. One of `subnet`,\n`subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent network is\nbacked by *IP Spaces*. Read more in IP allocation modes section.\n"
                    },
                    "subnets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewaySubnet:NsxtEdgegatewaySubnet"
                        },
                        "description": "One or more subnets defined for Edge Gateway. One of\n`subnet`, `subnet_with_total_ip_count` or `subnet_with_ip_count` is **required unless** parent\nnetwork is backed by *IP Spaces*. Read more in IP allocation modes section.\n"
                    },
                    "totalAllocatedIpCount": {
                        "type": "integer",
                        "description": "Required with `subnet_with_total_ip_count`. It is\n**read-only** attribute with other other allocation models `subnet` and `subnet_with_ip_count`.\n**Note**. It sets or reports IP count *only for NSX-T Tier 0 backed external network Uplink*.\n"
                    },
                    "unusedIpCount": {
                        "type": "integer",
                        "description": "Unused IP count in this Edge Gateway (for all uplinks). **Note**: it is not\nexposed when using IP Spaces.\n"
                    },
                    "useIpSpaces": {
                        "type": "boolean",
                        "description": "Boolean value that hints if the NSX-T Edge Gateway uses IP Spaces\n"
                    },
                    "usedIpCount": {
                        "type": "integer",
                        "description": "Used IP count in this Edge Gateway (for all uplinks). **Note**: it is not\nexposed when using IP Spaces.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "**Deprecated** in favor of `owner_id`. The name of VDC that owns the edge\ngateway. Can be inherited from `provider` configuration if not defined here.\n",
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayBgpConfiguration:NsxtEdgegatewayBgpConfiguration": {
            "properties": {
                "ecmpEnabled": {
                    "type": "boolean",
                    "description": "A flag indicating whether ECMP is enabled or not\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if BGP service is enabled or not\n"
                },
                "gracefulRestartMode": {
                    "type": "string",
                    "description": "Describes Graceful Restart configuration Modes for BGP\nconfiguration on an Edge Gateway. **Read only** for VRF backed Edge Gateways. Possible options are:\n* `DISABLE` - Both graceful restart and helper modes are disabled\n* `HELPER_ONLY` - The ability for a BGP speaker to indicate its ability to preserve forwarding\nstate during BGP restart\n* `GRACEFUL_AND_HELPER` - The ability of a BGP speaker to advertise its restart to its peers\n"
                },
                "gracefulRestartTimer": {
                    "type": "integer",
                    "description": "Maximum time taken (in seconds) for a BGP session to be\nestablished after a restart. If the session is not re-established within this timer, the receiving\nspeaker will delete all the stale routes from that peer. **Read only** for VRF backed Edge Gateways.\n"
                },
                "localAsNumber": {
                    "type": "string",
                    "description": "BGP autonomous systems (AS) number to advertise to BGP peers. BGP\nAS number can be specified in either ASPLAIN or ASDOT formats, like ASPLAIN format : '65546',\nASDOT format : '1.10'. **Read only** for VRF backed Edge Gateways\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n"
                },
                "staleRouteTimer": {
                    "type": "integer",
                    "description": "Maximum time (in seconds) before stale routes are removed when\nBGP restarts. **Read only** for VRF backed Edge Gateways\n\nMore information about settings can be found in VMware Cloud Director [BGP Configuration\ndocumentation](https://docs.vmware.com/en/VMware-Cloud-Director/10.3/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-EB585DDC-9F1C-4971-A4AD-44C239E6E822.html)\n"
                }
            },
            "required": [
                "edgeGatewayId",
                "enabled",
                "gracefulRestartMode",
                "gracefulRestartTimer",
                "localAsNumber",
                "staleRouteTimer"
            ],
            "inputProperties": {
                "ecmpEnabled": {
                    "type": "boolean",
                    "description": "A flag indicating whether ECMP is enabled or not\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if BGP service is enabled or not\n"
                },
                "gracefulRestartMode": {
                    "type": "string",
                    "description": "Describes Graceful Restart configuration Modes for BGP\nconfiguration on an Edge Gateway. **Read only** for VRF backed Edge Gateways. Possible options are:\n* `DISABLE` - Both graceful restart and helper modes are disabled\n* `HELPER_ONLY` - The ability for a BGP speaker to indicate its ability to preserve forwarding\nstate during BGP restart\n* `GRACEFUL_AND_HELPER` - The ability of a BGP speaker to advertise its restart to its peers\n"
                },
                "gracefulRestartTimer": {
                    "type": "integer",
                    "description": "Maximum time taken (in seconds) for a BGP session to be\nestablished after a restart. If the session is not re-established within this timer, the receiving\nspeaker will delete all the stale routes from that peer. **Read only** for VRF backed Edge Gateways.\n"
                },
                "localAsNumber": {
                    "type": "string",
                    "description": "BGP autonomous systems (AS) number to advertise to BGP peers. BGP\nAS number can be specified in either ASPLAIN or ASDOT formats, like ASPLAIN format : '65546',\nASDOT format : '1.10'. **Read only** for VRF backed Edge Gateways\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "staleRouteTimer": {
                    "type": "integer",
                    "description": "Maximum time (in seconds) before stale routes are removed when\nBGP restarts. **Read only** for VRF backed Edge Gateways\n\nMore information about settings can be found in VMware Cloud Director [BGP Configuration\ndocumentation](https://docs.vmware.com/en/VMware-Cloud-Director/10.3/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-EB585DDC-9F1C-4971-A4AD-44C239E6E822.html)\n"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "enabled"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayBgpConfiguration resources.\n",
                "properties": {
                    "ecmpEnabled": {
                        "type": "boolean",
                        "description": "A flag indicating whether ECMP is enabled or not\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Defines if BGP service is enabled or not\n"
                    },
                    "gracefulRestartMode": {
                        "type": "string",
                        "description": "Describes Graceful Restart configuration Modes for BGP\nconfiguration on an Edge Gateway. **Read only** for VRF backed Edge Gateways. Possible options are:\n* `DISABLE` - Both graceful restart and helper modes are disabled\n* `HELPER_ONLY` - The ability for a BGP speaker to indicate its ability to preserve forwarding\nstate during BGP restart\n* `GRACEFUL_AND_HELPER` - The ability of a BGP speaker to advertise its restart to its peers\n"
                    },
                    "gracefulRestartTimer": {
                        "type": "integer",
                        "description": "Maximum time taken (in seconds) for a BGP session to be\nestablished after a restart. If the session is not re-established within this timer, the receiving\nspeaker will delete all the stale routes from that peer. **Read only** for VRF backed Edge Gateways.\n"
                    },
                    "localAsNumber": {
                        "type": "string",
                        "description": "BGP autonomous systems (AS) number to advertise to BGP peers. BGP\nAS number can be specified in either ASPLAIN or ASDOT formats, like ASPLAIN format : '65546',\nASDOT format : '1.10'. **Read only** for VRF backed Edge Gateways\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "staleRouteTimer": {
                        "type": "integer",
                        "description": "Maximum time (in seconds) before stale routes are removed when\nBGP restarts. **Read only** for VRF backed Edge Gateways\n\nMore information about settings can be found in VMware Cloud Director [BGP Configuration\ndocumentation](https://docs.vmware.com/en/VMware-Cloud-Director/10.3/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-EB585DDC-9F1C-4971-A4AD-44C239E6E822.html)\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayBgpIpPrefixList:NsxtEdgegatewayBgpIpPrefixList": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of IP Prefix List\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n"
                },
                "ipPrefixes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayBgpIpPrefixListIpPrefix:NsxtEdgegatewayBgpIpPrefixListIpPrefix"
                    },
                    "description": "At least one `ip_prefix` definition. See IP Prefix for\ndefinition structure.\n\n\u003ca id=\"ip-prefix\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "The Name of IP Prefix List\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n"
                }
            },
            "required": [
                "edgeGatewayId",
                "ipPrefixes",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of IP Prefix List\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                    "willReplaceOnChanges": true
                },
                "ipPrefixes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayBgpIpPrefixListIpPrefix:NsxtEdgegatewayBgpIpPrefixListIpPrefix"
                    },
                    "description": "At least one `ip_prefix` definition. See IP Prefix for\ndefinition structure.\n\n\u003ca id=\"ip-prefix\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "The Name of IP Prefix List\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "ipPrefixes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayBgpIpPrefixList resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of IP Prefix List\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                        "willReplaceOnChanges": true
                    },
                    "ipPrefixes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewayBgpIpPrefixListIpPrefix:NsxtEdgegatewayBgpIpPrefixListIpPrefix"
                        },
                        "description": "At least one `ip_prefix` definition. See IP Prefix for\ndefinition structure.\n\n\u003ca id=\"ip-prefix\"\u003e\u003c/a\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Name of IP Prefix List\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayBgpNeighbor:NsxtEdgegatewayBgpNeighbor": {
            "properties": {
                "allowAsIn": {
                    "type": "boolean",
                    "description": "BGP Allow-as-in feature is used to allow the BGP speaker to accept the BGP updates even if its own BGP AS number is in the AS-Path attribute.\n"
                },
                "bfdDeadMultiple": {
                    "type": "integer",
                    "description": "Number of times a heartbeat packet is missed before BFD declares that the neighbor is down\n"
                },
                "bfdEnabled": {
                    "type": "boolean",
                    "description": "Should Bidirectional Forwarding Detection (BFD) be enabled\n"
                },
                "bfdInterval": {
                    "type": "integer",
                    "description": "Time interval (in milliseconds) between heartbeat packets\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the edge gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n"
                },
                "gracefulRestartMode": {
                    "type": "string",
                    "description": "BGP Neighbor Graceful Restart Mode. One of:\n* `DISABLE` - Overrides the global edge gateway settings and disables graceful restart mode for this neighbor.\n* `HELPER_ONLY` - Overrides the global edge gateway settings and configures graceful restart mode as Helper only for this neighbor.\n* `GRACEFUL_AND_HELPER` - Overrides the global edge gateway settings and configures graceful restart mode as Graceful restart and Helper for this neighbor.\n"
                },
                "holdDownTimer": {
                    "type": "integer",
                    "description": "Time interval (in seconds) before declaring a BGP peer dead\n"
                },
                "inFilterIpPrefixListId": {
                    "type": "string",
                    "description": "The ID of the IP Prefix List to be used for filtering incoming BGP routes\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "BGP Neighbor IP Address (IPv4 or IPv6)\n"
                },
                "keepAliveTimer": {
                    "type": "integer",
                    "description": "Time interval (in seconds) between sending keep-alive messages to a BGP peer\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n"
                },
                "outFilterIpPrefixListId": {
                    "type": "string",
                    "description": "The ID of the IP Prefix List to be used for filtering outgoing BGP routes\n"
                },
                "password": {
                    "type": "string",
                    "description": "BGP Neighbor Password\n",
                    "secret": true
                },
                "remoteAsNumber": {
                    "type": "string",
                    "description": "BGP Neighbor Remote Autonomous System (AS) Number\n"
                },
                "routeFiltering": {
                    "type": "string",
                    "description": "Route filtering by IP Address family. One of `DISABLED`, `IPV4`, `IPV6`\n"
                }
            },
            "required": [
                "allowAsIn",
                "bfdDeadMultiple",
                "bfdEnabled",
                "bfdInterval",
                "edgeGatewayId",
                "gracefulRestartMode",
                "holdDownTimer",
                "inFilterIpPrefixListId",
                "ipAddress",
                "keepAliveTimer",
                "outFilterIpPrefixListId",
                "remoteAsNumber",
                "routeFiltering"
            ],
            "inputProperties": {
                "allowAsIn": {
                    "type": "boolean",
                    "description": "BGP Allow-as-in feature is used to allow the BGP speaker to accept the BGP updates even if its own BGP AS number is in the AS-Path attribute.\n"
                },
                "bfdDeadMultiple": {
                    "type": "integer",
                    "description": "Number of times a heartbeat packet is missed before BFD declares that the neighbor is down\n"
                },
                "bfdEnabled": {
                    "type": "boolean",
                    "description": "Should Bidirectional Forwarding Detection (BFD) be enabled\n"
                },
                "bfdInterval": {
                    "type": "integer",
                    "description": "Time interval (in milliseconds) between heartbeat packets\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the edge gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                    "willReplaceOnChanges": true
                },
                "gracefulRestartMode": {
                    "type": "string",
                    "description": "BGP Neighbor Graceful Restart Mode. One of:\n* `DISABLE` - Overrides the global edge gateway settings and disables graceful restart mode for this neighbor.\n* `HELPER_ONLY` - Overrides the global edge gateway settings and configures graceful restart mode as Helper only for this neighbor.\n* `GRACEFUL_AND_HELPER` - Overrides the global edge gateway settings and configures graceful restart mode as Graceful restart and Helper for this neighbor.\n"
                },
                "holdDownTimer": {
                    "type": "integer",
                    "description": "Time interval (in seconds) before declaring a BGP peer dead\n"
                },
                "inFilterIpPrefixListId": {
                    "type": "string",
                    "description": "The ID of the IP Prefix List to be used for filtering incoming BGP routes\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "BGP Neighbor IP Address (IPv4 or IPv6)\n"
                },
                "keepAliveTimer": {
                    "type": "integer",
                    "description": "Time interval (in seconds) between sending keep-alive messages to a BGP peer\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "outFilterIpPrefixListId": {
                    "type": "string",
                    "description": "The ID of the IP Prefix List to be used for filtering outgoing BGP routes\n"
                },
                "password": {
                    "type": "string",
                    "description": "BGP Neighbor Password\n",
                    "secret": true
                },
                "remoteAsNumber": {
                    "type": "string",
                    "description": "BGP Neighbor Remote Autonomous System (AS) Number\n"
                },
                "routeFiltering": {
                    "type": "string",
                    "description": "Route filtering by IP Address family. One of `DISABLED`, `IPV4`, `IPV6`\n"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "ipAddress",
                "remoteAsNumber"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayBgpNeighbor resources.\n",
                "properties": {
                    "allowAsIn": {
                        "type": "boolean",
                        "description": "BGP Allow-as-in feature is used to allow the BGP speaker to accept the BGP updates even if its own BGP AS number is in the AS-Path attribute.\n"
                    },
                    "bfdDeadMultiple": {
                        "type": "integer",
                        "description": "Number of times a heartbeat packet is missed before BFD declares that the neighbor is down\n"
                    },
                    "bfdEnabled": {
                        "type": "boolean",
                        "description": "Should Bidirectional Forwarding Detection (BFD) be enabled\n"
                    },
                    "bfdInterval": {
                        "type": "integer",
                        "description": "Time interval (in milliseconds) between heartbeat packets\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the edge gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                        "willReplaceOnChanges": true
                    },
                    "gracefulRestartMode": {
                        "type": "string",
                        "description": "BGP Neighbor Graceful Restart Mode. One of:\n* `DISABLE` - Overrides the global edge gateway settings and disables graceful restart mode for this neighbor.\n* `HELPER_ONLY` - Overrides the global edge gateway settings and configures graceful restart mode as Helper only for this neighbor.\n* `GRACEFUL_AND_HELPER` - Overrides the global edge gateway settings and configures graceful restart mode as Graceful restart and Helper for this neighbor.\n"
                    },
                    "holdDownTimer": {
                        "type": "integer",
                        "description": "Time interval (in seconds) before declaring a BGP peer dead\n"
                    },
                    "inFilterIpPrefixListId": {
                        "type": "string",
                        "description": "The ID of the IP Prefix List to be used for filtering incoming BGP routes\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "BGP Neighbor IP Address (IPv4 or IPv6)\n"
                    },
                    "keepAliveTimer": {
                        "type": "integer",
                        "description": "Time interval (in seconds) between sending keep-alive messages to a BGP peer\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "outFilterIpPrefixListId": {
                        "type": "string",
                        "description": "The ID of the IP Prefix List to be used for filtering outgoing BGP routes\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "BGP Neighbor Password\n",
                        "secret": true
                    },
                    "remoteAsNumber": {
                        "type": "string",
                        "description": "BGP Neighbor Remote Autonomous System (AS) Number\n"
                    },
                    "routeFiltering": {
                        "type": "string",
                        "description": "Route filtering by IP Address family. One of `DISABLED`, `IPV4`, `IPV6`\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayDhcpForwarding:NsxtEdgegatewayDhcpForwarding": {
            "properties": {
                "dhcpServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP addresses of DHCP servers. Maximum 8 can be specified.\n\n\u003e Modification of the `dhcp_servers` field will not be changed in VCD when `enabled = false` because VCD API ignores DHCP server changes when DHCP forwarding is disabled.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "DHCP Forwarding status.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located, required\nif not set in the provider section.\n"
                }
            },
            "required": [
                "dhcpServers",
                "edgeGatewayId",
                "enabled"
            ],
            "inputProperties": {
                "dhcpServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP addresses of DHCP servers. Maximum 8 can be specified.\n\n\u003e Modification of the `dhcp_servers` field will not be changed in VCD when `enabled = false` because VCD API ignores DHCP server changes when DHCP forwarding is disabled.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "DHCP Forwarding status.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located, required\nif not set in the provider section.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "dhcpServers",
                "edgeGatewayId",
                "enabled"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayDhcpForwarding resources.\n",
                "properties": {
                    "dhcpServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IP addresses of DHCP servers. Maximum 8 can be specified.\n\n\u003e Modification of the `dhcp_servers` field will not be changed in VCD when `enabled = false` because VCD API ignores DHCP server changes when DHCP forwarding is disabled.\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "DHCP Forwarding status.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org in which the NSX-T Edge Gateway is located, required\nif not set in the provider section.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayDhcpv6:NsxtEdgegatewayDhcpv6": {
            "properties": {
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IPv6 DNS servers (only applicable for `DHCPv6` mode)\n"
                },
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of domain names (only applicable for `DHCPv6` mode)\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID\n"
                },
                "mode": {
                    "type": "string",
                    "description": "One of `SLAAC` (Stateless Address Autoconfiguration), `DHCPv6` (Dynamic Host\nConfiguration Protocol) or `DISABLED` (to disable the service). **Note:** destroying the resource\nwill also disable DHCPv6.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located\n"
                }
            },
            "required": [
                "edgeGatewayId",
                "mode"
            ],
            "inputProperties": {
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IPv6 DNS servers (only applicable for `DHCPv6` mode)\n"
                },
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of domain names (only applicable for `DHCPv6` mode)\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID\n",
                    "willReplaceOnChanges": true
                },
                "mode": {
                    "type": "string",
                    "description": "One of `SLAAC` (Stateless Address Autoconfiguration), `DHCPv6` (Dynamic Host\nConfiguration Protocol) or `DISABLED` (to disable the service). **Note:** destroying the resource\nwill also disable DHCPv6.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "mode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayDhcpv6 resources.\n",
                "properties": {
                    "dnsServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IPv6 DNS servers (only applicable for `DHCPv6` mode)\n"
                    },
                    "domainNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of domain names (only applicable for `DHCPv6` mode)\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID\n",
                        "willReplaceOnChanges": true
                    },
                    "mode": {
                        "type": "string",
                        "description": "One of `SLAAC` (Stateless Address Autoconfiguration), `DHCPv6` (Dynamic Host\nConfiguration Protocol) or `DISABLED` (to disable the service). **Note:** destroying the resource\nwill also disable DHCPv6.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org in which the NSX-T Edge Gateway is located\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayDns:NsxtEdgegatewayDns": {
            "properties": {
                "conditionalForwarderZones": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayDnsConditionalForwarderZone:NsxtEdgegatewayDnsConditionalForwarderZone"
                    },
                    "description": "A set (up to 5) of conditional forwarder zones that allows to define \nspecific forwarding routes based on the domain. See `conditional_forwarder_zone`\n"
                },
                "defaultForwarderZone": {
                    "$ref": "#/types/vcd:index/NsxtEdgegatewayDnsDefaultForwarderZone:NsxtEdgegatewayDnsDefaultForwarderZone",
                    "description": "The default forwarder zone to use if \ntheres no matching domain in the conditional forwarder zones. See `default_forwarder_zone`\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Status of the DNS forwarding service. Defaults to `true`.\n"
                },
                "listenerIp": {
                    "type": "string",
                    "description": "The IP on which the DNS forwarder listens. If the Edge Gateway \nhas a dedicated external network, this can be changed.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located, required\nif not set in the provider section.\n"
                },
                "snatRuleEnabled": {
                    "type": "boolean",
                    "description": "Is `true` if there exists a SNAT rule for the DNS forwarder. \nIf the Edge Gateway is connected to a dedicated provider gateway and `listener_ip`\nis modified manually, this field will be set to `false`, otherwise `true`.\n"
                },
                "snatRuleIpAddress": {
                    "type": "string",
                    "description": "This argument only applies if the Edge Gateway \nis connected to a Provider Gateway using IP Spaces. If specified, VCD will\nconveniently manage the SNAT rule with the specified IP address for the DNS forwarder.\nThe specified IP can be allocated using [`vcd.IpSpaceIpAllocation`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/ip_space_ip_allocation)\nIf not specified, the IP address will be computed and chosen by VCD.\n"
                }
            },
            "required": [
                "defaultForwarderZone",
                "edgeGatewayId",
                "listenerIp",
                "snatRuleEnabled",
                "snatRuleIpAddress"
            ],
            "inputProperties": {
                "conditionalForwarderZones": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayDnsConditionalForwarderZone:NsxtEdgegatewayDnsConditionalForwarderZone"
                    },
                    "description": "A set (up to 5) of conditional forwarder zones that allows to define \nspecific forwarding routes based on the domain. See `conditional_forwarder_zone`\n"
                },
                "defaultForwarderZone": {
                    "$ref": "#/types/vcd:index/NsxtEdgegatewayDnsDefaultForwarderZone:NsxtEdgegatewayDnsDefaultForwarderZone",
                    "description": "The default forwarder zone to use if \ntheres no matching domain in the conditional forwarder zones. See `default_forwarder_zone`\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Status of the DNS forwarding service. Defaults to `true`.\n"
                },
                "listenerIp": {
                    "type": "string",
                    "description": "The IP on which the DNS forwarder listens. If the Edge Gateway \nhas a dedicated external network, this can be changed.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located, required\nif not set in the provider section.\n",
                    "willReplaceOnChanges": true
                },
                "snatRuleIpAddress": {
                    "type": "string",
                    "description": "This argument only applies if the Edge Gateway \nis connected to a Provider Gateway using IP Spaces. If specified, VCD will\nconveniently manage the SNAT rule with the specified IP address for the DNS forwarder.\nThe specified IP can be allocated using [`vcd.IpSpaceIpAllocation`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/ip_space_ip_allocation)\nIf not specified, the IP address will be computed and chosen by VCD.\n"
                }
            },
            "requiredInputs": [
                "defaultForwarderZone",
                "edgeGatewayId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayDns resources.\n",
                "properties": {
                    "conditionalForwarderZones": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewayDnsConditionalForwarderZone:NsxtEdgegatewayDnsConditionalForwarderZone"
                        },
                        "description": "A set (up to 5) of conditional forwarder zones that allows to define \nspecific forwarding routes based on the domain. See `conditional_forwarder_zone`\n"
                    },
                    "defaultForwarderZone": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayDnsDefaultForwarderZone:NsxtEdgegatewayDnsDefaultForwarderZone",
                        "description": "The default forwarder zone to use if \ntheres no matching domain in the conditional forwarder zones. See `default_forwarder_zone`\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Status of the DNS forwarding service. Defaults to `true`.\n"
                    },
                    "listenerIp": {
                        "type": "string",
                        "description": "The IP on which the DNS forwarder listens. If the Edge Gateway \nhas a dedicated external network, this can be changed.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org in which the NSX-T Edge Gateway is located, required\nif not set in the provider section.\n",
                        "willReplaceOnChanges": true
                    },
                    "snatRuleEnabled": {
                        "type": "boolean",
                        "description": "Is `true` if there exists a SNAT rule for the DNS forwarder. \nIf the Edge Gateway is connected to a dedicated provider gateway and `listener_ip`\nis modified manually, this field will be set to `false`, otherwise `true`.\n"
                    },
                    "snatRuleIpAddress": {
                        "type": "string",
                        "description": "This argument only applies if the Edge Gateway \nis connected to a Provider Gateway using IP Spaces. If specified, VCD will\nconveniently manage the SNAT rule with the specified IP address for the DNS forwarder.\nThe specified IP can be allocated using [`vcd.IpSpaceIpAllocation`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/ip_space_ip_allocation)\nIf not specified, the IP address will be computed and chosen by VCD.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayL2VpnTunnel:NsxtEdgegatewayL2VpnTunnel": {
            "properties": {
                "connectorInitiationMode": {
                    "type": "string",
                    "description": "Mode in which the connection is formed. \nRequired for `SERVER` mode sessions. One of:\n* `INITIATOR` - Local endpoint initiates tunnel setup and will also respond to\nincoming tunnel setup requests from the peer gateway.\n* `RESPOND_ONLY` - Local endpoint shall only respond to incoming tunnel setup\nrequests, it shall not initiate the tunnel setup.\n* `ON_DEMAND` - In this mode local endpoint will initiate tunnel creation once\nfirst packet matching the policy rule is received, and will also respond to\nincoming initiation requests.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the tunnel.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). \nCan be looked up using [`vcd.NsxtEdgegateway`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "State of the `SERVER` mode session, always set to `true` for `CLIENT` \nmode sessions. Default is `true`.\n"
                },
                "localEndpointIp": {
                    "type": "string",
                    "description": "The IP address corresponding to the Edge \nGateway the tunnel is being configured on. The IP must be sub-allocated\non the Edge Gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the tunnel.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at \nprovider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "peerCode": {
                    "type": "string",
                    "description": "Base64 encoded string of the full configuration of the tunnel provided by the SERVER session. It is a computed field for\nSERVER sessions and is a required field for CLIENT sessions.\n"
                },
                "preSharedKey": {
                    "type": "string",
                    "description": "The key that is used for authenticating the \nconnection. Required for `SERVER` mode sessions.\n"
                },
                "remoteEndpointIp": {
                    "type": "string",
                    "description": "The IP address of the remote endpoint, which \ncorresponds to the device on the remote site terminating the VPN tunnel.\n"
                },
                "sessionMode": {
                    "type": "string",
                    "description": "Mode of the tunnel session (SERVER or CLIENT).\n"
                },
                "stretchedNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayL2VpnTunnelStretchedNetwork:NsxtEdgegatewayL2VpnTunnelStretchedNetwork"
                    },
                    "description": "One or more stretched networks for the tunnel. \nSee `stretched_network` for more detail.\n"
                },
                "tunnelInterface": {
                    "type": "string",
                    "description": "The network CIDR block over which the session \ninterfaces. Relevant only for `SERVER` mode sessions. If not provided, Cloud\nDirector will attempt to automatically allocate a tunnel interface.\n"
                }
            },
            "required": [
                "edgeGatewayId",
                "localEndpointIp",
                "name",
                "peerCode",
                "remoteEndpointIp",
                "sessionMode",
                "tunnelInterface"
            ],
            "inputProperties": {
                "connectorInitiationMode": {
                    "type": "string",
                    "description": "Mode in which the connection is formed. \nRequired for `SERVER` mode sessions. One of:\n* `INITIATOR` - Local endpoint initiates tunnel setup and will also respond to\nincoming tunnel setup requests from the peer gateway.\n* `RESPOND_ONLY` - Local endpoint shall only respond to incoming tunnel setup\nrequests, it shall not initiate the tunnel setup.\n* `ON_DEMAND` - In this mode local endpoint will initiate tunnel creation once\nfirst packet matching the policy rule is received, and will also respond to\nincoming initiation requests.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the tunnel.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). \nCan be looked up using [`vcd.NsxtEdgegateway`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "State of the `SERVER` mode session, always set to `true` for `CLIENT` \nmode sessions. Default is `true`.\n"
                },
                "localEndpointIp": {
                    "type": "string",
                    "description": "The IP address corresponding to the Edge \nGateway the tunnel is being configured on. The IP must be sub-allocated\non the Edge Gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the tunnel.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at \nprovider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "peerCode": {
                    "type": "string",
                    "description": "Base64 encoded string of the full configuration of the tunnel provided by the SERVER session. It is a computed field for\nSERVER sessions and is a required field for CLIENT sessions.\n"
                },
                "preSharedKey": {
                    "type": "string",
                    "description": "The key that is used for authenticating the \nconnection. Required for `SERVER` mode sessions.\n"
                },
                "remoteEndpointIp": {
                    "type": "string",
                    "description": "The IP address of the remote endpoint, which \ncorresponds to the device on the remote site terminating the VPN tunnel.\n"
                },
                "sessionMode": {
                    "type": "string",
                    "description": "Mode of the tunnel session (SERVER or CLIENT).\n",
                    "willReplaceOnChanges": true
                },
                "stretchedNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayL2VpnTunnelStretchedNetwork:NsxtEdgegatewayL2VpnTunnelStretchedNetwork"
                    },
                    "description": "One or more stretched networks for the tunnel. \nSee `stretched_network` for more detail.\n"
                },
                "tunnelInterface": {
                    "type": "string",
                    "description": "The network CIDR block over which the session \ninterfaces. Relevant only for `SERVER` mode sessions. If not provided, Cloud\nDirector will attempt to automatically allocate a tunnel interface.\n"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "localEndpointIp",
                "remoteEndpointIp",
                "sessionMode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayL2VpnTunnel resources.\n",
                "properties": {
                    "connectorInitiationMode": {
                        "type": "string",
                        "description": "Mode in which the connection is formed. \nRequired for `SERVER` mode sessions. One of:\n* `INITIATOR` - Local endpoint initiates tunnel setup and will also respond to\nincoming tunnel setup requests from the peer gateway.\n* `RESPOND_ONLY` - Local endpoint shall only respond to incoming tunnel setup\nrequests, it shall not initiate the tunnel setup.\n* `ON_DEMAND` - In this mode local endpoint will initiate tunnel creation once\nfirst packet matching the policy rule is received, and will also respond to\nincoming initiation requests.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the tunnel.\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). \nCan be looked up using [`vcd.NsxtEdgegateway`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "State of the `SERVER` mode session, always set to `true` for `CLIENT` \nmode sessions. Default is `true`.\n"
                    },
                    "localEndpointIp": {
                        "type": "string",
                        "description": "The IP address corresponding to the Edge \nGateway the tunnel is being configured on. The IP must be sub-allocated\non the Edge Gateway.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tunnel.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at \nprovider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "peerCode": {
                        "type": "string",
                        "description": "Base64 encoded string of the full configuration of the tunnel provided by the SERVER session. It is a computed field for\nSERVER sessions and is a required field for CLIENT sessions.\n"
                    },
                    "preSharedKey": {
                        "type": "string",
                        "description": "The key that is used for authenticating the \nconnection. Required for `SERVER` mode sessions.\n"
                    },
                    "remoteEndpointIp": {
                        "type": "string",
                        "description": "The IP address of the remote endpoint, which \ncorresponds to the device on the remote site terminating the VPN tunnel.\n"
                    },
                    "sessionMode": {
                        "type": "string",
                        "description": "Mode of the tunnel session (SERVER or CLIENT).\n",
                        "willReplaceOnChanges": true
                    },
                    "stretchedNetworks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewayL2VpnTunnelStretchedNetwork:NsxtEdgegatewayL2VpnTunnelStretchedNetwork"
                        },
                        "description": "One or more stretched networks for the tunnel. \nSee `stretched_network` for more detail.\n"
                    },
                    "tunnelInterface": {
                        "type": "string",
                        "description": "The network CIDR block over which the session \ninterfaces. Relevant only for `SERVER` mode sessions. If not provided, Cloud\nDirector will attempt to automatically allocate a tunnel interface.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayRateLimiting:NsxtEdgegatewayRateLimiting": {
            "properties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID\n"
                },
                "egressProfileId": {
                    "type": "string",
                    "description": "A QoS profile to apply for egress traffic. *Note* leaving empty\nmeans `unlimited`.\n\n\u003e Ingress and Egress profile IDs can be looked up using\n[`vcd.getNsxtEdgegatewayQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_edgegateway_qos_profile)\ndata source.\n"
                },
                "ingressProfileId": {
                    "type": "string",
                    "description": "A QoS profile to apply for ingress traffic. *Note* leaving empty\nmeans `unlimited`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located\n"
                }
            },
            "required": [
                "edgeGatewayId"
            ],
            "inputProperties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID\n",
                    "willReplaceOnChanges": true
                },
                "egressProfileId": {
                    "type": "string",
                    "description": "A QoS profile to apply for egress traffic. *Note* leaving empty\nmeans `unlimited`.\n\n\u003e Ingress and Egress profile IDs can be looked up using\n[`vcd.getNsxtEdgegatewayQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_edgegateway_qos_profile)\ndata source.\n"
                },
                "ingressProfileId": {
                    "type": "string",
                    "description": "A QoS profile to apply for ingress traffic. *Note* leaving empty\nmeans `unlimited`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Org in which the NSX-T Edge Gateway is located\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGatewayId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayRateLimiting resources.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID\n",
                        "willReplaceOnChanges": true
                    },
                    "egressProfileId": {
                        "type": "string",
                        "description": "A QoS profile to apply for egress traffic. *Note* leaving empty\nmeans `unlimited`.\n\n\u003e Ingress and Egress profile IDs can be looked up using\n[`vcd.getNsxtEdgegatewayQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_edgegateway_qos_profile)\ndata source.\n"
                    },
                    "ingressProfileId": {
                        "type": "string",
                        "description": "A QoS profile to apply for ingress traffic. *Note* leaving empty\nmeans `unlimited`.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org in which the NSX-T Edge Gateway is located\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtEdgegatewayStaticRoute:NsxtEdgegatewayStaticRoute": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description for NSX-T Edge Gateway Static Route\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for NSX-T Edge Gateway Static Route\n"
                },
                "networkCidr": {
                    "type": "string",
                    "description": "Specifies network prefix in CIDR format. Both IPv4 and IPv6 formats\nare supported.\n"
                },
                "nextHops": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayStaticRouteNextHop:NsxtEdgegatewayStaticRouteNextHop"
                    },
                    "description": "A set of next hops to use within the static route. At least one is\nrequired. See Next Hop for definition structure.\n\n\u003ca id=\"next-hop\"\u003e\u003c/a\u003e\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n"
                }
            },
            "required": [
                "edgeGatewayId",
                "name",
                "networkCidr",
                "nextHops"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description for NSX-T Edge Gateway Static Route\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name for NSX-T Edge Gateway Static Route\n"
                },
                "networkCidr": {
                    "type": "string",
                    "description": "Specifies network prefix in CIDR format. Both IPv4 and IPv6 formats\nare supported.\n"
                },
                "nextHops": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtEdgegatewayStaticRouteNextHop:NsxtEdgegatewayStaticRouteNextHop"
                    },
                    "description": "A set of next hops to use within the static route. At least one is\nrequired. See Next Hop for definition structure.\n\n\u003ca id=\"next-hop\"\u003e\u003c/a\u003e\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "networkCidr",
                "nextHops"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtEdgegatewayStaticRoute resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description for NSX-T Edge Gateway Static Route\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name for NSX-T Edge Gateway Static Route\n"
                    },
                    "networkCidr": {
                        "type": "string",
                        "description": "Specifies network prefix in CIDR format. Both IPv4 and IPv6 formats\nare supported.\n"
                    },
                    "nextHops": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtEdgegatewayStaticRouteNextHop:NsxtEdgegatewayStaticRouteNextHop"
                        },
                        "description": "A set of next hops to use within the static route. At least one is\nrequired. See Next Hop for definition structure.\n\n\u003ca id=\"next-hop\"\u003e\u003c/a\u003e\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtFirewall:NsxtFirewall": {
            "properties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtFirewallRule:NsxtFirewallRule"
                    },
                    "description": "One or more blocks with Firewall Rule definitions\n\n\u003ca id=\"firewall-rule\"\u003e\u003c/a\u003e\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "required": [
                "edgeGatewayId",
                "rules",
                "vdc"
            ],
            "inputProperties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtFirewallRule:NsxtFirewallRule"
                    },
                    "description": "One or more blocks with Firewall Rule definitions\n\n\u003ca id=\"firewall-rule\"\u003e\u003c/a\u003e\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "rules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtFirewall resources.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` datasource\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtFirewallRule:NsxtFirewallRule"
                        },
                        "description": "One or more blocks with Firewall Rule definitions\n\n\u003ca id=\"firewall-rule\"\u003e\u003c/a\u003e\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtGlobalDefaultSegmentProfileTemplate:NsxtGlobalDefaultSegmentProfileTemplate": {
            "properties": {
                "vappNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Global Default Segment Profile\nTemplate ID for all vApp Networks\n"
                },
                "vdcNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Global Default Segment Profile\nTemplate ID for all VDC Networks\n"
                }
            },
            "inputProperties": {
                "vappNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Global Default Segment Profile\nTemplate ID for all vApp Networks\n"
                },
                "vdcNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Global Default Segment Profile\nTemplate ID for all VDC Networks\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtGlobalDefaultSegmentProfileTemplate resources.\n",
                "properties": {
                    "vappNetworksDefaultSegmentProfileTemplateId": {
                        "type": "string",
                        "description": "Global Default Segment Profile\nTemplate ID for all vApp Networks\n"
                    },
                    "vdcNetworksDefaultSegmentProfileTemplateId": {
                        "type": "string",
                        "description": "Global Default Segment Profile\nTemplate ID for all VDC Networks\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtIpSet:NsxtIpSet": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the IP Set\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses, subnets or ranges (IPv4 or IPv6)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for IP Set\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "ownerId": {
                    "type": "string",
                    "description": "ID of VDC or VDC Group\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                    "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. IP Sets will inherit VDC from parent Edge Gateway."
                }
            },
            "required": [
                "edgeGatewayId",
                "name",
                "ownerId",
                "vdc"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the IP Set\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source.\n",
                    "willReplaceOnChanges": true
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses, subnets or ranges (IPv4 or IPv6)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for IP Set\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                    "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. IP Sets will inherit VDC from parent Edge Gateway."
                }
            },
            "requiredInputs": [
                "edgeGatewayId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtIpSet resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the IP Set\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of IP addresses, subnets or ranges (IPv4 or IPv6)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for IP Set\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "ID of VDC or VDC Group\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. IP Sets will inherit VDC from parent Edge Gateway."
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtIpsecVpnTunnel:NsxtIpsecVpnTunnel": {
            "properties": {
                "authenticationMode": {
                    "type": "string",
                    "description": "`PSK` (pre-shared key) or `CERTIFICATE` (default -\n`PSK`)\n"
                },
                "caCertificateId": {
                    "type": "string",
                    "description": "CA Certificate ID (can be handled by\n`vcd.LibraryCertificate` resource or datasource) *Note* `authentication_mode` must be set to\n`CERTIFICATE`\n"
                },
                "certificateId": {
                    "type": "string",
                    "description": "Certificate ID (can be handled by `vcd.LibraryCertificate`\nresource or datasource). *Note* `authentication_mode` must be set to `CERTIFICATE`\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the NSX-T IPsec VPN Tunnel\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enables or disables IPsec VPN Tunnel (default `true`)\n"
                },
                "ikeFailReason": {
                    "type": "string",
                    "description": "Provides more details of failure if the IKE service is not UP\n"
                },
                "ikeServiceStatus": {
                    "type": "string",
                    "description": "Status for the actual IKE Session for the given tunnel\n"
                },
                "localIpAddress": {
                    "type": "string",
                    "description": "IPv4 Address for the endpoint. This has to be a suballocated IP on the Edge Gateway.\n"
                },
                "localNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of local networks in CIDR format. At least one value required\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Sets whether logging for the tunnel is enabled or not. (default - `false`)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for NSX-T IPsec VPN Tunnel\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "preSharedKey": {
                    "type": "string",
                    "description": "Pre-shared key for negotiation. **Note** the pre-shared key must be\nthe same on the other end of the IPSec VPN tunnel and `authentication_mode` must be `PSK`\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "Remote ID uniquely identifies the peer site. If the remote ID is\nnot set, it will default to the remote IP address\n"
                },
                "remoteIpAddress": {
                    "type": "string",
                    "description": "Public IPv4 Address of the remote device terminating the VPN connection\n"
                },
                "remoteNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0\n"
                },
                "securityProfile": {
                    "type": "string",
                    "description": "`DEFAULT` for system provided configuration or `CUSTOM` if `security_profile_customization` is set\n"
                },
                "securityProfileCustomization": {
                    "$ref": "#/types/vcd:index/NsxtIpsecVpnTunnelSecurityProfileCustomization:NsxtIpsecVpnTunnelSecurityProfileCustomization",
                    "description": "a block allowing to\ncustomize default security profile parameters\n\n\u003ca id=\"security-profile\"\u003e\u003c/a\u003e\n"
                },
                "status": {
                    "type": "string",
                    "description": "Overall IPsec VPN Tunnel Status\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "required": [
                "edgeGatewayId",
                "ikeFailReason",
                "ikeServiceStatus",
                "localIpAddress",
                "localNetworks",
                "name",
                "preSharedKey",
                "remoteId",
                "remoteIpAddress",
                "securityProfile",
                "status",
                "vdc"
            ],
            "inputProperties": {
                "authenticationMode": {
                    "type": "string",
                    "description": "`PSK` (pre-shared key) or `CERTIFICATE` (default -\n`PSK`)\n"
                },
                "caCertificateId": {
                    "type": "string",
                    "description": "CA Certificate ID (can be handled by\n`vcd.LibraryCertificate` resource or datasource) *Note* `authentication_mode` must be set to\n`CERTIFICATE`\n"
                },
                "certificateId": {
                    "type": "string",
                    "description": "Certificate ID (can be handled by `vcd.LibraryCertificate`\nresource or datasource). *Note* `authentication_mode` must be set to `CERTIFICATE`\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the NSX-T IPsec VPN Tunnel\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enables or disables IPsec VPN Tunnel (default `true`)\n"
                },
                "localIpAddress": {
                    "type": "string",
                    "description": "IPv4 Address for the endpoint. This has to be a suballocated IP on the Edge Gateway.\n"
                },
                "localNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of local networks in CIDR format. At least one value required\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Sets whether logging for the tunnel is enabled or not. (default - `false`)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for NSX-T IPsec VPN Tunnel\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "preSharedKey": {
                    "type": "string",
                    "description": "Pre-shared key for negotiation. **Note** the pre-shared key must be\nthe same on the other end of the IPSec VPN tunnel and `authentication_mode` must be `PSK`\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "Remote ID uniquely identifies the peer site. If the remote ID is\nnot set, it will default to the remote IP address\n"
                },
                "remoteIpAddress": {
                    "type": "string",
                    "description": "Public IPv4 Address of the remote device terminating the VPN connection\n"
                },
                "remoteNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0\n"
                },
                "securityProfileCustomization": {
                    "$ref": "#/types/vcd:index/NsxtIpsecVpnTunnelSecurityProfileCustomization:NsxtIpsecVpnTunnelSecurityProfileCustomization",
                    "description": "a block allowing to\ncustomize default security profile parameters\n\n\u003ca id=\"security-profile\"\u003e\u003c/a\u003e\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "localIpAddress",
                "localNetworks",
                "preSharedKey",
                "remoteIpAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtIpsecVpnTunnel resources.\n",
                "properties": {
                    "authenticationMode": {
                        "type": "string",
                        "description": "`PSK` (pre-shared key) or `CERTIFICATE` (default -\n`PSK`)\n"
                    },
                    "caCertificateId": {
                        "type": "string",
                        "description": "CA Certificate ID (can be handled by\n`vcd.LibraryCertificate` resource or datasource) *Note* `authentication_mode` must be set to\n`CERTIFICATE`\n"
                    },
                    "certificateId": {
                        "type": "string",
                        "description": "Certificate ID (can be handled by `vcd.LibraryCertificate`\nresource or datasource). *Note* `authentication_mode` must be set to `CERTIFICATE`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the NSX-T IPsec VPN Tunnel\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enables or disables IPsec VPN Tunnel (default `true`)\n"
                    },
                    "ikeFailReason": {
                        "type": "string",
                        "description": "Provides more details of failure if the IKE service is not UP\n"
                    },
                    "ikeServiceStatus": {
                        "type": "string",
                        "description": "Status for the actual IKE Session for the given tunnel\n"
                    },
                    "localIpAddress": {
                        "type": "string",
                        "description": "IPv4 Address for the endpoint. This has to be a suballocated IP on the Edge Gateway.\n"
                    },
                    "localNetworks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of local networks in CIDR format. At least one value required\n"
                    },
                    "logging": {
                        "type": "boolean",
                        "description": "Sets whether logging for the tunnel is enabled or not. (default - `false`)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for NSX-T IPsec VPN Tunnel\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "preSharedKey": {
                        "type": "string",
                        "description": "Pre-shared key for negotiation. **Note** the pre-shared key must be\nthe same on the other end of the IPSec VPN tunnel and `authentication_mode` must be `PSK`\n",
                        "secret": true
                    },
                    "remoteId": {
                        "type": "string",
                        "description": "Remote ID uniquely identifies the peer site. If the remote ID is\nnot set, it will default to the remote IP address\n"
                    },
                    "remoteIpAddress": {
                        "type": "string",
                        "description": "Public IPv4 Address of the remote device terminating the VPN connection\n"
                    },
                    "remoteNetworks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0\n"
                    },
                    "securityProfile": {
                        "type": "string",
                        "description": "`DEFAULT` for system provided configuration or `CUSTOM` if `security_profile_customization` is set\n"
                    },
                    "securityProfileCustomization": {
                        "$ref": "#/types/vcd:index/NsxtIpsecVpnTunnelSecurityProfileCustomization:NsxtIpsecVpnTunnelSecurityProfileCustomization",
                        "description": "a block allowing to\ncustomize default security profile parameters\n\n\u003ca id=\"security-profile\"\u003e\u003c/a\u003e\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Overall IPsec VPN Tunnel Status\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtNatRule:NsxtNatRule": {
            "properties": {
                "appPortProfileId": {
                    "type": "string",
                    "description": "Application Port Profile to which to apply the rule. The\nApplication Port Profile includes a port, and a protocol that the incoming traffic uses on the edge\ngateway to connect to the internal network.  Can be looked up using `vcd.NsxtAppPortProfile`\ndata source or created using `vcd.NsxtAppPortProfile` resource\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the NAT rule\n"
                },
                "dnatExternalPort": {
                    "type": "string",
                    "description": "For `DNAT` only. This represents the external port number or port range when doing \n`DNAT` port forwarding from external to internal. The default dnatExternalPort is ANY meaning traffic on any port\nfor the given IPs selected will be translated.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enables or disables NAT rule (default `true`)\n"
                },
                "externalAddress": {
                    "type": "string",
                    "description": "The external address for the NAT Rule. This must be supplied as a single IP or Network\nCIDR. For a `DNAT` rule, this is the external facing IP Address for incoming traffic. For an `SNAT` rule, this is the\nexternal facing IP Address for outgoing traffic. These IPs are typically allocated/suballocated IP Addresses on the\nEdge Gateway. For a `REFLEXIVE` rule, these are the external facing IPs.\n"
                },
                "firewallMatch": {
                    "type": "string",
                    "description": "You can set a firewall match rule to determine how\nfirewall is applied during NAT. One of `MATCH_INTERNAL_ADDRESS`, `MATCH_EXTERNAL_ADDRESS`,\n`BYPASS`\n* `MATCH_INTERNAL_ADDRESS` - applies firewall rules to the internal address of a NAT rule\n* `MATCH_EXTERNAL_ADDRESS` - applies firewall rules to the external address of a NAT rule\n* `BYPASS` - skip applying firewall rules to NAT rule\n"
                },
                "internalAddress": {
                    "type": "string",
                    "description": "The internal address for the NAT Rule. This must be supplied as a single IP or\nNetwork CIDR. For a `DNAT` rule, this is the internal IP address for incoming traffic. For an `SNAT` rule, this is the\ninternal IP Address for outgoing traffic. For a `REFLEXIVE` rule, these are the internal IPs.\nThese IPs are typically the Private IPs that are allocated to workloads.\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Enable to have the address translation performed by this rule logged\n(default `false`). **Note** User might lack rights (**Organization Administrator** role by default\nis missing **Gateway \u003e Configure System Logging** right) to enable logging, but API does not\nreturn error and it is not possible to validate it. `pulumi preview` might show difference on\nevery update.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for NAT rule\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "if an address has multiple NAT rules, you can assign these\nrules different priorities to determine the order in which they are applied. A lower value means a\nhigher priority for this rule.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "One of `DNAT`, `NO_DNAT`, `SNAT`, `NO_SNAT`, `REFLEXIVE`\n* `DNAT` rule translates the external IP to an internal IP and is used for inbound traffic\n* `NO_DNAT` prevents external IP translation\n* `SNAT` translates an internal IP to an external IP and is used for outbound traffic\n* `NO_SNAT` prevents internal IP translation\n* `REFLEXIVE` (VCD 10.3+)  is also known as Stateless NAT. This translates an internal IP to an external IP and vice\nversa. The number of internal addresses should be exactly the same as that of external addresses.\n"
                },
                "snatDestinationAddress": {
                    "type": "string",
                    "description": "For `SNAT` only. The destination addresses to match in the `SNAT` Rule. This \nmust be supplied as a single IP or Network CIDR. Providing no value for this field results in match with ANY\ndestination network.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "required": [
                "edgeGatewayId",
                "firewallMatch",
                "name",
                "priority",
                "ruleType",
                "vdc"
            ],
            "inputProperties": {
                "appPortProfileId": {
                    "type": "string",
                    "description": "Application Port Profile to which to apply the rule. The\nApplication Port Profile includes a port, and a protocol that the incoming traffic uses on the edge\ngateway to connect to the internal network.  Can be looked up using `vcd.NsxtAppPortProfile`\ndata source or created using `vcd.NsxtAppPortProfile` resource\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the NAT rule\n"
                },
                "dnatExternalPort": {
                    "type": "string",
                    "description": "For `DNAT` only. This represents the external port number or port range when doing \n`DNAT` port forwarding from external to internal. The default dnatExternalPort is ANY meaning traffic on any port\nfor the given IPs selected will be translated.\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enables or disables NAT rule (default `true`)\n"
                },
                "externalAddress": {
                    "type": "string",
                    "description": "The external address for the NAT Rule. This must be supplied as a single IP or Network\nCIDR. For a `DNAT` rule, this is the external facing IP Address for incoming traffic. For an `SNAT` rule, this is the\nexternal facing IP Address for outgoing traffic. These IPs are typically allocated/suballocated IP Addresses on the\nEdge Gateway. For a `REFLEXIVE` rule, these are the external facing IPs.\n"
                },
                "firewallMatch": {
                    "type": "string",
                    "description": "You can set a firewall match rule to determine how\nfirewall is applied during NAT. One of `MATCH_INTERNAL_ADDRESS`, `MATCH_EXTERNAL_ADDRESS`,\n`BYPASS`\n* `MATCH_INTERNAL_ADDRESS` - applies firewall rules to the internal address of a NAT rule\n* `MATCH_EXTERNAL_ADDRESS` - applies firewall rules to the external address of a NAT rule\n* `BYPASS` - skip applying firewall rules to NAT rule\n"
                },
                "internalAddress": {
                    "type": "string",
                    "description": "The internal address for the NAT Rule. This must be supplied as a single IP or\nNetwork CIDR. For a `DNAT` rule, this is the internal IP address for incoming traffic. For an `SNAT` rule, this is the\ninternal IP Address for outgoing traffic. For a `REFLEXIVE` rule, these are the internal IPs.\nThese IPs are typically the Private IPs that are allocated to workloads.\n"
                },
                "logging": {
                    "type": "boolean",
                    "description": "Enable to have the address translation performed by this rule logged\n(default `false`). **Note** User might lack rights (**Organization Administrator** role by default\nis missing **Gateway \u003e Configure System Logging** right) to enable logging, but API does not\nreturn error and it is not possible to validate it. `pulumi preview` might show difference on\nevery update.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for NAT rule\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "integer",
                    "description": "if an address has multiple NAT rules, you can assign these\nrules different priorities to determine the order in which they are applied. A lower value means a\nhigher priority for this rule.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "One of `DNAT`, `NO_DNAT`, `SNAT`, `NO_SNAT`, `REFLEXIVE`\n* `DNAT` rule translates the external IP to an internal IP and is used for inbound traffic\n* `NO_DNAT` prevents external IP translation\n* `SNAT` translates an internal IP to an external IP and is used for outbound traffic\n* `NO_SNAT` prevents internal IP translation\n* `REFLEXIVE` (VCD 10.3+)  is also known as Stateless NAT. This translates an internal IP to an external IP and vice\nversa. The number of internal addresses should be exactly the same as that of external addresses.\n",
                    "willReplaceOnChanges": true
                },
                "snatDestinationAddress": {
                    "type": "string",
                    "description": "For `SNAT` only. The destination addresses to match in the `SNAT` Rule. This \nmust be supplied as a single IP or Network CIDR. Providing no value for this field results in match with ANY\ndestination network.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                }
            },
            "requiredInputs": [
                "edgeGatewayId",
                "ruleType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtNatRule resources.\n",
                "properties": {
                    "appPortProfileId": {
                        "type": "string",
                        "description": "Application Port Profile to which to apply the rule. The\nApplication Port Profile includes a port, and a protocol that the incoming traffic uses on the edge\ngateway to connect to the internal network.  Can be looked up using `vcd.NsxtAppPortProfile`\ndata source or created using `vcd.NsxtAppPortProfile` resource\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the NAT rule\n"
                    },
                    "dnatExternalPort": {
                        "type": "string",
                        "description": "For `DNAT` only. This represents the external port number or port range when doing \n`DNAT` port forwarding from external to internal. The default dnatExternalPort is ANY meaning traffic on any port\nfor the given IPs selected will be translated.\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enables or disables NAT rule (default `true`)\n"
                    },
                    "externalAddress": {
                        "type": "string",
                        "description": "The external address for the NAT Rule. This must be supplied as a single IP or Network\nCIDR. For a `DNAT` rule, this is the external facing IP Address for incoming traffic. For an `SNAT` rule, this is the\nexternal facing IP Address for outgoing traffic. These IPs are typically allocated/suballocated IP Addresses on the\nEdge Gateway. For a `REFLEXIVE` rule, these are the external facing IPs.\n"
                    },
                    "firewallMatch": {
                        "type": "string",
                        "description": "You can set a firewall match rule to determine how\nfirewall is applied during NAT. One of `MATCH_INTERNAL_ADDRESS`, `MATCH_EXTERNAL_ADDRESS`,\n`BYPASS`\n* `MATCH_INTERNAL_ADDRESS` - applies firewall rules to the internal address of a NAT rule\n* `MATCH_EXTERNAL_ADDRESS` - applies firewall rules to the external address of a NAT rule\n* `BYPASS` - skip applying firewall rules to NAT rule\n"
                    },
                    "internalAddress": {
                        "type": "string",
                        "description": "The internal address for the NAT Rule. This must be supplied as a single IP or\nNetwork CIDR. For a `DNAT` rule, this is the internal IP address for incoming traffic. For an `SNAT` rule, this is the\ninternal IP Address for outgoing traffic. For a `REFLEXIVE` rule, these are the internal IPs.\nThese IPs are typically the Private IPs that are allocated to workloads.\n"
                    },
                    "logging": {
                        "type": "boolean",
                        "description": "Enable to have the address translation performed by this rule logged\n(default `false`). **Note** User might lack rights (**Organization Administrator** role by default\nis missing **Gateway \u003e Configure System Logging** right) to enable logging, but API does not\nreturn error and it is not possible to validate it. `pulumi preview` might show difference on\nevery update.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for NAT rule\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "priority": {
                        "type": "integer",
                        "description": "if an address has multiple NAT rules, you can assign these\nrules different priorities to determine the order in which they are applied. A lower value means a\nhigher priority for this rule.\n"
                    },
                    "ruleType": {
                        "type": "string",
                        "description": "One of `DNAT`, `NO_DNAT`, `SNAT`, `NO_SNAT`, `REFLEXIVE`\n* `DNAT` rule translates the external IP to an internal IP and is used for inbound traffic\n* `NO_DNAT` prevents external IP translation\n* `SNAT` translates an internal IP to an external IP and is used for outbound traffic\n* `NO_SNAT` prevents internal IP translation\n* `REFLEXIVE` (VCD 10.3+)  is also known as Stateless NAT. This translates an internal IP to an external IP and vice\nversa. The number of internal addresses should be exactly the same as that of external addresses.\n",
                        "willReplaceOnChanges": true
                    },
                    "snatDestinationAddress": {
                        "type": "string",
                        "description": "For `SNAT` only. The destination addresses to match in the `SNAT` Rule. This \nmust be supplied as a single IP or Network CIDR. Providing no value for this field results in match with ANY\ndestination network.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtNetworkDhcp:NsxtNetworkDhcp": {
            "properties": {
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The DNS server IPs to be assigned by this\nDHCP service. Maximum two values.\n"
                },
                "leaseTime": {
                    "type": "integer",
                    "description": "Lease time in seconds. Minimum value is 60s\nand maximum is 4294967295s (~ 49 days).\n"
                },
                "listenerIpAddress": {
                    "type": "string",
                    "description": "IP address of DHCP server in network. Must match\nsubnet. **Only** used when `mode=NETWORK`.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "One of `EDGE`, `NETWORK` or `RELAY`. Default is `EDGE`\n* `EDGE` can be used with Routed Org VDC networks.\n* `NETWORK` can be used for Isolated and Routed Org VDC networks. It requires\n`listener_ip_address` to be set and Edge Cluster must be assigned to VDC.\n* `RELAY` can be used with Routed Org VDC networks, but requires DHCP forwarding configuration in\nNSX-T Edge Gateway.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "orgNetworkId": {
                    "type": "string",
                    "description": "ID of parent Org VDC Routed network.\n"
                },
                "pools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtNetworkDhcpPool:NsxtNetworkDhcpPool"
                    },
                    "description": "One or more blocks to define DHCP pool ranges. Must not be set when\n`mode=RELAY`. See Pools and example for usage details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Org network will be looked up based on 'org_network_id' field"
                }
            },
            "required": [
                "leaseTime",
                "orgNetworkId",
                "vdc"
            ],
            "inputProperties": {
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The DNS server IPs to be assigned by this\nDHCP service. Maximum two values.\n"
                },
                "leaseTime": {
                    "type": "integer",
                    "description": "Lease time in seconds. Minimum value is 60s\nand maximum is 4294967295s (~ 49 days).\n"
                },
                "listenerIpAddress": {
                    "type": "string",
                    "description": "IP address of DHCP server in network. Must match\nsubnet. **Only** used when `mode=NETWORK`.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "One of `EDGE`, `NETWORK` or `RELAY`. Default is `EDGE`\n* `EDGE` can be used with Routed Org VDC networks.\n* `NETWORK` can be used for Isolated and Routed Org VDC networks. It requires\n`listener_ip_address` to be set and Edge Cluster must be assigned to VDC.\n* `RELAY` can be used with Routed Org VDC networks, but requires DHCP forwarding configuration in\nNSX-T Edge Gateway.\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "orgNetworkId": {
                    "type": "string",
                    "description": "ID of parent Org VDC Routed network.\n",
                    "willReplaceOnChanges": true
                },
                "pools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtNetworkDhcpPool:NsxtNetworkDhcpPool"
                    },
                    "description": "One or more blocks to define DHCP pool ranges. Must not be set when\n`mode=RELAY`. See Pools and example for usage details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "deprecationMessage": "Org network will be looked up based on 'org_network_id' field"
                }
            },
            "requiredInputs": [
                "orgNetworkId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtNetworkDhcp resources.\n",
                "properties": {
                    "dnsServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The DNS server IPs to be assigned by this\nDHCP service. Maximum two values.\n"
                    },
                    "leaseTime": {
                        "type": "integer",
                        "description": "Lease time in seconds. Minimum value is 60s\nand maximum is 4294967295s (~ 49 days).\n"
                    },
                    "listenerIpAddress": {
                        "type": "string",
                        "description": "IP address of DHCP server in network. Must match\nsubnet. **Only** used when `mode=NETWORK`.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "One of `EDGE`, `NETWORK` or `RELAY`. Default is `EDGE`\n* `EDGE` can be used with Routed Org VDC networks.\n* `NETWORK` can be used for Isolated and Routed Org VDC networks. It requires\n`listener_ip_address` to be set and Edge Cluster must be assigned to VDC.\n* `RELAY` can be used with Routed Org VDC networks, but requires DHCP forwarding configuration in\nNSX-T Edge Gateway.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkId": {
                        "type": "string",
                        "description": "ID of parent Org VDC Routed network.\n",
                        "willReplaceOnChanges": true
                    },
                    "pools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtNetworkDhcpPool:NsxtNetworkDhcpPool"
                        },
                        "description": "One or more blocks to define DHCP pool ranges. Must not be set when\n`mode=RELAY`. See Pools and example for usage details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "deprecationMessage": "Org network will be looked up based on 'org_network_id' field"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtNetworkDhcpBinding:NsxtNetworkDhcpBinding": {
            "properties": {
                "bindingType": {
                    "type": "string",
                    "description": "One of `IPV4` or `IPV6`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of DHCP binding\n"
                },
                "dhcpV4Config": {
                    "$ref": "#/types/vcd:index/NsxtNetworkDhcpBindingDhcpV4Config:NsxtNetworkDhcpBindingDhcpV4Config",
                    "description": "Additional configuration for IPv4 specific options. See IPv4 block\n"
                },
                "dhcpV6Config": {
                    "$ref": "#/types/vcd:index/NsxtNetworkDhcpBindingDhcpV6Config:NsxtNetworkDhcpBindingDhcpV6Config",
                    "description": "Additional configuration for IPv6 specific options. See IPv6 block\n\n\u003ca id=\"ipv4-block\"\u003e\u003c/a\u003e\n"
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS servers. Maximum 2 can be specified\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address used for binding\n"
                },
                "leaseTime": {
                    "type": "integer",
                    "description": "Lease time in seconds. Minimum `3600` seconds\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "MAC address used for binding\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of DHCP binding\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization. Optional if defined at provider level\n"
                },
                "orgNetworkId": {
                    "type": "string",
                    "description": "The ID of an Org VDC network. **Note**  (`.id` field) of\n`vcd.NetworkIsolatedV2`, `vcd.NetworkRoutedV2` or `vcd.NsxtNetworkDhcp` can be referenced\nhere. It is more convenient to use reference to `vcd.NsxtNetworkDhcp` ID because it makes sure\nthat DHCP is enabled before configuring pools\n"
                }
            },
            "required": [
                "bindingType",
                "ipAddress",
                "leaseTime",
                "macAddress",
                "name",
                "orgNetworkId"
            ],
            "inputProperties": {
                "bindingType": {
                    "type": "string",
                    "description": "One of `IPV4` or `IPV6`\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Description of DHCP binding\n"
                },
                "dhcpV4Config": {
                    "$ref": "#/types/vcd:index/NsxtNetworkDhcpBindingDhcpV4Config:NsxtNetworkDhcpBindingDhcpV4Config",
                    "description": "Additional configuration for IPv4 specific options. See IPv4 block\n"
                },
                "dhcpV6Config": {
                    "$ref": "#/types/vcd:index/NsxtNetworkDhcpBindingDhcpV6Config:NsxtNetworkDhcpBindingDhcpV6Config",
                    "description": "Additional configuration for IPv6 specific options. See IPv6 block\n\n\u003ca id=\"ipv4-block\"\u003e\u003c/a\u003e\n"
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS servers. Maximum 2 can be specified\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "IP address used for binding\n"
                },
                "leaseTime": {
                    "type": "integer",
                    "description": "Lease time in seconds. Minimum `3600` seconds\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "MAC address used for binding\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of DHCP binding\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization. Optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "orgNetworkId": {
                    "type": "string",
                    "description": "The ID of an Org VDC network. **Note**  (`.id` field) of\n`vcd.NetworkIsolatedV2`, `vcd.NetworkRoutedV2` or `vcd.NsxtNetworkDhcp` can be referenced\nhere. It is more convenient to use reference to `vcd.NsxtNetworkDhcp` ID because it makes sure\nthat DHCP is enabled before configuring pools\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "bindingType",
                "ipAddress",
                "leaseTime",
                "macAddress",
                "orgNetworkId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtNetworkDhcpBinding resources.\n",
                "properties": {
                    "bindingType": {
                        "type": "string",
                        "description": "One of `IPV4` or `IPV6`\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of DHCP binding\n"
                    },
                    "dhcpV4Config": {
                        "$ref": "#/types/vcd:index/NsxtNetworkDhcpBindingDhcpV4Config:NsxtNetworkDhcpBindingDhcpV4Config",
                        "description": "Additional configuration for IPv4 specific options. See IPv4 block\n"
                    },
                    "dhcpV6Config": {
                        "$ref": "#/types/vcd:index/NsxtNetworkDhcpBindingDhcpV6Config:NsxtNetworkDhcpBindingDhcpV6Config",
                        "description": "Additional configuration for IPv6 specific options. See IPv6 block\n\n\u003ca id=\"ipv4-block\"\u003e\u003c/a\u003e\n"
                    },
                    "dnsServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of DNS servers. Maximum 2 can be specified\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "IP address used for binding\n"
                    },
                    "leaseTime": {
                        "type": "integer",
                        "description": "Lease time in seconds. Minimum `3600` seconds\n"
                    },
                    "macAddress": {
                        "type": "string",
                        "description": "MAC address used for binding\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of DHCP binding\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization. Optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkId": {
                        "type": "string",
                        "description": "The ID of an Org VDC network. **Note**  (`.id` field) of\n`vcd.NetworkIsolatedV2`, `vcd.NetworkRoutedV2` or `vcd.NsxtNetworkDhcp` can be referenced\nhere. It is more convenient to use reference to `vcd.NsxtNetworkDhcp` ID because it makes sure\nthat DHCP is enabled before configuring pools\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtNetworkImported:NsxtNetworkImported": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "dualStackEnabled": {
                    "type": "boolean",
                    "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                },
                "dvpgId": {
                    "type": "string",
                    "description": "ID of Distributed Virtual Port Group used by this network\n"
                },
                "dvpgName": {
                    "type": "string",
                    "description": "Unique name of an existing Distributed Virtual Port Group (DVPG). \n**Note** it will never be refreshed because API does not allow reading this name after it is\nconsumed. Instead ID will be stored in `dvpg_id` attribute.\n\n\u003e One of `nsxt_logical_switch_name` or `dvpg_name` must be provided.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "nsxtLogicalSwitchId": {
                    "type": "string",
                    "description": "ID of NSX-T logical switch used by this network\n"
                },
                "nsxtLogicalSwitchName": {
                    "type": "string",
                    "description": "Unique name of an existing NSX-T segment. \n**Note** it will never be refreshed because API does not allow reading this name after it is\nconsumed. Instead ID will be stored in `nsxt_logical_switch_id` attribute.\n\nThis resource **will fail** if multiple segments with the same name are available. One can rename\nthem in NSX-T manager to make them unique.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n"
                },
                "ownerId": {
                    "type": "string",
                    "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                },
                "secondaryGateway": {
                    "type": "string",
                    "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n"
                },
                "secondaryPrefixLength": {
                    "type": "string",
                    "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n"
                },
                "secondaryStaticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtNetworkImportedSecondaryStaticIpPool:NsxtNetworkImportedSecondaryStaticIpPool"
                    },
                    "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtNetworkImportedStaticIpPool:NsxtNetworkImportedStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                    "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                }
            },
            "required": [
                "dvpgId",
                "gateway",
                "name",
                "nsxtLogicalSwitchId",
                "ownerId",
                "prefixLength",
                "vdc"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network\n"
                },
                "dualStackEnabled": {
                    "type": "boolean",
                    "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                },
                "dvpgName": {
                    "type": "string",
                    "description": "Unique name of an existing Distributed Virtual Port Group (DVPG). \n**Note** it will never be refreshed because API does not allow reading this name after it is\nconsumed. Instead ID will be stored in `dvpg_id` attribute.\n\n\u003e One of `nsxt_logical_switch_name` or `dvpg_name` must be provided.\n",
                    "willReplaceOnChanges": true
                },
                "gateway": {
                    "type": "string",
                    "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network\n"
                },
                "nsxtLogicalSwitchName": {
                    "type": "string",
                    "description": "Unique name of an existing NSX-T segment. \n**Note** it will never be refreshed because API does not allow reading this name after it is\nconsumed. Instead ID will be stored in `nsxt_logical_switch_id` attribute.\n\nThis resource **will fail** if multiple segments with the same name are available. One can rename\nthem in NSX-T manager to make them unique.\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "ownerId": {
                    "type": "string",
                    "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                },
                "prefixLength": {
                    "type": "integer",
                    "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                },
                "secondaryGateway": {
                    "type": "string",
                    "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n",
                    "willReplaceOnChanges": true
                },
                "secondaryPrefixLength": {
                    "type": "string",
                    "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n",
                    "willReplaceOnChanges": true
                },
                "secondaryStaticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtNetworkImportedSecondaryStaticIpPool:NsxtNetworkImportedSecondaryStaticIpPool"
                    },
                    "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtNetworkImportedStaticIpPool:NsxtNetworkImportedStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                    "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                }
            },
            "requiredInputs": [
                "gateway",
                "prefixLength"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtNetworkImported resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the network\n"
                    },
                    "dns1": {
                        "type": "string",
                        "description": "First DNS server to use.\n"
                    },
                    "dns2": {
                        "type": "string",
                        "description": "Second DNS server to use.\n"
                    },
                    "dnsSuffix": {
                        "type": "string",
                        "description": "A FQDN for the virtual machines on this network\n"
                    },
                    "dualStackEnabled": {
                        "type": "boolean",
                        "description": "Enables Dual-Stack mode so that one can configure one\nIPv4 and one IPv6 networks. **Note** In such case *IPv4* addresses must be used in `gateway`,\n`prefix_length` and `static_ip_pool` while *IPv6* addresses in `secondary_gateway`,\n`secondary_prefix_length` and `secondary_static_ip_pool` fields.\n"
                    },
                    "dvpgId": {
                        "type": "string",
                        "description": "ID of Distributed Virtual Port Group used by this network\n"
                    },
                    "dvpgName": {
                        "type": "string",
                        "description": "Unique name of an existing Distributed Virtual Port Group (DVPG). \n**Note** it will never be refreshed because API does not allow reading this name after it is\nconsumed. Instead ID will be stored in `dvpg_id` attribute.\n\n\u003e One of `nsxt_logical_switch_name` or `dvpg_name` must be provided.\n",
                        "willReplaceOnChanges": true
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The gateway for this network (e.g. 192.168.1.1, 2002:0:0:1234:abcd:ffff:c0a7:121)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network\n"
                    },
                    "nsxtLogicalSwitchId": {
                        "type": "string",
                        "description": "ID of NSX-T logical switch used by this network\n"
                    },
                    "nsxtLogicalSwitchName": {
                        "type": "string",
                        "description": "Unique name of an existing NSX-T segment. \n**Note** it will never be refreshed because API does not allow reading this name after it is\nconsumed. Instead ID will be stored in `nsxt_logical_switch_id` attribute.\n\nThis resource **will fail** if multiple segments with the same name are available. One can rename\nthem in NSX-T manager to make them unique.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when\nconnected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                    },
                    "prefixLength": {
                        "type": "integer",
                        "description": "The prefix length for the new network (e.g. 24 for netmask 255.255.255.0).\n"
                    },
                    "secondaryGateway": {
                        "type": "string",
                        "description": "IPv6 gateway *when Dual-Stack mode is enabled*\n",
                        "willReplaceOnChanges": true
                    },
                    "secondaryPrefixLength": {
                        "type": "string",
                        "description": "IPv6 prefix length *when Dual-Stack mode is\nenabled*\n",
                        "willReplaceOnChanges": true
                    },
                    "secondaryStaticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtNetworkImportedSecondaryStaticIpPool:NsxtNetworkImportedSecondaryStaticIpPool"
                        },
                        "description": "One or more IPv6 static\npools *when Dual-Stack mode is enabled*\n\n\u003e When using IPv6, VCD API will expand IP Addresses if they are specified using *double colon*\nnotation and it will cause inconsistent plan. (e.g. `2002::1234:abcd:ffff:c0a6:121` will be\nconverted to `2002:0:0:1234:abcd:ffff:c0a6:121`)\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                    },
                    "staticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtNetworkImportedStaticIpPool:NsxtNetworkImportedStaticIpPool"
                        },
                        "description": "A range of IPs permitted to be used as static IPs for\nvirtual machines; see IP Pools below for details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtNetworkSegmentProfile:NsxtNetworkSegmentProfile": {
            "properties": {
                "ipDiscoveryProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentIpDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_ip_discovery_profile)\ndata source.\n"
                },
                "macDiscoveryProfileId": {
                    "type": "string",
                    "description": "MAC Discovery Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentMacDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_mac_discovery_profile)\ndata source.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level\n"
                },
                "orgNetworkId": {
                    "type": "string",
                    "description": "Org VDC Network ID\n"
                },
                "qosProfileId": {
                    "type": "string",
                    "description": "QoS Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_qos_profile)\ndata source.\n"
                },
                "segmentProfileTemplateId": {
                    "type": "string",
                    "description": "Segment Profile Template ID to be applied for this Org\nVDC Network\n"
                },
                "segmentProfileTemplateName": {
                    "type": "string",
                    "description": "Segment Profile Template Name\n"
                },
                "segmentSecurityProfileId": {
                    "type": "string",
                    "description": "Segment Security Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentSecurityProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_security_profile)\ndata source.\n"
                },
                "spoofGuardProfileId": {
                    "type": "string",
                    "description": "Spoof Guard Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentSpoofGuardProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_spoof_guard_profile)\ndata source.\n"
                }
            },
            "required": [
                "ipDiscoveryProfileId",
                "macDiscoveryProfileId",
                "orgNetworkId",
                "qosProfileId",
                "segmentProfileTemplateName",
                "segmentSecurityProfileId",
                "spoofGuardProfileId"
            ],
            "inputProperties": {
                "ipDiscoveryProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentIpDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_ip_discovery_profile)\ndata source.\n"
                },
                "macDiscoveryProfileId": {
                    "type": "string",
                    "description": "MAC Discovery Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentMacDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_mac_discovery_profile)\ndata source.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "orgNetworkId": {
                    "type": "string",
                    "description": "Org VDC Network ID\n"
                },
                "qosProfileId": {
                    "type": "string",
                    "description": "QoS Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_qos_profile)\ndata source.\n"
                },
                "segmentProfileTemplateId": {
                    "type": "string",
                    "description": "Segment Profile Template ID to be applied for this Org\nVDC Network\n"
                },
                "segmentSecurityProfileId": {
                    "type": "string",
                    "description": "Segment Security Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentSecurityProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_security_profile)\ndata source.\n"
                },
                "spoofGuardProfileId": {
                    "type": "string",
                    "description": "Spoof Guard Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentSpoofGuardProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_spoof_guard_profile)\ndata source.\n"
                }
            },
            "requiredInputs": [
                "orgNetworkId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtNetworkSegmentProfile resources.\n",
                "properties": {
                    "ipDiscoveryProfileId": {
                        "type": "string",
                        "description": "IP Discovery Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentIpDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_ip_discovery_profile)\ndata source.\n"
                    },
                    "macDiscoveryProfileId": {
                        "type": "string",
                        "description": "MAC Discovery Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentMacDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_mac_discovery_profile)\ndata source.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkId": {
                        "type": "string",
                        "description": "Org VDC Network ID\n"
                    },
                    "qosProfileId": {
                        "type": "string",
                        "description": "QoS Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_qos_profile)\ndata source.\n"
                    },
                    "segmentProfileTemplateId": {
                        "type": "string",
                        "description": "Segment Profile Template ID to be applied for this Org\nVDC Network\n"
                    },
                    "segmentProfileTemplateName": {
                        "type": "string",
                        "description": "Segment Profile Template Name\n"
                    },
                    "segmentSecurityProfileId": {
                        "type": "string",
                        "description": "Segment Security Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentSecurityProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_security_profile)\ndata source.\n"
                    },
                    "spoofGuardProfileId": {
                        "type": "string",
                        "description": "Spoof Guard Profile ID. Can be referenced using\n[`vcd.getNsxtSegmentSpoofGuardProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_spoof_guard_profile)\ndata source.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtRouteAdvertisement:NsxtRouteAdvertisement": {
            "properties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID in which route advertisement is located.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Define if route advertisement is active. Default `true`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organizations.\n"
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of subnets that will be advertised to Tier-0 gateway. Leaving it empty means none.\n"
                }
            },
            "required": [
                "edgeGatewayId"
            ],
            "inputProperties": {
                "edgeGatewayId": {
                    "type": "string",
                    "description": "NSX-T Edge Gateway ID in which route advertisement is located.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Define if route advertisement is active. Default `true`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organizations.\n",
                    "willReplaceOnChanges": true
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of subnets that will be advertised to Tier-0 gateway. Leaving it empty means none.\n"
                }
            },
            "requiredInputs": [
                "edgeGatewayId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtRouteAdvertisement resources.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID in which route advertisement is located.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Define if route advertisement is active. Default `true`.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organizations.\n",
                        "willReplaceOnChanges": true
                    },
                    "subnets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of subnets that will be advertised to Tier-0 gateway. Leaving it empty means none.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtSecurityGroup:NsxtSecurityGroup": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the Security Group\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n"
                },
                "memberOrgNetworkIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Org Network IDs\n"
                },
                "memberVms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxtSecurityGroupMemberVm:NsxtSecurityGroupMemberVm"
                    },
                    "description": "A set of member VMs (if exist). see Member VMs below for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for Security Group\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "ownerId": {
                    "type": "string",
                    "description": "ID of VDC or VDC Group\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                    "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. Security Group will inherit VDC from parent Edge Gateway."
                }
            },
            "required": [
                "edgeGatewayId",
                "memberVms",
                "name",
                "ownerId",
                "vdc"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the Security Group\n"
                },
                "edgeGatewayId": {
                    "type": "string",
                    "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n",
                    "willReplaceOnChanges": true
                },
                "memberOrgNetworkIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Org Network IDs\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for Security Group\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                    "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. Security Group will inherit VDC from parent Edge Gateway."
                }
            },
            "requiredInputs": [
                "edgeGatewayId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtSecurityGroup resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description of the Security Group\n"
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n",
                        "willReplaceOnChanges": true
                    },
                    "memberOrgNetworkIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of Org Network IDs\n"
                    },
                    "memberVms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxtSecurityGroupMemberVm:NsxtSecurityGroupMemberVm"
                        },
                        "description": "A set of member VMs (if exist). see Member VMs below for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for Security Group\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "ID of VDC or VDC Group\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. Security Group will inherit VDC from parent Edge Gateway."
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxtSegmentProfileTemplate:NsxtSegmentProfileTemplate": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of Segment Profile Template\n"
                },
                "ipDiscoveryProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentIpDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_ip_discovery_profile)\n"
                },
                "macDiscoveryProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentMacDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_mac_discovery_profile)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for Segment Profile Template\n"
                },
                "nsxtManagerId": {
                    "type": "string",
                    "description": "NSX-T Manager ID (can be referenced using\n[`vcd.getNsxtManager`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_manager) datasource)\n"
                },
                "qosProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_qos_profile)\n"
                },
                "segmentSecurityProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentSecurityProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_security_profile)\n"
                },
                "spoofGuardProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentSpoofGuardProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_spoof_guard_profile)\n"
                }
            },
            "required": [
                "name",
                "nsxtManagerId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of Segment Profile Template\n"
                },
                "ipDiscoveryProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentIpDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_ip_discovery_profile)\n"
                },
                "macDiscoveryProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentMacDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_mac_discovery_profile)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for Segment Profile Template\n"
                },
                "nsxtManagerId": {
                    "type": "string",
                    "description": "NSX-T Manager ID (can be referenced using\n[`vcd.getNsxtManager`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_manager) datasource)\n"
                },
                "qosProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_qos_profile)\n"
                },
                "segmentSecurityProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentSecurityProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_security_profile)\n"
                },
                "spoofGuardProfileId": {
                    "type": "string",
                    "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentSpoofGuardProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_spoof_guard_profile)\n"
                }
            },
            "requiredInputs": [
                "nsxtManagerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxtSegmentProfileTemplate resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of Segment Profile Template\n"
                    },
                    "ipDiscoveryProfileId": {
                        "type": "string",
                        "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentIpDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_ip_discovery_profile)\n"
                    },
                    "macDiscoveryProfileId": {
                        "type": "string",
                        "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentMacDiscoveryProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_mac_discovery_profile)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name for Segment Profile Template\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "NSX-T Manager ID (can be referenced using\n[`vcd.getNsxtManager`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_manager) datasource)\n"
                    },
                    "qosProfileId": {
                        "type": "string",
                        "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentQosProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_qos_profile)\n"
                    },
                    "segmentSecurityProfileId": {
                        "type": "string",
                        "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentSecurityProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_security_profile)\n"
                    },
                    "spoofGuardProfileId": {
                        "type": "string",
                        "description": "IP Discovery Profile ID. can be referenced using\n[`vcd.getNsxtSegmentSpoofGuardProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_segment_spoof_guard_profile)\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxvDhcpRelay:NsxvDhcpRelay": {
            "properties": {
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of domain names.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which DHCP relay is to be configured.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses.\n"
                },
                "ipSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP set names.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "relayAgents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDhcpRelayRelayAgent:NsxvDhcpRelayRelayAgent"
                    },
                    "description": "One or more blocks to define Org network and optional IP address of\nedge gateway interfaces from which DHCP messages are to be relayed to the external DHCP relay\nserver(s). See Relay Agent and example for usage details.\n\n\u003ca id=\"relay-agent\"\u003e\u003c/a\u003e\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "edgeGateway",
                "relayAgents"
            ],
            "inputProperties": {
                "domainNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of domain names.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which DHCP relay is to be configured.\n",
                    "willReplaceOnChanges": true
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses.\n"
                },
                "ipSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP set names.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "relayAgents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDhcpRelayRelayAgent:NsxvDhcpRelayRelayAgent"
                    },
                    "description": "One or more blocks to define Org network and optional IP address of\nedge gateway interfaces from which DHCP messages are to be relayed to the external DHCP relay\nserver(s). See Relay Agent and example for usage details.\n\n\u003ca id=\"relay-agent\"\u003e\u003c/a\u003e\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "relayAgents"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxvDhcpRelay resources.\n",
                "properties": {
                    "domainNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of domain names.\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which DHCP relay is to be configured.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of IP addresses.\n"
                    },
                    "ipSets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of IP set names.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "relayAgents": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxvDhcpRelayRelayAgent:NsxvDhcpRelayRelayAgent"
                        },
                        "description": "One or more blocks to define Org network and optional IP address of\nedge gateway interfaces from which DHCP messages are to be relayed to the external DHCP relay\nserver(s). See Relay Agent and example for usage details.\n\n\u003ca id=\"relay-agent\"\u003e\u003c/a\u003e\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxvDistributedFirewall:NsxvDistributedFirewall": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Shows whether the NSX-V Distributed Firewall is enabled.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDistributedFirewallRule:NsxvDistributedFirewallRule"
                    },
                    "description": "One or more blocks with Firewall Rule definitions. **Order\ndefines firewall rule precedence**. If no rules are defined, all will be removed from the firewall\n"
                },
                "vdcId": {
                    "type": "string",
                    "description": "The ID of VDC to manage the Distributed Firewall in. Can be looked up using a `vcd.OrgVdc` data source\n"
                }
            },
            "required": [
                "enabled",
                "vdcId"
            ],
            "inputProperties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvDistributedFirewallRule:NsxvDistributedFirewallRule"
                    },
                    "description": "One or more blocks with Firewall Rule definitions. **Order\ndefines firewall rule precedence**. If no rules are defined, all will be removed from the firewall\n"
                },
                "vdcId": {
                    "type": "string",
                    "description": "The ID of VDC to manage the Distributed Firewall in. Can be looked up using a `vcd.OrgVdc` data source\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "vdcId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxvDistributedFirewall resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Shows whether the NSX-V Distributed Firewall is enabled.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxvDistributedFirewallRule:NsxvDistributedFirewallRule"
                        },
                        "description": "One or more blocks with Firewall Rule definitions. **Order\ndefines firewall rule precedence**. If no rules are defined, all will be removed from the firewall\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of VDC to manage the Distributed Firewall in. Can be looked up using a `vcd.OrgVdc` data source\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxvDnat:NsxvDnat": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the DNAT rule.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabaled. Default `true`.\n"
                },
                "icmpType": {
                    "type": "string",
                    "description": "Only when `protocol` is set to `icmp`. One of `any`,\n`address-mask-request`, `address-mask-reply`, `destination-unreachable`, `echo-request`,\n`echo-reply`, `parameter-problem`, `redirect`, `router-advertisement`, `router-solicitation`,\n`source-quench`, `time-exceeded`, `timestamp-request`, `timestamp-reply`. Default `any`\n"
                },
                "loggingEnabled": {
                    "type": "boolean",
                    "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "The name of the network on which to apply the DNAT rule.\n"
                },
                "networkType": {
                    "type": "string",
                    "description": "Type of the network on which to apply the DNAT rule. Possible values\n`org` or `ext`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "originalAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. This address must be the public IP\naddress of the edge gateway for which you are configuring the DNAT rule. In the packet being\ninspected, this IP address or range would be those that appear as the destination IP address of the\npacket. These packet destination addresses are the ones translated by this DNAT rule.\n"
                },
                "originalPort": {
                    "type": "string",
                    "description": "Select the port or port range that the incoming traffic uses on the\nedge gateway to connect to the internal network on which the virtual machines are connected. This\nselection is not available when the Protocol is set to `icmp` or `any`. Default `any`.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Select the protocol to which the rule applies. One of `tcp`, `udp`,\n`icmp`, `any`. Default `any`\nprotocols, select Any.\n"
                },
                "ruleTag": {
                    "type": "integer",
                    "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "Possible values - `user`, `internal_high`.\n"
                },
                "translatedAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. IP addresses to which destination\naddresses on inbound packets will be translated. These addresses are the IP addresses of the one or\nmore virtual machines for which you are configuring DNAT so that they can receive traffic from the\nexternal network.\n"
                },
                "translatedPort": {
                    "type": "string",
                    "description": "Select the port or port range that inbound traffic is connecting\nto on the virtual machines on the internal network. These ports are the ones into which the DNAT\nrule is translating for the packets inbound to the virtual machines.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "edgeGateway",
                "networkName",
                "networkType",
                "originalAddress",
                "ruleTag",
                "ruleType"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the DNAT rule.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabaled. Default `true`.\n"
                },
                "icmpType": {
                    "type": "string",
                    "description": "Only when `protocol` is set to `icmp`. One of `any`,\n`address-mask-request`, `address-mask-reply`, `destination-unreachable`, `echo-request`,\n`echo-reply`, `parameter-problem`, `redirect`, `router-advertisement`, `router-solicitation`,\n`source-quench`, `time-exceeded`, `timestamp-request`, `timestamp-reply`. Default `any`\n"
                },
                "loggingEnabled": {
                    "type": "boolean",
                    "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "The name of the network on which to apply the DNAT rule.\n"
                },
                "networkType": {
                    "type": "string",
                    "description": "Type of the network on which to apply the DNAT rule. Possible values\n`org` or `ext`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "originalAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. This address must be the public IP\naddress of the edge gateway for which you are configuring the DNAT rule. In the packet being\ninspected, this IP address or range would be those that appear as the destination IP address of the\npacket. These packet destination addresses are the ones translated by this DNAT rule.\n"
                },
                "originalPort": {
                    "type": "string",
                    "description": "Select the port or port range that the incoming traffic uses on the\nedge gateway to connect to the internal network on which the virtual machines are connected. This\nselection is not available when the Protocol is set to `icmp` or `any`. Default `any`.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Select the protocol to which the rule applies. One of `tcp`, `udp`,\n`icmp`, `any`. Default `any`\nprotocols, select Any.\n"
                },
                "ruleTag": {
                    "type": "integer",
                    "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n",
                    "willReplaceOnChanges": true
                },
                "ruleType": {
                    "type": "string",
                    "description": "Possible values - `user`, `internal_high`.\n"
                },
                "translatedAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. IP addresses to which destination\naddresses on inbound packets will be translated. These addresses are the IP addresses of the one or\nmore virtual machines for which you are configuring DNAT so that they can receive traffic from the\nexternal network.\n"
                },
                "translatedPort": {
                    "type": "string",
                    "description": "Select the port or port range that inbound traffic is connecting\nto on the virtual machines on the internal network. These ports are the ones into which the DNAT\nrule is translating for the packets inbound to the virtual machines.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "networkName",
                "networkType",
                "originalAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxvDnat resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which to apply the DNAT rule.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Defines if the rule is enabaled. Default `true`.\n"
                    },
                    "icmpType": {
                        "type": "string",
                        "description": "Only when `protocol` is set to `icmp`. One of `any`,\n`address-mask-request`, `address-mask-reply`, `destination-unreachable`, `echo-request`,\n`echo-reply`, `parameter-problem`, `redirect`, `router-advertisement`, `router-solicitation`,\n`source-quench`, `time-exceeded`, `timestamp-request`, `timestamp-reply`. Default `any`\n"
                    },
                    "loggingEnabled": {
                        "type": "boolean",
                        "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                    },
                    "networkName": {
                        "type": "string",
                        "description": "The name of the network on which to apply the DNAT rule.\n"
                    },
                    "networkType": {
                        "type": "string",
                        "description": "Type of the network on which to apply the DNAT rule. Possible values\n`org` or `ext`.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "originalAddress": {
                        "type": "string",
                        "description": "IP address, range or subnet. This address must be the public IP\naddress of the edge gateway for which you are configuring the DNAT rule. In the packet being\ninspected, this IP address or range would be those that appear as the destination IP address of the\npacket. These packet destination addresses are the ones translated by this DNAT rule.\n"
                    },
                    "originalPort": {
                        "type": "string",
                        "description": "Select the port or port range that the incoming traffic uses on the\nedge gateway to connect to the internal network on which the virtual machines are connected. This\nselection is not available when the Protocol is set to `icmp` or `any`. Default `any`.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Select the protocol to which the rule applies. One of `tcp`, `udp`,\n`icmp`, `any`. Default `any`\nprotocols, select Any.\n"
                    },
                    "ruleTag": {
                        "type": "integer",
                        "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleType": {
                        "type": "string",
                        "description": "Possible values - `user`, `internal_high`.\n"
                    },
                    "translatedAddress": {
                        "type": "string",
                        "description": "IP address, range or subnet. IP addresses to which destination\naddresses on inbound packets will be translated. These addresses are the IP addresses of the one or\nmore virtual machines for which you are configuring DNAT so that they can receive traffic from the\nexternal network.\n"
                    },
                    "translatedPort": {
                        "type": "string",
                        "description": "Select the port or port range that inbound traffic is connecting\nto on the virtual machines on the internal network. These ports are the ones into which the DNAT\nrule is translating for the packets inbound to the virtual machines.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxvFirewallRule:NsxvFirewallRule": {
            "properties": {
                "aboveRuleId": {
                    "type": "string",
                    "description": "This can be used to alter default rule placement order. By default\nevery rule is appended to the end of firewall rule list. When a value of another rule is set - this\nrule will be placed above the specified rule.\n"
                },
                "action": {
                    "type": "string",
                    "description": "Defines if the rule is set to `accept` or `deny` traffic. Default `accept`\n"
                },
                "destination": {
                    "$ref": "#/types/vcd:index/NsxvFirewallRuleDestination:NsxvFirewallRuleDestination",
                    "description": "Exactly one block to define source criteria for firewall. See\nEndpoint and example for usage details.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the firewall rule.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabaled. Default `true`.\n"
                },
                "loggingEnabled": {
                    "type": "boolean",
                    "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Free text name. Can be duplicate.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "ruleTag": {
                    "type": "integer",
                    "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "Possible values - `user`, `internal_high`.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvFirewallRuleService:NsxvFirewallRuleService"
                    },
                    "description": "One or more blocks to define protocol and port details. Use multiple blocks\nif you want to define multiple port/protocol combinations for the same rule. See\nService and example for usage details.\n\n\n\u003ca id=\"endpoint\"\u003e\u003c/a\u003e\n"
                },
                "source": {
                    "$ref": "#/types/vcd:index/NsxvFirewallRuleSource:NsxvFirewallRuleSource",
                    "description": "Exactly one block to define source criteria for firewall. See\nEndpoint and example for usage details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "destination",
                "edgeGateway",
                "name",
                "ruleTag",
                "ruleType",
                "services",
                "source"
            ],
            "inputProperties": {
                "aboveRuleId": {
                    "type": "string",
                    "description": "This can be used to alter default rule placement order. By default\nevery rule is appended to the end of firewall rule list. When a value of another rule is set - this\nrule will be placed above the specified rule.\n",
                    "willReplaceOnChanges": true
                },
                "action": {
                    "type": "string",
                    "description": "Defines if the rule is set to `accept` or `deny` traffic. Default `accept`\n"
                },
                "destination": {
                    "$ref": "#/types/vcd:index/NsxvFirewallRuleDestination:NsxvFirewallRuleDestination",
                    "description": "Exactly one block to define source criteria for firewall. See\nEndpoint and example for usage details.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the firewall rule.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabaled. Default `true`.\n"
                },
                "loggingEnabled": {
                    "type": "boolean",
                    "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Free text name. Can be duplicate.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "ruleTag": {
                    "type": "integer",
                    "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n",
                    "willReplaceOnChanges": true
                },
                "ruleType": {
                    "type": "string",
                    "description": "Possible values - `user`, `internal_high`.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/NsxvFirewallRuleService:NsxvFirewallRuleService"
                    },
                    "description": "One or more blocks to define protocol and port details. Use multiple blocks\nif you want to define multiple port/protocol combinations for the same rule. See\nService and example for usage details.\n\n\n\u003ca id=\"endpoint\"\u003e\u003c/a\u003e\n"
                },
                "source": {
                    "$ref": "#/types/vcd:index/NsxvFirewallRuleSource:NsxvFirewallRuleSource",
                    "description": "Exactly one block to define source criteria for firewall. See\nEndpoint and example for usage details.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "destination",
                "edgeGateway",
                "services",
                "source"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxvFirewallRule resources.\n",
                "properties": {
                    "aboveRuleId": {
                        "type": "string",
                        "description": "This can be used to alter default rule placement order. By default\nevery rule is appended to the end of firewall rule list. When a value of another rule is set - this\nrule will be placed above the specified rule.\n",
                        "willReplaceOnChanges": true
                    },
                    "action": {
                        "type": "string",
                        "description": "Defines if the rule is set to `accept` or `deny` traffic. Default `accept`\n"
                    },
                    "destination": {
                        "$ref": "#/types/vcd:index/NsxvFirewallRuleDestination:NsxvFirewallRuleDestination",
                        "description": "Exactly one block to define source criteria for firewall. See\nEndpoint and example for usage details.\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which to apply the firewall rule.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Defines if the rule is enabaled. Default `true`.\n"
                    },
                    "loggingEnabled": {
                        "type": "boolean",
                        "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Free text name. Can be duplicate.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleTag": {
                        "type": "integer",
                        "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleType": {
                        "type": "string",
                        "description": "Possible values - `user`, `internal_high`.\n"
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/NsxvFirewallRuleService:NsxvFirewallRuleService"
                        },
                        "description": "One or more blocks to define protocol and port details. Use multiple blocks\nif you want to define multiple port/protocol combinations for the same rule. See\nService and example for usage details.\n\n\n\u003ca id=\"endpoint\"\u003e\u003c/a\u003e\n"
                    },
                    "source": {
                        "$ref": "#/types/vcd:index/NsxvFirewallRuleSource:NsxvFirewallRuleSource",
                        "description": "Exactly one block to define source criteria for firewall. See\nEndpoint and example for usage details.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxvIpSet:NsxvIpSet": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description for IP set.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses, CIDRs and ranges as strings.\n"
                },
                "isInheritanceAllowed": {
                    "type": "boolean",
                    "description": "Toggle to enable inheritance to allow visibility at underlying scopes. Default `true`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique IP set name.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                }
            },
            "required": [
                "ipAddresses",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description for IP set.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of IP addresses, CIDRs and ranges as strings.\n"
                },
                "isInheritanceAllowed": {
                    "type": "boolean",
                    "description": "Toggle to enable inheritance to allow visibility at underlying scopes. Default `true`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique IP set name.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ipAddresses"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxvIpSet resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description for IP set.\n"
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of IP addresses, CIDRs and ranges as strings.\n"
                    },
                    "isInheritanceAllowed": {
                        "type": "boolean",
                        "description": "Toggle to enable inheritance to allow visibility at underlying scopes. Default `true`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Unique IP set name.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/nsxvSnat:NsxvSnat": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the SNAT rule.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabaled. Default `true`.\n"
                },
                "loggingEnabled": {
                    "type": "boolean",
                    "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "The name of the network on which to apply the SNAT rule.\n"
                },
                "networkType": {
                    "type": "string",
                    "description": "Type of the network on which to apply the DNAT rule. Possible values\n`org` or `ext`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "originalAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. These addresses are the IP addresses\nof one or more virtual machines for which you are configuring the SNAT rule so that they can send\ntraffic to the external network.\n"
                },
                "ruleTag": {
                    "type": "integer",
                    "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "Possible values - `user`, `internal_high`.\n"
                },
                "translatedAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. This address is always the public\nIP address of the gateway for which you are configuring the SNAT rule. Specifies the IP address to\nwhich source addresses (the virtual machines) on outbound packets are translated to when they send\ntraffic to the external network.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "edgeGateway",
                "networkName",
                "networkType",
                "originalAddress",
                "ruleTag",
                "ruleType"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "edgeGateway": {
                    "type": "string",
                    "description": "The name of the edge gateway on which to apply the SNAT rule.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the rule is enabaled. Default `true`.\n"
                },
                "loggingEnabled": {
                    "type": "boolean",
                    "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "The name of the network on which to apply the SNAT rule.\n"
                },
                "networkType": {
                    "type": "string",
                    "description": "Type of the network on which to apply the DNAT rule. Possible values\n`org` or `ext`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "originalAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. These addresses are the IP addresses\nof one or more virtual machines for which you are configuring the SNAT rule so that they can send\ntraffic to the external network.\n"
                },
                "ruleTag": {
                    "type": "integer",
                    "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n",
                    "willReplaceOnChanges": true
                },
                "ruleType": {
                    "type": "string",
                    "description": "Possible values - `user`, `internal_high`.\n"
                },
                "translatedAddress": {
                    "type": "string",
                    "description": "IP address, range or subnet. This address is always the public\nIP address of the gateway for which you are configuring the SNAT rule. Specifies the IP address to\nwhich source addresses (the virtual machines) on outbound packets are translated to when they send\ntraffic to the external network.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeGateway",
                "networkName",
                "networkType",
                "originalAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NsxvSnat resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which to apply the SNAT rule.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Defines if the rule is enabaled. Default `true`.\n"
                    },
                    "loggingEnabled": {
                        "type": "boolean",
                        "description": "Defines if the logging for this rule is enabaled. Default `false`.\n"
                    },
                    "networkName": {
                        "type": "string",
                        "description": "The name of the network on which to apply the SNAT rule.\n"
                    },
                    "networkType": {
                        "type": "string",
                        "description": "Type of the network on which to apply the DNAT rule. Possible values\n`org` or `ext`.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "originalAddress": {
                        "type": "string",
                        "description": "IP address, range or subnet. These addresses are the IP addresses\nof one or more virtual machines for which you are configuring the SNAT rule so that they can send\ntraffic to the external network.\n"
                    },
                    "ruleTag": {
                        "type": "integer",
                        "description": "This can be used to specify user-controlled rule tag. If not specified,\nit will report rule ID after creation. Must be between 65537-131072.\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleType": {
                        "type": "string",
                        "description": "Possible values - `user`, `internal_high`.\n"
                    },
                    "translatedAddress": {
                        "type": "string",
                        "description": "IP address, range or subnet. This address is always the public\nIP address of the gateway for which you are configuring the SNAT rule. Specifies the IP address to\nwhich source addresses (the virtual machines) on outbound packets are translated to when they send\ntraffic to the external network.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/org:Org": {
            "properties": {
                "accountLockout": {
                    "$ref": "#/types/vcd:index/OrgAccountLockout:OrgAccountLockout",
                    "description": "Defines account lockout properties in this organization:\n"
                },
                "canPublishCatalogs": {
                    "type": "boolean",
                    "description": "True if this organization is allowed to share catalogs. Default is `true`.\n"
                },
                "canPublishExternalCatalogs": {
                    "type": "boolean",
                    "description": "True if this organization is allowed to publish external catalogs. Default is `false`.\n"
                },
                "canSubscribeExternalCatalogs": {
                    "type": "boolean",
                    "description": "True if this organization is allowed to subscribe to external catalogs. Default is `false`.\n"
                },
                "delayAfterPowerOnSeconds": {
                    "type": "integer",
                    "description": "Specifies this organization's default for virtual machine boot delay after power on. Default is `0`.\n"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "Pass `delete_force=true` and `delete_recursive=true` to remove an organization or VDC and any objects it contains, regardless of their state. Default is `false`\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "Pass `delete_recursive=true` as query parameter to remove an organization or VDC and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                },
                "deployedVmQuota": {
                    "type": "integer",
                    "description": "Maximum number of virtual machines that can be deployed simultaneously by a member of this organization. Default is unlimited (0)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Org description. Default is empty.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "Org full name\n"
                },
                "isEnabled": {
                    "type": "boolean",
                    "description": "True if this organization is enabled (allows login and all other operations). Default is `true`.\n"
                },
                "listOfCatalogs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v3.11+*) List of catalogs (sorted alphabetically), owned or shared, available to this organization.\n"
                },
                "listOfVdcs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v3.11+*) List of VDCs (sorted alphabetically), owned or shared, available to this organization.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this organization.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgMetadataEntry:OrgMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Org name\n"
                },
                "numberOfCatalogs": {
                    "type": "integer",
                    "description": "(*v3.11+*) Number of catalogs owned or shared, available to this organization.\n"
                },
                "numberOfVdcs": {
                    "type": "integer",
                    "description": "(*v3.11+*) Number of VDCs owned or shared, available to this organization.\n"
                },
                "storedVmQuota": {
                    "type": "integer",
                    "description": "Maximum number of virtual machines in vApps or vApp templates that can be stored in an undeployed state by a member of this organization. Default is unlimited (0)\n"
                },
                "vappLease": {
                    "$ref": "#/types/vcd:index/OrgVappLease:OrgVappLease",
                    "description": "Defines lease parameters for vApps created in this organization. See vApp Lease below for details.\n"
                },
                "vappTemplateLease": {
                    "$ref": "#/types/vcd:index/OrgVappTemplateLease:OrgVappTemplateLease",
                    "description": "Defines lease parameters for vApp templates created in this organization. See vApp Template Lease below for details.\n"
                }
            },
            "required": [
                "accountLockout",
                "fullName",
                "listOfCatalogs",
                "listOfVdcs",
                "metadata",
                "metadataEntries",
                "name",
                "numberOfCatalogs",
                "numberOfVdcs",
                "vappLease",
                "vappTemplateLease"
            ],
            "inputProperties": {
                "accountLockout": {
                    "$ref": "#/types/vcd:index/OrgAccountLockout:OrgAccountLockout",
                    "description": "Defines account lockout properties in this organization:\n"
                },
                "canPublishCatalogs": {
                    "type": "boolean",
                    "description": "True if this organization is allowed to share catalogs. Default is `true`.\n"
                },
                "canPublishExternalCatalogs": {
                    "type": "boolean",
                    "description": "True if this organization is allowed to publish external catalogs. Default is `false`.\n"
                },
                "canSubscribeExternalCatalogs": {
                    "type": "boolean",
                    "description": "True if this organization is allowed to subscribe to external catalogs. Default is `false`.\n"
                },
                "delayAfterPowerOnSeconds": {
                    "type": "integer",
                    "description": "Specifies this organization's default for virtual machine boot delay after power on. Default is `0`.\n"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "Pass `delete_force=true` and `delete_recursive=true` to remove an organization or VDC and any objects it contains, regardless of their state. Default is `false`\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "Pass `delete_recursive=true` as query parameter to remove an organization or VDC and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                },
                "deployedVmQuota": {
                    "type": "integer",
                    "description": "Maximum number of virtual machines that can be deployed simultaneously by a member of this organization. Default is unlimited (0)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Org description. Default is empty.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "Org full name\n"
                },
                "isEnabled": {
                    "type": "boolean",
                    "description": "True if this organization is enabled (allows login and all other operations). Default is `true`.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this organization.\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgMetadataEntry:OrgMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Org name\n"
                },
                "storedVmQuota": {
                    "type": "integer",
                    "description": "Maximum number of virtual machines in vApps or vApp templates that can be stored in an undeployed state by a member of this organization. Default is unlimited (0)\n"
                },
                "vappLease": {
                    "$ref": "#/types/vcd:index/OrgVappLease:OrgVappLease",
                    "description": "Defines lease parameters for vApps created in this organization. See vApp Lease below for details.\n"
                },
                "vappTemplateLease": {
                    "$ref": "#/types/vcd:index/OrgVappTemplateLease:OrgVappTemplateLease",
                    "description": "Defines lease parameters for vApp templates created in this organization. See vApp Template Lease below for details.\n"
                }
            },
            "requiredInputs": [
                "fullName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Org resources.\n",
                "properties": {
                    "accountLockout": {
                        "$ref": "#/types/vcd:index/OrgAccountLockout:OrgAccountLockout",
                        "description": "Defines account lockout properties in this organization:\n"
                    },
                    "canPublishCatalogs": {
                        "type": "boolean",
                        "description": "True if this organization is allowed to share catalogs. Default is `true`.\n"
                    },
                    "canPublishExternalCatalogs": {
                        "type": "boolean",
                        "description": "True if this organization is allowed to publish external catalogs. Default is `false`.\n"
                    },
                    "canSubscribeExternalCatalogs": {
                        "type": "boolean",
                        "description": "True if this organization is allowed to subscribe to external catalogs. Default is `false`.\n"
                    },
                    "delayAfterPowerOnSeconds": {
                        "type": "integer",
                        "description": "Specifies this organization's default for virtual machine boot delay after power on. Default is `0`.\n"
                    },
                    "deleteForce": {
                        "type": "boolean",
                        "description": "Pass `delete_force=true` and `delete_recursive=true` to remove an organization or VDC and any objects it contains, regardless of their state. Default is `false`\n"
                    },
                    "deleteRecursive": {
                        "type": "boolean",
                        "description": "Pass `delete_recursive=true` as query parameter to remove an organization or VDC and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                    },
                    "deployedVmQuota": {
                        "type": "integer",
                        "description": "Maximum number of virtual machines that can be deployed simultaneously by a member of this organization. Default is unlimited (0)\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Org description. Default is empty.\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "Org full name\n"
                    },
                    "isEnabled": {
                        "type": "boolean",
                        "description": "True if this organization is enabled (allows login and all other operations). Default is `true`.\n"
                    },
                    "listOfCatalogs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v3.11+*) List of catalogs (sorted alphabetically), owned or shared, available to this organization.\n"
                    },
                    "listOfVdcs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v3.11+*) List of VDCs (sorted alphabetically), owned or shared, available to this organization.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this organization.\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/OrgMetadataEntry:OrgMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Org name\n"
                    },
                    "numberOfCatalogs": {
                        "type": "integer",
                        "description": "(*v3.11+*) Number of catalogs owned or shared, available to this organization.\n"
                    },
                    "numberOfVdcs": {
                        "type": "integer",
                        "description": "(*v3.11+*) Number of VDCs owned or shared, available to this organization.\n"
                    },
                    "storedVmQuota": {
                        "type": "integer",
                        "description": "Maximum number of virtual machines in vApps or vApp templates that can be stored in an undeployed state by a member of this organization. Default is unlimited (0)\n"
                    },
                    "vappLease": {
                        "$ref": "#/types/vcd:index/OrgVappLease:OrgVappLease",
                        "description": "Defines lease parameters for vApps created in this organization. See vApp Lease below for details.\n"
                    },
                    "vappTemplateLease": {
                        "$ref": "#/types/vcd:index/OrgVappTemplateLease:OrgVappTemplateLease",
                        "description": "Defines lease parameters for vApp templates created in this organization. See vApp Template Lease below for details.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgGroup:OrgGroup": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of Organization group\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the group.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Identity provider type for this this group. One of `SAML`, `OAUTH` or\n`INTEGRATED`. **Note** `LDAP` must be configured to create `INTEGRATED` groups and names must\nmatch `LDAP` group names. If LDAP is not configured - it will return 403 errors.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The role of the group. Role names can be retrieved from the organization. Both built-in roles and\ncustom built can be used. The roles normally available are:\n* `Organization Administrator`\n* `Catalog Author`\n* `vApp Author`\n* `vApp User`\n* `Console Access Only`\n* `Defer to Identity Provider`\n"
                },
                "userNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of user names that belong to this group. It's only populated if the users\nare created after the group (with `depends_on` the given group).\n"
                }
            },
            "required": [
                "name",
                "providerType",
                "role",
                "userNames"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of Organization group\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the group.\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "providerType": {
                    "type": "string",
                    "description": "Identity provider type for this this group. One of `SAML`, `OAUTH` or\n`INTEGRATED`. **Note** `LDAP` must be configured to create `INTEGRATED` groups and names must\nmatch `LDAP` group names. If LDAP is not configured - it will return 403 errors.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The role of the group. Role names can be retrieved from the organization. Both built-in roles and\ncustom built can be used. The roles normally available are:\n* `Organization Administrator`\n* `Catalog Author`\n* `vApp Author`\n* `vApp User`\n* `Console Access Only`\n* `Defer to Identity Provider`\n"
                }
            },
            "requiredInputs": [
                "providerType",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgGroup resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of Organization group\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the group.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Identity provider type for this this group. One of `SAML`, `OAUTH` or\n`INTEGRATED`. **Note** `LDAP` must be configured to create `INTEGRATED` groups and names must\nmatch `LDAP` group names. If LDAP is not configured - it will return 403 errors.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The role of the group. Role names can be retrieved from the organization. Both built-in roles and\ncustom built can be used. The roles normally available are:\n* `Organization Administrator`\n* `Catalog Author`\n* `vApp Author`\n* `vApp User`\n* `Console Access Only`\n* `Defer to Identity Provider`\n"
                    },
                    "userNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The set of user names that belong to this group. It's only populated if the users\nare created after the group (with `depends_on` the given group).\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgLdap:OrgLdap": {
            "properties": {
                "customSettings": {
                    "$ref": "#/types/vcd:index/OrgLdapCustomSettings:OrgLdapCustomSettings",
                    "description": "LDAP server configuration. Becomes mandatory if `ldap_mode` is set to `CUSTOM`. See Custom Settings below for details\n\n\u003ca id=\"custom-settings\"\u003e\u003c/a\u003e\n"
                },
                "customUserOu": {
                    "type": "string",
                    "description": "If `ldap_mode` is `SYSTEM`, specifies an LDAP `attribute=value` pair to use for OU (organizational unit)\n"
                },
                "ldapMode": {
                    "type": "string",
                    "description": "One of `NONE`, `CUSTOM`, `SYSTEM`. Note that using `NONE` has the effect of removing the LDAP settings\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Org ID: there is only one LDAP configuration available for an organization. Thus, the resource can be identified by the Org.\n"
                }
            },
            "required": [
                "ldapMode",
                "orgId"
            ],
            "inputProperties": {
                "customSettings": {
                    "$ref": "#/types/vcd:index/OrgLdapCustomSettings:OrgLdapCustomSettings",
                    "description": "LDAP server configuration. Becomes mandatory if `ldap_mode` is set to `CUSTOM`. See Custom Settings below for details\n\n\u003ca id=\"custom-settings\"\u003e\u003c/a\u003e\n"
                },
                "customUserOu": {
                    "type": "string",
                    "description": "If `ldap_mode` is `SYSTEM`, specifies an LDAP `attribute=value` pair to use for OU (organizational unit)\n"
                },
                "ldapMode": {
                    "type": "string",
                    "description": "One of `NONE`, `CUSTOM`, `SYSTEM`. Note that using `NONE` has the effect of removing the LDAP settings\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Org ID: there is only one LDAP configuration available for an organization. Thus, the resource can be identified by the Org.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ldapMode",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgLdap resources.\n",
                "properties": {
                    "customSettings": {
                        "$ref": "#/types/vcd:index/OrgLdapCustomSettings:OrgLdapCustomSettings",
                        "description": "LDAP server configuration. Becomes mandatory if `ldap_mode` is set to `CUSTOM`. See Custom Settings below for details\n\n\u003ca id=\"custom-settings\"\u003e\u003c/a\u003e\n"
                    },
                    "customUserOu": {
                        "type": "string",
                        "description": "If `ldap_mode` is `SYSTEM`, specifies an LDAP `attribute=value` pair to use for OU (organizational unit)\n"
                    },
                    "ldapMode": {
                        "type": "string",
                        "description": "One of `NONE`, `CUSTOM`, `SYSTEM`. Note that using `NONE` has the effect of removing the LDAP settings\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Org ID: there is only one LDAP configuration available for an organization. Thus, the resource can be identified by the Org.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgOidc:OrgOidc": {
            "properties": {
                "accessTokenEndpoint": {
                    "type": "string",
                    "description": "The endpoint to use for access tokens.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "claimsMapping": {
                    "$ref": "#/types/vcd:index/OrgOidcClaimsMapping:OrgOidcClaimsMapping",
                    "description": "A single configuration block that specifies the claim mappings to use with the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**. This allows users\nto override the claims given by `wellknown_endpoint`. The supported claims are:\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID to use with the OIDC provider\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Client Secret to use with the OIDC provider\n",
                    "secret": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Either `true` or `false`, specifies whether the OIDC authentication is enabled for the given organization\n"
                },
                "issuerId": {
                    "type": "string",
                    "description": "The issuer ID for the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "keyExpireDurationHours": {
                    "type": "integer",
                    "description": "Required if `key_refresh_endpoint` is set and `key_refresh_strategy=EXPIRE_AFTER`. Defines the expiration period of the key\nYou can get more details of the `EXPIRE_AFTER` strategy [here](https://docs.vmware.com/en/VMware-Cloud-Director/10.4/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-92C030BE-5444-45B4-891F-63EA6872FEA1.html).\nMaximum value is `24`\n"
                },
                "keyRefreshEndpoint": {
                    "type": "string",
                    "description": "Endpoint used to refresh the keys. If set, `key_refresh_period_hours` and `key_refresh_strategy` will be required.\nIf `wellknown_endpoint` is set, then this argument will override the obtained endpoint\n"
                },
                "keyRefreshPeriodHours": {
                    "type": "integer",
                    "description": "Required if `key_refresh_endpoint` is set. Defines the frequency of key refresh. Maximum value is `720` (30 days)\n"
                },
                "keyRefreshStrategy": {
                    "type": "string",
                    "description": "Required if `key_refresh_endpoint` is set. Defines the strategy of key refresh. One of `ADD`, `REPLACE`, `EXPIRE_AFTER`.\nThe different strategies are explained [here](https://docs.vmware.com/en/VMware-Cloud-Director/10.4/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-92C030BE-5444-45B4-891F-63EA6872FEA1.html)\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgOidcKey:OrgOidcKey"
                    },
                    "description": "One or more configuration blocks that specify the keys to use with the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**. This allows users\nto override the keys given by `wellknown_endpoint`. Each key requires the following:\n"
                },
                "maxClockSkewSeconds": {
                    "type": "integer",
                    "description": "The maximum clock skew is the maximum allowable time difference between the client and server.\nThis time compensates for any small-time differences in the timestamps when verifying tokens. The **default** value is `60` seconds\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "ID of the Organization that will have the OpenID Connect settings configured. There must be only one\nresource `vcd.OrgOidc` per `org_id`, as there is only one OpenID configuration per Organization\n"
                },
                "preferIdToken": {
                    "type": "boolean",
                    "description": "If you want to combine claims from `userinfo_endpoint` and the ID Token, set this to `true`.\nThe identity providers do not provide all the required claims set in `userinfo_endpoint`. By setting this argument to `true`,\nVMware Cloud Director can fetch and consume claims from both sources\n"
                },
                "redirectUri": {
                    "type": "string",
                    "description": "The client configuration redirect URI used to create a client application registration with an identity provider\nthat complies with the OpenID Connect standard\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of scopes to use with the OpenID Connect provider. They are used to authorize access to user details, by defining\nthe permissions that the access tokens have to access user information. If 'wellknown_endpoint' is set, this attribute\noverrides the obtained scopes\n"
                },
                "uiButtonLabel": {
                    "type": "string",
                    "description": "Customizes the label of the UI button of the login screen\n"
                },
                "userAuthorizationEndpoint": {
                    "type": "string",
                    "description": "The endpoint to use for authorization.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "userinfoEndpoint": {
                    "type": "string",
                    "description": "The endpoint to use for User Info.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "wellknownEndpoint": {
                    "type": "string",
                    "description": "This endpoint retrieves the OIDC provider configuration and automatically sets\nthe following arguments, without setting them explicitly: `issuer_id`, `user_authorization_endpoint`, `access_token_endpoint`,\n`userinfo_endpoint`, the `claims_mapping` block, the `key` blocks, and `scopes`. These mentioned attributes will be computed, and\ncan be overridden by setting them explicitly in HCL code\n"
                }
            },
            "required": [
                "accessTokenEndpoint",
                "claimsMapping",
                "clientId",
                "clientSecret",
                "enabled",
                "issuerId",
                "keys",
                "keyRefreshEndpoint",
                "orgId",
                "redirectUri",
                "scopes",
                "userAuthorizationEndpoint",
                "userinfoEndpoint"
            ],
            "inputProperties": {
                "accessTokenEndpoint": {
                    "type": "string",
                    "description": "The endpoint to use for access tokens.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "claimsMapping": {
                    "$ref": "#/types/vcd:index/OrgOidcClaimsMapping:OrgOidcClaimsMapping",
                    "description": "A single configuration block that specifies the claim mappings to use with the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**. This allows users\nto override the claims given by `wellknown_endpoint`. The supported claims are:\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID to use with the OIDC provider\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Client Secret to use with the OIDC provider\n",
                    "secret": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Either `true` or `false`, specifies whether the OIDC authentication is enabled for the given organization\n"
                },
                "issuerId": {
                    "type": "string",
                    "description": "The issuer ID for the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "keyExpireDurationHours": {
                    "type": "integer",
                    "description": "Required if `key_refresh_endpoint` is set and `key_refresh_strategy=EXPIRE_AFTER`. Defines the expiration period of the key\nYou can get more details of the `EXPIRE_AFTER` strategy [here](https://docs.vmware.com/en/VMware-Cloud-Director/10.4/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-92C030BE-5444-45B4-891F-63EA6872FEA1.html).\nMaximum value is `24`\n"
                },
                "keyRefreshEndpoint": {
                    "type": "string",
                    "description": "Endpoint used to refresh the keys. If set, `key_refresh_period_hours` and `key_refresh_strategy` will be required.\nIf `wellknown_endpoint` is set, then this argument will override the obtained endpoint\n"
                },
                "keyRefreshPeriodHours": {
                    "type": "integer",
                    "description": "Required if `key_refresh_endpoint` is set. Defines the frequency of key refresh. Maximum value is `720` (30 days)\n"
                },
                "keyRefreshStrategy": {
                    "type": "string",
                    "description": "Required if `key_refresh_endpoint` is set. Defines the strategy of key refresh. One of `ADD`, `REPLACE`, `EXPIRE_AFTER`.\nThe different strategies are explained [here](https://docs.vmware.com/en/VMware-Cloud-Director/10.4/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-92C030BE-5444-45B4-891F-63EA6872FEA1.html)\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgOidcKey:OrgOidcKey"
                    },
                    "description": "One or more configuration blocks that specify the keys to use with the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**. This allows users\nto override the keys given by `wellknown_endpoint`. Each key requires the following:\n"
                },
                "maxClockSkewSeconds": {
                    "type": "integer",
                    "description": "The maximum clock skew is the maximum allowable time difference between the client and server.\nThis time compensates for any small-time differences in the timestamps when verifying tokens. The **default** value is `60` seconds\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "ID of the Organization that will have the OpenID Connect settings configured. There must be only one\nresource `vcd.OrgOidc` per `org_id`, as there is only one OpenID configuration per Organization\n",
                    "willReplaceOnChanges": true
                },
                "preferIdToken": {
                    "type": "boolean",
                    "description": "If you want to combine claims from `userinfo_endpoint` and the ID Token, set this to `true`.\nThe identity providers do not provide all the required claims set in `userinfo_endpoint`. By setting this argument to `true`,\nVMware Cloud Director can fetch and consume claims from both sources\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of scopes to use with the OpenID Connect provider. They are used to authorize access to user details, by defining\nthe permissions that the access tokens have to access user information. If 'wellknown_endpoint' is set, this attribute\noverrides the obtained scopes\n"
                },
                "uiButtonLabel": {
                    "type": "string",
                    "description": "Customizes the label of the UI button of the login screen\n"
                },
                "userAuthorizationEndpoint": {
                    "type": "string",
                    "description": "The endpoint to use for authorization.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "userinfoEndpoint": {
                    "type": "string",
                    "description": "The endpoint to use for User Info.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                },
                "wellknownEndpoint": {
                    "type": "string",
                    "description": "This endpoint retrieves the OIDC provider configuration and automatically sets\nthe following arguments, without setting them explicitly: `issuer_id`, `user_authorization_endpoint`, `access_token_endpoint`,\n`userinfo_endpoint`, the `claims_mapping` block, the `key` blocks, and `scopes`. These mentioned attributes will be computed, and\ncan be overridden by setting them explicitly in HCL code\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "clientSecret",
                "enabled",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgOidc resources.\n",
                "properties": {
                    "accessTokenEndpoint": {
                        "type": "string",
                        "description": "The endpoint to use for access tokens.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                    },
                    "claimsMapping": {
                        "$ref": "#/types/vcd:index/OrgOidcClaimsMapping:OrgOidcClaimsMapping",
                        "description": "A single configuration block that specifies the claim mappings to use with the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**. This allows users\nto override the claims given by `wellknown_endpoint`. The supported claims are:\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "Client ID to use with the OIDC provider\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "Client Secret to use with the OIDC provider\n",
                        "secret": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Either `true` or `false`, specifies whether the OIDC authentication is enabled for the given organization\n"
                    },
                    "issuerId": {
                        "type": "string",
                        "description": "The issuer ID for the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                    },
                    "keyExpireDurationHours": {
                        "type": "integer",
                        "description": "Required if `key_refresh_endpoint` is set and `key_refresh_strategy=EXPIRE_AFTER`. Defines the expiration period of the key\nYou can get more details of the `EXPIRE_AFTER` strategy [here](https://docs.vmware.com/en/VMware-Cloud-Director/10.4/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-92C030BE-5444-45B4-891F-63EA6872FEA1.html).\nMaximum value is `24`\n"
                    },
                    "keyRefreshEndpoint": {
                        "type": "string",
                        "description": "Endpoint used to refresh the keys. If set, `key_refresh_period_hours` and `key_refresh_strategy` will be required.\nIf `wellknown_endpoint` is set, then this argument will override the obtained endpoint\n"
                    },
                    "keyRefreshPeriodHours": {
                        "type": "integer",
                        "description": "Required if `key_refresh_endpoint` is set. Defines the frequency of key refresh. Maximum value is `720` (30 days)\n"
                    },
                    "keyRefreshStrategy": {
                        "type": "string",
                        "description": "Required if `key_refresh_endpoint` is set. Defines the strategy of key refresh. One of `ADD`, `REPLACE`, `EXPIRE_AFTER`.\nThe different strategies are explained [here](https://docs.vmware.com/en/VMware-Cloud-Director/10.4/VMware-Cloud-Director-Tenant-Portal-Guide/GUID-92C030BE-5444-45B4-891F-63EA6872FEA1.html)\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/OrgOidcKey:OrgOidcKey"
                        },
                        "description": "One or more configuration blocks that specify the keys to use with the OIDC provider.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**. This allows users\nto override the keys given by `wellknown_endpoint`. Each key requires the following:\n"
                    },
                    "maxClockSkewSeconds": {
                        "type": "integer",
                        "description": "The maximum clock skew is the maximum allowable time difference between the client and server.\nThis time compensates for any small-time differences in the timestamps when verifying tokens. The **default** value is `60` seconds\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "ID of the Organization that will have the OpenID Connect settings configured. There must be only one\nresource `vcd.OrgOidc` per `org_id`, as there is only one OpenID configuration per Organization\n",
                        "willReplaceOnChanges": true
                    },
                    "preferIdToken": {
                        "type": "boolean",
                        "description": "If you want to combine claims from `userinfo_endpoint` and the ID Token, set this to `true`.\nThe identity providers do not provide all the required claims set in `userinfo_endpoint`. By setting this argument to `true`,\nVMware Cloud Director can fetch and consume claims from both sources\n"
                    },
                    "redirectUri": {
                        "type": "string",
                        "description": "The client configuration redirect URI used to create a client application registration with an identity provider\nthat complies with the OpenID Connect standard\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of scopes to use with the OpenID Connect provider. They are used to authorize access to user details, by defining\nthe permissions that the access tokens have to access user information. If 'wellknown_endpoint' is set, this attribute\noverrides the obtained scopes\n"
                    },
                    "uiButtonLabel": {
                        "type": "string",
                        "description": "Customizes the label of the UI button of the login screen\n"
                    },
                    "userAuthorizationEndpoint": {
                        "type": "string",
                        "description": "The endpoint to use for authorization.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                    },
                    "userinfoEndpoint": {
                        "type": "string",
                        "description": "The endpoint to use for User Info.\nIf `wellknown_endpoint` is **not** set, then this argument is **required**. Otherwise, it is **optional**.\nThis allows users to override the configuration given by `wellknown_endpoint`\n"
                    },
                    "wellknownEndpoint": {
                        "type": "string",
                        "description": "This endpoint retrieves the OIDC provider configuration and automatically sets\nthe following arguments, without setting them explicitly: `issuer_id`, `user_authorization_endpoint`, `access_token_endpoint`,\n`userinfo_endpoint`, the `claims_mapping` block, the `key` blocks, and `scopes`. These mentioned attributes will be computed, and\ncan be overridden by setting them explicitly in HCL code\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgSaml:OrgSaml": {
            "properties": {
                "email": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the email address of the user\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If true, the organization will use SAML for authentication\n"
                },
                "entityId": {
                    "type": "string",
                    "description": "Your service provider entity ID. Once you set this field, it cannot be changed back to empty\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the first name of the user\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the full name of the user\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the identifiers of all the groups of which the user is a member\n"
                },
                "identityProviderMetadataFile": {
                    "type": "string",
                    "description": "Name of a file containing the metadata text from a SAML Identity Provider. Required if `identity_provider_metadata_text` is not defined\n"
                },
                "identityProviderMetadataText": {
                    "type": "string",
                    "description": "Text of the metadata text from a SAML Identity Provider. Required if `identity_provider_metadata_file` is not defined\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Since there is only one SAML configuration available for an organization, the resource can be identified by the Org itself\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the identifiers of all roles of the user\n"
                },
                "surname": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the surname of the user\n"
                },
                "userName": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the username of the user\n"
                }
            },
            "required": [
                "enabled",
                "orgId"
            ],
            "inputProperties": {
                "email": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the email address of the user\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If true, the organization will use SAML for authentication\n"
                },
                "entityId": {
                    "type": "string",
                    "description": "Your service provider entity ID. Once you set this field, it cannot be changed back to empty\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the first name of the user\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the full name of the user\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the identifiers of all the groups of which the user is a member\n"
                },
                "identityProviderMetadataFile": {
                    "type": "string",
                    "description": "Name of a file containing the metadata text from a SAML Identity Provider. Required if `identity_provider_metadata_text` is not defined\n"
                },
                "identityProviderMetadataText": {
                    "type": "string",
                    "description": "Text of the metadata text from a SAML Identity Provider. Required if `identity_provider_metadata_file` is not defined\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Since there is only one SAML configuration available for an organization, the resource can be identified by the Org itself\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the identifiers of all roles of the user\n"
                },
                "surname": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the surname of the user\n"
                },
                "userName": {
                    "type": "string",
                    "description": "The name of the SAML attribute that returns the username of the user\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgSaml resources.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "The name of the SAML attribute that returns the email address of the user\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "If true, the organization will use SAML for authentication\n"
                    },
                    "entityId": {
                        "type": "string",
                        "description": "Your service provider entity ID. Once you set this field, it cannot be changed back to empty\n"
                    },
                    "firstName": {
                        "type": "string",
                        "description": "The name of the SAML attribute that returns the first name of the user\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "The name of the SAML attribute that returns the full name of the user\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name of the SAML attribute that returns the identifiers of all the groups of which the user is a member\n"
                    },
                    "identityProviderMetadataFile": {
                        "type": "string",
                        "description": "Name of a file containing the metadata text from a SAML Identity Provider. Required if `identity_provider_metadata_text` is not defined\n"
                    },
                    "identityProviderMetadataText": {
                        "type": "string",
                        "description": "Text of the metadata text from a SAML Identity Provider. Required if `identity_provider_metadata_file` is not defined\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Since there is only one SAML configuration available for an organization, the resource can be identified by the Org itself\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the SAML attribute that returns the identifiers of all roles of the user\n"
                    },
                    "surname": {
                        "type": "string",
                        "description": "The name of the SAML attribute that returns the surname of the user\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "The name of the SAML attribute that returns the username of the user\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgUser:OrgUser": {
            "properties": {
                "deployedVmQuota": {
                    "type": "integer",
                    "description": "Quota of vApps that this user can deploy. A value of 0 specifies an unlimited quota.\nThe default is 0.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the user.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "The Org User email address. Needs to be a properly formatted email address.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if the user is enabled and can log in. The default is `true`.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user.\n"
                },
                "groupNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of group names to which this user belongs. It's only populated if the users\nare created after the group (with this user having a `depends_on` of the given group).\n"
                },
                "instantMessaging": {
                    "type": "string",
                    "description": "The Org User instant messaging.\n"
                },
                "isExternal": {
                    "type": "boolean",
                    "description": "If the user account is going to be imported from an external resource, like an LDAP.\nIn this case, `password` nor `password_file` are not required. Defaults to `false`.\n"
                },
                "isGroupRole": {
                    "type": "boolean",
                    "description": "True if this user has a group role. The default is `false`.\n"
                },
                "isLocked": {
                    "type": "boolean",
                    "description": "If the user account has been locked due to too many invalid login attempts, the value will \nchange to true (only the system can lock the user). To unlock the user re-set this flag to false.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the user.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the user belongs. Optional if defined at provider level. If we \nwant to create a user at provider level, use \"System\" as org name.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The user's password. This value is never returned on read. Either \"password\" or \"password_file\" must be included on\ncreation unless is_external is true.\n",
                    "secret": true
                },
                "passwordFile": {
                    "type": "string",
                    "description": "Name of a file containing the user's password. Either \"password_file\" or \"password\" must be included on creation unless\nis_external is true.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Identity provider type for this user. One of: `INTEGRATED`, `SAML`, `OAUTH`. The default\nis `INTEGRATED`.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The role of the user. Role names can be retrieved from the organization. Both built-in roles and\ncustom built can be used. The roles normally available are:\n* `Organization Administrator`\n* `Catalog Author`\n* `vApp Author`\n* `vApp User`\n* `Console Access Only`\n* `Defer to Identity Provider`\n"
                },
                "storedVmQuota": {
                    "type": "integer",
                    "description": "Quota of vApps that this user can store. A value of 0 specifies an unlimited quota.\nThe default is 0.\n"
                },
                "takeOwnership": {
                    "type": "boolean",
                    "description": "Take ownership of user's objects on deletion.\n"
                },
                "telephone": {
                    "type": "string",
                    "description": "The Org User telephone number.\n"
                }
            },
            "required": [
                "deployedVmQuota",
                "emailAddress",
                "fullName",
                "groupNames",
                "instantMessaging",
                "name",
                "role",
                "storedVmQuota",
                "telephone"
            ],
            "inputProperties": {
                "deployedVmQuota": {
                    "type": "integer",
                    "description": "Quota of vApps that this user can deploy. A value of 0 specifies an unlimited quota.\nThe default is 0.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the user.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "The Org User email address. Needs to be a properly formatted email address.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if the user is enabled and can log in. The default is `true`.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user.\n"
                },
                "instantMessaging": {
                    "type": "string",
                    "description": "The Org User instant messaging.\n"
                },
                "isExternal": {
                    "type": "boolean",
                    "description": "If the user account is going to be imported from an external resource, like an LDAP.\nIn this case, `password` nor `password_file` are not required. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "isGroupRole": {
                    "type": "boolean",
                    "description": "True if this user has a group role. The default is `false`.\n"
                },
                "isLocked": {
                    "type": "boolean",
                    "description": "If the user account has been locked due to too many invalid login attempts, the value will \nchange to true (only the system can lock the user). To unlock the user re-set this flag to false.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the user.\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the user belongs. Optional if defined at provider level. If we \nwant to create a user at provider level, use \"System\" as org name.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "The user's password. This value is never returned on read. Either \"password\" or \"password_file\" must be included on\ncreation unless is_external is true.\n",
                    "secret": true
                },
                "passwordFile": {
                    "type": "string",
                    "description": "Name of a file containing the user's password. Either \"password_file\" or \"password\" must be included on creation unless\nis_external is true.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Identity provider type for this user. One of: `INTEGRATED`, `SAML`, `OAUTH`. The default\nis `INTEGRATED`.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The role of the user. Role names can be retrieved from the organization. Both built-in roles and\ncustom built can be used. The roles normally available are:\n* `Organization Administrator`\n* `Catalog Author`\n* `vApp Author`\n* `vApp User`\n* `Console Access Only`\n* `Defer to Identity Provider`\n"
                },
                "storedVmQuota": {
                    "type": "integer",
                    "description": "Quota of vApps that this user can store. A value of 0 specifies an unlimited quota.\nThe default is 0.\n"
                },
                "takeOwnership": {
                    "type": "boolean",
                    "description": "Take ownership of user's objects on deletion.\n"
                },
                "telephone": {
                    "type": "string",
                    "description": "The Org User telephone number.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgUser resources.\n",
                "properties": {
                    "deployedVmQuota": {
                        "type": "integer",
                        "description": "Quota of vApps that this user can deploy. A value of 0 specifies an unlimited quota.\nThe default is 0.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the user.\n"
                    },
                    "emailAddress": {
                        "type": "string",
                        "description": "The Org User email address. Needs to be a properly formatted email address.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "True if the user is enabled and can log in. The default is `true`.\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "The full name of the user.\n"
                    },
                    "groupNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The set of group names to which this user belongs. It's only populated if the users\nare created after the group (with this user having a `depends_on` of the given group).\n"
                    },
                    "instantMessaging": {
                        "type": "string",
                        "description": "The Org User instant messaging.\n"
                    },
                    "isExternal": {
                        "type": "boolean",
                        "description": "If the user account is going to be imported from an external resource, like an LDAP.\nIn this case, `password` nor `password_file` are not required. Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "isGroupRole": {
                        "type": "boolean",
                        "description": "True if this user has a group role. The default is `false`.\n"
                    },
                    "isLocked": {
                        "type": "boolean",
                        "description": "If the user account has been locked due to too many invalid login attempts, the value will \nchange to true (only the system can lock the user). To unlock the user re-set this flag to false.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the user.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the user belongs. Optional if defined at provider level. If we \nwant to create a user at provider level, use \"System\" as org name.\n",
                        "willReplaceOnChanges": true
                    },
                    "password": {
                        "type": "string",
                        "description": "The user's password. This value is never returned on read. Either \"password\" or \"password_file\" must be included on\ncreation unless is_external is true.\n",
                        "secret": true
                    },
                    "passwordFile": {
                        "type": "string",
                        "description": "Name of a file containing the user's password. Either \"password_file\" or \"password\" must be included on creation unless\nis_external is true.\n"
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Identity provider type for this user. One of: `INTEGRATED`, `SAML`, `OAUTH`. The default\nis `INTEGRATED`.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The role of the user. Role names can be retrieved from the organization. Both built-in roles and\ncustom built can be used. The roles normally available are:\n* `Organization Administrator`\n* `Catalog Author`\n* `vApp Author`\n* `vApp User`\n* `Console Access Only`\n* `Defer to Identity Provider`\n"
                    },
                    "storedVmQuota": {
                        "type": "integer",
                        "description": "Quota of vApps that this user can store. A value of 0 specifies an unlimited quota.\nThe default is 0.\n"
                    },
                    "takeOwnership": {
                        "type": "boolean",
                        "description": "Take ownership of user's objects on deletion.\n"
                    },
                    "telephone": {
                        "type": "string",
                        "description": "The Org User telephone number.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgVdc:OrgVdc": {
            "properties": {
                "allocationModel": {
                    "type": "string",
                    "description": "The allocation model used by this VDC; must be one of \n* AllocationVApp (\"Pay as you go\")\n* AllocationPool (\"Allocation pool\")\n* ReservationPool (\"Reservation pool\")\n* Flex (\"Flex\") (*v2.7+*, *VCD 9.7+*)\n"
                },
                "allowOverCommit": {
                    "type": "boolean",
                    "description": "Set to false to disallow creation of the VDC if the `allocation_model` is AllocationPool or ReservationPool and the ComputeCapacity you specified is greater than what the backing Provider VDC can supply. Default is true.\n"
                },
                "computeCapacity": {
                    "$ref": "#/types/vcd:index/OrgVdcComputeCapacity:OrgVdcComputeCapacity",
                    "description": "The compute capacity allocated to this VDC.  See Compute Capacity below for details.\n"
                },
                "cpuGuaranteed": {
                    "type": "number",
                    "description": "Percentage of allocated CPU resources guaranteed to vApps deployed in this VDC. For example, if this value is 0.75, then 75% of allocated resources are guaranteed. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex. If left empty, VCD sets a value.\n"
                },
                "cpuSpeed": {
                    "type": "integer",
                    "description": "Specifies the clock frequency, in Megahertz, for any virtual CPU that is allocated to a VM. A VM with 2 vCPUs will consume twice as much of this value. Ignored for ReservationPool. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex, and may not be less than 256 MHz. Defaults to 1000 MHz if value isn't provided.\n"
                },
                "defaultComputePolicyId": {
                    "type": "string",
                    "description": "ID of the default Compute Policy for this VDC. It can be a VM Sizing Policy, a VM Placement Policy or a vGPU Policy.\n"
                },
                "defaultVmSizingPolicyId": {
                    "type": "string",
                    "description": "ID of the default Compute Policy for this VDC. It can be a VM Sizing Policy, a VM Placement Policy or a vGPU Policy. Deprecated in favor of `default_compute_policy_id`.\n",
                    "deprecationMessage": "Use `default_compute_policy_id` attribute instead, which can support VM Sizing Policies, VM Placement Policies and vGPU Policies"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "When destroying use `delete_force=true` to remove a VDC and any objects it contains, regardless of their state. Default is `false`\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "When destroying use `delete_recursive=true` to remove the VDC and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                },
                "description": {
                    "type": "string",
                    "description": "VDC friendly description\n"
                },
                "edgeClusterId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Cluster which\nshould provide vApp Networking Services or DHCP for isolated networks. Can be looked up using\n`vcd.getNsxtEdgeCluster` data source. This field is **deprecated** in favor of\n[`vcd.OrgVdcNsxtNetworkProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc_nsxt_network_profile).\n",
                    "deprecationMessage": "Please use 'vcd_org_vdc_nsxt_network_profile' resource to manage Edge Cluster and Segment Profile Templates"
                },
                "elasticity": {
                    "type": "boolean",
                    "description": "Indicates if the Flex VDC should be elastic. Required with the Flex allocation model.\n"
                },
                "enableFastProvisioning": {
                    "type": "boolean",
                    "description": "Request fast provisioning. Request will be honored only if the underlying datastore supports it. Fast provisioning can reduce the time it takes to create virtual machines by using vSphere linked clones. If you disable fast provisioning, all provisioning operations will result in full clones.\n"
                },
                "enableNsxvDistributedFirewall": {
                    "type": "boolean",
                    "description": "Enables or disables the NSX-V distributed firewall.\n\n\u003ca id=\"storageprofile\"\u003e\u003c/a\u003e\n"
                },
                "enableThinProvisioning": {
                    "type": "boolean",
                    "description": "Boolean to request thin provisioning. Request will be honored only if the underlying data store supports it. Thin provisioning saves storage space by committing it on demand. This allows over-allocation of storage.\n"
                },
                "enableVmDiscovery": {
                    "type": "boolean",
                    "description": "If true, discovery of vCenter VMs is enabled for resource pools backing this VDC. If false, discovery is disabled. If left unspecified, the actual behaviour depends on enablement at the organization level and at the system level.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if this VDC is enabled for use by the organization VDCs. Default is true.\n"
                },
                "includeVmMemoryOverhead": {
                    "type": "boolean",
                    "description": "Indicates if the Flex VDC should include memory overhead into its accounting for admission control. Required with the Flex allocation model. `memory_guaranteed` must also be specified together with this parameter.\n"
                },
                "memoryGuaranteed": {
                    "type": "number",
                    "description": "Percentage of allocated memory resources guaranteed to vApps deployed in this VDC. For example, if this value is 0.75, then 75% of allocated resources are guaranteed. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex. When Allocation model is AllocationPool minimum value is 0.2. If left empty, VCD sets a value.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this VDC\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcMetadataEntry:OrgVdcMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "VDC name\n"
                },
                "networkPoolName": {
                    "type": "string",
                    "description": "Reference to a network pool in the Provider VDC. Required if this VDC will contain routed or isolated networks.\n"
                },
                "networkQuota": {
                    "type": "integer",
                    "description": "Maximum number of network objects that can be deployed in this VDC. Defaults to 0, which means no networks can be deployed.\n"
                },
                "nicQuota": {
                    "type": "integer",
                    "description": "Maximum number of virtual NICs allowed in this VDC. Defaults to 0, which specifies an unlimited number.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Organization to create the VDC in, optional if defined at provider level\n"
                },
                "providerVdcName": {
                    "type": "string",
                    "description": "Name of the Provider VDC from which this organization VDC is provisioned.\n"
                },
                "storageProfiles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcStorageProfile:OrgVdcStorageProfile"
                    },
                    "description": "Storage profiles supported by this VDC.  See Storage Profile below for details.\n"
                },
                "vmPlacementPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of VM Placement policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                },
                "vmQuota": {
                    "type": "integer",
                    "description": "The maximum number of VMs that can be created in this VDC. Includes deployed and undeployed VMs in vApps and vApp templates. Defaults to 0, which specifies an unlimited number.\n"
                },
                "vmSizingPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of VM Sizing policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                },
                "vmVgpuPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of VM vGPU policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                }
            },
            "required": [
                "allocationModel",
                "allowOverCommit",
                "computeCapacity",
                "cpuGuaranteed",
                "cpuSpeed",
                "defaultComputePolicyId",
                "defaultVmSizingPolicyId",
                "edgeClusterId",
                "elasticity",
                "enableNsxvDistributedFirewall",
                "includeVmMemoryOverhead",
                "memoryGuaranteed",
                "metadata",
                "metadataEntries",
                "name",
                "providerVdcName",
                "storageProfiles",
                "vmPlacementPolicyIds",
                "vmSizingPolicyIds",
                "vmVgpuPolicyIds"
            ],
            "inputProperties": {
                "allocationModel": {
                    "type": "string",
                    "description": "The allocation model used by this VDC; must be one of \n* AllocationVApp (\"Pay as you go\")\n* AllocationPool (\"Allocation pool\")\n* ReservationPool (\"Reservation pool\")\n* Flex (\"Flex\") (*v2.7+*, *VCD 9.7+*)\n",
                    "willReplaceOnChanges": true
                },
                "allowOverCommit": {
                    "type": "boolean",
                    "description": "Set to false to disallow creation of the VDC if the `allocation_model` is AllocationPool or ReservationPool and the ComputeCapacity you specified is greater than what the backing Provider VDC can supply. Default is true.\n"
                },
                "computeCapacity": {
                    "$ref": "#/types/vcd:index/OrgVdcComputeCapacity:OrgVdcComputeCapacity",
                    "description": "The compute capacity allocated to this VDC.  See Compute Capacity below for details.\n"
                },
                "cpuGuaranteed": {
                    "type": "number",
                    "description": "Percentage of allocated CPU resources guaranteed to vApps deployed in this VDC. For example, if this value is 0.75, then 75% of allocated resources are guaranteed. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex. If left empty, VCD sets a value.\n"
                },
                "cpuSpeed": {
                    "type": "integer",
                    "description": "Specifies the clock frequency, in Megahertz, for any virtual CPU that is allocated to a VM. A VM with 2 vCPUs will consume twice as much of this value. Ignored for ReservationPool. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex, and may not be less than 256 MHz. Defaults to 1000 MHz if value isn't provided.\n"
                },
                "defaultComputePolicyId": {
                    "type": "string",
                    "description": "ID of the default Compute Policy for this VDC. It can be a VM Sizing Policy, a VM Placement Policy or a vGPU Policy.\n"
                },
                "defaultVmSizingPolicyId": {
                    "type": "string",
                    "description": "ID of the default Compute Policy for this VDC. It can be a VM Sizing Policy, a VM Placement Policy or a vGPU Policy. Deprecated in favor of `default_compute_policy_id`.\n",
                    "deprecationMessage": "Use `default_compute_policy_id` attribute instead, which can support VM Sizing Policies, VM Placement Policies and vGPU Policies"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "When destroying use `delete_force=true` to remove a VDC and any objects it contains, regardless of their state. Default is `false`\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "When destroying use `delete_recursive=true` to remove the VDC and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                },
                "description": {
                    "type": "string",
                    "description": "VDC friendly description\n"
                },
                "edgeClusterId": {
                    "type": "string",
                    "description": "An ID of NSX-T Edge Cluster which\nshould provide vApp Networking Services or DHCP for isolated networks. Can be looked up using\n`vcd.getNsxtEdgeCluster` data source. This field is **deprecated** in favor of\n[`vcd.OrgVdcNsxtNetworkProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc_nsxt_network_profile).\n",
                    "deprecationMessage": "Please use 'vcd_org_vdc_nsxt_network_profile' resource to manage Edge Cluster and Segment Profile Templates"
                },
                "elasticity": {
                    "type": "boolean",
                    "description": "Indicates if the Flex VDC should be elastic. Required with the Flex allocation model.\n"
                },
                "enableFastProvisioning": {
                    "type": "boolean",
                    "description": "Request fast provisioning. Request will be honored only if the underlying datastore supports it. Fast provisioning can reduce the time it takes to create virtual machines by using vSphere linked clones. If you disable fast provisioning, all provisioning operations will result in full clones.\n"
                },
                "enableNsxvDistributedFirewall": {
                    "type": "boolean",
                    "description": "Enables or disables the NSX-V distributed firewall.\n\n\u003ca id=\"storageprofile\"\u003e\u003c/a\u003e\n"
                },
                "enableThinProvisioning": {
                    "type": "boolean",
                    "description": "Boolean to request thin provisioning. Request will be honored only if the underlying data store supports it. Thin provisioning saves storage space by committing it on demand. This allows over-allocation of storage.\n"
                },
                "enableVmDiscovery": {
                    "type": "boolean",
                    "description": "If true, discovery of vCenter VMs is enabled for resource pools backing this VDC. If false, discovery is disabled. If left unspecified, the actual behaviour depends on enablement at the organization level and at the system level.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if this VDC is enabled for use by the organization VDCs. Default is true.\n"
                },
                "includeVmMemoryOverhead": {
                    "type": "boolean",
                    "description": "Indicates if the Flex VDC should include memory overhead into its accounting for admission control. Required with the Flex allocation model. `memory_guaranteed` must also be specified together with this parameter.\n"
                },
                "memoryGuaranteed": {
                    "type": "number",
                    "description": "Percentage of allocated memory resources guaranteed to vApps deployed in this VDC. For example, if this value is 0.75, then 75% of allocated resources are guaranteed. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex. When Allocation model is AllocationPool minimum value is 0.2. If left empty, VCD sets a value.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this VDC\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcMetadataEntry:OrgVdcMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "VDC name\n"
                },
                "networkPoolName": {
                    "type": "string",
                    "description": "Reference to a network pool in the Provider VDC. Required if this VDC will contain routed or isolated networks.\n"
                },
                "networkQuota": {
                    "type": "integer",
                    "description": "Maximum number of network objects that can be deployed in this VDC. Defaults to 0, which means no networks can be deployed.\n"
                },
                "nicQuota": {
                    "type": "integer",
                    "description": "Maximum number of virtual NICs allowed in this VDC. Defaults to 0, which specifies an unlimited number.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Organization to create the VDC in, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "providerVdcName": {
                    "type": "string",
                    "description": "Name of the Provider VDC from which this organization VDC is provisioned.\n",
                    "willReplaceOnChanges": true
                },
                "storageProfiles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcStorageProfile:OrgVdcStorageProfile"
                    },
                    "description": "Storage profiles supported by this VDC.  See Storage Profile below for details.\n"
                },
                "vmPlacementPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of VM Placement policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                },
                "vmQuota": {
                    "type": "integer",
                    "description": "The maximum number of VMs that can be created in this VDC. Includes deployed and undeployed VMs in vApps and vApp templates. Defaults to 0, which specifies an unlimited number.\n"
                },
                "vmSizingPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of VM Sizing policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                },
                "vmVgpuPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of VM vGPU policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                }
            },
            "requiredInputs": [
                "allocationModel",
                "computeCapacity",
                "providerVdcName",
                "storageProfiles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgVdc resources.\n",
                "properties": {
                    "allocationModel": {
                        "type": "string",
                        "description": "The allocation model used by this VDC; must be one of \n* AllocationVApp (\"Pay as you go\")\n* AllocationPool (\"Allocation pool\")\n* ReservationPool (\"Reservation pool\")\n* Flex (\"Flex\") (*v2.7+*, *VCD 9.7+*)\n",
                        "willReplaceOnChanges": true
                    },
                    "allowOverCommit": {
                        "type": "boolean",
                        "description": "Set to false to disallow creation of the VDC if the `allocation_model` is AllocationPool or ReservationPool and the ComputeCapacity you specified is greater than what the backing Provider VDC can supply. Default is true.\n"
                    },
                    "computeCapacity": {
                        "$ref": "#/types/vcd:index/OrgVdcComputeCapacity:OrgVdcComputeCapacity",
                        "description": "The compute capacity allocated to this VDC.  See Compute Capacity below for details.\n"
                    },
                    "cpuGuaranteed": {
                        "type": "number",
                        "description": "Percentage of allocated CPU resources guaranteed to vApps deployed in this VDC. For example, if this value is 0.75, then 75% of allocated resources are guaranteed. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex. If left empty, VCD sets a value.\n"
                    },
                    "cpuSpeed": {
                        "type": "integer",
                        "description": "Specifies the clock frequency, in Megahertz, for any virtual CPU that is allocated to a VM. A VM with 2 vCPUs will consume twice as much of this value. Ignored for ReservationPool. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex, and may not be less than 256 MHz. Defaults to 1000 MHz if value isn't provided.\n"
                    },
                    "defaultComputePolicyId": {
                        "type": "string",
                        "description": "ID of the default Compute Policy for this VDC. It can be a VM Sizing Policy, a VM Placement Policy or a vGPU Policy.\n"
                    },
                    "defaultVmSizingPolicyId": {
                        "type": "string",
                        "description": "ID of the default Compute Policy for this VDC. It can be a VM Sizing Policy, a VM Placement Policy or a vGPU Policy. Deprecated in favor of `default_compute_policy_id`.\n",
                        "deprecationMessage": "Use `default_compute_policy_id` attribute instead, which can support VM Sizing Policies, VM Placement Policies and vGPU Policies"
                    },
                    "deleteForce": {
                        "type": "boolean",
                        "description": "When destroying use `delete_force=true` to remove a VDC and any objects it contains, regardless of their state. Default is `false`\n"
                    },
                    "deleteRecursive": {
                        "type": "boolean",
                        "description": "When destroying use `delete_recursive=true` to remove the VDC and any objects it contains that are in a state that normally allows removal. Default is `false`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "VDC friendly description\n"
                    },
                    "edgeClusterId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Cluster which\nshould provide vApp Networking Services or DHCP for isolated networks. Can be looked up using\n`vcd.getNsxtEdgeCluster` data source. This field is **deprecated** in favor of\n[`vcd.OrgVdcNsxtNetworkProfile`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc_nsxt_network_profile).\n",
                        "deprecationMessage": "Please use 'vcd_org_vdc_nsxt_network_profile' resource to manage Edge Cluster and Segment Profile Templates"
                    },
                    "elasticity": {
                        "type": "boolean",
                        "description": "Indicates if the Flex VDC should be elastic. Required with the Flex allocation model.\n"
                    },
                    "enableFastProvisioning": {
                        "type": "boolean",
                        "description": "Request fast provisioning. Request will be honored only if the underlying datastore supports it. Fast provisioning can reduce the time it takes to create virtual machines by using vSphere linked clones. If you disable fast provisioning, all provisioning operations will result in full clones.\n"
                    },
                    "enableNsxvDistributedFirewall": {
                        "type": "boolean",
                        "description": "Enables or disables the NSX-V distributed firewall.\n\n\u003ca id=\"storageprofile\"\u003e\u003c/a\u003e\n"
                    },
                    "enableThinProvisioning": {
                        "type": "boolean",
                        "description": "Boolean to request thin provisioning. Request will be honored only if the underlying data store supports it. Thin provisioning saves storage space by committing it on demand. This allows over-allocation of storage.\n"
                    },
                    "enableVmDiscovery": {
                        "type": "boolean",
                        "description": "If true, discovery of vCenter VMs is enabled for resource pools backing this VDC. If false, discovery is disabled. If left unspecified, the actual behaviour depends on enablement at the organization level and at the system level.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "True if this VDC is enabled for use by the organization VDCs. Default is true.\n"
                    },
                    "includeVmMemoryOverhead": {
                        "type": "boolean",
                        "description": "Indicates if the Flex VDC should include memory overhead into its accounting for admission control. Required with the Flex allocation model. `memory_guaranteed` must also be specified together with this parameter.\n"
                    },
                    "memoryGuaranteed": {
                        "type": "number",
                        "description": "Percentage of allocated memory resources guaranteed to vApps deployed in this VDC. For example, if this value is 0.75, then 75% of allocated resources are guaranteed. Required when `allocation_model` is AllocationVApp, AllocationPool or Flex. When Allocation model is AllocationPool minimum value is 0.2. If left empty, VCD sets a value.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this VDC\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/OrgVdcMetadataEntry:OrgVdcMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "VDC name\n"
                    },
                    "networkPoolName": {
                        "type": "string",
                        "description": "Reference to a network pool in the Provider VDC. Required if this VDC will contain routed or isolated networks.\n"
                    },
                    "networkQuota": {
                        "type": "integer",
                        "description": "Maximum number of network objects that can be deployed in this VDC. Defaults to 0, which means no networks can be deployed.\n"
                    },
                    "nicQuota": {
                        "type": "integer",
                        "description": "Maximum number of virtual NICs allowed in this VDC. Defaults to 0, which specifies an unlimited number.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Organization to create the VDC in, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "providerVdcName": {
                        "type": "string",
                        "description": "Name of the Provider VDC from which this organization VDC is provisioned.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageProfiles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/OrgVdcStorageProfile:OrgVdcStorageProfile"
                        },
                        "description": "Storage profiles supported by this VDC.  See Storage Profile below for details.\n"
                    },
                    "vmPlacementPolicyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IDs of VM Placement policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                    },
                    "vmQuota": {
                        "type": "integer",
                        "description": "The maximum number of VMs that can be created in this VDC. Includes deployed and undeployed VMs in vApps and vApp templates. Defaults to 0, which specifies an unlimited number.\n"
                    },
                    "vmSizingPolicyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IDs of VM Sizing policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                    },
                    "vmVgpuPolicyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IDs of VM vGPU policies that are assigned to this VDC. This field requires `default_compute_policy_id` to be configured together.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgVdcAccessControl:OrgVdcAccessControl": {
            "description": "Provides a VMware Cloud Director Org VDC access control resource. This can be\nused to share VDC across users and/or groups.\n\nSupported in provider *v3.7+*\n\n\u003e **Note:** This resource requires either system or org administrator privileges.\n\n## Example Usage\n\n### Example Usage 1 (Giving VDC read only access to a couple of users)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_user = vcd.getOrgUser({\n    org: \"my-org\",\n    name: \"my-user\",\n});\nconst my_user2 = vcd.getOrgUser({\n    org: \"my-org\",\n    name: \"my-user2\",\n});\nconst myAccessControl = new vcd.OrgVdcAccessControl(\"my_access_control\", {\n    org: \"my-org\",\n    vdc: \"my-vdc\",\n    sharedWithEveryone: false,\n    sharedWiths: [\n        {\n            userId: my_user.then(my_user =\u003e my_user.id),\n            accessLevel: \"ReadOnly\",\n        },\n        {\n            userId: my_user2.then(my_user2 =\u003e my_user2.id),\n            accessLevel: \"ReadOnly\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_user = vcd.get_org_user(org=\"my-org\",\n    name=\"my-user\")\nmy_user2 = vcd.get_org_user(org=\"my-org\",\n    name=\"my-user2\")\nmy_access_control = vcd.OrgVdcAccessControl(\"my_access_control\",\n    org=\"my-org\",\n    vdc=\"my-vdc\",\n    shared_with_everyone=False,\n    shared_withs=[\n        {\n            \"user_id\": my_user.id,\n            \"access_level\": \"ReadOnly\",\n        },\n        {\n            \"user_id\": my_user2.id,\n            \"access_level\": \"ReadOnly\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_user = Vcd.GetOrgUser.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-user\",\n    });\n\n    var my_user2 = Vcd.GetOrgUser.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-user2\",\n    });\n\n    var myAccessControl = new Vcd.OrgVdcAccessControl(\"my_access_control\", new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n        SharedWithEveryone = false,\n        SharedWiths = new[]\n        {\n            new Vcd.Inputs.OrgVdcAccessControlSharedWithArgs\n            {\n                UserId = my_user.Apply(my_user =\u003e my_user.Apply(getOrgUserResult =\u003e getOrgUserResult.Id)),\n                AccessLevel = \"ReadOnly\",\n            },\n            new Vcd.Inputs.OrgVdcAccessControlSharedWithArgs\n            {\n                UserId = my_user2.Apply(my_user2 =\u003e my_user2.Apply(getOrgUserResult =\u003e getOrgUserResult.Id)),\n                AccessLevel = \"ReadOnly\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_user, err := vcd.LookupOrgUser(ctx, \u0026vcd.LookupOrgUserArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-user\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmy_user2, err := vcd.LookupOrgUser(ctx, \u0026vcd.LookupOrgUserArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-user2\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewOrgVdcAccessControl(ctx, \"my_access_control\", \u0026vcd.OrgVdcAccessControlArgs{\n\t\t\tOrg:                pulumi.String(\"my-org\"),\n\t\t\tVdc:                pulumi.String(\"my-vdc\"),\n\t\t\tSharedWithEveryone: pulumi.Bool(false),\n\t\t\tSharedWiths: vcd.OrgVdcAccessControlSharedWithArray{\n\t\t\t\t\u0026vcd.OrgVdcAccessControlSharedWithArgs{\n\t\t\t\t\tUserId:      pulumi.String(my_user.Id),\n\t\t\t\t\tAccessLevel: pulumi.String(\"ReadOnly\"),\n\t\t\t\t},\n\t\t\t\t\u0026vcd.OrgVdcAccessControlSharedWithArgs{\n\t\t\t\t\tUserId:      pulumi.String(my_user2.Id),\n\t\t\t\t\tAccessLevel: pulumi.String(\"ReadOnly\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgUserArgs;\nimport com.pulumi.vcd.OrgVdcAccessControl;\nimport com.pulumi.vcd.OrgVdcAccessControlArgs;\nimport com.pulumi.vcd.inputs.OrgVdcAccessControlSharedWithArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-user = VcdFunctions.getOrgUser(GetOrgUserArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-user\")\n            .build());\n\n        final var my-user2 = VcdFunctions.getOrgUser(GetOrgUserArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-user2\")\n            .build());\n\n        var myAccessControl = new OrgVdcAccessControl(\"myAccessControl\", OrgVdcAccessControlArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .sharedWithEveryone(false)\n            .sharedWiths(            \n                OrgVdcAccessControlSharedWithArgs.builder()\n                    .userId(my_user.id())\n                    .accessLevel(\"ReadOnly\")\n                    .build(),\n                OrgVdcAccessControlSharedWithArgs.builder()\n                    .userId(my_user2.id())\n                    .accessLevel(\"ReadOnly\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myAccessControl:\n    type: vcd:OrgVdcAccessControl\n    name: my_access_control\n    properties:\n      org: my-org\n      vdc: my-vdc\n      sharedWithEveryone: false\n      sharedWiths:\n        - userId: ${[\"my-user\"].id}\n          accessLevel: ReadOnly\n        - userId: ${[\"my-user2\"].id}\n          accessLevel: ReadOnly\nvariables:\n  my-user:\n    fn::invoke:\n      function: vcd:getOrgUser\n      arguments:\n        org: my-org\n        name: my-user\n  my-user2:\n    fn::invoke:\n      function: vcd:getOrgUser\n      arguments:\n        org: my-org\n        name: my-user2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage 2 (Giving VDC read only access to everybody)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myAccessControl = new vcd.OrgVdcAccessControl(\"my_access_control\", {\n    org: \"my-org\",\n    vdc: \"my-vdc\",\n    sharedWithEveryone: true,\n    everyoneAccessLevel: \"ReadOnly\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_access_control = vcd.OrgVdcAccessControl(\"my_access_control\",\n    org=\"my-org\",\n    vdc=\"my-vdc\",\n    shared_with_everyone=True,\n    everyone_access_level=\"ReadOnly\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myAccessControl = new Vcd.OrgVdcAccessControl(\"my_access_control\", new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n        SharedWithEveryone = true,\n        EveryoneAccessLevel = \"ReadOnly\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.NewOrgVdcAccessControl(ctx, \"my_access_control\", \u0026vcd.OrgVdcAccessControlArgs{\n\t\t\tOrg:                 pulumi.String(\"my-org\"),\n\t\t\tVdc:                 pulumi.String(\"my-vdc\"),\n\t\t\tSharedWithEveryone:  pulumi.Bool(true),\n\t\t\tEveryoneAccessLevel: pulumi.String(\"ReadOnly\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.OrgVdcAccessControl;\nimport com.pulumi.vcd.OrgVdcAccessControlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myAccessControl = new OrgVdcAccessControl(\"myAccessControl\", OrgVdcAccessControlArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .sharedWithEveryone(true)\n            .everyoneAccessLevel(\"ReadOnly\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myAccessControl:\n    type: vcd:OrgVdcAccessControl\n    name: my_access_control\n    properties:\n      org: my-org\n      vdc: my-vdc\n      sharedWithEveryone: true\n      everyoneAccessLevel: ReadOnly\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage 3 (Creating a VDC and setting VDC read only access to everybody)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myVdc = new vcd.OrgVdc(\"my_vdc\", {\n    name: \"my-vdc\",\n    org: \"my-org\",\n    allocationModel: \"Flex\",\n    networkPoolName: \"my-network-pool\",\n    providerVdcName: \"my-provider-vdc\",\n    computeCapacity: {\n        cpu: {\n            allocated: 1024,\n            limit: 1024,\n        },\n        memory: {\n            allocated: 1024,\n            limit: 1024,\n        },\n    },\n    storageProfiles: [{\n        name: \"my-storage-profile\",\n        enabled: true,\n        limit: 10240,\n        \"default\": true,\n    }],\n    enabled: true,\n    enableThinProvisioning: true,\n    enableFastProvisioning: true,\n    deleteForce: true,\n    deleteRecursive: true,\n    elasticity: false,\n    includeVmMemoryOverhead: false,\n});\nconst myAccessControl = new vcd.OrgVdcAccessControl(\"my_access_control\", {\n    org: \"my-org\",\n    vdc: \"my-vdc\",\n    sharedWithEveryone: true,\n    everyoneAccessLevel: \"ReadOnly\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_vdc = vcd.OrgVdc(\"my_vdc\",\n    name=\"my-vdc\",\n    org=\"my-org\",\n    allocation_model=\"Flex\",\n    network_pool_name=\"my-network-pool\",\n    provider_vdc_name=\"my-provider-vdc\",\n    compute_capacity={\n        \"cpu\": {\n            \"allocated\": 1024,\n            \"limit\": 1024,\n        },\n        \"memory\": {\n            \"allocated\": 1024,\n            \"limit\": 1024,\n        },\n    },\n    storage_profiles=[{\n        \"name\": \"my-storage-profile\",\n        \"enabled\": True,\n        \"limit\": 10240,\n        \"default\": True,\n    }],\n    enabled=True,\n    enable_thin_provisioning=True,\n    enable_fast_provisioning=True,\n    delete_force=True,\n    delete_recursive=True,\n    elasticity=False,\n    include_vm_memory_overhead=False)\nmy_access_control = vcd.OrgVdcAccessControl(\"my_access_control\",\n    org=\"my-org\",\n    vdc=\"my-vdc\",\n    shared_with_everyone=True,\n    everyone_access_level=\"ReadOnly\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myVdc = new Vcd.OrgVdc(\"my_vdc\", new()\n    {\n        Name = \"my-vdc\",\n        Org = \"my-org\",\n        AllocationModel = \"Flex\",\n        NetworkPoolName = \"my-network-pool\",\n        ProviderVdcName = \"my-provider-vdc\",\n        ComputeCapacity = new Vcd.Inputs.OrgVdcComputeCapacityArgs\n        {\n            Cpu = new Vcd.Inputs.OrgVdcComputeCapacityCpuArgs\n            {\n                Allocated = 1024,\n                Limit = 1024,\n            },\n            Memory = new Vcd.Inputs.OrgVdcComputeCapacityMemoryArgs\n            {\n                Allocated = 1024,\n                Limit = 1024,\n            },\n        },\n        StorageProfiles = new[]\n        {\n            new Vcd.Inputs.OrgVdcStorageProfileArgs\n            {\n                Name = \"my-storage-profile\",\n                Enabled = true,\n                Limit = 10240,\n                Default = true,\n            },\n        },\n        Enabled = true,\n        EnableThinProvisioning = true,\n        EnableFastProvisioning = true,\n        DeleteForce = true,\n        DeleteRecursive = true,\n        Elasticity = false,\n        IncludeVmMemoryOverhead = false,\n    });\n\n    var myAccessControl = new Vcd.OrgVdcAccessControl(\"my_access_control\", new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n        SharedWithEveryone = true,\n        EveryoneAccessLevel = \"ReadOnly\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.NewOrgVdc(ctx, \"my_vdc\", \u0026vcd.OrgVdcArgs{\n\t\t\tName:            pulumi.String(\"my-vdc\"),\n\t\t\tOrg:             pulumi.String(\"my-org\"),\n\t\t\tAllocationModel: pulumi.String(\"Flex\"),\n\t\t\tNetworkPoolName: pulumi.String(\"my-network-pool\"),\n\t\t\tProviderVdcName: pulumi.String(\"my-provider-vdc\"),\n\t\t\tComputeCapacity: \u0026vcd.OrgVdcComputeCapacityArgs{\n\t\t\t\tCpu: \u0026vcd.OrgVdcComputeCapacityCpuArgs{\n\t\t\t\t\tAllocated: pulumi.Int(1024),\n\t\t\t\t\tLimit:     pulumi.Int(1024),\n\t\t\t\t},\n\t\t\t\tMemory: \u0026vcd.OrgVdcComputeCapacityMemoryArgs{\n\t\t\t\t\tAllocated: pulumi.Int(1024),\n\t\t\t\t\tLimit:     pulumi.Int(1024),\n\t\t\t\t},\n\t\t\t},\n\t\t\tStorageProfiles: vcd.OrgVdcStorageProfileArray{\n\t\t\t\t\u0026vcd.OrgVdcStorageProfileArgs{\n\t\t\t\t\tName:    pulumi.String(\"my-storage-profile\"),\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tLimit:   pulumi.Int(10240),\n\t\t\t\t\tDefault: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnabled:                 pulumi.Bool(true),\n\t\t\tEnableThinProvisioning:  pulumi.Bool(true),\n\t\t\tEnableFastProvisioning:  pulumi.Bool(true),\n\t\t\tDeleteForce:             pulumi.Bool(true),\n\t\t\tDeleteRecursive:         pulumi.Bool(true),\n\t\t\tElasticity:              pulumi.Bool(false),\n\t\t\tIncludeVmMemoryOverhead: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewOrgVdcAccessControl(ctx, \"my_access_control\", \u0026vcd.OrgVdcAccessControlArgs{\n\t\t\tOrg:                 pulumi.String(\"my-org\"),\n\t\t\tVdc:                 pulumi.String(\"my-vdc\"),\n\t\t\tSharedWithEveryone:  pulumi.Bool(true),\n\t\t\tEveryoneAccessLevel: pulumi.String(\"ReadOnly\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.OrgVdc;\nimport com.pulumi.vcd.OrgVdcArgs;\nimport com.pulumi.vcd.inputs.OrgVdcComputeCapacityArgs;\nimport com.pulumi.vcd.inputs.OrgVdcComputeCapacityCpuArgs;\nimport com.pulumi.vcd.inputs.OrgVdcComputeCapacityMemoryArgs;\nimport com.pulumi.vcd.inputs.OrgVdcStorageProfileArgs;\nimport com.pulumi.vcd.OrgVdcAccessControl;\nimport com.pulumi.vcd.OrgVdcAccessControlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myVdc = new OrgVdc(\"myVdc\", OrgVdcArgs.builder()\n            .name(\"my-vdc\")\n            .org(\"my-org\")\n            .allocationModel(\"Flex\")\n            .networkPoolName(\"my-network-pool\")\n            .providerVdcName(\"my-provider-vdc\")\n            .computeCapacity(OrgVdcComputeCapacityArgs.builder()\n                .cpu(OrgVdcComputeCapacityCpuArgs.builder()\n                    .allocated(\"1024\")\n                    .limit(\"1024\")\n                    .build())\n                .memory(OrgVdcComputeCapacityMemoryArgs.builder()\n                    .allocated(\"1024\")\n                    .limit(\"1024\")\n                    .build())\n                .build())\n            .storageProfiles(OrgVdcStorageProfileArgs.builder()\n                .name(\"my-storage-profile\")\n                .enabled(true)\n                .limit(10240)\n                .default_(true)\n                .build())\n            .enabled(true)\n            .enableThinProvisioning(true)\n            .enableFastProvisioning(true)\n            .deleteForce(true)\n            .deleteRecursive(true)\n            .elasticity(false)\n            .includeVmMemoryOverhead(false)\n            .build());\n\n        var myAccessControl = new OrgVdcAccessControl(\"myAccessControl\", OrgVdcAccessControlArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .sharedWithEveryone(true)\n            .everyoneAccessLevel(\"ReadOnly\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myVdc:\n    type: vcd:OrgVdc\n    name: my_vdc\n    properties:\n      name: my-vdc\n      org: my-org\n      allocationModel: Flex\n      networkPoolName: my-network-pool\n      providerVdcName: my-provider-vdc\n      computeCapacity:\n        cpu:\n          allocated: '1024'\n          limit: '1024'\n        memory:\n          allocated: '1024'\n          limit: '1024'\n      storageProfiles:\n        - name: my-storage-profile\n          enabled: true\n          limit: 10240\n          default: true\n      enabled: true\n      enableThinProvisioning: true\n      enableFastProvisioning: true\n      deleteForce: true\n      deleteRecursive: true\n      elasticity: false\n      includeVmMemoryOverhead: false\n  myAccessControl:\n    type: vcd:OrgVdcAccessControl\n    name: my_access_control\n    properties:\n      org: my-org\n      vdc: my-vdc\n      sharedWithEveryone: true\n      everyoneAccessLevel: ReadOnly\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "everyoneAccessLevel": {
                    "type": "string",
                    "description": "Access level when the VDC is shared with everyone (only `ReadOnly` is available). Required when shared_with_everyone is set.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations.\n"
                },
                "sharedWithEveryone": {
                    "type": "boolean",
                    "description": "Whether the VDC is shared with everyone.\n"
                },
                "sharedWiths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcAccessControlSharedWith:OrgVdcAccessControlSharedWith"
                    },
                    "description": "one or more blocks defining a subject to which we are sharing.\nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is set.\n\n\u003e **Note:** Users must either set sharing for everybody using `shared_with_everyone` and `everyone_access_level` arguments or per user/group access using `shared_with` argument. Setting both will make the resource to error.\n\n\u003ca id=\"shared_with\"\u003e\u003c/a\u003e\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "sharedWithEveryone"
            ],
            "inputProperties": {
                "everyoneAccessLevel": {
                    "type": "string",
                    "description": "Access level when the VDC is shared with everyone (only `ReadOnly` is available). Required when shared_with_everyone is set.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations.\n",
                    "willReplaceOnChanges": true
                },
                "sharedWithEveryone": {
                    "type": "boolean",
                    "description": "Whether the VDC is shared with everyone.\n"
                },
                "sharedWiths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcAccessControlSharedWith:OrgVdcAccessControlSharedWith"
                    },
                    "description": "one or more blocks defining a subject to which we are sharing.\nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is set.\n\n\u003e **Note:** Users must either set sharing for everybody using `shared_with_everyone` and `everyone_access_level` arguments or per user/group access using `shared_with` argument. Setting both will make the resource to error.\n\n\u003ca id=\"shared_with\"\u003e\u003c/a\u003e\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "sharedWithEveryone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgVdcAccessControl resources.\n",
                "properties": {
                    "everyoneAccessLevel": {
                        "type": "string",
                        "description": "Access level when the VDC is shared with everyone (only `ReadOnly` is available). Required when shared_with_everyone is set.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations.\n",
                        "willReplaceOnChanges": true
                    },
                    "sharedWithEveryone": {
                        "type": "boolean",
                        "description": "Whether the VDC is shared with everyone.\n"
                    },
                    "sharedWiths": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/OrgVdcAccessControlSharedWith:OrgVdcAccessControlSharedWith"
                        },
                        "description": "one or more blocks defining a subject to which we are sharing.\nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is set.\n\n\u003e **Note:** Users must either set sharing for everybody using `shared_with_everyone` and `everyone_access_level` arguments or per user/group access using `shared_with` argument. Setting both will make the resource to error.\n\n\u003ca id=\"shared_with\"\u003e\u003c/a\u003e\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgVdcNsxtNetworkProfile:OrgVdcNsxtNetworkProfile": {
            "properties": {
                "edgeClusterId": {
                    "type": "string",
                    "description": "Edge Cluster ID to be used for this VDC\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n"
                },
                "vappNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Default Segment Profile\nTemplate ID for all vApp Networks in a VDC\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vdcNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Default Segment Profile\nTemplate ID for all VDC Networks in a VDC\n"
                }
            },
            "inputProperties": {
                "edgeClusterId": {
                    "type": "string",
                    "description": "Edge Cluster ID to be used for this VDC\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                    "willReplaceOnChanges": true
                },
                "vappNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Default Segment Profile\nTemplate ID for all vApp Networks in a VDC\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "vdcNetworksDefaultSegmentProfileTemplateId": {
                    "type": "string",
                    "description": "Default Segment Profile\nTemplate ID for all VDC Networks in a VDC\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgVdcNsxtNetworkProfile resources.\n",
                "properties": {
                    "edgeClusterId": {
                        "type": "string",
                        "description": "Edge Cluster ID to be used for this VDC\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                        "willReplaceOnChanges": true
                    },
                    "vappNetworksDefaultSegmentProfileTemplateId": {
                        "type": "string",
                        "description": "Default Segment Profile\nTemplate ID for all vApp Networks in a VDC\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vdcNetworksDefaultSegmentProfileTemplateId": {
                        "type": "string",
                        "description": "Default Segment Profile\nTemplate ID for all VDC Networks in a VDC\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgVdcTemplate:OrgVdcTemplate": {
            "properties": {
                "allocationModel": {
                    "type": "string",
                    "description": "Allocation model that the VDCs instantiated from this template will use.\nMust be one of: `AllocationVApp`, `AllocationPool`, `ReservationPool` or  `Flex`\n"
                },
                "computeConfiguration": {
                    "$ref": "#/types/vcd:index/OrgVdcTemplateComputeConfiguration:OrgVdcTemplateComputeConfiguration",
                    "description": "The compute configuration for the VDCs instantiated from this template:\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the Organization VDC Template, as seen by System administrators\n"
                },
                "edgeGateway": {
                    "$ref": "#/types/vcd:index/OrgVdcTemplateEdgeGateway:OrgVdcTemplateEdgeGateway",
                    "description": "VDCs instantiated from this template will create a new Edge Gateway with the provided setup. Required if any `provider_vdc` block\nhas defined a `gateway_edge_cluster_id`. This **unique** block has the following properties:\n"
                },
                "enableFastProvisioning": {
                    "type": "boolean",
                    "description": "If `true`, the VDCs instantiated from this template will have Fast provisioning enabled. Defaults to `false`\n"
                },
                "enableThinProvisioning": {
                    "type": "boolean",
                    "description": "If `true`, the VDCs instantiated from this template will have Thin provisioning enabled. Defaults to `false`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name to give to the Organization VDC Template, as seen by System administrators\n"
                },
                "networkPoolId": {
                    "type": "string",
                    "description": "If set, specifies the Network pool for the instantiated VDCs. Otherwise, it is automatically chosen\n"
                },
                "nicQuota": {
                    "type": "integer",
                    "description": "Quota for the NICs of the instantiated VDCs. Defaults to 100\n"
                },
                "providerVdcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcTemplateProviderVdc:OrgVdcTemplateProviderVdc"
                    },
                    "description": "A block that defines a candidate location for the instantiated VDCs. There must be **at least one**, which has the following properties:\n"
                },
                "provisionedNetworkQuota": {
                    "type": "integer",
                    "description": "Quota for the provisioned networks of the instantiated VDCs. Defaults to 1000\n"
                },
                "readableByOrgIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Organization IDs that will be able to view and read this VDC template, they can be obtained with\n[`vcd.Org` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org)\n"
                },
                "storageProfiles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcTemplateStorageProfile:OrgVdcTemplateStorageProfile"
                    },
                    "description": "A block that defines a storage profile that the VDCs instantiated from this template will use. Must be **at least one**, which has the following properties:\n"
                },
                "tenantDescription": {
                    "type": "string",
                    "description": "Description of the Organization VDC Template, as seen by the allowed tenants\n"
                },
                "tenantName": {
                    "type": "string",
                    "description": "Name to give to the Organization VDC Template, as seen by the allowed tenants\n"
                },
                "vmQuota": {
                    "type": "integer",
                    "description": "Quota for the VMs of the instantiated VDCs. 0 means unlimited. Defaults to 0\n"
                }
            },
            "required": [
                "allocationModel",
                "computeConfiguration",
                "name",
                "providerVdcs",
                "storageProfiles",
                "tenantName"
            ],
            "inputProperties": {
                "allocationModel": {
                    "type": "string",
                    "description": "Allocation model that the VDCs instantiated from this template will use.\nMust be one of: `AllocationVApp`, `AllocationPool`, `ReservationPool` or  `Flex`\n"
                },
                "computeConfiguration": {
                    "$ref": "#/types/vcd:index/OrgVdcTemplateComputeConfiguration:OrgVdcTemplateComputeConfiguration",
                    "description": "The compute configuration for the VDCs instantiated from this template:\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the Organization VDC Template, as seen by System administrators\n"
                },
                "edgeGateway": {
                    "$ref": "#/types/vcd:index/OrgVdcTemplateEdgeGateway:OrgVdcTemplateEdgeGateway",
                    "description": "VDCs instantiated from this template will create a new Edge Gateway with the provided setup. Required if any `provider_vdc` block\nhas defined a `gateway_edge_cluster_id`. This **unique** block has the following properties:\n"
                },
                "enableFastProvisioning": {
                    "type": "boolean",
                    "description": "If `true`, the VDCs instantiated from this template will have Fast provisioning enabled. Defaults to `false`\n"
                },
                "enableThinProvisioning": {
                    "type": "boolean",
                    "description": "If `true`, the VDCs instantiated from this template will have Thin provisioning enabled. Defaults to `false`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name to give to the Organization VDC Template, as seen by System administrators\n"
                },
                "networkPoolId": {
                    "type": "string",
                    "description": "If set, specifies the Network pool for the instantiated VDCs. Otherwise, it is automatically chosen\n"
                },
                "nicQuota": {
                    "type": "integer",
                    "description": "Quota for the NICs of the instantiated VDCs. Defaults to 100\n"
                },
                "providerVdcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcTemplateProviderVdc:OrgVdcTemplateProviderVdc"
                    },
                    "description": "A block that defines a candidate location for the instantiated VDCs. There must be **at least one**, which has the following properties:\n"
                },
                "provisionedNetworkQuota": {
                    "type": "integer",
                    "description": "Quota for the provisioned networks of the instantiated VDCs. Defaults to 1000\n"
                },
                "readableByOrgIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Organization IDs that will be able to view and read this VDC template, they can be obtained with\n[`vcd.Org` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org)\n"
                },
                "storageProfiles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/OrgVdcTemplateStorageProfile:OrgVdcTemplateStorageProfile"
                    },
                    "description": "A block that defines a storage profile that the VDCs instantiated from this template will use. Must be **at least one**, which has the following properties:\n"
                },
                "tenantDescription": {
                    "type": "string",
                    "description": "Description of the Organization VDC Template, as seen by the allowed tenants\n"
                },
                "tenantName": {
                    "type": "string",
                    "description": "Name to give to the Organization VDC Template, as seen by the allowed tenants\n"
                },
                "vmQuota": {
                    "type": "integer",
                    "description": "Quota for the VMs of the instantiated VDCs. 0 means unlimited. Defaults to 0\n"
                }
            },
            "requiredInputs": [
                "allocationModel",
                "computeConfiguration",
                "providerVdcs",
                "storageProfiles",
                "tenantName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgVdcTemplate resources.\n",
                "properties": {
                    "allocationModel": {
                        "type": "string",
                        "description": "Allocation model that the VDCs instantiated from this template will use.\nMust be one of: `AllocationVApp`, `AllocationPool`, `ReservationPool` or  `Flex`\n"
                    },
                    "computeConfiguration": {
                        "$ref": "#/types/vcd:index/OrgVdcTemplateComputeConfiguration:OrgVdcTemplateComputeConfiguration",
                        "description": "The compute configuration for the VDCs instantiated from this template:\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the Organization VDC Template, as seen by System administrators\n"
                    },
                    "edgeGateway": {
                        "$ref": "#/types/vcd:index/OrgVdcTemplateEdgeGateway:OrgVdcTemplateEdgeGateway",
                        "description": "VDCs instantiated from this template will create a new Edge Gateway with the provided setup. Required if any `provider_vdc` block\nhas defined a `gateway_edge_cluster_id`. This **unique** block has the following properties:\n"
                    },
                    "enableFastProvisioning": {
                        "type": "boolean",
                        "description": "If `true`, the VDCs instantiated from this template will have Fast provisioning enabled. Defaults to `false`\n"
                    },
                    "enableThinProvisioning": {
                        "type": "boolean",
                        "description": "If `true`, the VDCs instantiated from this template will have Thin provisioning enabled. Defaults to `false`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name to give to the Organization VDC Template, as seen by System administrators\n"
                    },
                    "networkPoolId": {
                        "type": "string",
                        "description": "If set, specifies the Network pool for the instantiated VDCs. Otherwise, it is automatically chosen\n"
                    },
                    "nicQuota": {
                        "type": "integer",
                        "description": "Quota for the NICs of the instantiated VDCs. Defaults to 100\n"
                    },
                    "providerVdcs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/OrgVdcTemplateProviderVdc:OrgVdcTemplateProviderVdc"
                        },
                        "description": "A block that defines a candidate location for the instantiated VDCs. There must be **at least one**, which has the following properties:\n"
                    },
                    "provisionedNetworkQuota": {
                        "type": "integer",
                        "description": "Quota for the provisioned networks of the instantiated VDCs. Defaults to 1000\n"
                    },
                    "readableByOrgIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of Organization IDs that will be able to view and read this VDC template, they can be obtained with\n[`vcd.Org` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org)\n"
                    },
                    "storageProfiles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/OrgVdcTemplateStorageProfile:OrgVdcTemplateStorageProfile"
                        },
                        "description": "A block that defines a storage profile that the VDCs instantiated from this template will use. Must be **at least one**, which has the following properties:\n"
                    },
                    "tenantDescription": {
                        "type": "string",
                        "description": "Description of the Organization VDC Template, as seen by the allowed tenants\n"
                    },
                    "tenantName": {
                        "type": "string",
                        "description": "Name to give to the Organization VDC Template, as seen by the allowed tenants\n"
                    },
                    "vmQuota": {
                        "type": "integer",
                        "description": "Quota for the VMs of the instantiated VDCs. 0 means unlimited. Defaults to 0\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/orgVdcTemplateInstance:OrgVdcTemplateInstance": {
            "properties": {
                "deleteForce": {
                    "type": "boolean",
                    "description": "Defaults to `false`. If this flag is set to `true`, it forcefully deletes the VDC, only when `delete_instantiated_vdc_on_removal=true`\n"
                },
                "deleteInstantiatedVdcOnRemoval": {
                    "type": "boolean",
                    "description": "If this flag is set to `true`, removing this resource will attempt to delete the instantiated VDC\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "Defaults to `false`. If this flag is set to `true`, it recursively deletes the VDC, only when `delete_instantiated_vdc_on_removal=true`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the instantiated Organization VDC\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name to give to the instantiated Organization VDC\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "ID of the Organization where the VDC will be instantiated\n"
                },
                "orgVdcTemplateId": {
                    "type": "string",
                    "description": "The ID of the VDC Template to instantiate\n"
                }
            },
            "required": [
                "deleteInstantiatedVdcOnRemoval",
                "name",
                "orgId",
                "orgVdcTemplateId"
            ],
            "inputProperties": {
                "deleteForce": {
                    "type": "boolean",
                    "description": "Defaults to `false`. If this flag is set to `true`, it forcefully deletes the VDC, only when `delete_instantiated_vdc_on_removal=true`\n"
                },
                "deleteInstantiatedVdcOnRemoval": {
                    "type": "boolean",
                    "description": "If this flag is set to `true`, removing this resource will attempt to delete the instantiated VDC\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "Defaults to `false`. If this flag is set to `true`, it recursively deletes the VDC, only when `delete_instantiated_vdc_on_removal=true`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the instantiated Organization VDC\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name to give to the instantiated Organization VDC\n",
                    "willReplaceOnChanges": true
                },
                "orgId": {
                    "type": "string",
                    "description": "ID of the Organization where the VDC will be instantiated\n",
                    "willReplaceOnChanges": true
                },
                "orgVdcTemplateId": {
                    "type": "string",
                    "description": "The ID of the VDC Template to instantiate\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "deleteInstantiatedVdcOnRemoval",
                "orgId",
                "orgVdcTemplateId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgVdcTemplateInstance resources.\n",
                "properties": {
                    "deleteForce": {
                        "type": "boolean",
                        "description": "Defaults to `false`. If this flag is set to `true`, it forcefully deletes the VDC, only when `delete_instantiated_vdc_on_removal=true`\n"
                    },
                    "deleteInstantiatedVdcOnRemoval": {
                        "type": "boolean",
                        "description": "If this flag is set to `true`, removing this resource will attempt to delete the instantiated VDC\n"
                    },
                    "deleteRecursive": {
                        "type": "boolean",
                        "description": "Defaults to `false`. If this flag is set to `true`, it recursively deletes the VDC, only when `delete_instantiated_vdc_on_removal=true`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the instantiated Organization VDC\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name to give to the instantiated Organization VDC\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "ID of the Organization where the VDC will be instantiated\n",
                        "willReplaceOnChanges": true
                    },
                    "orgVdcTemplateId": {
                        "type": "string",
                        "description": "The ID of the VDC Template to instantiate\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/providerVdc:ProviderVdc": {
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of virtual hardware versions supported by this Provider VDC.\n"
                },
                "computeCapacities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ProviderVdcComputeCapacity:ProviderVdcComputeCapacity"
                    },
                    "description": "An indicator of CPU and memory capacity. See Compute Capacity below for details.\n"
                },
                "computeProviderScope": {
                    "type": "string",
                    "description": "Represents the compute fault domain for this Provider VDC. This value is a tenant-facing tag that is shown to tenants when viewing fault domains of the child Organization VDCs (for example, a VDC Group).\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the Provider VDC.\n"
                },
                "externalNetworkIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of External Networks.\n"
                },
                "highestSupportedHardwareVersion": {
                    "type": "string",
                    "description": "The highest virtual hardware version supported by this Provider VDC. This value cannot be changed to a lower version, and can only be updated when adding a new resource pool.\n"
                },
                "hostIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set containing all the hosts which are connected to VC server.\n"
                },
                "isEnabled": {
                    "type": "boolean",
                    "description": "True if this Provider VDC is enabled and can provide resources to organization VDCs. A Provider VDC is always enabled on creation.\n"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ProviderVdcMetadataEntry:ProviderVdcMetadataEntry"
                    },
                    "description": "A set of metadata entries assigned to the Provider VDC. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Provider VDC name\n"
                },
                "networkPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set IDs of the Network Pools used by this Provider VDC.\n"
                },
                "nsxtManagerId": {
                    "type": "string",
                    "description": "ID of the registered NSX-T Manager that backs networking operations for this Provider VDC.\n"
                },
                "resourcePoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of the Resource Pools backing this provider VDC. (Note: only one resource pool can be set at creation).\n"
                },
                "status": {
                    "type": "integer",
                    "description": "Status of the Provider VDC: -1 (creation failed), 0 (not ready), 1 (ready), 2 (unknown) or 3 (unrecognized).\n"
                },
                "storageContainerIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of the vSphere datastores backing this provider VDC\n"
                },
                "storageProfileIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs to the Storage Profiles available to this Provider VDC.\n"
                },
                "storageProfileNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of Storage Profile names used to create this provider VDC.\n"
                },
                "universalNetworkPoolId": {
                    "type": "string",
                    "description": "ID of the universal network reference.\n"
                },
                "vcenterId": {
                    "type": "string",
                    "description": "ID of the vCenter Server that provides the Resource Pools and Datastores.\n"
                }
            },
            "required": [
                "capabilities",
                "computeCapacities",
                "computeProviderScope",
                "externalNetworkIds",
                "highestSupportedHardwareVersion",
                "hostIds",
                "name",
                "networkPoolIds",
                "resourcePoolIds",
                "status",
                "storageContainerIds",
                "storageProfileIds",
                "storageProfileNames",
                "universalNetworkPoolId",
                "vcenterId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the Provider VDC.\n"
                },
                "highestSupportedHardwareVersion": {
                    "type": "string",
                    "description": "The highest virtual hardware version supported by this Provider VDC. This value cannot be changed to a lower version, and can only be updated when adding a new resource pool.\n"
                },
                "isEnabled": {
                    "type": "boolean",
                    "description": "True if this Provider VDC is enabled and can provide resources to organization VDCs. A Provider VDC is always enabled on creation.\n"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/ProviderVdcMetadataEntry:ProviderVdcMetadataEntry"
                    },
                    "description": "A set of metadata entries assigned to the Provider VDC. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Provider VDC name\n"
                },
                "networkPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set IDs of the Network Pools used by this Provider VDC.\n"
                },
                "nsxtManagerId": {
                    "type": "string",
                    "description": "ID of the registered NSX-T Manager that backs networking operations for this Provider VDC.\n",
                    "willReplaceOnChanges": true
                },
                "resourcePoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of IDs of the Resource Pools backing this provider VDC. (Note: only one resource pool can be set at creation).\n"
                },
                "storageProfileNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of Storage Profile names used to create this provider VDC.\n"
                },
                "vcenterId": {
                    "type": "string",
                    "description": "ID of the vCenter Server that provides the Resource Pools and Datastores.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "highestSupportedHardwareVersion",
                "resourcePoolIds",
                "storageProfileNames",
                "vcenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProviderVdc resources.\n",
                "properties": {
                    "capabilities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of virtual hardware versions supported by this Provider VDC.\n"
                    },
                    "computeCapacities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/ProviderVdcComputeCapacity:ProviderVdcComputeCapacity"
                        },
                        "description": "An indicator of CPU and memory capacity. See Compute Capacity below for details.\n"
                    },
                    "computeProviderScope": {
                        "type": "string",
                        "description": "Represents the compute fault domain for this Provider VDC. This value is a tenant-facing tag that is shown to tenants when viewing fault domains of the child Organization VDCs (for example, a VDC Group).\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the Provider VDC.\n"
                    },
                    "externalNetworkIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IDs of External Networks.\n"
                    },
                    "highestSupportedHardwareVersion": {
                        "type": "string",
                        "description": "The highest virtual hardware version supported by this Provider VDC. This value cannot be changed to a lower version, and can only be updated when adding a new resource pool.\n"
                    },
                    "hostIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set containing all the hosts which are connected to VC server.\n"
                    },
                    "isEnabled": {
                        "type": "boolean",
                        "description": "True if this Provider VDC is enabled and can provide resources to organization VDCs. A Provider VDC is always enabled on creation.\n"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/ProviderVdcMetadataEntry:ProviderVdcMetadataEntry"
                        },
                        "description": "A set of metadata entries assigned to the Provider VDC. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Provider VDC name\n"
                    },
                    "networkPoolIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set IDs of the Network Pools used by this Provider VDC.\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "ID of the registered NSX-T Manager that backs networking operations for this Provider VDC.\n",
                        "willReplaceOnChanges": true
                    },
                    "resourcePoolIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IDs of the Resource Pools backing this provider VDC. (Note: only one resource pool can be set at creation).\n"
                    },
                    "status": {
                        "type": "integer",
                        "description": "Status of the Provider VDC: -1 (creation failed), 0 (not ready), 1 (ready), 2 (unknown) or 3 (unrecognized).\n"
                    },
                    "storageContainerIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IDs of the vSphere datastores backing this provider VDC\n"
                    },
                    "storageProfileIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of IDs to the Storage Profiles available to this Provider VDC.\n"
                    },
                    "storageProfileNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of Storage Profile names used to create this provider VDC.\n"
                    },
                    "universalNetworkPoolId": {
                        "type": "string",
                        "description": "ID of the universal network reference.\n"
                    },
                    "vcenterId": {
                        "type": "string",
                        "description": "ID of the vCenter Server that provides the Resource Pools and Datastores.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/rde:Rde": {
            "properties": {
                "computedEntity": {
                    "type": "string",
                    "description": "The real state of this RDE in VCD. See Input entity vs Computed entity below for details.\n"
                },
                "entityInSync": {
                    "type": "boolean",
                    "description": "It's `true` when `computed_entity` is equal to either `input_entity` or the contents of `input_entity_url`,\nmeaning that the computed RDE retrieved from VCD is synchronized with the input RDE.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "An external input_entity's ID that this Runtime Defined Entity may have a relation to.\n"
                },
                "inputEntity": {
                    "type": "string",
                    "description": "A string that specifies a valid JSON for the RDE. It can be retrieved with functions such as `file`, `templatefile`... Either `input_entity` or `input_entity_url` is required.\n"
                },
                "inputEntityUrl": {
                    "type": "string",
                    "description": "URL that should point to a JSON representation of the Runtime Defined Entity and is used to initialize/override its\ncontents\n"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/RdeMetadataEntry:RdeMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Runtime Defined Entity. It can be non-unique.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Name of the [Organization](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org) that will own the RDE, optional if defined at provider level.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the [Organization](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org) to which the Runtime Defined Entity belongs.\n"
                },
                "ownerUserId": {
                    "type": "string",
                    "description": "The ID of the [Organization user](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_user) that owns this Runtime Defined Entity.\n"
                },
                "rdeTypeId": {
                    "type": "string",
                    "description": "The ID of the [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/rde_type) to instantiate. It only supports\nupdating to a **newer/lower** `version` of the **same** RDE Type.\n"
                },
                "resolve": {
                    "type": "boolean",
                    "description": "If `true`, the Runtime Defined Entity will be resolved by this provider. If `false`, it won't be\nresolved and must be done either by an external component action or by an update. The Runtime Defined Entity can't be\ndeleted until the input_entity is resolved by either party, unless `resolve_on_removal=true`. See RDE resolution for more details.\n"
                },
                "resolveOnRemoval": {
                    "type": "boolean",
                    "description": "If `true`, the Runtime Defined Entity will be resolved before it gets deleted, to ensure forced deletion. Destroy will fail if it is not resolved. It is `false` by default.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Specifies whether the entity is correctly resolved or not. When created it will be in `PRE_CREATED` state.\nIf the entity is correctly validated against its [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type) schema, the state will be `RESOLVED`,\notherwise it will be `RESOLUTION_ERROR`.\n"
                }
            },
            "required": [
                "computedEntity",
                "entityInSync",
                "externalId",
                "name",
                "orgId",
                "ownerUserId",
                "rdeTypeId",
                "resolve",
                "state"
            ],
            "inputProperties": {
                "externalId": {
                    "type": "string",
                    "description": "An external input_entity's ID that this Runtime Defined Entity may have a relation to.\n"
                },
                "inputEntity": {
                    "type": "string",
                    "description": "A string that specifies a valid JSON for the RDE. It can be retrieved with functions such as `file`, `templatefile`... Either `input_entity` or `input_entity_url` is required.\n"
                },
                "inputEntityUrl": {
                    "type": "string",
                    "description": "URL that should point to a JSON representation of the Runtime Defined Entity and is used to initialize/override its\ncontents\n"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/RdeMetadataEntry:RdeMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Runtime Defined Entity. It can be non-unique.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Name of the [Organization](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org) that will own the RDE, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "rdeTypeId": {
                    "type": "string",
                    "description": "The ID of the [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/rde_type) to instantiate. It only supports\nupdating to a **newer/lower** `version` of the **same** RDE Type.\n"
                },
                "resolve": {
                    "type": "boolean",
                    "description": "If `true`, the Runtime Defined Entity will be resolved by this provider. If `false`, it won't be\nresolved and must be done either by an external component action or by an update. The Runtime Defined Entity can't be\ndeleted until the input_entity is resolved by either party, unless `resolve_on_removal=true`. See RDE resolution for more details.\n"
                },
                "resolveOnRemoval": {
                    "type": "boolean",
                    "description": "If `true`, the Runtime Defined Entity will be resolved before it gets deleted, to ensure forced deletion. Destroy will fail if it is not resolved. It is `false` by default.\n"
                }
            },
            "requiredInputs": [
                "rdeTypeId",
                "resolve"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Rde resources.\n",
                "properties": {
                    "computedEntity": {
                        "type": "string",
                        "description": "The real state of this RDE in VCD. See Input entity vs Computed entity below for details.\n"
                    },
                    "entityInSync": {
                        "type": "boolean",
                        "description": "It's `true` when `computed_entity` is equal to either `input_entity` or the contents of `input_entity_url`,\nmeaning that the computed RDE retrieved from VCD is synchronized with the input RDE.\n"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "An external input_entity's ID that this Runtime Defined Entity may have a relation to.\n"
                    },
                    "inputEntity": {
                        "type": "string",
                        "description": "A string that specifies a valid JSON for the RDE. It can be retrieved with functions such as `file`, `templatefile`... Either `input_entity` or `input_entity_url` is required.\n"
                    },
                    "inputEntityUrl": {
                        "type": "string",
                        "description": "URL that should point to a JSON representation of the Runtime Defined Entity and is used to initialize/override its\ncontents\n"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/RdeMetadataEntry:RdeMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Runtime Defined Entity. It can be non-unique.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Name of the [Organization](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org) that will own the RDE, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the [Organization](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org) to which the Runtime Defined Entity belongs.\n"
                    },
                    "ownerUserId": {
                        "type": "string",
                        "description": "The ID of the [Organization user](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_user) that owns this Runtime Defined Entity.\n"
                    },
                    "rdeTypeId": {
                        "type": "string",
                        "description": "The ID of the [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/rde_type) to instantiate. It only supports\nupdating to a **newer/lower** `version` of the **same** RDE Type.\n"
                    },
                    "resolve": {
                        "type": "boolean",
                        "description": "If `true`, the Runtime Defined Entity will be resolved by this provider. If `false`, it won't be\nresolved and must be done either by an external component action or by an update. The Runtime Defined Entity can't be\ndeleted until the input_entity is resolved by either party, unless `resolve_on_removal=true`. See RDE resolution for more details.\n"
                    },
                    "resolveOnRemoval": {
                        "type": "boolean",
                        "description": "If `true`, the Runtime Defined Entity will be resolved before it gets deleted, to ensure forced deletion. Destroy will fail if it is not resolved. It is `false` by default.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Specifies whether the entity is correctly resolved or not. When created it will be in `PRE_CREATED` state.\nIf the entity is correctly validated against its [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type) schema, the state will be `RESOLVED`,\notherwise it will be `RESOLUTION_ERROR`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/rdeInterface:RdeInterface": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the RDE Interface.\n"
                },
                "nss": {
                    "type": "string",
                    "description": "A unique namespace associated with the RDE Interface. Only alphanumeric characters, underscores and hyphens allowed.\n"
                },
                "readonly": {
                    "type": "boolean",
                    "description": "Specifies if the RDE Interface can be only read.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "The vendor of the RDE Interface. Only alphanumeric characters, underscores and hyphens allowed.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the RDE Interface. Must follow [semantic versioning](https://semver.org/) syntax.\n"
                }
            },
            "required": [
                "name",
                "nss",
                "readonly",
                "vendor",
                "version"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the RDE Interface.\n"
                },
                "nss": {
                    "type": "string",
                    "description": "A unique namespace associated with the RDE Interface. Only alphanumeric characters, underscores and hyphens allowed.\n",
                    "willReplaceOnChanges": true
                },
                "vendor": {
                    "type": "string",
                    "description": "The vendor of the RDE Interface. Only alphanumeric characters, underscores and hyphens allowed.\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "string",
                    "description": "The version of the RDE Interface. Must follow [semantic versioning](https://semver.org/) syntax.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "nss",
                "vendor",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RdeInterface resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the RDE Interface.\n"
                    },
                    "nss": {
                        "type": "string",
                        "description": "A unique namespace associated with the RDE Interface. Only alphanumeric characters, underscores and hyphens allowed.\n",
                        "willReplaceOnChanges": true
                    },
                    "readonly": {
                        "type": "boolean",
                        "description": "Specifies if the RDE Interface can be only read.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor of the RDE Interface. Only alphanumeric characters, underscores and hyphens allowed.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the RDE Interface. Must follow [semantic versioning](https://semver.org/) syntax.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/rdeInterfaceBehavior:RdeInterfaceBehavior": {
            "properties": {
                "alwaysUpdateSecureExecutionProperties": {
                    "type": "boolean",
                    "description": "Useful to update execution properties marked with `_secure_` and `_internal_`\nas these are not retrievable from VCD, so they are not saved in state. Setting this to `true` will make the provider\nto ask for updates whenever there is a secure property in the execution of the Behavior\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description specifying the contract of the Behavior\n"
                },
                "execution": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map that specifies the Behavior execution mechanism, this is just a simplification of `execution_json` that\ncan make the configuration more readable for simpler Behaviors. One of `execution_json` or `execution` must be set.\n"
                },
                "executionJson": {
                    "type": "string",
                    "description": "A string representing a valid JSON that specifies the Behavior execution mechanism.\nYou can find more information about the different execution types, like `WebHook`, `noop`, `Activity`, `MQTT`, `VRO`, `AWSLambdaFaaS`\nand others [in the Extensibility SDK documentation](https://vmware.github.io/vcd-ext-sdk/docs/defined_entities_api/behaviors).\nOne of `execution_json` or `execution` must be set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Behavior\n"
                },
                "rdeInterfaceId": {
                    "type": "string",
                    "description": "The ID of the RDE Interface that owns the Behavior\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The Behavior invocation reference to be used for polymorphic behavior invocations\n"
                }
            },
            "required": [
                "execution",
                "executionJson",
                "name",
                "rdeInterfaceId",
                "ref"
            ],
            "inputProperties": {
                "alwaysUpdateSecureExecutionProperties": {
                    "type": "boolean",
                    "description": "Useful to update execution properties marked with `_secure_` and `_internal_`\nas these are not retrievable from VCD, so they are not saved in state. Setting this to `true` will make the provider\nto ask for updates whenever there is a secure property in the execution of the Behavior\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description specifying the contract of the Behavior\n"
                },
                "execution": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map that specifies the Behavior execution mechanism, this is just a simplification of `execution_json` that\ncan make the configuration more readable for simpler Behaviors. One of `execution_json` or `execution` must be set.\n"
                },
                "executionJson": {
                    "type": "string",
                    "description": "A string representing a valid JSON that specifies the Behavior execution mechanism.\nYou can find more information about the different execution types, like `WebHook`, `noop`, `Activity`, `MQTT`, `VRO`, `AWSLambdaFaaS`\nand others [in the Extensibility SDK documentation](https://vmware.github.io/vcd-ext-sdk/docs/defined_entities_api/behaviors).\nOne of `execution_json` or `execution` must be set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Behavior\n",
                    "willReplaceOnChanges": true
                },
                "rdeInterfaceId": {
                    "type": "string",
                    "description": "The ID of the RDE Interface that owns the Behavior\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "rdeInterfaceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RdeInterfaceBehavior resources.\n",
                "properties": {
                    "alwaysUpdateSecureExecutionProperties": {
                        "type": "boolean",
                        "description": "Useful to update execution properties marked with `_secure_` and `_internal_`\nas these are not retrievable from VCD, so they are not saved in state. Setting this to `true` will make the provider\nto ask for updates whenever there is a secure property in the execution of the Behavior\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description specifying the contract of the Behavior\n"
                    },
                    "execution": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map that specifies the Behavior execution mechanism, this is just a simplification of `execution_json` that\ncan make the configuration more readable for simpler Behaviors. One of `execution_json` or `execution` must be set.\n"
                    },
                    "executionJson": {
                        "type": "string",
                        "description": "A string representing a valid JSON that specifies the Behavior execution mechanism.\nYou can find more information about the different execution types, like `WebHook`, `noop`, `Activity`, `MQTT`, `VRO`, `AWSLambdaFaaS`\nand others [in the Extensibility SDK documentation](https://vmware.github.io/vcd-ext-sdk/docs/defined_entities_api/behaviors).\nOne of `execution_json` or `execution` must be set.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Behavior\n",
                        "willReplaceOnChanges": true
                    },
                    "rdeInterfaceId": {
                        "type": "string",
                        "description": "The ID of the RDE Interface that owns the Behavior\n",
                        "willReplaceOnChanges": true
                    },
                    "ref": {
                        "type": "string",
                        "description": "The Behavior invocation reference to be used for polymorphic behavior invocations\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/rdeType:RdeType": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the Runtime Defined Entity Type.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "An external entity's ID that this Runtime Defined Entity Type may apply to.\n"
                },
                "hooks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/RdeTypeHook:RdeTypeHook"
                    },
                    "description": "Each block maps a lifecycle event of [RDEs](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)  \nto existing [Behaviors](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior), that will be\nautomatically invoked when the corresponding event is triggered. These blocks have the following properties:\n"
                },
                "inheritedVersion": {
                    "type": "string",
                    "description": "To be used when creating a new version of a Runtime Defined Entity Type.\nSpecifies the version of the type that will be the template for the authorization configuration of the new version.\nThe Type ACLs and the access requirements of the Type Behaviors of the new version will be copied from those of the inherited version.\nIf not set, then the new type version will not inherit another version and will have the default authorization settings, just like the first version of a new type.\n"
                },
                "interfaceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of [Defined Interfaces](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface) that this Runtime Defined Entity Type will use.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Runtime Defined Entity Type.\n"
                },
                "nss": {
                    "type": "string",
                    "description": "A unique namespace associated with the Runtime Defined Entity Type. Only alphanumeric characters, underscores and hyphens allowed.\n"
                },
                "readonly": {
                    "type": "boolean",
                    "description": "True if the Runtime Defined Entity Type cannot be modified.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The JSON-Schema valid definition of the Runtime Defined Entity Type\n"
                },
                "schemaUrl": {
                    "type": "string",
                    "description": "URL that should point to a JSON-Schema valid definition file of the Runtime Defined Entity Type\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "The vendor of the Runtime Defined Entity Type. Only alphanumeric characters, underscores and hyphens allowed.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the Runtime Defined Entity Type. Must follow [semantic versioning](https://semver.org/) syntax.\n"
                }
            },
            "required": [
                "name",
                "nss",
                "readonly",
                "schema",
                "vendor",
                "version"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the Runtime Defined Entity Type.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "An external entity's ID that this Runtime Defined Entity Type may apply to.\n"
                },
                "hooks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/RdeTypeHook:RdeTypeHook"
                    },
                    "description": "Each block maps a lifecycle event of [RDEs](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)  \nto existing [Behaviors](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior), that will be\nautomatically invoked when the corresponding event is triggered. These blocks have the following properties:\n"
                },
                "inheritedVersion": {
                    "type": "string",
                    "description": "To be used when creating a new version of a Runtime Defined Entity Type.\nSpecifies the version of the type that will be the template for the authorization configuration of the new version.\nThe Type ACLs and the access requirements of the Type Behaviors of the new version will be copied from those of the inherited version.\nIf not set, then the new type version will not inherit another version and will have the default authorization settings, just like the first version of a new type.\n",
                    "willReplaceOnChanges": true
                },
                "interfaceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of [Defined Interfaces](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface) that this Runtime Defined Entity Type will use.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Runtime Defined Entity Type.\n"
                },
                "nss": {
                    "type": "string",
                    "description": "A unique namespace associated with the Runtime Defined Entity Type. Only alphanumeric characters, underscores and hyphens allowed.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The JSON-Schema valid definition of the Runtime Defined Entity Type\n"
                },
                "schemaUrl": {
                    "type": "string",
                    "description": "URL that should point to a JSON-Schema valid definition file of the Runtime Defined Entity Type\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "The vendor of the Runtime Defined Entity Type. Only alphanumeric characters, underscores and hyphens allowed.\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "string",
                    "description": "The version of the Runtime Defined Entity Type. Must follow [semantic versioning](https://semver.org/) syntax.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "nss",
                "vendor",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RdeType resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the Runtime Defined Entity Type.\n"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "An external entity's ID that this Runtime Defined Entity Type may apply to.\n"
                    },
                    "hooks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/RdeTypeHook:RdeTypeHook"
                        },
                        "description": "Each block maps a lifecycle event of [RDEs](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)  \nto existing [Behaviors](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior), that will be\nautomatically invoked when the corresponding event is triggered. These blocks have the following properties:\n"
                    },
                    "inheritedVersion": {
                        "type": "string",
                        "description": "To be used when creating a new version of a Runtime Defined Entity Type.\nSpecifies the version of the type that will be the template for the authorization configuration of the new version.\nThe Type ACLs and the access requirements of the Type Behaviors of the new version will be copied from those of the inherited version.\nIf not set, then the new type version will not inherit another version and will have the default authorization settings, just like the first version of a new type.\n",
                        "willReplaceOnChanges": true
                    },
                    "interfaceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The set of [Defined Interfaces](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface) that this Runtime Defined Entity Type will use.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Runtime Defined Entity Type.\n"
                    },
                    "nss": {
                        "type": "string",
                        "description": "A unique namespace associated with the Runtime Defined Entity Type. Only alphanumeric characters, underscores and hyphens allowed.\n",
                        "willReplaceOnChanges": true
                    },
                    "readonly": {
                        "type": "boolean",
                        "description": "True if the Runtime Defined Entity Type cannot be modified.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The JSON-Schema valid definition of the Runtime Defined Entity Type\n"
                    },
                    "schemaUrl": {
                        "type": "string",
                        "description": "URL that should point to a JSON-Schema valid definition file of the Runtime Defined Entity Type\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor of the Runtime Defined Entity Type. Only alphanumeric characters, underscores and hyphens allowed.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the Runtime Defined Entity Type. Must follow [semantic versioning](https://semver.org/) syntax.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/rdeTypeBehavior:RdeTypeBehavior": {
            "properties": {
                "alwaysUpdateSecureExecutionProperties": {
                    "type": "boolean",
                    "description": "Useful to update execution properties marked with `_secure_` and `_internal_`\nas these are not retrievable from VCD, so they are not saved in state. Setting this to `true` will make the provider\nto ask for updates whenever there is a secure property in the execution of the Behavior\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the RDE Type Behavior.\n"
                },
                "execution": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map that specifies the Behavior execution mechanism, this is just a simplification of `execution_json` that\ncan make the configuration more readable for simpler Behaviors. One of `execution_json` or `execution` must be set.\n"
                },
                "executionJson": {
                    "type": "string",
                    "description": "A string representing a valid JSON that specifies the Behavior execution mechanism.\nYou can find more information about the different execution types, like `WebHook`, `noop`, `Activity`, `MQTT`, `VRO`, `AWSLambdaFaaS`\nand others [in the Extensibility SDK documentation](https://vmware.github.io/vcd-ext-sdk/docs/defined_entities_api/behaviors).\nOne of `execution_json` or `execution` must be set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the overridden Behavior\n"
                },
                "rdeInterfaceBehaviorId": {
                    "type": "string",
                    "description": "The ID of the [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior) to override\n"
                },
                "rdeTypeId": {
                    "type": "string",
                    "description": "The ID of the RDE Type that owns the Behavior\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The Behavior invocation reference to be used for polymorphic behavior invocations\n"
                }
            },
            "required": [
                "execution",
                "executionJson",
                "name",
                "rdeInterfaceBehaviorId",
                "rdeTypeId",
                "ref"
            ],
            "inputProperties": {
                "alwaysUpdateSecureExecutionProperties": {
                    "type": "boolean",
                    "description": "Useful to update execution properties marked with `_secure_` and `_internal_`\nas these are not retrievable from VCD, so they are not saved in state. Setting this to `true` will make the provider\nto ask for updates whenever there is a secure property in the execution of the Behavior\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the RDE Type Behavior.\n"
                },
                "execution": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map that specifies the Behavior execution mechanism, this is just a simplification of `execution_json` that\ncan make the configuration more readable for simpler Behaviors. One of `execution_json` or `execution` must be set.\n"
                },
                "executionJson": {
                    "type": "string",
                    "description": "A string representing a valid JSON that specifies the Behavior execution mechanism.\nYou can find more information about the different execution types, like `WebHook`, `noop`, `Activity`, `MQTT`, `VRO`, `AWSLambdaFaaS`\nand others [in the Extensibility SDK documentation](https://vmware.github.io/vcd-ext-sdk/docs/defined_entities_api/behaviors).\nOne of `execution_json` or `execution` must be set.\n"
                },
                "rdeInterfaceBehaviorId": {
                    "type": "string",
                    "description": "The ID of the [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior) to override\n",
                    "willReplaceOnChanges": true
                },
                "rdeTypeId": {
                    "type": "string",
                    "description": "The ID of the RDE Type that owns the Behavior\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "rdeInterfaceBehaviorId",
                "rdeTypeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RdeTypeBehavior resources.\n",
                "properties": {
                    "alwaysUpdateSecureExecutionProperties": {
                        "type": "boolean",
                        "description": "Useful to update execution properties marked with `_secure_` and `_internal_`\nas these are not retrievable from VCD, so they are not saved in state. Setting this to `true` will make the provider\nto ask for updates whenever there is a secure property in the execution of the Behavior\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the RDE Type Behavior.\n"
                    },
                    "execution": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map that specifies the Behavior execution mechanism, this is just a simplification of `execution_json` that\ncan make the configuration more readable for simpler Behaviors. One of `execution_json` or `execution` must be set.\n"
                    },
                    "executionJson": {
                        "type": "string",
                        "description": "A string representing a valid JSON that specifies the Behavior execution mechanism.\nYou can find more information about the different execution types, like `WebHook`, `noop`, `Activity`, `MQTT`, `VRO`, `AWSLambdaFaaS`\nand others [in the Extensibility SDK documentation](https://vmware.github.io/vcd-ext-sdk/docs/defined_entities_api/behaviors).\nOne of `execution_json` or `execution` must be set.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the overridden Behavior\n"
                    },
                    "rdeInterfaceBehaviorId": {
                        "type": "string",
                        "description": "The ID of the [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior) to override\n",
                        "willReplaceOnChanges": true
                    },
                    "rdeTypeId": {
                        "type": "string",
                        "description": "The ID of the RDE Type that owns the Behavior\n",
                        "willReplaceOnChanges": true
                    },
                    "ref": {
                        "type": "string",
                        "description": "The Behavior invocation reference to be used for polymorphic behavior invocations\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/rdeTypeBehaviorAcl:RdeTypeBehaviorAcl": {
            "properties": {
                "accessLevelIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of Access Level IDs to associate to the Behavior defined in `behavior_id` argument\n"
                },
                "behaviorId": {
                    "type": "string",
                    "description": "The ID of either a [RDE Type Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type_behavior)\nor a [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior)\n"
                },
                "rdeTypeId": {
                    "type": "string",
                    "description": "The ID of the RDE Type\n"
                }
            },
            "required": [
                "accessLevelIds",
                "behaviorId",
                "rdeTypeId"
            ],
            "inputProperties": {
                "accessLevelIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of Access Level IDs to associate to the Behavior defined in `behavior_id` argument\n"
                },
                "behaviorId": {
                    "type": "string",
                    "description": "The ID of either a [RDE Type Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type_behavior)\nor a [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior)\n",
                    "willReplaceOnChanges": true
                },
                "rdeTypeId": {
                    "type": "string",
                    "description": "The ID of the RDE Type\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessLevelIds",
                "behaviorId",
                "rdeTypeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RdeTypeBehaviorAcl resources.\n",
                "properties": {
                    "accessLevelIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of Access Level IDs to associate to the Behavior defined in `behavior_id` argument\n"
                    },
                    "behaviorId": {
                        "type": "string",
                        "description": "The ID of either a [RDE Type Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type_behavior)\nor a [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior)\n",
                        "willReplaceOnChanges": true
                    },
                    "rdeTypeId": {
                        "type": "string",
                        "description": "The ID of the RDE Type\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/rightsBundle:RightsBundle": {
            "properties": {
                "bundleKey": {
                    "type": "string",
                    "description": "Key used for internationalization\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rights bundle\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rights bundle.\n"
                },
                "publishToAllTenants": {
                    "type": "boolean",
                    "description": "When true, publishes the rights bundle to all tenants\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Whether this rights bundle is read-only\n"
                },
                "rights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of rights assigned to this role\n"
                },
                "tenants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of tenants to which this rights bundle gets published. Ignored if `publish_to_all_tenants` is true.\n"
                }
            },
            "required": [
                "bundleKey",
                "description",
                "name",
                "publishToAllTenants",
                "readOnly"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the rights bundle\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rights bundle.\n"
                },
                "publishToAllTenants": {
                    "type": "boolean",
                    "description": "When true, publishes the rights bundle to all tenants\n"
                },
                "rights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of rights assigned to this role\n"
                },
                "tenants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of tenants to which this rights bundle gets published. Ignored if `publish_to_all_tenants` is true.\n"
                }
            },
            "requiredInputs": [
                "description",
                "publishToAllTenants"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RightsBundle resources.\n",
                "properties": {
                    "bundleKey": {
                        "type": "string",
                        "description": "Key used for internationalization\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the rights bundle\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rights bundle.\n"
                    },
                    "publishToAllTenants": {
                        "type": "boolean",
                        "description": "When true, publishes the rights bundle to all tenants\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "Whether this rights bundle is read-only\n"
                    },
                    "rights": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of rights assigned to this role\n"
                    },
                    "tenants": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of tenants to which this rights bundle gets published. Ignored if `publish_to_all_tenants` is true.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/role:Role": {
            "properties": {
                "bundleKey": {
                    "type": "string",
                    "description": "Key used for internationalization\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Whether this role is read-only\n"
                },
                "rights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of rights assigned to this role\n"
                }
            },
            "required": [
                "bundleKey",
                "description",
                "name",
                "readOnly"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "rights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of rights assigned to this role\n"
                }
            },
            "requiredInputs": [
                "description"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "bundleKey": {
                        "type": "string",
                        "description": "Key used for internationalization\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the role\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "Whether this role is read-only\n"
                    },
                    "rights": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of rights assigned to this role\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/securityTag:SecurityTag": {
            "description": "Provides a VMware Cloud Director Security Tag resource. This can be\nused to assign security tag to VMs.\n\nSupported in provider *v3.7+* and requires VCD 10.3.0+\n\n\u003e **Note:** Only one of `vcd.SecurityTag` resource or [`security_tags` attribute from `vcd.VappVm`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_vm)\nshould be used. Using both would cause a behavioral conflict.\n\n\u003e **Note:** This resource requires either system or org administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myTag = new vcd.SecurityTag(\"my_tag\", {\n    name: \"test-tag\",\n    vmIds: [\n        my_vm_one.id,\n        my_vm_two.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_tag = vcd.SecurityTag(\"my_tag\",\n    name=\"test-tag\",\n    vm_ids=[\n        my_vm_one[\"id\"],\n        my_vm_two[\"id\"],\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myTag = new Vcd.SecurityTag(\"my_tag\", new()\n    {\n        Name = \"test-tag\",\n        VmIds = new[]\n        {\n            my_vm_one.Id,\n            my_vm_two.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.NewSecurityTag(ctx, \"my_tag\", \u0026vcd.SecurityTagArgs{\n\t\t\tName: pulumi.String(\"test-tag\"),\n\t\t\tVmIds: pulumi.StringArray{\n\t\t\t\tmy_vm_one.Id,\n\t\t\t\tmy_vm_two.Id,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.SecurityTag;\nimport com.pulumi.vcd.SecurityTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myTag = new SecurityTag(\"myTag\", SecurityTagArgs.builder()\n            .name(\"test-tag\")\n            .vmIds(            \n                my_vm_one.id(),\n                my_vm_two.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myTag:\n    type: vcd:SecurityTag\n    name: my_tag\n    properties:\n      name: test-tag\n      vmIds:\n        - ${[\"my-vm-one\"].id}\n        - ${[\"my-vm-two\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the security tag.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of VM IDs that the security tags is going to be tied to\n"
                }
            },
            "required": [
                "name",
                "vmIds"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the security tag.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of VM IDs that the security tags is going to be tied to\n"
                }
            },
            "requiredInputs": [
                "vmIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecurityTag resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the security tag.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "vmIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of VM IDs that the security tags is going to be tied to\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/serviceAccount:ServiceAccount": {
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Status of the Service Account. Can be set to `false` and back to `true` if\nthe access token was lost to get a new one.\n"
                },
                "allowTokenFile": {
                    "type": "boolean",
                    "description": "If set to false, will output a warning about the service account file\ncontaining sensitive information.\n"
                },
                "fileName": {
                    "type": "string",
                    "description": "Required only when `active` is set to `true`. Contains the access token\nthat can be used for authenticating to VCD.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the Service Account in an organisation.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Role ID of service account\n"
                },
                "softwareId": {
                    "type": "string",
                    "description": "UUID of the Service Account.\n"
                },
                "softwareVersion": {
                    "type": "string",
                    "description": "Version of the service using the Service Account\n"
                },
                "uri": {
                    "type": "string",
                    "description": "URI of the service using the Service Account\n"
                }
            },
            "required": [
                "name",
                "roleId",
                "softwareId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "Status of the Service Account. Can be set to `false` and back to `true` if\nthe access token was lost to get a new one.\n"
                },
                "allowTokenFile": {
                    "type": "boolean",
                    "description": "If set to false, will output a warning about the service account file\ncontaining sensitive information.\n"
                },
                "fileName": {
                    "type": "string",
                    "description": "Required only when `active` is set to `true`. Contains the access token\nthat can be used for authenticating to VCD.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the Service Account in an organisation.\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string",
                    "description": "Role ID of service account\n"
                },
                "softwareId": {
                    "type": "string",
                    "description": "UUID of the Service Account.\n"
                },
                "softwareVersion": {
                    "type": "string",
                    "description": "Version of the service using the Service Account\n"
                },
                "uri": {
                    "type": "string",
                    "description": "URI of the service using the Service Account\n"
                }
            },
            "requiredInputs": [
                "roleId",
                "softwareId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceAccount resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Status of the Service Account. Can be set to `false` and back to `true` if\nthe access token was lost to get a new one.\n"
                    },
                    "allowTokenFile": {
                        "type": "boolean",
                        "description": "If set to false, will output a warning about the service account file\ncontaining sensitive information.\n"
                    },
                    "fileName": {
                        "type": "string",
                        "description": "Required only when `active` is set to `true`. Contains the access token\nthat can be used for authenticating to VCD.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the Service Account in an organisation.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string",
                        "description": "Role ID of service account\n"
                    },
                    "softwareId": {
                        "type": "string",
                        "description": "UUID of the Service Account.\n"
                    },
                    "softwareVersion": {
                        "type": "string",
                        "description": "Version of the service using the Service Account\n"
                    },
                    "uri": {
                        "type": "string",
                        "description": "URI of the service using the Service Account\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/solutionAddOn:SolutionAddOn": {
            "properties": {
                "addOnPath": {
                    "type": "string",
                    "description": "Local filesystem path of Solution Add-On. The Add-On image is required\nlocally as some of the metadata must be extracted for creating the Solution Add-On entry in Cloud\nDirector.\n"
                },
                "autoTrustCertificate": {
                    "type": "boolean",
                    "description": "Plugin can automatically trust the certificate of Solution\nAdd-On. This is required for Solution Add-Ons to work and one will have to do it manually before\nusing the Solution Add-On if not enabled here.\n"
                },
                "catalogItemId": {
                    "type": "string",
                    "description": "The catalog item ID of Solution Add-On. It can be uploaded using\n[`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/catalog_media)\n"
                },
                "name": {
                    "type": "string",
                    "description": "reports the name of Solution Add-On as defined in the system. This name can be also used\nin data source\n[`vcd.SolutionAddOn`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/solution_add_on)\n"
                },
                "rdeState": {
                    "type": "string",
                    "description": "Parent RDE state\n"
                }
            },
            "required": [
                "addOnPath",
                "catalogItemId",
                "name",
                "rdeState"
            ],
            "inputProperties": {
                "addOnPath": {
                    "type": "string",
                    "description": "Local filesystem path of Solution Add-On. The Add-On image is required\nlocally as some of the metadata must be extracted for creating the Solution Add-On entry in Cloud\nDirector.\n",
                    "willReplaceOnChanges": true
                },
                "autoTrustCertificate": {
                    "type": "boolean",
                    "description": "Plugin can automatically trust the certificate of Solution\nAdd-On. This is required for Solution Add-Ons to work and one will have to do it manually before\nusing the Solution Add-On if not enabled here.\n",
                    "willReplaceOnChanges": true
                },
                "catalogItemId": {
                    "type": "string",
                    "description": "The catalog item ID of Solution Add-On. It can be uploaded using\n[`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/catalog_media)\n"
                }
            },
            "requiredInputs": [
                "addOnPath",
                "catalogItemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SolutionAddOn resources.\n",
                "properties": {
                    "addOnPath": {
                        "type": "string",
                        "description": "Local filesystem path of Solution Add-On. The Add-On image is required\nlocally as some of the metadata must be extracted for creating the Solution Add-On entry in Cloud\nDirector.\n",
                        "willReplaceOnChanges": true
                    },
                    "autoTrustCertificate": {
                        "type": "boolean",
                        "description": "Plugin can automatically trust the certificate of Solution\nAdd-On. This is required for Solution Add-Ons to work and one will have to do it manually before\nusing the Solution Add-On if not enabled here.\n",
                        "willReplaceOnChanges": true
                    },
                    "catalogItemId": {
                        "type": "string",
                        "description": "The catalog item ID of Solution Add-On. It can be uploaded using\n[`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/catalog_media)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "reports the name of Solution Add-On as defined in the system. This name can be also used\nin data source\n[`vcd.SolutionAddOn`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/solution_add_on)\n"
                    },
                    "rdeState": {
                        "type": "string",
                        "description": "Parent RDE state\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/solutionAddOnInstance:SolutionAddOnInstance": {
            "properties": {
                "acceptEula": {
                    "type": "boolean",
                    "description": "Solution Add-On Instance cannot be create if EULA is not accepted.\nSupplying a `false` value will print EULA.\n"
                },
                "addOnId": {
                    "type": "string",
                    "description": "Existing Solution Add-On ID\n[`vcd.SolutionAddOn`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/solution_add_on)\n"
                },
                "deleteInput": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Just like `input` field for creation, it is a map of keys and values\nas required for removal of a particular Solution Add-On. It will require all values that are\nspecified in a particular Add-On schema unless `validate_only_required_inputs=true` is set. Missing\na value will print an error message with all field descriptions and missing value. Update is a no-op\noperation\n"
                },
                "input": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of keys and values as required for a particular Solution Add-On\nInstance. It will require all values that are specified in a particular Add-On schema unless\n`validate_only_required_inputs=true` is set. Missing a value will print an error message with all\nfield descriptions and missing value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of Solution Add-On Instance\n"
                },
                "rdeState": {
                    "type": "string",
                    "description": "reports the state of parent [Runtime Defined\nEntity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)\n"
                },
                "validateOnlyRequiredInputs": {
                    "type": "boolean",
                    "description": "By default (`false`) will check that all fields are\ndefined in `input` and `delete_input` fields. It will only validate fields that are marked as\nrequired when set to `true`. Update is a noop that will affect further operation.\n"
                }
            },
            "required": [
                "acceptEula",
                "addOnId",
                "name",
                "rdeState"
            ],
            "inputProperties": {
                "acceptEula": {
                    "type": "boolean",
                    "description": "Solution Add-On Instance cannot be create if EULA is not accepted.\nSupplying a `false` value will print EULA.\n",
                    "willReplaceOnChanges": true
                },
                "addOnId": {
                    "type": "string",
                    "description": "Existing Solution Add-On ID\n[`vcd.SolutionAddOn`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/solution_add_on)\n",
                    "willReplaceOnChanges": true
                },
                "deleteInput": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Just like `input` field for creation, it is a map of keys and values\nas required for removal of a particular Solution Add-On. It will require all values that are\nspecified in a particular Add-On schema unless `validate_only_required_inputs=true` is set. Missing\na value will print an error message with all field descriptions and missing value. Update is a no-op\noperation\n"
                },
                "input": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of keys and values as required for a particular Solution Add-On\nInstance. It will require all values that are specified in a particular Add-On schema unless\n`validate_only_required_inputs=true` is set. Missing a value will print an error message with all\nfield descriptions and missing value.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of Solution Add-On Instance\n",
                    "willReplaceOnChanges": true
                },
                "validateOnlyRequiredInputs": {
                    "type": "boolean",
                    "description": "By default (`false`) will check that all fields are\ndefined in `input` and `delete_input` fields. It will only validate fields that are marked as\nrequired when set to `true`. Update is a noop that will affect further operation.\n"
                }
            },
            "requiredInputs": [
                "acceptEula",
                "addOnId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SolutionAddOnInstance resources.\n",
                "properties": {
                    "acceptEula": {
                        "type": "boolean",
                        "description": "Solution Add-On Instance cannot be create if EULA is not accepted.\nSupplying a `false` value will print EULA.\n",
                        "willReplaceOnChanges": true
                    },
                    "addOnId": {
                        "type": "string",
                        "description": "Existing Solution Add-On ID\n[`vcd.SolutionAddOn`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/solution_add_on)\n",
                        "willReplaceOnChanges": true
                    },
                    "deleteInput": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Just like `input` field for creation, it is a map of keys and values\nas required for removal of a particular Solution Add-On. It will require all values that are\nspecified in a particular Add-On schema unless `validate_only_required_inputs=true` is set. Missing\na value will print an error message with all field descriptions and missing value. Update is a no-op\noperation\n"
                    },
                    "input": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of keys and values as required for a particular Solution Add-On\nInstance. It will require all values that are specified in a particular Add-On schema unless\n`validate_only_required_inputs=true` is set. Missing a value will print an error message with all\nfield descriptions and missing value.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of Solution Add-On Instance\n",
                        "willReplaceOnChanges": true
                    },
                    "rdeState": {
                        "type": "string",
                        "description": "reports the state of parent [Runtime Defined\nEntity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)\n"
                    },
                    "validateOnlyRequiredInputs": {
                        "type": "boolean",
                        "description": "By default (`false`) will check that all fields are\ndefined in `input` and `delete_input` fields. It will only validate fields that are marked as\nrequired when set to `true`. Update is a noop that will affect further operation.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/solutionAddOnInstancePublish:SolutionAddOnInstancePublish": {
            "properties": {
                "addOnInstanceId": {
                    "type": "string",
                    "description": "Solution Add-On instance ID\n"
                },
                "orgIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Recipient Organization IDs\n"
                },
                "publishToAllTenants": {
                    "type": "boolean",
                    "description": "Set to `true` to publish to everyone\n"
                },
                "rdeState": {
                    "type": "string",
                    "description": "Parent RDE state\n"
                }
            },
            "required": [
                "addOnInstanceId",
                "rdeState"
            ],
            "inputProperties": {
                "addOnInstanceId": {
                    "type": "string",
                    "description": "Solution Add-On instance ID\n",
                    "willReplaceOnChanges": true
                },
                "orgIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Recipient Organization IDs\n"
                },
                "publishToAllTenants": {
                    "type": "boolean",
                    "description": "Set to `true` to publish to everyone\n"
                }
            },
            "requiredInputs": [
                "addOnInstanceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SolutionAddOnInstancePublish resources.\n",
                "properties": {
                    "addOnInstanceId": {
                        "type": "string",
                        "description": "Solution Add-On instance ID\n",
                        "willReplaceOnChanges": true
                    },
                    "orgIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Recipient Organization IDs\n"
                    },
                    "publishToAllTenants": {
                        "type": "boolean",
                        "description": "Set to `true` to publish to everyone\n"
                    },
                    "rdeState": {
                        "type": "string",
                        "description": "Parent RDE state\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/solutionLandingZone:SolutionLandingZone": {
            "properties": {
                "catalog": {
                    "$ref": "#/types/vcd:index/SolutionLandingZoneCatalog:SolutionLandingZoneCatalog",
                    "description": "This catalog stores all executable .ISO files for solution add-ons. There\ncan be a single `catalog` element and the required field is `id`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Destination Organization name for Solution Add-ons\n"
                },
                "state": {
                    "type": "string",
                    "description": "reports the state of parent [Runtime Defined\nEntity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)\n"
                },
                "vdcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/SolutionLandingZoneVdc:SolutionLandingZoneVdc"
                    },
                    "description": "A single vdc block that defines landing VDC configuration\n\n\u003ca id=\"vdc\"\u003e\u003c/a\u003e\n"
                }
            },
            "required": [
                "catalog",
                "state",
                "vdcs"
            ],
            "inputProperties": {
                "catalog": {
                    "$ref": "#/types/vcd:index/SolutionLandingZoneCatalog:SolutionLandingZoneCatalog",
                    "description": "This catalog stores all executable .ISO files for solution add-ons. There\ncan be a single `catalog` element and the required field is `id`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "Destination Organization name for Solution Add-ons\n",
                    "willReplaceOnChanges": true
                },
                "vdcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/SolutionLandingZoneVdc:SolutionLandingZoneVdc"
                    },
                    "description": "A single vdc block that defines landing VDC configuration\n\n\u003ca id=\"vdc\"\u003e\u003c/a\u003e\n"
                }
            },
            "requiredInputs": [
                "catalog",
                "vdcs"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SolutionLandingZone resources.\n",
                "properties": {
                    "catalog": {
                        "$ref": "#/types/vcd:index/SolutionLandingZoneCatalog:SolutionLandingZoneCatalog",
                        "description": "This catalog stores all executable .ISO files for solution add-ons. There\ncan be a single `catalog` element and the required field is `id`.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Destination Organization name for Solution Add-ons\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "reports the state of parent [Runtime Defined\nEntity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)\n"
                    },
                    "vdcs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/SolutionLandingZoneVdc:SolutionLandingZoneVdc"
                        },
                        "description": "A single vdc block that defines landing VDC configuration\n\n\u003ca id=\"vdc\"\u003e\u003c/a\u003e\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/subscribedCatalog:SubscribedCatalog": {
            "properties": {
                "cancelFailedTasks": {
                    "type": "boolean",
                    "description": "When `true`, the subscribed catalog will attempt canceling failed tasks.\n"
                },
                "catalogVersion": {
                    "type": "integer",
                    "description": "Version number from this catalog. This is inherited from the publishing catalog and updated on sync.\n"
                },
                "created": {
                    "type": "string",
                    "description": "Date and time of catalog creation. This is the creation date of the subscription, not the original published catalog.\n"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "When destroying use `delete_force=true` with `delete_recursive=true` to remove a catalog and any objects it contains, regardless of their state.\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "When destroying use `delete_recursive=true` to remove the catalog and any objects it contains that are in a state that normally allows removal.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of catalog. This is inherited from the publishing catalog and updated on sync.\n"
                },
                "failedTasks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of synchronization tasks that are have failed. They can refer to the catalog or any of its catalog items.\n"
                },
                "href": {
                    "type": "string",
                    "description": "the catalog's Hyper reference.\n"
                },
                "isLocal": {
                    "type": "boolean",
                    "description": "(*v3.8.1+*) Indicates if this catalog was created in the current organization.\n"
                },
                "isPublished": {
                    "type": "boolean",
                    "description": "Indicates if this catalog is available for subscription. (Always false)\n"
                },
                "isShared": {
                    "type": "boolean",
                    "description": "Indicates if the catalog is shared.\n"
                },
                "makeLocalCopy": {
                    "type": "boolean",
                    "description": "If `true`, subscription to a catalog creates a local copy of all items. Defaults to `false`, which does not create a local copy of catalog items unless a sync operation is performed.\nIt can only be `false` if the user configured in the provider is the System administrator.\n"
                },
                "mediaItemLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of media item names in this catalog, in alphabetical order.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "(*Available until VCD 10.5*) Optional metadata of the catalog. This is inherited from the publishing catalog and updated on sync.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Catalog name\n"
                },
                "numberOfMedia": {
                    "type": "integer",
                    "description": "Number of media items available in this catalog.\n"
                },
                "numberOfVappTemplates": {
                    "type": "integer",
                    "description": "Number of vApp templates available in this catalog.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level.\n"
                },
                "ownerName": {
                    "type": "string",
                    "description": "Owner of the catalog.\n"
                },
                "publishSubscriptionType": {
                    "type": "string",
                    "description": "Shows if the catalog is published, if it is a subscription from another one or none of those. (Always `SUBSCRIBED`)\n"
                },
                "runningTasks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of running synchronization tasks that are still running. They can refer to the catalog or any of its catalog items.\n"
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Allows to set specific storage profile to be used for catalog.\n"
                },
                "storeTasks": {
                    "type": "boolean",
                    "description": "if `true`, saves the list of tasks to a file for later update.\n"
                },
                "subscriptionPassword": {
                    "type": "string",
                    "description": "An optional password to access the catalog. Only ASCII characters are allowed in a valid password. \nThe password is only required when set by the publishing catalog. Passing in six asterisks '******' indicates to keep current password.\nPassing in an empty string indicates to remove password.\n",
                    "secret": true
                },
                "subscriptionUrl": {
                    "type": "string",
                    "description": "The URL to subscribe to the external catalog.\n"
                },
                "syncAll": {
                    "type": "boolean",
                    "description": "If `true`, synchronise this catalog and all items.\n"
                },
                "syncAllMediaItems": {
                    "type": "boolean",
                    "description": "If `true`, synchronise all media items. Not to be used when `sync_all` is set.\n"
                },
                "syncAllVappTemplates": {
                    "type": "boolean",
                    "description": "If `true`, synchronise all vApp templates. Not to be used when `sync_all` is set.\n"
                },
                "syncCatalog": {
                    "type": "boolean",
                    "description": "If `true`, synchronise this catalog. Not to be used when `sync_all` is set. This operation fetches the list of items. If `make_local_copy` is set, it also synchronises all the items.\n"
                },
                "syncMediaItems": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Synchronise a list of media items. Not to be used when `sync_all` or `sync_all_media_items` are set.\n"
                },
                "syncOnRefresh": {
                    "type": "boolean",
                    "description": "Boolean value that shows if sync should be performed on every refresh.\n"
                },
                "syncVappTemplates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Synchronise a list of vApp templates. Not to be used when `sync_all` or `sync_all_vapp_templates` are set.\n"
                },
                "tasksFileName": {
                    "type": "string",
                    "description": "Where the running tasks IDs have been stored. Only if `store_tasks` is set.\n"
                },
                "vappTemplateLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of vApp template names in this catalog, in alphabetical order.\n"
                }
            },
            "required": [
                "catalogVersion",
                "created",
                "description",
                "failedTasks",
                "href",
                "isLocal",
                "isPublished",
                "isShared",
                "mediaItemLists",
                "metadata",
                "name",
                "numberOfMedia",
                "numberOfVappTemplates",
                "ownerName",
                "publishSubscriptionType",
                "runningTasks",
                "subscriptionPassword",
                "subscriptionUrl",
                "tasksFileName",
                "vappTemplateLists"
            ],
            "inputProperties": {
                "cancelFailedTasks": {
                    "type": "boolean",
                    "description": "When `true`, the subscribed catalog will attempt canceling failed tasks.\n"
                },
                "deleteForce": {
                    "type": "boolean",
                    "description": "When destroying use `delete_force=true` with `delete_recursive=true` to remove a catalog and any objects it contains, regardless of their state.\n"
                },
                "deleteRecursive": {
                    "type": "boolean",
                    "description": "When destroying use `delete_recursive=true` to remove the catalog and any objects it contains that are in a state that normally allows removal.\n"
                },
                "makeLocalCopy": {
                    "type": "boolean",
                    "description": "If `true`, subscription to a catalog creates a local copy of all items. Defaults to `false`, which does not create a local copy of catalog items unless a sync operation is performed.\nIt can only be `false` if the user configured in the provider is the System administrator.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Catalog name\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "storageProfileId": {
                    "type": "string",
                    "description": "Allows to set specific storage profile to be used for catalog.\n"
                },
                "storeTasks": {
                    "type": "boolean",
                    "description": "if `true`, saves the list of tasks to a file for later update.\n"
                },
                "subscriptionPassword": {
                    "type": "string",
                    "description": "An optional password to access the catalog. Only ASCII characters are allowed in a valid password. \nThe password is only required when set by the publishing catalog. Passing in six asterisks '******' indicates to keep current password.\nPassing in an empty string indicates to remove password.\n",
                    "secret": true
                },
                "subscriptionUrl": {
                    "type": "string",
                    "description": "The URL to subscribe to the external catalog.\n",
                    "willReplaceOnChanges": true
                },
                "syncAll": {
                    "type": "boolean",
                    "description": "If `true`, synchronise this catalog and all items.\n"
                },
                "syncAllMediaItems": {
                    "type": "boolean",
                    "description": "If `true`, synchronise all media items. Not to be used when `sync_all` is set.\n"
                },
                "syncAllVappTemplates": {
                    "type": "boolean",
                    "description": "If `true`, synchronise all vApp templates. Not to be used when `sync_all` is set.\n"
                },
                "syncCatalog": {
                    "type": "boolean",
                    "description": "If `true`, synchronise this catalog. Not to be used when `sync_all` is set. This operation fetches the list of items. If `make_local_copy` is set, it also synchronises all the items.\n"
                },
                "syncMediaItems": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Synchronise a list of media items. Not to be used when `sync_all` or `sync_all_media_items` are set.\n"
                },
                "syncOnRefresh": {
                    "type": "boolean",
                    "description": "Boolean value that shows if sync should be performed on every refresh.\n"
                },
                "syncVappTemplates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Synchronise a list of vApp templates. Not to be used when `sync_all` or `sync_all_vapp_templates` are set.\n"
                }
            },
            "requiredInputs": [
                "subscriptionUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SubscribedCatalog resources.\n",
                "properties": {
                    "cancelFailedTasks": {
                        "type": "boolean",
                        "description": "When `true`, the subscribed catalog will attempt canceling failed tasks.\n"
                    },
                    "catalogVersion": {
                        "type": "integer",
                        "description": "Version number from this catalog. This is inherited from the publishing catalog and updated on sync.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "Date and time of catalog creation. This is the creation date of the subscription, not the original published catalog.\n"
                    },
                    "deleteForce": {
                        "type": "boolean",
                        "description": "When destroying use `delete_force=true` with `delete_recursive=true` to remove a catalog and any objects it contains, regardless of their state.\n"
                    },
                    "deleteRecursive": {
                        "type": "boolean",
                        "description": "When destroying use `delete_recursive=true` to remove the catalog and any objects it contains that are in a state that normally allows removal.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of catalog. This is inherited from the publishing catalog and updated on sync.\n"
                    },
                    "failedTasks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of synchronization tasks that are have failed. They can refer to the catalog or any of its catalog items.\n"
                    },
                    "href": {
                        "type": "string",
                        "description": "the catalog's Hyper reference.\n"
                    },
                    "isLocal": {
                        "type": "boolean",
                        "description": "(*v3.8.1+*) Indicates if this catalog was created in the current organization.\n"
                    },
                    "isPublished": {
                        "type": "boolean",
                        "description": "Indicates if this catalog is available for subscription. (Always false)\n"
                    },
                    "isShared": {
                        "type": "boolean",
                        "description": "Indicates if the catalog is shared.\n"
                    },
                    "makeLocalCopy": {
                        "type": "boolean",
                        "description": "If `true`, subscription to a catalog creates a local copy of all items. Defaults to `false`, which does not create a local copy of catalog items unless a sync operation is performed.\nIt can only be `false` if the user configured in the provider is the System administrator.\n"
                    },
                    "mediaItemLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of media item names in this catalog, in alphabetical order.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "(*Available until VCD 10.5*) Optional metadata of the catalog. This is inherited from the publishing catalog and updated on sync.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Catalog name\n"
                    },
                    "numberOfMedia": {
                        "type": "integer",
                        "description": "Number of media items available in this catalog.\n"
                    },
                    "numberOfVappTemplates": {
                        "type": "integer",
                        "description": "Number of vApp templates available in this catalog.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerName": {
                        "type": "string",
                        "description": "Owner of the catalog.\n"
                    },
                    "publishSubscriptionType": {
                        "type": "string",
                        "description": "Shows if the catalog is published, if it is a subscription from another one or none of those. (Always `SUBSCRIBED`)\n"
                    },
                    "runningTasks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of running synchronization tasks that are still running. They can refer to the catalog or any of its catalog items.\n"
                    },
                    "storageProfileId": {
                        "type": "string",
                        "description": "Allows to set specific storage profile to be used for catalog.\n"
                    },
                    "storeTasks": {
                        "type": "boolean",
                        "description": "if `true`, saves the list of tasks to a file for later update.\n"
                    },
                    "subscriptionPassword": {
                        "type": "string",
                        "description": "An optional password to access the catalog. Only ASCII characters are allowed in a valid password. \nThe password is only required when set by the publishing catalog. Passing in six asterisks '******' indicates to keep current password.\nPassing in an empty string indicates to remove password.\n",
                        "secret": true
                    },
                    "subscriptionUrl": {
                        "type": "string",
                        "description": "The URL to subscribe to the external catalog.\n",
                        "willReplaceOnChanges": true
                    },
                    "syncAll": {
                        "type": "boolean",
                        "description": "If `true`, synchronise this catalog and all items.\n"
                    },
                    "syncAllMediaItems": {
                        "type": "boolean",
                        "description": "If `true`, synchronise all media items. Not to be used when `sync_all` is set.\n"
                    },
                    "syncAllVappTemplates": {
                        "type": "boolean",
                        "description": "If `true`, synchronise all vApp templates. Not to be used when `sync_all` is set.\n"
                    },
                    "syncCatalog": {
                        "type": "boolean",
                        "description": "If `true`, synchronise this catalog. Not to be used when `sync_all` is set. This operation fetches the list of items. If `make_local_copy` is set, it also synchronises all the items.\n"
                    },
                    "syncMediaItems": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Synchronise a list of media items. Not to be used when `sync_all` or `sync_all_media_items` are set.\n"
                    },
                    "syncOnRefresh": {
                        "type": "boolean",
                        "description": "Boolean value that shows if sync should be performed on every refresh.\n"
                    },
                    "syncVappTemplates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Synchronise a list of vApp templates. Not to be used when `sync_all` or `sync_all_vapp_templates` are set.\n"
                    },
                    "tasksFileName": {
                        "type": "string",
                        "description": "Where the running tasks IDs have been stored. Only if `store_tasks` is set.\n"
                    },
                    "vappTemplateLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of vApp template names in this catalog, in alphabetical order.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/uiPlugin:UiPlugin": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the UI Plugin\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the UI Plugin will be enabled (`true`) or not (`false`)\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license of the UI Plugin\n"
                },
                "link": {
                    "type": "string",
                    "description": "The website or custom URL of the UI Plugin\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the UI Plugin\n"
                },
                "pluginPath": {
                    "type": "string",
                    "description": "Path to a .zip file that contains the bundled UI Plugin\n"
                },
                "providerScoped": {
                    "type": "boolean",
                    "description": "**Can only be set on updates**, the initial value is taken from the JSON manifest.\nChanges the scope of the UI Plugin for System providers. It should be set to `true` when the UI Plugin is published to the System organization, to prevent\nunwanted updates-in-place.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the UI Plugin (for example, `ready`, `unavailable`, etc)\n"
                },
                "tenantIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identifiers of the [Organizations](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org)\nthat will be able to use the UI Plugin if enabled. If not set, it doesn't publish to any Organization.\n"
                },
                "tenantScoped": {
                    "type": "boolean",
                    "description": "**Can only be set on updates**, the initial value is taken from the JSON manifest.\nChanges the scope of the UI Plugin for Organization users. It should be set to `true` when the UI Plugin is published to any organization, to prevent\nunwanted updates-in-place.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "The vendor of the UI Plugin\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the UI Plugin\n"
                }
            },
            "required": [
                "description",
                "enabled",
                "license",
                "link",
                "name",
                "providerScoped",
                "status",
                "tenantScoped",
                "vendor",
                "version"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the UI Plugin will be enabled (`true`) or not (`false`)\n"
                },
                "pluginPath": {
                    "type": "string",
                    "description": "Path to a .zip file that contains the bundled UI Plugin\n",
                    "willReplaceOnChanges": true
                },
                "providerScoped": {
                    "type": "boolean",
                    "description": "**Can only be set on updates**, the initial value is taken from the JSON manifest.\nChanges the scope of the UI Plugin for System providers. It should be set to `true` when the UI Plugin is published to the System organization, to prevent\nunwanted updates-in-place.\n"
                },
                "tenantIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identifiers of the [Organizations](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org)\nthat will be able to use the UI Plugin if enabled. If not set, it doesn't publish to any Organization.\n"
                },
                "tenantScoped": {
                    "type": "boolean",
                    "description": "**Can only be set on updates**, the initial value is taken from the JSON manifest.\nChanges the scope of the UI Plugin for Organization users. It should be set to `true` when the UI Plugin is published to any organization, to prevent\nunwanted updates-in-place.\n"
                }
            },
            "requiredInputs": [
                "enabled"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UiPlugin resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the UI Plugin\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the UI Plugin will be enabled (`true`) or not (`false`)\n"
                    },
                    "license": {
                        "type": "string",
                        "description": "The license of the UI Plugin\n"
                    },
                    "link": {
                        "type": "string",
                        "description": "The website or custom URL of the UI Plugin\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the UI Plugin\n"
                    },
                    "pluginPath": {
                        "type": "string",
                        "description": "Path to a .zip file that contains the bundled UI Plugin\n",
                        "willReplaceOnChanges": true
                    },
                    "providerScoped": {
                        "type": "boolean",
                        "description": "**Can only be set on updates**, the initial value is taken from the JSON manifest.\nChanges the scope of the UI Plugin for System providers. It should be set to `true` when the UI Plugin is published to the System organization, to prevent\nunwanted updates-in-place.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the UI Plugin (for example, `ready`, `unavailable`, etc)\n"
                    },
                    "tenantIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The identifiers of the [Organizations](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org)\nthat will be able to use the UI Plugin if enabled. If not set, it doesn't publish to any Organization.\n"
                    },
                    "tenantScoped": {
                        "type": "boolean",
                        "description": "**Can only be set on updates**, the initial value is taken from the JSON manifest.\nChanges the scope of the UI Plugin for Organization users. It should be set to `true` when the UI Plugin is published to any organization, to prevent\nunwanted updates-in-place.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor of the UI Plugin\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the UI Plugin\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vapp:Vapp": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description for the vApp, up to 256 characters.\n"
                },
                "guestProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of vApp guest properties\n"
                },
                "href": {
                    "type": "string",
                    "description": "(Computed) The vApp Hyper Reference.\n"
                },
                "inheritedMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "(Computed; *v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides\ndetails on the origin of the vApp (e.g. `vapp.origin.id`, `vapp.origin.name`, `vapp.origin.type`).\n"
                },
                "lease": {
                    "$ref": "#/types/vcd:index/VappLease:VappLease",
                    "description": "the information about the vApp lease. It includes the fields below. When this section is \nincluded, both fields are mandatory. If lease values are higher than the ones allowed for the whole Org, the values\nare **silently** reduced to the highest value allowed.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this vApp. Key and value can be any string. (Since *v2.2+* metadata is added directly to vApp instead of first VM in vApp)\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappMetadataEntry:VappMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the vApp\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this vApp should be powered on. Default is `false`. Works only on update when vApp already has VMs.\n"
                },
                "status": {
                    "type": "integer",
                    "description": "(Computed; *v2.5+*) The vApp status as a numeric code.\n"
                },
                "statusText": {
                    "type": "string",
                    "description": "(Computed; *v2.5+*) The vApp status as text.\n"
                },
                "vappNetworkNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v3.13.0+*) A list of vApp network names included in this vApp\n"
                },
                "vappOrgNetworkNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v3.13.0+*) A list of vApp Org network names included in this vApp\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vmNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(*v3.13.0+*) A list of VM names included in this vApp\n"
                }
            },
            "required": [
                "href",
                "inheritedMetadata",
                "lease",
                "metadata",
                "metadataEntries",
                "name",
                "status",
                "statusText",
                "vappNetworkNames",
                "vappOrgNetworkNames",
                "vmNames"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description for the vApp, up to 256 characters.\n"
                },
                "guestProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of vApp guest properties\n"
                },
                "lease": {
                    "$ref": "#/types/vcd:index/VappLease:VappLease",
                    "description": "the information about the vApp lease. It includes the fields below. When this section is \nincluded, both fields are mandatory. If lease values are higher than the ones allowed for the whole Org, the values\nare **silently** reduced to the highest value allowed.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this vApp. Key and value can be any string. (Since *v2.2+* metadata is added directly to vApp instead of first VM in vApp)\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappMetadataEntry:VappMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the vApp\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this vApp should be powered on. Default is `false`. Works only on update when vApp already has VMs.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vapp resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "An optional description for the vApp, up to 256 characters.\n"
                    },
                    "guestProperties": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key value map of vApp guest properties\n"
                    },
                    "href": {
                        "type": "string",
                        "description": "(Computed) The vApp Hyper Reference.\n"
                    },
                    "inheritedMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "(Computed; *v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides\ndetails on the origin of the vApp (e.g. `vapp.origin.id`, `vapp.origin.name`, `vapp.origin.type`).\n"
                    },
                    "lease": {
                        "$ref": "#/types/vcd:index/VappLease:VappLease",
                        "description": "the information about the vApp lease. It includes the fields below. When this section is \nincluded, both fields are mandatory. If lease values are higher than the ones allowed for the whole Org, the values\nare **silently** reduced to the highest value allowed.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this vApp. Key and value can be any string. (Since *v2.2+* metadata is added directly to vApp instead of first VM in vApp)\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappMetadataEntry:VappMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the vApp\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "powerOn": {
                        "type": "boolean",
                        "description": "A boolean value stating if this vApp should be powered on. Default is `false`. Works only on update when vApp already has VMs.\n"
                    },
                    "status": {
                        "type": "integer",
                        "description": "(Computed; *v2.5+*) The vApp status as a numeric code.\n"
                    },
                    "statusText": {
                        "type": "string",
                        "description": "(Computed; *v2.5+*) The vApp status as text.\n"
                    },
                    "vappNetworkNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v3.13.0+*) A list of vApp network names included in this vApp\n"
                    },
                    "vappOrgNetworkNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v3.13.0+*) A list of vApp Org network names included in this vApp\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vmNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(*v3.13.0+*) A list of VM names included in this vApp\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vappAccessControl:VappAccessControl": {
            "properties": {
                "everyoneAccessLevel": {
                    "type": "string",
                    "description": "Access level when the vApp is shared with everyone (one of `ReadOnly`, `Change`, \n`FullControl`). Required if `shared_with_everyone` is `true`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the vApp belongs. Optional if defined at provider level.\n"
                },
                "sharedWithEveryone": {
                    "type": "boolean",
                    "description": "Whether the vApp is shared with everyone. If any `shared_with` blocks are included,\nthis property must be set to `false`.\n"
                },
                "sharedWiths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappAccessControlSharedWith:VappAccessControlSharedWith"
                    },
                    "description": "one or more blocks defining a subject to which we are sharing. \nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is set.\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "A unique identifier for the vApp.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of organization to which the vApp belongs. Optional if defined at provider level.\n"
                }
            },
            "required": [
                "sharedWithEveryone",
                "vappId"
            ],
            "inputProperties": {
                "everyoneAccessLevel": {
                    "type": "string",
                    "description": "Access level when the vApp is shared with everyone (one of `ReadOnly`, `Change`, \n`FullControl`). Required if `shared_with_everyone` is `true`.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to which the vApp belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                },
                "sharedWithEveryone": {
                    "type": "boolean",
                    "description": "Whether the vApp is shared with everyone. If any `shared_with` blocks are included,\nthis property must be set to `false`.\n"
                },
                "sharedWiths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappAccessControlSharedWith:VappAccessControlSharedWith"
                    },
                    "description": "one or more blocks defining a subject to which we are sharing. \nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is set.\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "A unique identifier for the vApp.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of organization to which the vApp belongs. Optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "sharedWithEveryone",
                "vappId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappAccessControl resources.\n",
                "properties": {
                    "everyoneAccessLevel": {
                        "type": "string",
                        "description": "Access level when the vApp is shared with everyone (one of `ReadOnly`, `Change`, \n`FullControl`). Required if `shared_with_everyone` is `true`.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the vApp belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "sharedWithEveryone": {
                        "type": "boolean",
                        "description": "Whether the vApp is shared with everyone. If any `shared_with` blocks are included,\nthis property must be set to `false`.\n"
                    },
                    "sharedWiths": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappAccessControlSharedWith:VappAccessControlSharedWith"
                        },
                        "description": "one or more blocks defining a subject to which we are sharing. \nSee shared_with below for detail. It cannot be used if `shared_with_everyone` is set.\n"
                    },
                    "vappId": {
                        "type": "string",
                        "description": "A unique identifier for the vApp.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of organization to which the vApp belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vappFirewallRules:VappFirewallRules": {
            "properties": {
                "defaultAction": {
                    "type": "string",
                    "description": "Either 'allow' or 'drop'. Specifies what to do should none of the rules match.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable firewall. Default is `true`.\n"
                },
                "logDefaultAction": {
                    "type": "boolean",
                    "description": "Flag to enable logging for default action. Default value is `false`.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappFirewallRulesRule:VappFirewallRulesRule"
                    },
                    "description": "Configures a firewall rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "defaultAction",
                "networkId",
                "vappId"
            ],
            "inputProperties": {
                "defaultAction": {
                    "type": "string",
                    "description": "Either 'allow' or 'drop'. Specifies what to do should none of the rules match.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable firewall. Default is `true`.\n"
                },
                "logDefaultAction": {
                    "type": "boolean",
                    "description": "Flag to enable logging for default action. Default value is `false`.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappFirewallRulesRule:VappFirewallRulesRule"
                    },
                    "description": "Configures a firewall rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "defaultAction",
                "networkId",
                "vappId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappFirewallRules resources.\n",
                "properties": {
                    "defaultAction": {
                        "type": "string",
                        "description": "Either 'allow' or 'drop'. Specifies what to do should none of the rules match.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable or disable firewall. Default is `true`.\n"
                    },
                    "logDefaultAction": {
                        "type": "boolean",
                        "description": "Flag to enable logging for default action. Default value is `false`.\n"
                    },
                    "networkId": {
                        "type": "string",
                        "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappFirewallRulesRule:VappFirewallRulesRule"
                        },
                        "description": "Configures a firewall rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                    },
                    "vappId": {
                        "type": "string",
                        "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vappNatRules:VappNatRules": {
            "properties": {
                "enableIpMasquerade": {
                    "type": "boolean",
                    "description": "When enabled translates a virtual machine's private, internal IP address to a public IP address for outbound traffic. Default value is `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable NAT. Default is `true`. To enable the NAT service, [vcd.VappFirewallRules](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_firewall_rules) needs to be enabled as well.\n"
                },
                "natType": {
                    "type": "string",
                    "description": "\"One of: `ipTranslation` (use IP translation), `portForwarding` (use port forwarding). For `ipTranslation` fields `vm_id`, `vm_nic_id`, `mapping_mode` are required and `external_ip` is optional. For `portForwarding` fields `vm_id`, `vm_nic_id`, `protocol`, `external_port` and `forward_to_port` are required.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappNatRulesRule:VappNatRulesRule"
                    },
                    "description": "Configures a NAT rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "natType",
                "networkId",
                "vappId"
            ],
            "inputProperties": {
                "enableIpMasquerade": {
                    "type": "boolean",
                    "description": "When enabled translates a virtual machine's private, internal IP address to a public IP address for outbound traffic. Default value is `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable NAT. Default is `true`. To enable the NAT service, [vcd.VappFirewallRules](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_firewall_rules) needs to be enabled as well.\n"
                },
                "natType": {
                    "type": "string",
                    "description": "\"One of: `ipTranslation` (use IP translation), `portForwarding` (use port forwarding). For `ipTranslation` fields `vm_id`, `vm_nic_id`, `mapping_mode` are required and `external_ip` is optional. For `portForwarding` fields `vm_id`, `vm_nic_id`, `protocol`, `external_port` and `forward_to_port` are required.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappNatRulesRule:VappNatRulesRule"
                    },
                    "description": "Configures a NAT rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "natType",
                "networkId",
                "vappId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappNatRules resources.\n",
                "properties": {
                    "enableIpMasquerade": {
                        "type": "boolean",
                        "description": "When enabled translates a virtual machine's private, internal IP address to a public IP address for outbound traffic. Default value is `false`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable or disable NAT. Default is `true`. To enable the NAT service, [vcd.VappFirewallRules](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_firewall_rules) needs to be enabled as well.\n"
                    },
                    "natType": {
                        "type": "string",
                        "description": "\"One of: `ipTranslation` (use IP translation), `portForwarding` (use port forwarding). For `ipTranslation` fields `vm_id`, `vm_nic_id`, `mapping_mode` are required and `external_ip` is optional. For `portForwarding` fields `vm_id`, `vm_nic_id`, `protocol`, `external_port` and `forward_to_port` are required.\n"
                    },
                    "networkId": {
                        "type": "string",
                        "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappNatRulesRule:VappNatRulesRule"
                        },
                        "description": "Configures a NAT rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                    },
                    "vappId": {
                        "type": "string",
                        "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vappNetwork:VappNetwork": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of vApp network\n"
                },
                "dhcpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappNetworkDhcpPool:VappNetworkDhcpPool"
                    },
                    "description": "A range of IPs to issue to virtual machines that don't have a static IP; see IP Pools below for details.\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway of the network\n"
                },
                "guestVlanAllowed": {
                    "type": "boolean",
                    "description": "True if Network allows guest VLAN tagging.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network.\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "Netmask address for a subnet.\n",
                    "deprecationMessage": "Use prefix_length instead which supports both IPv4 and IPv6"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when \nconnected as sysadmin working across different organisations.\n"
                },
                "orgNetworkName": {
                    "type": "string",
                    "description": "An Org network name to which vApp network is connected. If not configured, then an isolated network is created.\n"
                },
                "prefixLength": {
                    "type": "string",
                    "description": "The subnet prefix length for the network.\n"
                },
                "rebootVappOnRemoval": {
                    "type": "boolean",
                    "description": "**VCD 10.4.1+** API **prohibits removal of vApp\nnetwork from a powered on vApp**. Set to `true` to power off the vApp during vApp network removal.\nIf the vApp's original state was powered on, it will be powered back on after removing the\nnetwork. (default `false`) **Note.** It only affects *delete* operation for the resource and will\nnever power cycle vApp during *update* operations. Changing this value will cause plan change, but\n*update* will be a no-op operation.\n\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "retainIpMacEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Default is false.\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappNetworkStaticIpPool:VappNetworkStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for virtual machines; see IP Pools below for details.\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this network belongs to.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "gateway",
                "name",
                "netmask",
                "prefixLength",
                "vappName"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of vApp network\n"
                },
                "dhcpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappNetworkDhcpPool:VappNetworkDhcpPool"
                    },
                    "description": "A range of IPs to issue to virtual machines that don't have a static IP; see IP Pools below for details.\n"
                },
                "dns1": {
                    "type": "string",
                    "description": "First DNS server to use.\n"
                },
                "dns2": {
                    "type": "string",
                    "description": "Second DNS server to use.\n"
                },
                "dnsSuffix": {
                    "type": "string",
                    "description": "A FQDN for the virtual machines on this network.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway of the network\n",
                    "willReplaceOnChanges": true
                },
                "guestVlanAllowed": {
                    "type": "boolean",
                    "description": "True if Network allows guest VLAN tagging.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the network.\n",
                    "willReplaceOnChanges": true
                },
                "netmask": {
                    "type": "string",
                    "description": "Netmask address for a subnet.\n",
                    "deprecationMessage": "Use prefix_length instead which supports both IPv4 and IPv6",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when \nconnected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "orgNetworkName": {
                    "type": "string",
                    "description": "An Org network name to which vApp network is connected. If not configured, then an isolated network is created.\n"
                },
                "prefixLength": {
                    "type": "string",
                    "description": "The subnet prefix length for the network.\n",
                    "willReplaceOnChanges": true
                },
                "rebootVappOnRemoval": {
                    "type": "boolean",
                    "description": "**VCD 10.4.1+** API **prohibits removal of vApp\nnetwork from a powered on vApp**. Set to `true` to power off the vApp during vApp network removal.\nIf the vApp's original state was powered on, it will be powered back on after removing the\nnetwork. (default `false`) **Note.** It only affects *delete* operation for the resource and will\nnever power cycle vApp during *update* operations. Changing this value will cause plan change, but\n*update* will be a no-op operation.\n\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                },
                "retainIpMacEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Default is false.\n"
                },
                "staticIpPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappNetworkStaticIpPool:VappNetworkStaticIpPool"
                    },
                    "description": "A range of IPs permitted to be used as static IPs for virtual machines; see IP Pools below for details.\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this network belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "gateway",
                "vappName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappNetwork resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of vApp network\n"
                    },
                    "dhcpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappNetworkDhcpPool:VappNetworkDhcpPool"
                        },
                        "description": "A range of IPs to issue to virtual machines that don't have a static IP; see IP Pools below for details.\n"
                    },
                    "dns1": {
                        "type": "string",
                        "description": "First DNS server to use.\n"
                    },
                    "dns2": {
                        "type": "string",
                        "description": "Second DNS server to use.\n"
                    },
                    "dnsSuffix": {
                        "type": "string",
                        "description": "A FQDN for the virtual machines on this network.\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "Gateway of the network\n",
                        "willReplaceOnChanges": true
                    },
                    "guestVlanAllowed": {
                        "type": "boolean",
                        "description": "True if Network allows guest VLAN tagging.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network.\n",
                        "willReplaceOnChanges": true
                    },
                    "netmask": {
                        "type": "string",
                        "description": "Netmask address for a subnet.\n",
                        "deprecationMessage": "Use prefix_length instead which supports both IPv4 and IPv6",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when \nconnected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkName": {
                        "type": "string",
                        "description": "An Org network name to which vApp network is connected. If not configured, then an isolated network is created.\n"
                    },
                    "prefixLength": {
                        "type": "string",
                        "description": "The subnet prefix length for the network.\n",
                        "willReplaceOnChanges": true
                    },
                    "rebootVappOnRemoval": {
                        "type": "boolean",
                        "description": "**VCD 10.4.1+** API **prohibits removal of vApp\nnetwork from a powered on vApp**. Set to `true` to power off the vApp during vApp network removal.\nIf the vApp's original state was powered on, it will be powered back on after removing the\nnetwork. (default `false`) **Note.** It only affects *delete* operation for the resource and will\nnever power cycle vApp during *update* operations. Changing this value will cause plan change, but\n*update* will be a no-op operation.\n\n\n\u003ca id=\"ip-pools\"\u003e\u003c/a\u003e\n"
                    },
                    "retainIpMacEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Default is false.\n"
                    },
                    "staticIpPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappNetworkStaticIpPool:VappNetworkStaticIpPool"
                        },
                        "description": "A range of IPs permitted to be used as static IPs for virtual machines; see IP Pools below for details.\n"
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vApp this network belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vappOrgNetwork:VappOrgNetwork": {
            "properties": {
                "isFenced": {
                    "type": "boolean",
                    "description": "Fencing allows identical virtual machines in different vApp networks connect to organization VDC networks that are accessed in this vApp. Default is false.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when \nconnected as sysadmin working across different organisations.\n"
                },
                "orgNetworkName": {
                    "type": "string",
                    "description": "An Org network name to which vApp network is connected. If not configured, then an isolated network is created.\n"
                },
                "rebootVappOnRemoval": {
                    "type": "boolean",
                    "description": "**VCD 10.4.1+** API **prohibits removal of vApp\nnetwork from a powered on vApp**. Set to `true` to power off the vApp during vApp network removal.\nIf the vApp's original state was powered on, it will be powered back on after removing the\nnetwork. (default `false`) **Note.** It only affects *delete* operation for the resource and will\nnever power cycle vApp during *update* operations. Changing this value will cause plan change, but\n*update* will be a no-op operation.\n"
                },
                "retainIpMacEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Configurable when `is_fenced` is true.\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this network belongs to.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "orgNetworkName",
                "vappName"
            ],
            "inputProperties": {
                "isFenced": {
                    "type": "boolean",
                    "description": "Fencing allows identical virtual machines in different vApp networks connect to organization VDC networks that are accessed in this vApp. Default is false.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when \nconnected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "orgNetworkName": {
                    "type": "string",
                    "description": "An Org network name to which vApp network is connected. If not configured, then an isolated network is created.\n",
                    "willReplaceOnChanges": true
                },
                "rebootVappOnRemoval": {
                    "type": "boolean",
                    "description": "**VCD 10.4.1+** API **prohibits removal of vApp\nnetwork from a powered on vApp**. Set to `true` to power off the vApp during vApp network removal.\nIf the vApp's original state was powered on, it will be powered back on after removing the\nnetwork. (default `false`) **Note.** It only affects *delete* operation for the resource and will\nnever power cycle vApp during *update* operations. Changing this value will cause plan change, but\n*update* will be a no-op operation.\n"
                },
                "retainIpMacEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Configurable when `is_fenced` is true.\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this network belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "orgNetworkName",
                "vappName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappOrgNetwork resources.\n",
                "properties": {
                    "isFenced": {
                        "type": "boolean",
                        "description": "Fencing allows identical virtual machines in different vApp networks connect to organization VDC networks that are accessed in this vApp. Default is false.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when \nconnected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkName": {
                        "type": "string",
                        "description": "An Org network name to which vApp network is connected. If not configured, then an isolated network is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "rebootVappOnRemoval": {
                        "type": "boolean",
                        "description": "**VCD 10.4.1+** API **prohibits removal of vApp\nnetwork from a powered on vApp**. Set to `true` to power off the vApp during vApp network removal.\nIf the vApp's original state was powered on, it will be powered back on after removing the\nnetwork. (default `false`) **Note.** It only affects *delete* operation for the resource and will\nnever power cycle vApp during *update* operations. Changing this value will cause plan change, but\n*update* will be a no-op operation.\n"
                    },
                    "retainIpMacEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether the network resources such as IP/MAC of router will be retained across deployments. Configurable when `is_fenced` is true.\n"
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vApp this network belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vappStaticRouting:VappStaticRouting": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable static Routing. Default is `true`.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappStaticRoutingRule:VappStaticRoutingRule"
                    },
                    "description": "Configures a static routing rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n"
                }
            },
            "required": [
                "networkId",
                "vappId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable static Routing. Default is `true`.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n",
                    "willReplaceOnChanges": true
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappStaticRoutingRule:VappStaticRoutingRule"
                    },
                    "description": "Configures a static routing rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                },
                "vappId": {
                    "type": "string",
                    "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "networkId",
                "vappId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappStaticRouting resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable or disable static Routing. Default is `true`.\n"
                    },
                    "networkId": {
                        "type": "string",
                        "description": "The identifier of [vApp network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp_network).\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappStaticRoutingRule:VappStaticRoutingRule"
                        },
                        "description": "Configures a static routing rule; see Rules below for details.\n\n\u003ca id=\"rules\"\u003e\u003c/a\u003e\n"
                    },
                    "vappId": {
                        "type": "string",
                        "description": "The identifier of [vApp](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vapp).\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vappVm:VappVm": {
            "properties": {
                "acceptAllEulas": {
                    "type": "boolean",
                    "description": "Automatically accept EULA if OVA has it. Default is `true`\n"
                },
                "bootImage": {
                    "type": "string",
                    "description": "Use `boot_image_id` instead. Media name to mount as boot image. Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).\n",
                    "deprecationMessage": "Use `boot_image_id` instead"
                },
                "bootImageId": {
                    "type": "string",
                    "description": "Media URN to mount as boot image. You can fetch it using a [`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_media) data source.\nImage is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).\n"
                },
                "bootOptions": {
                    "$ref": "#/types/vcd:index/VappVmBootOptions:VappVmBootOptions",
                    "description": "A block to define boot options of the VM. See Boot Options\n"
                },
                "catalogName": {
                    "type": "string",
                    "description": "Use a [`vcd.Catalog`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog) data source along with `vapp_template_id` or `boot_image_id` instead. The catalog name in which to find the given vApp Template or media for `boot_image`.\n",
                    "deprecationMessage": "You should use `vapp_template_id` or `boot_image_id` without the need of a catalog name"
                },
                "computerName": {
                    "type": "string",
                    "description": "Computer name to assign to this virtual machine.\n"
                },
                "consolidateDisksOnCreate": {
                    "type": "boolean",
                    "description": "Performs disk consolidation during creation.\nThe main use case is when one wants to grow template disk size using `override_template_disk` in\nfast provisioned VDCs. **Note:** Consolidating disks requires right `vApp: VM Migrate, Force\nUndeploy, Relocate, Consolidate`. This operation _may take long time_ depending on disk size and\nstorage performance.\n"
                },
                "copyFromVmId": {
                    "type": "string",
                    "description": "The ID of *an existing VM* to make a copy of it (it\ncannot be a vApp template). The source VM *must be in the same Org* (but can be in different VDC).\n*Note:* `sizing_policy_id` must be specified when creating a standalone VM (using `vcd.Vm`\nresource) and using different source/destination VDCs.\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "The number of cores per socket.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of virtual CPUs while powered on. Default is `false`.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The limit (in MHz) for how much of CPU can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n"
                },
                "cpuPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of MHz reservation on the underlying virtualization infrastructure.\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource in MHz. This is a read-only, unless the `cpu_priority` is \"CUSTOM\"\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of virtual CPUs to allocate to the VM. Socket count is a result of: virtual logical processors/cores per socket. If `cpu_hot_add_enabled` is true, then cpus will be increased without VM power off.\n"
                },
                "customization": {
                    "$ref": "#/types/vcd:index/VappVmCustomization:VappVmCustomization",
                    "description": "A block to define for guest customization options. See Customization\n"
                },
                "description": {
                    "type": "string",
                    "description": "The VM description. Note: for VM from Template `description` is read only. Currently, this field has\nthe description of the OVA used to create the VM.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmDisk:VappVmDisk"
                    },
                    "description": "Independent disk attachment configuration. See Disk below for details.\n"
                },
                "exposeHardwareVirtualization": {
                    "type": "boolean",
                    "description": "Boolean for exposing full CPU virtualization to the\nguest operating system so that applications that require hardware virtualization can run on virtual machines without binary\ntranslation or paravirtualization. Useful for hypervisor nesting provided underlying hardware supports it. Default is `false`.\n"
                },
                "extraConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmExtraConfig:VappVmExtraConfig"
                    },
                    "description": "(*v3.13.+*) The VM extra configuration. See Extra Configuration for more detail. *Not populated on VCD 10.4.0*.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "Specify boot firmware of the VM. Can be `efi` or `bios`. If unset, defaults to `bios`. Changing the value requires the VM to power off.\n"
                },
                "guestProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of guest properties\n"
                },
                "hardwareVersion": {
                    "type": "string",
                    "description": "Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.). Required when creating empty VM.\n"
                },
                "href": {
                    "type": "string",
                    "description": "VM Hyper Reference\n"
                },
                "imported": {
                    "type": "boolean",
                    "description": "(*v3.13.+*) A true/false value telling whether the resource was imported.\n"
                },
                "inheritedMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "(*v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides\ndetails on the origin of the VM (e.g. `vm.origin.id`, `vm.origin.name`, `vm.origin.type`).\n"
                },
                "internalDisks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmInternalDisk:VappVmInternalDisk"
                    },
                    "description": "(*v2.7+*) A block providing internal disk of VM details. See Internal Disk below for details.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) to allocate to the VM. If `memory_hot_add_enabled` is true, then memory will be increased without VM power off\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of memory while powered on. Default is `false`.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The limit (in MB) for how much of memory can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n"
                },
                "memoryPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) reservation on the underlying virtualization infrastructure\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource in MB. This is a read-only, unless the `memory_priority` is \"CUSTOM\"\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this VM\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmMetadataEntry:VappVmMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n"
                },
                "networkDhcpWaitSeconds": {
                    "type": "integer",
                    "description": "Optional number of seconds to try and wait for DHCP IP (only valid\nfor adapters in `network` block with `ip_allocation_mode=DHCP`). It constantly checks if IP is present so the time given\nis a maximum. VM must be powered on and _at least one_ of the following _must be true_:\n* VM has Guest Tools. It waits for IP address to be reported by Guest Tools. This is a slower option, but\ndoes not require for the VM to use Edge Gateways DHCP service.\n* VM DHCP interface is connected to routed Org network and is using Edge Gateways DHCP service (not\nrelayed). It works by querying DHCP leases on Edge Gateway. In general it is quicker than waiting\nuntil Guest Tools report IP addresses, but is more constrained. However this is the only option if Guest\nTools are not present on the VM.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmNetwork:VappVmNetwork"
                    },
                    "description": "A block to define network interface. Multiple can be used. See Network and \nexample for usage details.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "osType": {
                    "type": "string",
                    "description": "Operating System type. Possible values can be found in Os Types. Required when creating empty VM.\n"
                },
                "overrideTemplateDisks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmOverrideTemplateDisk:VappVmOverrideTemplateDisk"
                    },
                    "description": "Allows to update internal disk in template before first VM boot. Disk is matched by `bus_type`, `bus_number` and `unit_number`. See Override template Disk below for details.\n"
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM placement policy or [vGPU policy][vgpu-policy] (*3.11+*) ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)\nIn this case, if the placement policy is not set, it will pick the VDC default on creation. It must be set explicitly\nif one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `\"\"` to be removed.\n"
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this VM should be powered on. Default is `true`\n"
                },
                "preventUpdatePowerOff": {
                    "type": "boolean",
                    "description": "True if the update of resource should fail when virtual machine power off needed. Default is `false`.\n"
                },
                "securityTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of security tags to be managed by the `vcd.VappVm` resource.\nTo remove `security_tags` you must set `security_tags = []` and do not remove the attribute. Removing the attribute will cause the tags to remain unchanged and just stop being managed by this resource.\nThis is to be consistent with existing security tags that were created by the `vcd_security_tags` resource.\n"
                },
                "setExtraConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmSetExtraConfig:VappVmSetExtraConfig"
                    },
                    "description": "Set of extra configuration key/values to be added or modified. See Extra Configuration\n\n\u003e **Note:** Only one of `security_tags` attribute or [`vcd.SecurityTag`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/security_tag) resource\nshould be used. Using both would cause a behavioral conflict.\n"
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM sizing policy ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)\nusing `vcd_org_vdc.vm_sizing_policy_ids` (and `vcd_org_vdc.default_compute_policy_id` to make it default).\nIn this case, if the sizing policy is not set, it will pick the VDC default on creation. It must be set explicitly\nif one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `\"\"` to be removed.\n"
                },
                "status": {
                    "type": "integer",
                    "description": "(*v3.8+*) The vApp status as a numeric code.\n"
                },
                "statusText": {
                    "type": "string",
                    "description": "(*v3.8+*) The vApp status as text.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the default one\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "Use `vapp_template_id` instead. The name of the vApp Template to use\n",
                    "deprecationMessage": "Use `vapp_template_id` instead"
                },
                "vappId": {
                    "type": "string",
                    "description": "ID of parent vApp\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this VM belongs to.\n"
                },
                "vappTemplateId": {
                    "type": "string",
                    "description": "The URN of the vApp Template to use. You can fetch it using a [`vcd.CatalogVappTemplate`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) data source.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vmNameInTemplate": {
                    "type": "string",
                    "description": "The name of the VM in vApp Template to use. For cases when vApp template has more than one VM.\n"
                },
                "vmType": {
                    "type": "string",
                    "description": "(*3.2+*) Type of the VM (either `vcd.VappVm` or `vcd.Vm`).\n"
                }
            },
            "required": [
                "bootOptions",
                "computerName",
                "cpuCores",
                "cpuLimit",
                "cpuPriority",
                "cpuReservation",
                "cpuShares",
                "cpus",
                "customization",
                "description",
                "extraConfigs",
                "firmware",
                "hardwareVersion",
                "href",
                "imported",
                "inheritedMetadata",
                "internalDisks",
                "memory",
                "memoryLimit",
                "memoryPriority",
                "memoryReservation",
                "memoryShares",
                "metadata",
                "metadataEntries",
                "name",
                "osType",
                "placementPolicyId",
                "securityTags",
                "sizingPolicyId",
                "status",
                "statusText",
                "storageProfile",
                "vappId",
                "vappName",
                "vmType"
            ],
            "inputProperties": {
                "acceptAllEulas": {
                    "type": "boolean",
                    "description": "Automatically accept EULA if OVA has it. Default is `true`\n"
                },
                "bootImage": {
                    "type": "string",
                    "description": "Use `boot_image_id` instead. Media name to mount as boot image. Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).\n",
                    "deprecationMessage": "Use `boot_image_id` instead"
                },
                "bootImageId": {
                    "type": "string",
                    "description": "Media URN to mount as boot image. You can fetch it using a [`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_media) data source.\nImage is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).\n"
                },
                "bootOptions": {
                    "$ref": "#/types/vcd:index/VappVmBootOptions:VappVmBootOptions",
                    "description": "A block to define boot options of the VM. See Boot Options\n"
                },
                "catalogName": {
                    "type": "string",
                    "description": "Use a [`vcd.Catalog`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog) data source along with `vapp_template_id` or `boot_image_id` instead. The catalog name in which to find the given vApp Template or media for `boot_image`.\n",
                    "deprecationMessage": "You should use `vapp_template_id` or `boot_image_id` without the need of a catalog name"
                },
                "computerName": {
                    "type": "string",
                    "description": "Computer name to assign to this virtual machine.\n"
                },
                "consolidateDisksOnCreate": {
                    "type": "boolean",
                    "description": "Performs disk consolidation during creation.\nThe main use case is when one wants to grow template disk size using `override_template_disk` in\nfast provisioned VDCs. **Note:** Consolidating disks requires right `vApp: VM Migrate, Force\nUndeploy, Relocate, Consolidate`. This operation _may take long time_ depending on disk size and\nstorage performance.\n",
                    "willReplaceOnChanges": true
                },
                "copyFromVmId": {
                    "type": "string",
                    "description": "The ID of *an existing VM* to make a copy of it (it\ncannot be a vApp template). The source VM *must be in the same Org* (but can be in different VDC).\n*Note:* `sizing_policy_id` must be specified when creating a standalone VM (using `vcd.Vm`\nresource) and using different source/destination VDCs.\n",
                    "willReplaceOnChanges": true
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "The number of cores per socket.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of virtual CPUs while powered on. Default is `false`.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The limit (in MHz) for how much of CPU can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n"
                },
                "cpuPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of MHz reservation on the underlying virtualization infrastructure.\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource in MHz. This is a read-only, unless the `cpu_priority` is \"CUSTOM\"\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of virtual CPUs to allocate to the VM. Socket count is a result of: virtual logical processors/cores per socket. If `cpu_hot_add_enabled` is true, then cpus will be increased without VM power off.\n"
                },
                "customization": {
                    "$ref": "#/types/vcd:index/VappVmCustomization:VappVmCustomization",
                    "description": "A block to define for guest customization options. See Customization\n"
                },
                "description": {
                    "type": "string",
                    "description": "The VM description. Note: for VM from Template `description` is read only. Currently, this field has\nthe description of the OVA used to create the VM.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmDisk:VappVmDisk"
                    },
                    "description": "Independent disk attachment configuration. See Disk below for details.\n"
                },
                "exposeHardwareVirtualization": {
                    "type": "boolean",
                    "description": "Boolean for exposing full CPU virtualization to the\nguest operating system so that applications that require hardware virtualization can run on virtual machines without binary\ntranslation or paravirtualization. Useful for hypervisor nesting provided underlying hardware supports it. Default is `false`.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "Specify boot firmware of the VM. Can be `efi` or `bios`. If unset, defaults to `bios`. Changing the value requires the VM to power off.\n"
                },
                "guestProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of guest properties\n"
                },
                "hardwareVersion": {
                    "type": "string",
                    "description": "Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.). Required when creating empty VM.\n"
                },
                "href": {
                    "type": "string",
                    "description": "VM Hyper Reference\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) to allocate to the VM. If `memory_hot_add_enabled` is true, then memory will be increased without VM power off\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of memory while powered on. Default is `false`.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The limit (in MB) for how much of memory can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n"
                },
                "memoryPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) reservation on the underlying virtualization infrastructure\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource in MB. This is a read-only, unless the `memory_priority` is \"CUSTOM\"\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this VM\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmMetadataEntry:VappVmMetadataEntry"
                    },
                    "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n",
                    "willReplaceOnChanges": true
                },
                "networkDhcpWaitSeconds": {
                    "type": "integer",
                    "description": "Optional number of seconds to try and wait for DHCP IP (only valid\nfor adapters in `network` block with `ip_allocation_mode=DHCP`). It constantly checks if IP is present so the time given\nis a maximum. VM must be powered on and _at least one_ of the following _must be true_:\n* VM has Guest Tools. It waits for IP address to be reported by Guest Tools. This is a slower option, but\ndoes not require for the VM to use Edge Gateways DHCP service.\n* VM DHCP interface is connected to routed Org network and is using Edge Gateways DHCP service (not\nrelayed). It works by querying DHCP leases on Edge Gateway. In general it is quicker than waiting\nuntil Guest Tools report IP addresses, but is more constrained. However this is the only option if Guest\nTools are not present on the VM.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmNetwork:VappVmNetwork"
                    },
                    "description": "A block to define network interface. Multiple can be used. See Network and \nexample for usage details.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "osType": {
                    "type": "string",
                    "description": "Operating System type. Possible values can be found in Os Types. Required when creating empty VM.\n"
                },
                "overrideTemplateDisks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmOverrideTemplateDisk:VappVmOverrideTemplateDisk"
                    },
                    "description": "Allows to update internal disk in template before first VM boot. Disk is matched by `bus_type`, `bus_number` and `unit_number`. See Override template Disk below for details.\n",
                    "willReplaceOnChanges": true
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM placement policy or [vGPU policy][vgpu-policy] (*3.11+*) ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)\nIn this case, if the placement policy is not set, it will pick the VDC default on creation. It must be set explicitly\nif one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `\"\"` to be removed.\n"
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this VM should be powered on. Default is `true`\n"
                },
                "preventUpdatePowerOff": {
                    "type": "boolean",
                    "description": "True if the update of resource should fail when virtual machine power off needed. Default is `false`.\n"
                },
                "securityTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of security tags to be managed by the `vcd.VappVm` resource.\nTo remove `security_tags` you must set `security_tags = []` and do not remove the attribute. Removing the attribute will cause the tags to remain unchanged and just stop being managed by this resource.\nThis is to be consistent with existing security tags that were created by the `vcd_security_tags` resource.\n"
                },
                "setExtraConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VappVmSetExtraConfig:VappVmSetExtraConfig"
                    },
                    "description": "Set of extra configuration key/values to be added or modified. See Extra Configuration\n\n\u003e **Note:** Only one of `security_tags` attribute or [`vcd.SecurityTag`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/security_tag) resource\nshould be used. Using both would cause a behavioral conflict.\n"
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM sizing policy ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)\nusing `vcd_org_vdc.vm_sizing_policy_ids` (and `vcd_org_vdc.default_compute_policy_id` to make it default).\nIn this case, if the sizing policy is not set, it will pick the VDC default on creation. It must be set explicitly\nif one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `\"\"` to be removed.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the default one\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "Use `vapp_template_id` instead. The name of the vApp Template to use\n",
                    "deprecationMessage": "Use `vapp_template_id` instead",
                    "willReplaceOnChanges": true
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this VM belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "vappTemplateId": {
                    "type": "string",
                    "description": "The URN of the vApp Template to use. You can fetch it using a [`vcd.CatalogVappTemplate`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) data source.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "vmNameInTemplate": {
                    "type": "string",
                    "description": "The name of the VM in vApp Template to use. For cases when vApp template has more than one VM.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "vappName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappVm resources.\n",
                "properties": {
                    "acceptAllEulas": {
                        "type": "boolean",
                        "description": "Automatically accept EULA if OVA has it. Default is `true`\n"
                    },
                    "bootImage": {
                        "type": "string",
                        "description": "Use `boot_image_id` instead. Media name to mount as boot image. Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).\n",
                        "deprecationMessage": "Use `boot_image_id` instead"
                    },
                    "bootImageId": {
                        "type": "string",
                        "description": "Media URN to mount as boot image. You can fetch it using a [`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_media) data source.\nImage is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).\n"
                    },
                    "bootOptions": {
                        "$ref": "#/types/vcd:index/VappVmBootOptions:VappVmBootOptions",
                        "description": "A block to define boot options of the VM. See Boot Options\n"
                    },
                    "catalogName": {
                        "type": "string",
                        "description": "Use a [`vcd.Catalog`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog) data source along with `vapp_template_id` or `boot_image_id` instead. The catalog name in which to find the given vApp Template or media for `boot_image`.\n",
                        "deprecationMessage": "You should use `vapp_template_id` or `boot_image_id` without the need of a catalog name"
                    },
                    "computerName": {
                        "type": "string",
                        "description": "Computer name to assign to this virtual machine.\n"
                    },
                    "consolidateDisksOnCreate": {
                        "type": "boolean",
                        "description": "Performs disk consolidation during creation.\nThe main use case is when one wants to grow template disk size using `override_template_disk` in\nfast provisioned VDCs. **Note:** Consolidating disks requires right `vApp: VM Migrate, Force\nUndeploy, Relocate, Consolidate`. This operation _may take long time_ depending on disk size and\nstorage performance.\n",
                        "willReplaceOnChanges": true
                    },
                    "copyFromVmId": {
                        "type": "string",
                        "description": "The ID of *an existing VM* to make a copy of it (it\ncannot be a vApp template). The source VM *must be in the same Org* (but can be in different VDC).\n*Note:* `sizing_policy_id` must be specified when creating a standalone VM (using `vcd.Vm`\nresource) and using different source/destination VDCs.\n",
                        "willReplaceOnChanges": true
                    },
                    "cpuCores": {
                        "type": "integer",
                        "description": "The number of cores per socket.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "True if the virtual machine supports addition of virtual CPUs while powered on. Default is `false`.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The limit (in MHz) for how much of CPU can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n"
                    },
                    "cpuPriority": {
                        "type": "string",
                        "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The amount of MHz reservation on the underlying virtualization infrastructure.\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "Custom priority for the resource in MHz. This is a read-only, unless the `cpu_priority` is \"CUSTOM\"\n"
                    },
                    "cpus": {
                        "type": "integer",
                        "description": "The number of virtual CPUs to allocate to the VM. Socket count is a result of: virtual logical processors/cores per socket. If `cpu_hot_add_enabled` is true, then cpus will be increased without VM power off.\n"
                    },
                    "customization": {
                        "$ref": "#/types/vcd:index/VappVmCustomization:VappVmCustomization",
                        "description": "A block to define for guest customization options. See Customization\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The VM description. Note: for VM from Template `description` is read only. Currently, this field has\nthe description of the OVA used to create the VM.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappVmDisk:VappVmDisk"
                        },
                        "description": "Independent disk attachment configuration. See Disk below for details.\n"
                    },
                    "exposeHardwareVirtualization": {
                        "type": "boolean",
                        "description": "Boolean for exposing full CPU virtualization to the\nguest operating system so that applications that require hardware virtualization can run on virtual machines without binary\ntranslation or paravirtualization. Useful for hypervisor nesting provided underlying hardware supports it. Default is `false`.\n"
                    },
                    "extraConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappVmExtraConfig:VappVmExtraConfig"
                        },
                        "description": "(*v3.13.+*) The VM extra configuration. See Extra Configuration for more detail. *Not populated on VCD 10.4.0*.\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "Specify boot firmware of the VM. Can be `efi` or `bios`. If unset, defaults to `bios`. Changing the value requires the VM to power off.\n"
                    },
                    "guestProperties": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key value map of guest properties\n"
                    },
                    "hardwareVersion": {
                        "type": "string",
                        "description": "Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.). Required when creating empty VM.\n"
                    },
                    "href": {
                        "type": "string",
                        "description": "VM Hyper Reference\n"
                    },
                    "imported": {
                        "type": "boolean",
                        "description": "(*v3.13.+*) A true/false value telling whether the resource was imported.\n"
                    },
                    "inheritedMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "(*v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides\ndetails on the origin of the VM (e.g. `vm.origin.id`, `vm.origin.name`, `vm.origin.type`).\n"
                    },
                    "internalDisks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappVmInternalDisk:VappVmInternalDisk"
                        },
                        "description": "(*v2.7+*) A block providing internal disk of VM details. See Internal Disk below for details.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The amount of RAM (in MB) to allocate to the VM. If `memory_hot_add_enabled` is true, then memory will be increased without VM power off\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "True if the virtual machine supports addition of memory while powered on. Default is `false`.\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The limit (in MB) for how much of memory can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n"
                    },
                    "memoryPriority": {
                        "type": "string",
                        "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The amount of RAM (in MB) reservation on the underlying virtualization infrastructure\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "Custom priority for the resource in MB. This is a read-only, unless the `memory_priority` is \"CUSTOM\"\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Use `metadata_entry` instead. Key value map of metadata to assign to this VM\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappVmMetadataEntry:VappVmMetadataEntry"
                        },
                        "description": "A set of metadata entries to assign. See Metadata section for details.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for the VM, unique within the vApp\n",
                        "willReplaceOnChanges": true
                    },
                    "networkDhcpWaitSeconds": {
                        "type": "integer",
                        "description": "Optional number of seconds to try and wait for DHCP IP (only valid\nfor adapters in `network` block with `ip_allocation_mode=DHCP`). It constantly checks if IP is present so the time given\nis a maximum. VM must be powered on and _at least one_ of the following _must be true_:\n* VM has Guest Tools. It waits for IP address to be reported by Guest Tools. This is a slower option, but\ndoes not require for the VM to use Edge Gateways DHCP service.\n* VM DHCP interface is connected to routed Org network and is using Edge Gateways DHCP service (not\nrelayed). It works by querying DHCP leases on Edge Gateway. In general it is quicker than waiting\nuntil Guest Tools report IP addresses, but is more constrained. However this is the only option if Guest\nTools are not present on the VM.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappVmNetwork:VappVmNetwork"
                        },
                        "description": "A block to define network interface. Multiple can be used. See Network and \nexample for usage details.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "osType": {
                        "type": "string",
                        "description": "Operating System type. Possible values can be found in Os Types. Required when creating empty VM.\n"
                    },
                    "overrideTemplateDisks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappVmOverrideTemplateDisk:VappVmOverrideTemplateDisk"
                        },
                        "description": "Allows to update internal disk in template before first VM boot. Disk is matched by `bus_type`, `bus_number` and `unit_number`. See Override template Disk below for details.\n",
                        "willReplaceOnChanges": true
                    },
                    "placementPolicyId": {
                        "type": "string",
                        "description": "VM placement policy or [vGPU policy][vgpu-policy] (*3.11+*) ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)\nIn this case, if the placement policy is not set, it will pick the VDC default on creation. It must be set explicitly\nif one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `\"\"` to be removed.\n"
                    },
                    "powerOn": {
                        "type": "boolean",
                        "description": "A boolean value stating if this VM should be powered on. Default is `true`\n"
                    },
                    "preventUpdatePowerOff": {
                        "type": "boolean",
                        "description": "True if the update of resource should fail when virtual machine power off needed. Default is `false`.\n"
                    },
                    "securityTags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of security tags to be managed by the `vcd.VappVm` resource.\nTo remove `security_tags` you must set `security_tags = []` and do not remove the attribute. Removing the attribute will cause the tags to remain unchanged and just stop being managed by this resource.\nThis is to be consistent with existing security tags that were created by the `vcd_security_tags` resource.\n"
                    },
                    "setExtraConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VappVmSetExtraConfig:VappVmSetExtraConfig"
                        },
                        "description": "Set of extra configuration key/values to be added or modified. See Extra Configuration\n\n\u003e **Note:** Only one of `security_tags` attribute or [`vcd.SecurityTag`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/security_tag) resource\nshould be used. Using both would cause a behavioral conflict.\n"
                    },
                    "sizingPolicyId": {
                        "type": "string",
                        "description": "VM sizing policy ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)\nusing `vcd_org_vdc.vm_sizing_policy_ids` (and `vcd_org_vdc.default_compute_policy_id` to make it default).\nIn this case, if the sizing policy is not set, it will pick the VDC default on creation. It must be set explicitly\nif one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `\"\"` to be removed.\n"
                    },
                    "status": {
                        "type": "integer",
                        "description": "(*v3.8+*) The vApp status as a numeric code.\n"
                    },
                    "statusText": {
                        "type": "string",
                        "description": "(*v3.8+*) The vApp status as text.\n"
                    },
                    "storageProfile": {
                        "type": "string",
                        "description": "Storage profile to override the default one\n"
                    },
                    "templateName": {
                        "type": "string",
                        "description": "Use `vapp_template_id` instead. The name of the vApp Template to use\n",
                        "deprecationMessage": "Use `vapp_template_id` instead",
                        "willReplaceOnChanges": true
                    },
                    "vappId": {
                        "type": "string",
                        "description": "ID of parent vApp\n"
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vApp this VM belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "vappTemplateId": {
                        "type": "string",
                        "description": "The URN of the vApp Template to use. You can fetch it using a [`vcd.CatalogVappTemplate`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) data source.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vmNameInTemplate": {
                        "type": "string",
                        "description": "The name of the VM in vApp Template to use. For cases when vApp template has more than one VM.\n",
                        "willReplaceOnChanges": true
                    },
                    "vmType": {
                        "type": "string",
                        "description": "(*3.2+*) Type of the VM (either `vcd.VappVm` or `vcd.Vm`).\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vdcGroup:VdcGroup": {
            "properties": {
                "defaultPolicyStatus": {
                    "type": "boolean",
                    "description": "Whether this security policy is enabled. `dfw_enabled` must be `true`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "VDC group description\n"
                },
                "dfwEnabled": {
                    "type": "boolean",
                    "description": "Whether Distributed Firewall is enabled for this VDC group.\n"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "More detailed error message when VDC group has error status\n"
                },
                "forceDelete": {
                    "type": "boolean",
                    "description": "When `true`, will request VCD to force VDC Group deletion. It\nshould clean up child components. Default `false` (VCD may fail removing VDC Group if there are\nchild components remaining). **Note:** when setting it to `true` for existing resource, it will\ncause a plan change (update), but this will not alter the resource in any way.\n"
                },
                "localEgress": {
                    "type": "boolean",
                    "description": "Status whether local egress is enabled for a universal router belonging to a universal VDC group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for VDC group\n"
                },
                "networkPoolId": {
                    "type": "string",
                    "description": "ID of used network pool.\n"
                },
                "networkPoolUniversalId": {
                    "type": "string",
                    "description": "The network providers universal id that is backing the universal network pool.\n"
                },
                "networkProviderType": {
                    "type": "string",
                    "description": "Defines the networking provider backing the VDC group.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations\n"
                },
                "participatingOrgVdcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VdcGroupParticipatingOrgVdc:VdcGroupParticipatingOrgVdc"
                    },
                    "description": "A list of blocks providing organization VDCs that are participating in this group details. See Participating Org VDCs below for details.\n"
                },
                "participatingVdcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of organization VDCs that are participating in this group. **Note**: `starting_vdc_id` isn't automatically included in this list.\n"
                },
                "removeDefaultFirewallRule": {
                    "type": "boolean",
                    "description": "Marks whether default firewall rule should be\nremoved after activating. Both `dfw_enabled` and `default_policy_status` must be true. **Note.**\nThis is mainly useful when using\n[`vcd.NsxtDistributedFirewallRule`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_distributed_firewall_rule)\nresource as it cannot remove the default rule.\n"
                },
                "startingVdcId": {
                    "type": "string",
                    "description": "With selecting a starting VDC you will be able to create a group in which this VDC can participate. **Note**: `starting_vdc_id` must be included in `participating_vdc_ids` to participate in this group.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').\n"
                },
                "type": {
                    "type": "string",
                    "description": "Defines the group as LOCAL or UNIVERSAL.\n"
                },
                "universalNetworkingEnabled": {
                    "type": "boolean",
                    "description": "True means that a VDC group router has been created.\n"
                }
            },
            "required": [
                "defaultPolicyStatus",
                "dfwEnabled",
                "errorMessage",
                "localEgress",
                "name",
                "networkPoolId",
                "networkPoolUniversalId",
                "networkProviderType",
                "participatingOrgVdcs",
                "participatingVdcIds",
                "startingVdcId",
                "status",
                "type",
                "universalNetworkingEnabled"
            ],
            "inputProperties": {
                "defaultPolicyStatus": {
                    "type": "boolean",
                    "description": "Whether this security policy is enabled. `dfw_enabled` must be `true`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "VDC group description\n"
                },
                "dfwEnabled": {
                    "type": "boolean",
                    "description": "Whether Distributed Firewall is enabled for this VDC group.\n"
                },
                "forceDelete": {
                    "type": "boolean",
                    "description": "When `true`, will request VCD to force VDC Group deletion. It\nshould clean up child components. Default `false` (VCD may fail removing VDC Group if there are\nchild components remaining). **Note:** when setting it to `true` for existing resource, it will\ncause a plan change (update), but this will not alter the resource in any way.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for VDC group\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations\n",
                    "willReplaceOnChanges": true
                },
                "participatingVdcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of organization VDCs that are participating in this group. **Note**: `starting_vdc_id` isn't automatically included in this list.\n"
                },
                "removeDefaultFirewallRule": {
                    "type": "boolean",
                    "description": "Marks whether default firewall rule should be\nremoved after activating. Both `dfw_enabled` and `default_policy_status` must be true. **Note.**\nThis is mainly useful when using\n[`vcd.NsxtDistributedFirewallRule`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_distributed_firewall_rule)\nresource as it cannot remove the default rule.\n"
                },
                "startingVdcId": {
                    "type": "string",
                    "description": "With selecting a starting VDC you will be able to create a group in which this VDC can participate. **Note**: `starting_vdc_id` must be included in `participating_vdc_ids` to participate in this group.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "participatingVdcIds",
                "startingVdcId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VdcGroup resources.\n",
                "properties": {
                    "defaultPolicyStatus": {
                        "type": "boolean",
                        "description": "Whether this security policy is enabled. `dfw_enabled` must be `true`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "VDC group description\n"
                    },
                    "dfwEnabled": {
                        "type": "boolean",
                        "description": "Whether Distributed Firewall is enabled for this VDC group.\n"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "More detailed error message when VDC group has error status\n"
                    },
                    "forceDelete": {
                        "type": "boolean",
                        "description": "When `true`, will request VCD to force VDC Group deletion. It\nshould clean up child components. Default `false` (VCD may fail removing VDC Group if there are\nchild components remaining). **Note:** when setting it to `true` for existing resource, it will\ncause a plan change (update), but this will not alter the resource in any way.\n"
                    },
                    "localEgress": {
                        "type": "boolean",
                        "description": "Status whether local egress is enabled for a universal router belonging to a universal VDC group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for VDC group\n"
                    },
                    "networkPoolId": {
                        "type": "string",
                        "description": "ID of used network pool.\n"
                    },
                    "networkPoolUniversalId": {
                        "type": "string",
                        "description": "The network providers universal id that is backing the universal network pool.\n"
                    },
                    "networkProviderType": {
                        "type": "string",
                        "description": "Defines the networking provider backing the VDC group.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations\n",
                        "willReplaceOnChanges": true
                    },
                    "participatingOrgVdcs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VdcGroupParticipatingOrgVdc:VdcGroupParticipatingOrgVdc"
                        },
                        "description": "A list of blocks providing organization VDCs that are participating in this group details. See Participating Org VDCs below for details.\n"
                    },
                    "participatingVdcIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of organization VDCs that are participating in this group. **Note**: `starting_vdc_id` isn't automatically included in this list.\n"
                    },
                    "removeDefaultFirewallRule": {
                        "type": "boolean",
                        "description": "Marks whether default firewall rule should be\nremoved after activating. Both `dfw_enabled` and `default_policy_status` must be true. **Note.**\nThis is mainly useful when using\n[`vcd.NsxtDistributedFirewallRule`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_distributed_firewall_rule)\nresource as it cannot remove the default rule.\n"
                    },
                    "startingVdcId": {
                        "type": "string",
                        "description": "With selecting a starting VDC you will be able to create a group in which this VDC can participate. **Note**: `starting_vdc_id` must be included in `participating_vdc_ids` to participate in this group.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Defines the group as LOCAL or UNIVERSAL.\n"
                    },
                    "universalNetworkingEnabled": {
                        "type": "boolean",
                        "description": "True means that a VDC group router has been created.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vm:Vm": {
            "properties": {
                "acceptAllEulas": {
                    "type": "boolean",
                    "description": "Automatically accept EULA if OVA has it\n"
                },
                "bootImage": {
                    "type": "string",
                    "description": "Media name to add as boot image.\n",
                    "deprecationMessage": "Use `boot_image_id` instead"
                },
                "bootImageId": {
                    "type": "string",
                    "description": "The URN of the media to use as boot image.\n"
                },
                "bootOptions": {
                    "$ref": "#/types/vcd:index/VmBootOptions:VmBootOptions",
                    "description": "A block defining the boot options of a VM\n"
                },
                "catalogName": {
                    "type": "string",
                    "description": "The catalog name in which to find the given vApp Template or media for boot_image\n",
                    "deprecationMessage": "You should use `vapp_template_id` or `boot_image_id` without the need of a catalog name"
                },
                "computerName": {
                    "type": "string",
                    "description": "Computer name to assign to this virtual machine\n"
                },
                "consolidateDisksOnCreate": {
                    "type": "boolean",
                    "description": "Consolidates disks during creation and allows to change disk size using 'override_template_disk' in fast provisioned\nVDCs\n"
                },
                "copyFromVmId": {
                    "type": "string",
                    "description": "Source VM that should be copied from\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "The number of cores per socket\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of virtual CPUs while powered on.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The limit for how much of CPU can be consumed on the underlying virtualization infrastructure. This is only valid when\nthe resource allocation is not unlimited.\n"
                },
                "cpuPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the\nvirtualized workload\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of MHz reservation on the underlying virtualization infrastructure\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource. This is a read-only, unless the `cpu_priority` is CUSTOM\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of virtual CPUs to allocate to the VM\n"
                },
                "customization": {
                    "$ref": "#/types/vcd:index/VmCustomization:VmCustomization",
                    "description": "Guest customization block\n"
                },
                "description": {
                    "type": "string",
                    "description": "The VM description\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmDisk:VmDisk"
                    }
                },
                "exposeHardwareVirtualization": {
                    "type": "boolean",
                    "description": "Expose hardware-assisted CPU virtualization to guest OS.\n"
                },
                "extraConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmExtraConfig:VmExtraConfig"
                    },
                    "description": "A block to retrieve extra configuration key-value pairs\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "Firmware of the VM. Can be either EFI or BIOS, availabilitydepending on the os_type argument. If unset, is set to 'bios'\nby default. Changing the value when `power_on` is set to true, will cause a reboot of the VM.\n"
                },
                "guestProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key/value settings for guest properties\n"
                },
                "hardwareVersion": {
                    "type": "string",
                    "description": "Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.)\n"
                },
                "href": {
                    "type": "string",
                    "description": "VM Hyper Reference\n"
                },
                "imported": {
                    "type": "boolean",
                    "description": "Tells whether this resource has been imported\n"
                },
                "inheritedMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map that contains metadata that is automatically added by VCD (10.5.1+) and provides details on the origin of the VM\n"
                },
                "internalDisks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmInternalDisk:VmInternalDisk"
                    },
                    "description": "A block will show internal disk details\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) to allocate to the VM\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of memory while powered on.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The limit for how much of memory can be consumed on the underlying virtualization infrastructure. This is only valid\nwhen the resource allocation is not unlimited.\n"
                },
                "memoryPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the\nvirtualized workload\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) reservation on the underlying virtualization infrastructure\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource. This is a read-only, unless the `memory_priority` is CUSTOM\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of metadata to assign to this VM\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmMetadataEntry:VmMetadataEntry"
                    },
                    "description": "Metadata entries for the given VM\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n"
                },
                "networkDhcpWaitSeconds": {
                    "type": "integer",
                    "description": "Optional number of seconds to try and wait for DHCP IP (valid for 'network' block only)\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmNetwork:VmNetwork"
                    },
                    "description": "A block to define network interface. Multiple can be used.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n"
                },
                "osType": {
                    "type": "string",
                    "description": "Operating System type. Possible values can be found in documentation.\n"
                },
                "overrideTemplateDisks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmOverrideTemplateDisk:VmOverrideTemplateDisk"
                    },
                    "description": "A block to match internal_disk interface in template. Multiple can be used. Disk will be matched by bus_type, bus_number\nand unit_number.\n"
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM placement policy ID. Has to be assigned to Org VDC.\n"
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this VM should be powered on\n"
                },
                "preventUpdatePowerOff": {
                    "type": "boolean",
                    "description": "True if the update of resource should fail when virtual machine power off needed.\n"
                },
                "securityTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Security tags to assign to this VM\n"
                },
                "setExtraConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmSetExtraConfig:VmSetExtraConfig"
                    },
                    "description": "A block to set extra configuration key-value pairs\n"
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM sizing policy ID. Has to be assigned to Org VDC.\n"
                },
                "status": {
                    "type": "integer",
                    "description": "Shows the status code of the VM\n"
                },
                "statusText": {
                    "type": "string",
                    "description": "Shows the status of the VM\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the default one\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the vApp Template to use\n",
                    "deprecationMessage": "Use `vapp_template_id` instead"
                },
                "vappId": {
                    "type": "string",
                    "description": "ID of parent vApp\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this VM belongs to - Required, unless it is a standalone VM\n"
                },
                "vappTemplateId": {
                    "type": "string",
                    "description": "The URN of the vApp Template to use\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vmNameInTemplate": {
                    "type": "string",
                    "description": "The name of the VM in vApp Template to use. In cases when vApp template has more than one VM\n"
                },
                "vmType": {
                    "type": "string",
                    "description": "Type of VM: either 'vcd_vapp_vm' or 'vcd_vm'\n"
                }
            },
            "required": [
                "bootOptions",
                "computerName",
                "cpuCores",
                "cpuLimit",
                "cpuPriority",
                "cpuReservation",
                "cpuShares",
                "cpus",
                "customization",
                "description",
                "extraConfigs",
                "firmware",
                "hardwareVersion",
                "href",
                "imported",
                "inheritedMetadata",
                "internalDisks",
                "memory",
                "memoryLimit",
                "memoryPriority",
                "memoryReservation",
                "memoryShares",
                "metadata",
                "metadataEntries",
                "name",
                "osType",
                "placementPolicyId",
                "securityTags",
                "sizingPolicyId",
                "status",
                "statusText",
                "storageProfile",
                "vappId",
                "vappName",
                "vmType"
            ],
            "inputProperties": {
                "acceptAllEulas": {
                    "type": "boolean",
                    "description": "Automatically accept EULA if OVA has it\n"
                },
                "bootImage": {
                    "type": "string",
                    "description": "Media name to add as boot image.\n",
                    "deprecationMessage": "Use `boot_image_id` instead"
                },
                "bootImageId": {
                    "type": "string",
                    "description": "The URN of the media to use as boot image.\n"
                },
                "bootOptions": {
                    "$ref": "#/types/vcd:index/VmBootOptions:VmBootOptions",
                    "description": "A block defining the boot options of a VM\n"
                },
                "catalogName": {
                    "type": "string",
                    "description": "The catalog name in which to find the given vApp Template or media for boot_image\n",
                    "deprecationMessage": "You should use `vapp_template_id` or `boot_image_id` without the need of a catalog name"
                },
                "computerName": {
                    "type": "string",
                    "description": "Computer name to assign to this virtual machine\n"
                },
                "consolidateDisksOnCreate": {
                    "type": "boolean",
                    "description": "Consolidates disks during creation and allows to change disk size using 'override_template_disk' in fast provisioned\nVDCs\n",
                    "willReplaceOnChanges": true
                },
                "copyFromVmId": {
                    "type": "string",
                    "description": "Source VM that should be copied from\n",
                    "willReplaceOnChanges": true
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "The number of cores per socket\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of virtual CPUs while powered on.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The limit for how much of CPU can be consumed on the underlying virtualization infrastructure. This is only valid when\nthe resource allocation is not unlimited.\n"
                },
                "cpuPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the\nvirtualized workload\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of MHz reservation on the underlying virtualization infrastructure\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource. This is a read-only, unless the `cpu_priority` is CUSTOM\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of virtual CPUs to allocate to the VM\n"
                },
                "customization": {
                    "$ref": "#/types/vcd:index/VmCustomization:VmCustomization",
                    "description": "Guest customization block\n"
                },
                "description": {
                    "type": "string",
                    "description": "The VM description\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmDisk:VmDisk"
                    }
                },
                "exposeHardwareVirtualization": {
                    "type": "boolean",
                    "description": "Expose hardware-assisted CPU virtualization to guest OS.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "Firmware of the VM. Can be either EFI or BIOS, availabilitydepending on the os_type argument. If unset, is set to 'bios'\nby default. Changing the value when `power_on` is set to true, will cause a reboot of the VM.\n"
                },
                "guestProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key/value settings for guest properties\n"
                },
                "hardwareVersion": {
                    "type": "string",
                    "description": "Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.)\n"
                },
                "href": {
                    "type": "string",
                    "description": "VM Hyper Reference\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) to allocate to the VM\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "True if the virtual machine supports addition of memory while powered on.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The limit for how much of memory can be consumed on the underlying virtualization infrastructure. This is only valid\nwhen the resource allocation is not unlimited.\n"
                },
                "memoryPriority": {
                    "type": "string",
                    "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the\nvirtualized workload\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of RAM (in MB) reservation on the underlying virtualization infrastructure\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "Custom priority for the resource. This is a read-only, unless the `memory_priority` is CUSTOM\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key value map of metadata to assign to this VM\n",
                    "deprecationMessage": "Use metadata_entry instead"
                },
                "metadataEntries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmMetadataEntry:VmMetadataEntry"
                    },
                    "description": "Metadata entries for the given VM\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name for the VM, unique within the vApp\n",
                    "willReplaceOnChanges": true
                },
                "networkDhcpWaitSeconds": {
                    "type": "integer",
                    "description": "Optional number of seconds to try and wait for DHCP IP (valid for 'network' block only)\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmNetwork:VmNetwork"
                    },
                    "description": "A block to define network interface. Multiple can be used.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                    "willReplaceOnChanges": true
                },
                "osType": {
                    "type": "string",
                    "description": "Operating System type. Possible values can be found in documentation.\n"
                },
                "overrideTemplateDisks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmOverrideTemplateDisk:VmOverrideTemplateDisk"
                    },
                    "description": "A block to match internal_disk interface in template. Multiple can be used. Disk will be matched by bus_type, bus_number\nand unit_number.\n",
                    "willReplaceOnChanges": true
                },
                "placementPolicyId": {
                    "type": "string",
                    "description": "VM placement policy ID. Has to be assigned to Org VDC.\n"
                },
                "powerOn": {
                    "type": "boolean",
                    "description": "A boolean value stating if this VM should be powered on\n"
                },
                "preventUpdatePowerOff": {
                    "type": "boolean",
                    "description": "True if the update of resource should fail when virtual machine power off needed.\n"
                },
                "securityTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Security tags to assign to this VM\n"
                },
                "setExtraConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmSetExtraConfig:VmSetExtraConfig"
                    },
                    "description": "A block to set extra configuration key-value pairs\n"
                },
                "sizingPolicyId": {
                    "type": "string",
                    "description": "VM sizing policy ID. Has to be assigned to Org VDC.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile to override the default one\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the vApp Template to use\n",
                    "deprecationMessage": "Use `vapp_template_id` instead",
                    "willReplaceOnChanges": true
                },
                "vappName": {
                    "type": "string",
                    "description": "The vApp this VM belongs to - Required, unless it is a standalone VM\n"
                },
                "vappTemplateId": {
                    "type": "string",
                    "description": "The URN of the vApp Template to use\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "vmNameInTemplate": {
                    "type": "string",
                    "description": "The name of the VM in vApp Template to use. In cases when vApp template has more than one VM\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vm resources.\n",
                "properties": {
                    "acceptAllEulas": {
                        "type": "boolean",
                        "description": "Automatically accept EULA if OVA has it\n"
                    },
                    "bootImage": {
                        "type": "string",
                        "description": "Media name to add as boot image.\n",
                        "deprecationMessage": "Use `boot_image_id` instead"
                    },
                    "bootImageId": {
                        "type": "string",
                        "description": "The URN of the media to use as boot image.\n"
                    },
                    "bootOptions": {
                        "$ref": "#/types/vcd:index/VmBootOptions:VmBootOptions",
                        "description": "A block defining the boot options of a VM\n"
                    },
                    "catalogName": {
                        "type": "string",
                        "description": "The catalog name in which to find the given vApp Template or media for boot_image\n",
                        "deprecationMessage": "You should use `vapp_template_id` or `boot_image_id` without the need of a catalog name"
                    },
                    "computerName": {
                        "type": "string",
                        "description": "Computer name to assign to this virtual machine\n"
                    },
                    "consolidateDisksOnCreate": {
                        "type": "boolean",
                        "description": "Consolidates disks during creation and allows to change disk size using 'override_template_disk' in fast provisioned\nVDCs\n",
                        "willReplaceOnChanges": true
                    },
                    "copyFromVmId": {
                        "type": "string",
                        "description": "Source VM that should be copied from\n",
                        "willReplaceOnChanges": true
                    },
                    "cpuCores": {
                        "type": "integer",
                        "description": "The number of cores per socket\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "True if the virtual machine supports addition of virtual CPUs while powered on.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The limit for how much of CPU can be consumed on the underlying virtualization infrastructure. This is only valid when\nthe resource allocation is not unlimited.\n"
                    },
                    "cpuPriority": {
                        "type": "string",
                        "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the\nvirtualized workload\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The amount of MHz reservation on the underlying virtualization infrastructure\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "Custom priority for the resource. This is a read-only, unless the `cpu_priority` is CUSTOM\n"
                    },
                    "cpus": {
                        "type": "integer",
                        "description": "The number of virtual CPUs to allocate to the VM\n"
                    },
                    "customization": {
                        "$ref": "#/types/vcd:index/VmCustomization:VmCustomization",
                        "description": "Guest customization block\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The VM description\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmDisk:VmDisk"
                        }
                    },
                    "exposeHardwareVirtualization": {
                        "type": "boolean",
                        "description": "Expose hardware-assisted CPU virtualization to guest OS.\n"
                    },
                    "extraConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmExtraConfig:VmExtraConfig"
                        },
                        "description": "A block to retrieve extra configuration key-value pairs\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "Firmware of the VM. Can be either EFI or BIOS, availabilitydepending on the os_type argument. If unset, is set to 'bios'\nby default. Changing the value when `power_on` is set to true, will cause a reboot of the VM.\n"
                    },
                    "guestProperties": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key/value settings for guest properties\n"
                    },
                    "hardwareVersion": {
                        "type": "string",
                        "description": "Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.)\n"
                    },
                    "href": {
                        "type": "string",
                        "description": "VM Hyper Reference\n"
                    },
                    "imported": {
                        "type": "boolean",
                        "description": "Tells whether this resource has been imported\n"
                    },
                    "inheritedMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map that contains metadata that is automatically added by VCD (10.5.1+) and provides details on the origin of the VM\n"
                    },
                    "internalDisks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmInternalDisk:VmInternalDisk"
                        },
                        "description": "A block will show internal disk details\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The amount of RAM (in MB) to allocate to the VM\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "True if the virtual machine supports addition of memory while powered on.\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The limit for how much of memory can be consumed on the underlying virtualization infrastructure. This is only valid\nwhen the resource allocation is not unlimited.\n"
                    },
                    "memoryPriority": {
                        "type": "string",
                        "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the\nvirtualized workload\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The amount of RAM (in MB) reservation on the underlying virtualization infrastructure\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "Custom priority for the resource. This is a read-only, unless the `memory_priority` is CUSTOM\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key value map of metadata to assign to this VM\n",
                        "deprecationMessage": "Use metadata_entry instead"
                    },
                    "metadataEntries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmMetadataEntry:VmMetadataEntry"
                        },
                        "description": "Metadata entries for the given VM\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for the VM, unique within the vApp\n",
                        "willReplaceOnChanges": true
                    },
                    "networkDhcpWaitSeconds": {
                        "type": "integer",
                        "description": "Optional number of seconds to try and wait for DHCP IP (valid for 'network' block only)\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmNetwork:VmNetwork"
                        },
                        "description": "A block to define network interface. Multiple can be used.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across\ndifferent organizations\n",
                        "willReplaceOnChanges": true
                    },
                    "osType": {
                        "type": "string",
                        "description": "Operating System type. Possible values can be found in documentation.\n"
                    },
                    "overrideTemplateDisks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmOverrideTemplateDisk:VmOverrideTemplateDisk"
                        },
                        "description": "A block to match internal_disk interface in template. Multiple can be used. Disk will be matched by bus_type, bus_number\nand unit_number.\n",
                        "willReplaceOnChanges": true
                    },
                    "placementPolicyId": {
                        "type": "string",
                        "description": "VM placement policy ID. Has to be assigned to Org VDC.\n"
                    },
                    "powerOn": {
                        "type": "boolean",
                        "description": "A boolean value stating if this VM should be powered on\n"
                    },
                    "preventUpdatePowerOff": {
                        "type": "boolean",
                        "description": "True if the update of resource should fail when virtual machine power off needed.\n"
                    },
                    "securityTags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Security tags to assign to this VM\n"
                    },
                    "setExtraConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmSetExtraConfig:VmSetExtraConfig"
                        },
                        "description": "A block to set extra configuration key-value pairs\n"
                    },
                    "sizingPolicyId": {
                        "type": "string",
                        "description": "VM sizing policy ID. Has to be assigned to Org VDC.\n"
                    },
                    "status": {
                        "type": "integer",
                        "description": "Shows the status code of the VM\n"
                    },
                    "statusText": {
                        "type": "string",
                        "description": "Shows the status of the VM\n"
                    },
                    "storageProfile": {
                        "type": "string",
                        "description": "Storage profile to override the default one\n"
                    },
                    "templateName": {
                        "type": "string",
                        "description": "The name of the vApp Template to use\n",
                        "deprecationMessage": "Use `vapp_template_id` instead",
                        "willReplaceOnChanges": true
                    },
                    "vappId": {
                        "type": "string",
                        "description": "ID of parent vApp\n"
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vApp this VM belongs to - Required, unless it is a standalone VM\n"
                    },
                    "vappTemplateId": {
                        "type": "string",
                        "description": "The URN of the vApp Template to use\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vmNameInTemplate": {
                        "type": "string",
                        "description": "The name of the VM in vApp Template to use. In cases when vApp template has more than one VM\n",
                        "willReplaceOnChanges": true
                    },
                    "vmType": {
                        "type": "string",
                        "description": "Type of VM: either 'vcd_vapp_vm' or 'vcd_vm'\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vmAffinityRule:VmAffinityRule": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "True if this affinity rule is enabled. The default is `true`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of VM affinity rule. Duplicates are allowed, although the name can be used to retrieve\nthe rule (as data source or when importing) only if it is unique.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations\n"
                },
                "polarity": {
                    "type": "string",
                    "description": "One of `Affinity` or `Anti-Affinity`. This property cannot be changed. Once created, if we\nneed to change polarity, we need to remove the rule and create a new one.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "True if this affinity rule is required. When a rule is mandatory, a host failover will not \npower on the VM if doing so would violate the rule. The default is `true`\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of virtual machine IDs that compose this rule. At least 2 IDs must be provided.\n"
                }
            },
            "required": [
                "name",
                "polarity",
                "vmIds"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "True if this affinity rule is enabled. The default is `true`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of VM affinity rule. Duplicates are allowed, although the name can be used to retrieve\nthe rule (as data source or when importing) only if it is unique.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations\n",
                    "willReplaceOnChanges": true
                },
                "polarity": {
                    "type": "string",
                    "description": "One of `Affinity` or `Anti-Affinity`. This property cannot be changed. Once created, if we\nneed to change polarity, we need to remove the rule and create a new one.\n",
                    "willReplaceOnChanges": true
                },
                "required": {
                    "type": "boolean",
                    "description": "True if this affinity rule is required. When a rule is mandatory, a host failover will not \npower on the VM if doing so would violate the rule. The default is `true`\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "vmIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of virtual machine IDs that compose this rule. At least 2 IDs must be provided.\n"
                }
            },
            "requiredInputs": [
                "polarity",
                "vmIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmAffinityRule resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "True if this affinity rule is enabled. The default is `true`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of VM affinity rule. Duplicates are allowed, although the name can be used to retrieve\nthe rule (as data source or when importing) only if it is unique.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations\n",
                        "willReplaceOnChanges": true
                    },
                    "polarity": {
                        "type": "string",
                        "description": "One of `Affinity` or `Anti-Affinity`. This property cannot be changed. Once created, if we\nneed to change polarity, we need to remove the rule and create a new one.\n",
                        "willReplaceOnChanges": true
                    },
                    "required": {
                        "type": "boolean",
                        "description": "True if this affinity rule is required. When a rule is mandatory, a host failover will not \npower on the VM if doing so would violate the rule. The default is `true`\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vmIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of virtual machine IDs that compose this rule. At least 2 IDs must be provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vmInternalDisk:VmInternalDisk": {
            "properties": {
                "allowVmReboot": {
                    "type": "boolean",
                    "description": "Powers off VM when changing any attribute of an IDE disk or unit/bus number of other disk types, after the change is complete VM is powered back on. Without this setting enabled, such changes on a powered-on VM would fail. Defaults to false.\n"
                },
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n"
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: `ide`, `parallel`( LSI Logic Parallel SCSI),\n`sas`(LSI Logic SAS (SCSI)), `paravirtual`(Paravirtual (SCSI)), `sata`, `nvme`. **Note** `nvme` requires *v3.4.0+* and\nVCD *10.2.1+*\n"
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile which overrides the VM default one.\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Specifies whether the disk storage is pre-allocated or allocated on demand.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n"
                },
                "vappName": {
                    "type": "string",
                    "description": "The vAPP this VM internal disk belongs to.\n"
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n"
                },
                "vmName": {
                    "type": "string",
                    "description": "VM in vAPP in which internal disk is created.\n"
                }
            },
            "required": [
                "busNumber",
                "busType",
                "iops",
                "sizeInMb",
                "storageProfile",
                "thinProvisioned",
                "unitNumber",
                "vappName",
                "vmName"
            ],
            "inputProperties": {
                "allowVmReboot": {
                    "type": "boolean",
                    "description": "Powers off VM when changing any attribute of an IDE disk or unit/bus number of other disk types, after the change is complete VM is powered back on. Without this setting enabled, such changes on a powered-on VM would fail. Defaults to false.\n"
                },
                "busNumber": {
                    "type": "integer",
                    "description": "The number of the SCSI or IDE controller itself.\n",
                    "willReplaceOnChanges": true
                },
                "busType": {
                    "type": "string",
                    "description": "The type of disk controller. Possible values: `ide`, `parallel`( LSI Logic Parallel SCSI),\n`sas`(LSI Logic SAS (SCSI)), `paravirtual`(Paravirtual (SCSI)), `sata`, `nvme`. **Note** `nvme` requires *v3.4.0+* and\nVCD *10.2.1+*\n",
                    "willReplaceOnChanges": true
                },
                "iops": {
                    "type": "integer",
                    "description": "Specifies the IOPS for the disk. Default is 0.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                    "willReplaceOnChanges": true
                },
                "sizeInMb": {
                    "type": "integer",
                    "description": "The size of the disk in MB.\n"
                },
                "storageProfile": {
                    "type": "string",
                    "description": "Storage profile which overrides the VM default one.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The device number on the SCSI or IDE controller of the disk.\n",
                    "willReplaceOnChanges": true
                },
                "vappName": {
                    "type": "string",
                    "description": "The vAPP this VM internal disk belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "vdc": {
                    "type": "string",
                    "description": "The name of VDC to use, optional if defined at provider level\n",
                    "willReplaceOnChanges": true
                },
                "vmName": {
                    "type": "string",
                    "description": "VM in vAPP in which internal disk is created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "busNumber",
                "busType",
                "sizeInMb",
                "unitNumber",
                "vappName",
                "vmName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmInternalDisk resources.\n",
                "properties": {
                    "allowVmReboot": {
                        "type": "boolean",
                        "description": "Powers off VM when changing any attribute of an IDE disk or unit/bus number of other disk types, after the change is complete VM is powered back on. Without this setting enabled, such changes on a powered-on VM would fail. Defaults to false.\n"
                    },
                    "busNumber": {
                        "type": "integer",
                        "description": "The number of the SCSI or IDE controller itself.\n",
                        "willReplaceOnChanges": true
                    },
                    "busType": {
                        "type": "string",
                        "description": "The type of disk controller. Possible values: `ide`, `parallel`( LSI Logic Parallel SCSI),\n`sas`(LSI Logic SAS (SCSI)), `paravirtual`(Paravirtual (SCSI)), `sata`, `nvme`. **Note** `nvme` requires *v3.4.0+* and\nVCD *10.2.1+*\n",
                        "willReplaceOnChanges": true
                    },
                    "iops": {
                        "type": "integer",
                        "description": "Specifies the IOPS for the disk. Default is 0.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "sizeInMb": {
                        "type": "integer",
                        "description": "The size of the disk in MB.\n"
                    },
                    "storageProfile": {
                        "type": "string",
                        "description": "Storage profile which overrides the VM default one.\n"
                    },
                    "thinProvisioned": {
                        "type": "boolean",
                        "description": "Specifies whether the disk storage is pre-allocated or allocated on demand.\n"
                    },
                    "unitNumber": {
                        "type": "integer",
                        "description": "The device number on the SCSI or IDE controller of the disk.\n",
                        "willReplaceOnChanges": true
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vAPP this VM internal disk belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vmName": {
                        "type": "string",
                        "description": "VM in vAPP in which internal disk is created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vmPlacementPolicy:VmPlacementPolicy": {
            "description": "Provides a VMware Cloud Director VM Placement Policy resource. This can be used to create, modify, and delete VM Placement Policy.\n\nSupported in provider *v3.8+* and requires VCD 10.2+\n\n\u003e **Note:** This resource requires system administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst pvdc = vcd.getProviderVdc({\n    name: \"my-pvdc\",\n});\nconst vm_group = pvdc.then(pvdc =\u003e vcd.getVmGroup({\n    name: \"vmware-vm-group\",\n    providerVdcId: pvdc.id,\n}));\nconst test_placement_pol = new vcd.VmPlacementPolicy(\"test-placement-pol\", {\n    name: \"my-placement-pol\",\n    description: \"My awesome VM Placement Policy\",\n    providerVdcId: pvdc.then(pvdc =\u003e pvdc.id),\n    vmGroupIds: [vm_group.then(vm_group =\u003e vm_group.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\npvdc = vcd.get_provider_vdc(name=\"my-pvdc\")\nvm_group = vcd.get_vm_group(name=\"vmware-vm-group\",\n    provider_vdc_id=pvdc.id)\ntest_placement_pol = vcd.VmPlacementPolicy(\"test-placement-pol\",\n    name=\"my-placement-pol\",\n    description=\"My awesome VM Placement Policy\",\n    provider_vdc_id=pvdc.id,\n    vm_group_ids=[vm_group.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pvdc = Vcd.GetProviderVdc.Invoke(new()\n    {\n        Name = \"my-pvdc\",\n    });\n\n    var vm_group = Vcd.GetVmGroup.Invoke(new()\n    {\n        Name = \"vmware-vm-group\",\n        ProviderVdcId = pvdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Id),\n    });\n\n    var test_placement_pol = new Vcd.VmPlacementPolicy(\"test-placement-pol\", new()\n    {\n        Name = \"my-placement-pol\",\n        Description = \"My awesome VM Placement Policy\",\n        ProviderVdcId = pvdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Id),\n        VmGroupIds = new[]\n        {\n            vm_group.Apply(vm_group =\u003e vm_group.Apply(getVmGroupResult =\u003e getVmGroupResult.Id)),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpvdc, err := vcd.LookupProviderVdc(ctx, \u0026vcd.LookupProviderVdcArgs{\n\t\t\tName: \"my-pvdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm_group, err := vcd.GetVmGroup(ctx, \u0026vcd.GetVmGroupArgs{\n\t\t\tName:          \"vmware-vm-group\",\n\t\t\tProviderVdcId: pvdc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewVmPlacementPolicy(ctx, \"test-placement-pol\", \u0026vcd.VmPlacementPolicyArgs{\n\t\t\tName:          pulumi.String(\"my-placement-pol\"),\n\t\t\tDescription:   pulumi.String(\"My awesome VM Placement Policy\"),\n\t\t\tProviderVdcId: pulumi.String(pvdc.Id),\n\t\t\tVmGroupIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(vm_group.Id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetProviderVdcArgs;\nimport com.pulumi.vcd.inputs.GetVmGroupArgs;\nimport com.pulumi.vcd.VmPlacementPolicy;\nimport com.pulumi.vcd.VmPlacementPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var pvdc = VcdFunctions.getProviderVdc(GetProviderVdcArgs.builder()\n            .name(\"my-pvdc\")\n            .build());\n\n        final var vm-group = VcdFunctions.getVmGroup(GetVmGroupArgs.builder()\n            .name(\"vmware-vm-group\")\n            .providerVdcId(pvdc.applyValue(getProviderVdcResult -\u003e getProviderVdcResult.id()))\n            .build());\n\n        var test_placement_pol = new VmPlacementPolicy(\"test-placement-pol\", VmPlacementPolicyArgs.builder()\n            .name(\"my-placement-pol\")\n            .description(\"My awesome VM Placement Policy\")\n            .providerVdcId(pvdc.applyValue(getProviderVdcResult -\u003e getProviderVdcResult.id()))\n            .vmGroupIds(vm_group.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test-placement-pol:\n    type: vcd:VmPlacementPolicy\n    properties:\n      name: my-placement-pol\n      description: My awesome VM Placement Policy\n      providerVdcId: ${pvdc.id}\n      vmGroupIds:\n        - ${[\"vm-group\"].id}\nvariables:\n  pvdc:\n    fn::invoke:\n      function: vcd:getProviderVdc\n      arguments:\n        name: my-pvdc\n  vm-group:\n    fn::invoke:\n      function: vcd:getVmGroup\n      arguments:\n        name: vmware-vm-group\n        providerVdcId: ${pvdc.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "description of VM Placement Policy.\n"
                },
                "logicalVmGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IDs of one or more Logical VM Groups to define this VM Placement Policy. There is an AND relationship among all the\nentries set in this attribute\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of VM Placement Policy.\n"
                },
                "providerVdcId": {
                    "type": "string",
                    "description": "The ID of the Provider VDC to which this VM Placement Policy belongs.\n"
                },
                "vmGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IDs of the collection of VMs with similar host requirements. **Note:** Either `vm_group_ids` or `logical_vm_group_ids` must be set.\n"
                }
            },
            "required": [
                "description",
                "name",
                "providerVdcId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "description of VM Placement Policy.\n"
                },
                "logicalVmGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IDs of one or more Logical VM Groups to define this VM Placement Policy. There is an AND relationship among all the\nentries set in this attribute\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of VM Placement Policy.\n"
                },
                "providerVdcId": {
                    "type": "string",
                    "description": "The ID of the Provider VDC to which this VM Placement Policy belongs.\n"
                },
                "vmGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IDs of the collection of VMs with similar host requirements. **Note:** Either `vm_group_ids` or `logical_vm_group_ids` must be set.\n"
                }
            },
            "requiredInputs": [
                "providerVdcId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmPlacementPolicy resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "description of VM Placement Policy.\n"
                    },
                    "logicalVmGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IDs of one or more Logical VM Groups to define this VM Placement Policy. There is an AND relationship among all the\nentries set in this attribute\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of VM Placement Policy.\n"
                    },
                    "providerVdcId": {
                        "type": "string",
                        "description": "The ID of the Provider VDC to which this VM Placement Policy belongs.\n"
                    },
                    "vmGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IDs of the collection of VMs with similar host requirements. **Note:** Either `vm_group_ids` or `logical_vm_group_ids` must be set.\n"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vmSizingPolicy:VmSizingPolicy": {
            "properties": {
                "cpu": {
                    "$ref": "#/types/vcd:index/VmSizingPolicyCpu:VmSizingPolicyCpu",
                    "description": "Configures cpu policy; see Cpu below for details.\n"
                },
                "description": {
                    "type": "string",
                    "description": "description of VM sizing policy.\n"
                },
                "memory": {
                    "$ref": "#/types/vcd:index/VmSizingPolicyMemory:VmSizingPolicyMemory",
                    "description": "Configures memory policy; see Memory below for details.\n\n\u003e **Note:**\nPreviously, it was incorrectly stated that the `org` argument was required. In fact, it is not, and it has been deprecated in the resource schema.\nTo preserve compatibility until the next release, though, the parameter is still parsed, but ignored.\n\n\u003ca id=\"cpu\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of VM sizing policy.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use - Deprecated and unneeded: will be ignored if used\n",
                    "deprecationMessage": "Unneeded property, which was included by mistake"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "cpu": {
                    "$ref": "#/types/vcd:index/VmSizingPolicyCpu:VmSizingPolicyCpu",
                    "description": "Configures cpu policy; see Cpu below for details.\n"
                },
                "description": {
                    "type": "string",
                    "description": "description of VM sizing policy.\n"
                },
                "memory": {
                    "$ref": "#/types/vcd:index/VmSizingPolicyMemory:VmSizingPolicyMemory",
                    "description": "Configures memory policy; see Memory below for details.\n\n\u003e **Note:**\nPreviously, it was incorrectly stated that the `org` argument was required. In fact, it is not, and it has been deprecated in the resource schema.\nTo preserve compatibility until the next release, though, the parameter is still parsed, but ignored.\n\n\u003ca id=\"cpu\"\u003e\u003c/a\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of VM sizing policy.\n"
                },
                "org": {
                    "type": "string",
                    "description": "The name of organization to use - Deprecated and unneeded: will be ignored if used\n",
                    "deprecationMessage": "Unneeded property, which was included by mistake"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmSizingPolicy resources.\n",
                "properties": {
                    "cpu": {
                        "$ref": "#/types/vcd:index/VmSizingPolicyCpu:VmSizingPolicyCpu",
                        "description": "Configures cpu policy; see Cpu below for details.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "description of VM sizing policy.\n"
                    },
                    "memory": {
                        "$ref": "#/types/vcd:index/VmSizingPolicyMemory:VmSizingPolicyMemory",
                        "description": "Configures memory policy; see Memory below for details.\n\n\u003e **Note:**\nPreviously, it was incorrectly stated that the `org` argument was required. In fact, it is not, and it has been deprecated in the resource schema.\nTo preserve compatibility until the next release, though, the parameter is still parsed, but ignored.\n\n\u003ca id=\"cpu\"\u003e\u003c/a\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of VM sizing policy.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use - Deprecated and unneeded: will be ignored if used\n",
                        "deprecationMessage": "Unneeded property, which was included by mistake"
                    }
                },
                "type": "object"
            }
        },
        "vcd:index/vmVgpuPolicy:VmVgpuPolicy": {
            "description": "Experimental in provider *3.11*.\n\n\u003e **Note:** This resource requires system administrator privileges.\n\nProvides a resource to manage vGPU policies for virtual machines in VMware Cloud Director.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst exampleOrg = vcd.getOrg({\n    name: \"test_org\",\n});\nconst exampleVgpuProfile = vcd.getVgpuProfile({\n    name: \"grid_a100-10c\",\n});\nconst exampleProviderVdc = vcd.getProviderVdc({\n    name: \"example_provider_vdc\",\n});\nconst vmGroupExample = vcd.getVmGroup({\n    name: \"vm-group-1\",\n});\nconst exampleVgpuPolicy = new vcd.VmVgpuPolicy(\"example_vgpu_policy\", {\n    name: \"example-vgpu-policy\",\n    description: \"An example vGPU policy configuration\",\n    vgpuProfile: {\n        id: exampleVgpuProfile.then(exampleVgpuProfile =\u003e exampleVgpuProfile.id),\n        count: 1,\n    },\n    cpu: {\n        shares: \"886\",\n        limitInMhz: \"2400\",\n        count: \"9\",\n        speedInMhz: \"2500\",\n        coresPerSocket: \"3\",\n        reservationGuarantee: \"0.55\",\n    },\n    memory: {\n        shares: \"1580\",\n        sizeInMb: \"3200\",\n        limitInMb: \"2800\",\n    },\n    providerVdcScopes: [{\n        providerVdcId: exampleProviderVdc.then(exampleProviderVdc =\u003e exampleProviderVdc.id),\n        clusterNames: [\"cluster1\"],\n        vmGroupId: vmGroupExample.then(vmGroupExample =\u003e vmGroupExample.id),\n    }],\n});\nconst exampleOrgVdc = new vcd.OrgVdc(\"example_org_vdc\", {\n    org: exampleOrg.then(exampleOrg =\u003e exampleOrg.name),\n    name: \"test-org-vdc\",\n    providerVdcName: exampleProviderVdc.then(exampleProviderVdc =\u003e exampleProviderVdc.name),\n    allocationModel: \"Flex\",\n    deleteForce: true,\n    computeCapacity: {\n        cpu: {\n            allocated: 2048,\n        },\n        memory: {\n            allocated: 2048,\n        },\n    },\n    storageProfiles: [{\n        name: \"*\",\n        limit: 10240,\n        \"default\": true,\n    }],\n    elasticity: true,\n    includeVmMemoryOverhead: true,\n    memoryGuaranteed: 1,\n    defaultComputePolicyId: exampleVgpuPolicy.id,\n    vmVgpuPolicyIds: [exampleVgpuPolicy.id],\n});\nconst testVm = new vcd.Vm(\"test_vm\", {\n    org: exampleOrg.then(exampleOrg =\u003e exampleOrg.name),\n    vdc: exampleOrgVdc.name,\n    name: \"terraform-provider-vm\",\n    computerName: \"emptyVM\",\n    memory: 2048,\n    cpus: 2,\n    cpuCores: 1,\n    powerOn: false,\n    osType: \"sles11_64Guest\",\n    hardwareVersion: \"vmx-19\",\n    placementPolicyId: exampleVgpuPolicy.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexample_org = vcd.get_org(name=\"test_org\")\nexample_vgpu_profile = vcd.get_vgpu_profile(name=\"grid_a100-10c\")\nexample_provider_vdc = vcd.get_provider_vdc(name=\"example_provider_vdc\")\nvm_group_example = vcd.get_vm_group(name=\"vm-group-1\")\nexample_vgpu_policy = vcd.VmVgpuPolicy(\"example_vgpu_policy\",\n    name=\"example-vgpu-policy\",\n    description=\"An example vGPU policy configuration\",\n    vgpu_profile={\n        \"id\": example_vgpu_profile.id,\n        \"count\": 1,\n    },\n    cpu={\n        \"shares\": \"886\",\n        \"limit_in_mhz\": \"2400\",\n        \"count\": \"9\",\n        \"speed_in_mhz\": \"2500\",\n        \"cores_per_socket\": \"3\",\n        \"reservation_guarantee\": \"0.55\",\n    },\n    memory={\n        \"shares\": \"1580\",\n        \"size_in_mb\": \"3200\",\n        \"limit_in_mb\": \"2800\",\n    },\n    provider_vdc_scopes=[{\n        \"provider_vdc_id\": example_provider_vdc.id,\n        \"cluster_names\": [\"cluster1\"],\n        \"vm_group_id\": vm_group_example.id,\n    }])\nexample_org_vdc = vcd.OrgVdc(\"example_org_vdc\",\n    org=example_org.name,\n    name=\"test-org-vdc\",\n    provider_vdc_name=example_provider_vdc.name,\n    allocation_model=\"Flex\",\n    delete_force=True,\n    compute_capacity={\n        \"cpu\": {\n            \"allocated\": 2048,\n        },\n        \"memory\": {\n            \"allocated\": 2048,\n        },\n    },\n    storage_profiles=[{\n        \"name\": \"*\",\n        \"limit\": 10240,\n        \"default\": True,\n    }],\n    elasticity=True,\n    include_vm_memory_overhead=True,\n    memory_guaranteed=1,\n    default_compute_policy_id=example_vgpu_policy.id,\n    vm_vgpu_policy_ids=[example_vgpu_policy.id])\ntest_vm = vcd.Vm(\"test_vm\",\n    org=example_org.name,\n    vdc=example_org_vdc.name,\n    name=\"terraform-provider-vm\",\n    computer_name=\"emptyVM\",\n    memory=2048,\n    cpus=2,\n    cpu_cores=1,\n    power_on=False,\n    os_type=\"sles11_64Guest\",\n    hardware_version=\"vmx-19\",\n    placement_policy_id=example_vgpu_policy.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleOrg = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"test_org\",\n    });\n\n    var exampleVgpuProfile = Vcd.GetVgpuProfile.Invoke(new()\n    {\n        Name = \"grid_a100-10c\",\n    });\n\n    var exampleProviderVdc = Vcd.GetProviderVdc.Invoke(new()\n    {\n        Name = \"example_provider_vdc\",\n    });\n\n    var vmGroupExample = Vcd.GetVmGroup.Invoke(new()\n    {\n        Name = \"vm-group-1\",\n    });\n\n    var exampleVgpuPolicy = new Vcd.VmVgpuPolicy(\"example_vgpu_policy\", new()\n    {\n        Name = \"example-vgpu-policy\",\n        Description = \"An example vGPU policy configuration\",\n        VgpuProfile = new Vcd.Inputs.VmVgpuPolicyVgpuProfileArgs\n        {\n            Id = exampleVgpuProfile.Apply(getVgpuProfileResult =\u003e getVgpuProfileResult.Id),\n            Count = 1,\n        },\n        Cpu = new Vcd.Inputs.VmVgpuPolicyCpuArgs\n        {\n            Shares = \"886\",\n            LimitInMhz = \"2400\",\n            Count = \"9\",\n            SpeedInMhz = \"2500\",\n            CoresPerSocket = \"3\",\n            ReservationGuarantee = \"0.55\",\n        },\n        Memory = new Vcd.Inputs.VmVgpuPolicyMemoryArgs\n        {\n            Shares = \"1580\",\n            SizeInMb = \"3200\",\n            LimitInMb = \"2800\",\n        },\n        ProviderVdcScopes = new[]\n        {\n            new Vcd.Inputs.VmVgpuPolicyProviderVdcScopeArgs\n            {\n                ProviderVdcId = exampleProviderVdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Id),\n                ClusterNames = new[]\n                {\n                    \"cluster1\",\n                },\n                VmGroupId = vmGroupExample.Apply(getVmGroupResult =\u003e getVmGroupResult.Id),\n            },\n        },\n    });\n\n    var exampleOrgVdc = new Vcd.OrgVdc(\"example_org_vdc\", new()\n    {\n        Org = exampleOrg.Apply(getOrgResult =\u003e getOrgResult.Name),\n        Name = \"test-org-vdc\",\n        ProviderVdcName = exampleProviderVdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Name),\n        AllocationModel = \"Flex\",\n        DeleteForce = true,\n        ComputeCapacity = new Vcd.Inputs.OrgVdcComputeCapacityArgs\n        {\n            Cpu = new Vcd.Inputs.OrgVdcComputeCapacityCpuArgs\n            {\n                Allocated = 2048,\n            },\n            Memory = new Vcd.Inputs.OrgVdcComputeCapacityMemoryArgs\n            {\n                Allocated = 2048,\n            },\n        },\n        StorageProfiles = new[]\n        {\n            new Vcd.Inputs.OrgVdcStorageProfileArgs\n            {\n                Name = \"*\",\n                Limit = 10240,\n                Default = true,\n            },\n        },\n        Elasticity = true,\n        IncludeVmMemoryOverhead = true,\n        MemoryGuaranteed = 1,\n        DefaultComputePolicyId = exampleVgpuPolicy.Id,\n        VmVgpuPolicyIds = new[]\n        {\n            exampleVgpuPolicy.Id,\n        },\n    });\n\n    var testVm = new Vcd.Vm(\"test_vm\", new()\n    {\n        Org = exampleOrg.Apply(getOrgResult =\u003e getOrgResult.Name),\n        Vdc = exampleOrgVdc.Name,\n        Name = \"terraform-provider-vm\",\n        ComputerName = \"emptyVM\",\n        Memory = 2048,\n        Cpus = 2,\n        CpuCores = 1,\n        PowerOn = false,\n        OsType = \"sles11_64Guest\",\n        HardwareVersion = \"vmx-19\",\n        PlacementPolicyId = exampleVgpuPolicy.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleOrg, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"test_org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleVgpuProfile, err := vcd.GetVgpuProfile(ctx, \u0026vcd.GetVgpuProfileArgs{\n\t\t\tName: \"grid_a100-10c\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleProviderVdc, err := vcd.LookupProviderVdc(ctx, \u0026vcd.LookupProviderVdcArgs{\n\t\t\tName: \"example_provider_vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvmGroupExample, err := vcd.GetVmGroup(ctx, \u0026vcd.GetVmGroupArgs{\n\t\t\tName: \"vm-group-1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleVgpuPolicy, err := vcd.NewVmVgpuPolicy(ctx, \"example_vgpu_policy\", \u0026vcd.VmVgpuPolicyArgs{\n\t\t\tName:        pulumi.String(\"example-vgpu-policy\"),\n\t\t\tDescription: pulumi.String(\"An example vGPU policy configuration\"),\n\t\t\tVgpuProfile: \u0026vcd.VmVgpuPolicyVgpuProfileArgs{\n\t\t\t\tId:    pulumi.String(exampleVgpuProfile.Id),\n\t\t\t\tCount: pulumi.Int(1),\n\t\t\t},\n\t\t\tCpu: \u0026vcd.VmVgpuPolicyCpuArgs{\n\t\t\t\tShares:               pulumi.String(\"886\"),\n\t\t\t\tLimitInMhz:           pulumi.String(\"2400\"),\n\t\t\t\tCount:                pulumi.String(\"9\"),\n\t\t\t\tSpeedInMhz:           pulumi.String(\"2500\"),\n\t\t\t\tCoresPerSocket:       pulumi.String(\"3\"),\n\t\t\t\tReservationGuarantee: pulumi.String(\"0.55\"),\n\t\t\t},\n\t\t\tMemory: \u0026vcd.VmVgpuPolicyMemoryArgs{\n\t\t\t\tShares:    pulumi.String(\"1580\"),\n\t\t\t\tSizeInMb:  pulumi.String(\"3200\"),\n\t\t\t\tLimitInMb: pulumi.String(\"2800\"),\n\t\t\t},\n\t\t\tProviderVdcScopes: vcd.VmVgpuPolicyProviderVdcScopeArray{\n\t\t\t\t\u0026vcd.VmVgpuPolicyProviderVdcScopeArgs{\n\t\t\t\t\tProviderVdcId: pulumi.String(exampleProviderVdc.Id),\n\t\t\t\t\tClusterNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"cluster1\"),\n\t\t\t\t\t},\n\t\t\t\t\tVmGroupId: pulumi.String(vmGroupExample.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleOrgVdc, err := vcd.NewOrgVdc(ctx, \"example_org_vdc\", \u0026vcd.OrgVdcArgs{\n\t\t\tOrg:             pulumi.String(exampleOrg.Name),\n\t\t\tName:            pulumi.String(\"test-org-vdc\"),\n\t\t\tProviderVdcName: pulumi.String(exampleProviderVdc.Name),\n\t\t\tAllocationModel: pulumi.String(\"Flex\"),\n\t\t\tDeleteForce:     pulumi.Bool(true),\n\t\t\tComputeCapacity: \u0026vcd.OrgVdcComputeCapacityArgs{\n\t\t\t\tCpu: \u0026vcd.OrgVdcComputeCapacityCpuArgs{\n\t\t\t\t\tAllocated: pulumi.Int(2048),\n\t\t\t\t},\n\t\t\t\tMemory: \u0026vcd.OrgVdcComputeCapacityMemoryArgs{\n\t\t\t\t\tAllocated: pulumi.Int(2048),\n\t\t\t\t},\n\t\t\t},\n\t\t\tStorageProfiles: vcd.OrgVdcStorageProfileArray{\n\t\t\t\t\u0026vcd.OrgVdcStorageProfileArgs{\n\t\t\t\t\tName:    pulumi.String(\"*\"),\n\t\t\t\t\tLimit:   pulumi.Int(10240),\n\t\t\t\t\tDefault: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t\tElasticity:              pulumi.Bool(true),\n\t\t\tIncludeVmMemoryOverhead: pulumi.Bool(true),\n\t\t\tMemoryGuaranteed:        pulumi.Float64(1),\n\t\t\tDefaultComputePolicyId:  exampleVgpuPolicy.ID(),\n\t\t\tVmVgpuPolicyIds: pulumi.StringArray{\n\t\t\t\texampleVgpuPolicy.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewVm(ctx, \"test_vm\", \u0026vcd.VmArgs{\n\t\t\tOrg:               pulumi.String(exampleOrg.Name),\n\t\t\tVdc:               exampleOrgVdc.Name,\n\t\t\tName:              pulumi.String(\"terraform-provider-vm\"),\n\t\t\tComputerName:      pulumi.String(\"emptyVM\"),\n\t\t\tMemory:            pulumi.Int(2048),\n\t\t\tCpus:              pulumi.Int(2),\n\t\t\tCpuCores:          pulumi.Int(1),\n\t\t\tPowerOn:           pulumi.Bool(false),\n\t\t\tOsType:            pulumi.String(\"sles11_64Guest\"),\n\t\t\tHardwareVersion:   pulumi.String(\"vmx-19\"),\n\t\t\tPlacementPolicyId: exampleVgpuPolicy.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetVgpuProfileArgs;\nimport com.pulumi.vcd.inputs.GetProviderVdcArgs;\nimport com.pulumi.vcd.inputs.GetVmGroupArgs;\nimport com.pulumi.vcd.VmVgpuPolicy;\nimport com.pulumi.vcd.VmVgpuPolicyArgs;\nimport com.pulumi.vcd.inputs.VmVgpuPolicyVgpuProfileArgs;\nimport com.pulumi.vcd.inputs.VmVgpuPolicyCpuArgs;\nimport com.pulumi.vcd.inputs.VmVgpuPolicyMemoryArgs;\nimport com.pulumi.vcd.inputs.VmVgpuPolicyProviderVdcScopeArgs;\nimport com.pulumi.vcd.OrgVdc;\nimport com.pulumi.vcd.OrgVdcArgs;\nimport com.pulumi.vcd.inputs.OrgVdcComputeCapacityArgs;\nimport com.pulumi.vcd.inputs.OrgVdcComputeCapacityCpuArgs;\nimport com.pulumi.vcd.inputs.OrgVdcComputeCapacityMemoryArgs;\nimport com.pulumi.vcd.inputs.OrgVdcStorageProfileArgs;\nimport com.pulumi.vcd.Vm;\nimport com.pulumi.vcd.VmArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleOrg = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"test_org\")\n            .build());\n\n        final var exampleVgpuProfile = VcdFunctions.getVgpuProfile(GetVgpuProfileArgs.builder()\n            .name(\"grid_a100-10c\")\n            .build());\n\n        final var exampleProviderVdc = VcdFunctions.getProviderVdc(GetProviderVdcArgs.builder()\n            .name(\"example_provider_vdc\")\n            .build());\n\n        final var vmGroupExample = VcdFunctions.getVmGroup(GetVmGroupArgs.builder()\n            .name(\"vm-group-1\")\n            .build());\n\n        var exampleVgpuPolicy = new VmVgpuPolicy(\"exampleVgpuPolicy\", VmVgpuPolicyArgs.builder()\n            .name(\"example-vgpu-policy\")\n            .description(\"An example vGPU policy configuration\")\n            .vgpuProfile(VmVgpuPolicyVgpuProfileArgs.builder()\n                .id(exampleVgpuProfile.applyValue(getVgpuProfileResult -\u003e getVgpuProfileResult.id()))\n                .count(1)\n                .build())\n            .cpu(VmVgpuPolicyCpuArgs.builder()\n                .shares(\"886\")\n                .limitInMhz(\"2400\")\n                .count(\"9\")\n                .speedInMhz(\"2500\")\n                .coresPerSocket(\"3\")\n                .reservationGuarantee(\"0.55\")\n                .build())\n            .memory(VmVgpuPolicyMemoryArgs.builder()\n                .shares(\"1580\")\n                .sizeInMb(\"3200\")\n                .limitInMb(\"2800\")\n                .build())\n            .providerVdcScopes(VmVgpuPolicyProviderVdcScopeArgs.builder()\n                .providerVdcId(exampleProviderVdc.applyValue(getProviderVdcResult -\u003e getProviderVdcResult.id()))\n                .clusterNames(\"cluster1\")\n                .vmGroupId(vmGroupExample.applyValue(getVmGroupResult -\u003e getVmGroupResult.id()))\n                .build())\n            .build());\n\n        var exampleOrgVdc = new OrgVdc(\"exampleOrgVdc\", OrgVdcArgs.builder()\n            .org(exampleOrg.applyValue(getOrgResult -\u003e getOrgResult.name()))\n            .name(\"test-org-vdc\")\n            .providerVdcName(exampleProviderVdc.applyValue(getProviderVdcResult -\u003e getProviderVdcResult.name()))\n            .allocationModel(\"Flex\")\n            .deleteForce(true)\n            .computeCapacity(OrgVdcComputeCapacityArgs.builder()\n                .cpu(OrgVdcComputeCapacityCpuArgs.builder()\n                    .allocated(2048)\n                    .build())\n                .memory(OrgVdcComputeCapacityMemoryArgs.builder()\n                    .allocated(2048)\n                    .build())\n                .build())\n            .storageProfiles(OrgVdcStorageProfileArgs.builder()\n                .name(\"*\")\n                .limit(10240)\n                .default_(true)\n                .build())\n            .elasticity(true)\n            .includeVmMemoryOverhead(true)\n            .memoryGuaranteed(1)\n            .defaultComputePolicyId(exampleVgpuPolicy.id())\n            .vmVgpuPolicyIds(exampleVgpuPolicy.id())\n            .build());\n\n        var testVm = new Vm(\"testVm\", VmArgs.builder()\n            .org(exampleOrg.applyValue(getOrgResult -\u003e getOrgResult.name()))\n            .vdc(exampleOrgVdc.name())\n            .name(\"terraform-provider-vm\")\n            .computerName(\"emptyVM\")\n            .memory(2048)\n            .cpus(2)\n            .cpuCores(1)\n            .powerOn(false)\n            .osType(\"sles11_64Guest\")\n            .hardwareVersion(\"vmx-19\")\n            .placementPolicyId(exampleVgpuPolicy.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleVgpuPolicy:\n    type: vcd:VmVgpuPolicy\n    name: example_vgpu_policy\n    properties:\n      name: example-vgpu-policy\n      description: An example vGPU policy configuration\n      vgpuProfile:\n        id: ${exampleVgpuProfile.id}\n        count: 1\n      cpu:\n        shares: '886'\n        limitInMhz: '2400'\n        count: '9'\n        speedInMhz: '2500'\n        coresPerSocket: '3'\n        reservationGuarantee: '0.55'\n      memory:\n        shares: '1580'\n        sizeInMb: '3200'\n        limitInMb: '2800'\n      providerVdcScopes:\n        - providerVdcId: ${exampleProviderVdc.id}\n          clusterNames:\n            - cluster1\n          vmGroupId: ${vmGroupExample.id}\n  exampleOrgVdc:\n    type: vcd:OrgVdc\n    name: example_org_vdc\n    properties:\n      org: ${exampleOrg.name}\n      name: test-org-vdc\n      providerVdcName: ${exampleProviderVdc.name}\n      allocationModel: Flex\n      deleteForce: true\n      computeCapacity:\n        cpu:\n          allocated: 2048\n        memory:\n          allocated: 2048\n      storageProfiles:\n        - name: '*'\n          limit: 10240\n          default: true\n      elasticity: true\n      includeVmMemoryOverhead: true\n      memoryGuaranteed: 1\n      defaultComputePolicyId: ${exampleVgpuPolicy.id}\n      vmVgpuPolicyIds:\n        - ${exampleVgpuPolicy.id}\n  testVm:\n    type: vcd:Vm\n    name: test_vm\n    properties:\n      org: ${exampleOrg.name}\n      vdc: ${exampleOrgVdc.name}\n      name: terraform-provider-vm\n      computerName: emptyVM\n      memory: 2048\n      cpus: 2\n      cpuCores: 1\n      powerOn: false\n      osType: sles11_64Guest\n      hardwareVersion: vmx-19\n      placementPolicyId: ${exampleVgpuPolicy.id}\nvariables:\n  exampleOrg:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: test_org\n  exampleVgpuProfile:\n    fn::invoke:\n      function: vcd:getVgpuProfile\n      arguments:\n        name: grid_a100-10c\n  exampleProviderVdc:\n    fn::invoke:\n      function: vcd:getProviderVdc\n      arguments:\n        name: example_provider_vdc\n  vmGroupExample:\n    fn::invoke:\n      function: vcd:getVmGroup\n      arguments:\n        name: vm-group-1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Without A Sizing Policy)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst exampleVgpuPolicyWithoutSizing = new vcd.VmVgpuPolicy(\"example_vgpu_policy_without_sizing\", {\n    name: \"example-vgpu-policy-without-sizing\",\n    description: \"An example vGPU policy configuration\",\n    vgpuProfile: {\n        id: exampleVgpuProfile.id,\n        count: 1,\n    },\n    providerVdcScopes: [{\n        providerVdcId: exampleProviderVdc.id,\n        clusterNames: [\"cluster1\"],\n        vmGroupId: vmGroupExample.id,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexample_vgpu_policy_without_sizing = vcd.VmVgpuPolicy(\"example_vgpu_policy_without_sizing\",\n    name=\"example-vgpu-policy-without-sizing\",\n    description=\"An example vGPU policy configuration\",\n    vgpu_profile={\n        \"id\": example_vgpu_profile[\"id\"],\n        \"count\": 1,\n    },\n    provider_vdc_scopes=[{\n        \"provider_vdc_id\": example_provider_vdc[\"id\"],\n        \"cluster_names\": [\"cluster1\"],\n        \"vm_group_id\": vm_group_example[\"id\"],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleVgpuPolicyWithoutSizing = new Vcd.VmVgpuPolicy(\"example_vgpu_policy_without_sizing\", new()\n    {\n        Name = \"example-vgpu-policy-without-sizing\",\n        Description = \"An example vGPU policy configuration\",\n        VgpuProfile = new Vcd.Inputs.VmVgpuPolicyVgpuProfileArgs\n        {\n            Id = exampleVgpuProfile.Id,\n            Count = 1,\n        },\n        ProviderVdcScopes = new[]\n        {\n            new Vcd.Inputs.VmVgpuPolicyProviderVdcScopeArgs\n            {\n                ProviderVdcId = exampleProviderVdc.Id,\n                ClusterNames = new[]\n                {\n                    \"cluster1\",\n                },\n                VmGroupId = vmGroupExample.Id,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.NewVmVgpuPolicy(ctx, \"example_vgpu_policy_without_sizing\", \u0026vcd.VmVgpuPolicyArgs{\n\t\t\tName:        pulumi.String(\"example-vgpu-policy-without-sizing\"),\n\t\t\tDescription: pulumi.String(\"An example vGPU policy configuration\"),\n\t\t\tVgpuProfile: \u0026vcd.VmVgpuPolicyVgpuProfileArgs{\n\t\t\t\tId:    pulumi.Any(exampleVgpuProfile.Id),\n\t\t\t\tCount: pulumi.Int(1),\n\t\t\t},\n\t\t\tProviderVdcScopes: vcd.VmVgpuPolicyProviderVdcScopeArray{\n\t\t\t\t\u0026vcd.VmVgpuPolicyProviderVdcScopeArgs{\n\t\t\t\t\tProviderVdcId: pulumi.Any(exampleProviderVdc.Id),\n\t\t\t\t\tClusterNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"cluster1\"),\n\t\t\t\t\t},\n\t\t\t\t\tVmGroupId: pulumi.Any(vmGroupExample.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VmVgpuPolicy;\nimport com.pulumi.vcd.VmVgpuPolicyArgs;\nimport com.pulumi.vcd.inputs.VmVgpuPolicyVgpuProfileArgs;\nimport com.pulumi.vcd.inputs.VmVgpuPolicyProviderVdcScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleVgpuPolicyWithoutSizing = new VmVgpuPolicy(\"exampleVgpuPolicyWithoutSizing\", VmVgpuPolicyArgs.builder()\n            .name(\"example-vgpu-policy-without-sizing\")\n            .description(\"An example vGPU policy configuration\")\n            .vgpuProfile(VmVgpuPolicyVgpuProfileArgs.builder()\n                .id(exampleVgpuProfile.id())\n                .count(1)\n                .build())\n            .providerVdcScopes(VmVgpuPolicyProviderVdcScopeArgs.builder()\n                .providerVdcId(exampleProviderVdc.id())\n                .clusterNames(\"cluster1\")\n                .vmGroupId(vmGroupExample.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleVgpuPolicyWithoutSizing:\n    type: vcd:VmVgpuPolicy\n    name: example_vgpu_policy_without_sizing\n    properties:\n      name: example-vgpu-policy-without-sizing\n      description: An example vGPU policy configuration\n      vgpuProfile:\n        id: ${exampleVgpuProfile.id}\n        count: 1\n      providerVdcScopes:\n        - providerVdcId: ${exampleProviderVdc.id}\n          clusterNames:\n            - cluster1\n          vmGroupId: ${vmGroupExample.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cpu": {
                    "$ref": "#/types/vcd:index/VmVgpuPolicyCpu:VmVgpuPolicyCpu",
                    "description": "Configuration options for CPU resources. If this is set, \na VM created with this policy can't specify a custom sizing policy. See [cpu] for more details.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A brief description of the vGPU policy.\n"
                },
                "memory": {
                    "$ref": "#/types/vcd:index/VmVgpuPolicyMemory:VmVgpuPolicyMemory",
                    "description": "Memory resource configuration settings. If this is set, \na VM created with this policy can't specify a custom sizing policy. See [memory] for more details.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name assigned to the vGPU policy for a virtual machine.\n"
                },
                "providerVdcScopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmVgpuPolicyProviderVdcScope:VmVgpuPolicyProviderVdcScope"
                    },
                    "description": "Defines the scope of the policy within \nprovider virtual data centers. If not provided, applies to all the current ant future PVDCs.\nSee `provider_vdc_scope` for more details.\n"
                },
                "vgpuProfile": {
                    "$ref": "#/types/vcd:index/VmVgpuPolicyVgpuProfile:VmVgpuPolicyVgpuProfile",
                    "description": "Defines the vGPU profile ID and count.\n"
                }
            },
            "required": [
                "name",
                "vgpuProfile"
            ],
            "inputProperties": {
                "cpu": {
                    "$ref": "#/types/vcd:index/VmVgpuPolicyCpu:VmVgpuPolicyCpu",
                    "description": "Configuration options for CPU resources. If this is set, \na VM created with this policy can't specify a custom sizing policy. See [cpu] for more details.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A brief description of the vGPU policy.\n"
                },
                "memory": {
                    "$ref": "#/types/vcd:index/VmVgpuPolicyMemory:VmVgpuPolicyMemory",
                    "description": "Memory resource configuration settings. If this is set, \na VM created with this policy can't specify a custom sizing policy. See [memory] for more details.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The unique name assigned to the vGPU policy for a virtual machine.\n"
                },
                "providerVdcScopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vcd:index/VmVgpuPolicyProviderVdcScope:VmVgpuPolicyProviderVdcScope"
                    },
                    "description": "Defines the scope of the policy within \nprovider virtual data centers. If not provided, applies to all the current ant future PVDCs.\nSee `provider_vdc_scope` for more details.\n"
                },
                "vgpuProfile": {
                    "$ref": "#/types/vcd:index/VmVgpuPolicyVgpuProfile:VmVgpuPolicyVgpuProfile",
                    "description": "Defines the vGPU profile ID and count.\n"
                }
            },
            "requiredInputs": [
                "vgpuProfile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmVgpuPolicy resources.\n",
                "properties": {
                    "cpu": {
                        "$ref": "#/types/vcd:index/VmVgpuPolicyCpu:VmVgpuPolicyCpu",
                        "description": "Configuration options for CPU resources. If this is set, \na VM created with this policy can't specify a custom sizing policy. See [cpu] for more details.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A brief description of the vGPU policy.\n"
                    },
                    "memory": {
                        "$ref": "#/types/vcd:index/VmVgpuPolicyMemory:VmVgpuPolicyMemory",
                        "description": "Memory resource configuration settings. If this is set, \na VM created with this policy can't specify a custom sizing policy. See [memory] for more details.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The unique name assigned to the vGPU policy for a virtual machine.\n"
                    },
                    "providerVdcScopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vcd:index/VmVgpuPolicyProviderVdcScope:VmVgpuPolicyProviderVdcScope"
                        },
                        "description": "Defines the scope of the policy within \nprovider virtual data centers. If not provided, applies to all the current ant future PVDCs.\nSee `provider_vdc_scope` for more details.\n"
                    },
                    "vgpuProfile": {
                        "$ref": "#/types/vcd:index/VmVgpuPolicyVgpuProfile:VmVgpuPolicyVgpuProfile",
                        "description": "Defines the vGPU profile ID and count.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vcd:index/getApiFilter:getApiFilter": {
            "description": "Supported in provider *v3.14+* and VCD 10.4.3+.\n\nProvides a data source to read API Filters in VMware Cloud Director. An API Filter allows to extend VCD API with customised URLs\nthat can be redirected to an [`vcd.ExternalEndpoint`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/external_endpoint).\n\n\u003e Only `System Administrator` can use this data source.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst apiFilter1 = vcd.getApiFilter({\n    apiFilterId: \"urn:vcloud:apiFilter:4252ab09-eed8-4bc6-86d7-6019090273f5\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\napi_filter1 = vcd.get_api_filter(api_filter_id=\"urn:vcloud:apiFilter:4252ab09-eed8-4bc6-86d7-6019090273f5\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var apiFilter1 = Vcd.GetApiFilter.Invoke(new()\n    {\n        ApiFilterId = \"urn:vcloud:apiFilter:4252ab09-eed8-4bc6-86d7-6019090273f5\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupApiFilter(ctx, \u0026vcd.LookupApiFilterArgs{\n\t\t\tApiFilterId: \"urn:vcloud:apiFilter:4252ab09-eed8-4bc6-86d7-6019090273f5\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetApiFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var apiFilter1 = VcdFunctions.getApiFilter(GetApiFilterArgs.builder()\n            .apiFilterId(\"urn:vcloud:apiFilter:4252ab09-eed8-4bc6-86d7-6019090273f5\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  apiFilter1:\n    fn::invoke:\n      function: vcd:getApiFilter\n      arguments:\n        apiFilterId: urn:vcloud:apiFilter:4252ab09-eed8-4bc6-86d7-6019090273f5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getApiFilter.\n",
                "properties": {
                    "apiFilterId": {
                        "type": "string",
                        "description": "ID of the API Filter. This is the only way of unequivocally identify an API Filter. A list of\navailable API Filters can be obtained by using the `list@` option of the import mechanism of the [resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_filter#importing)\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiFilterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getApiFilter.\n",
                "properties": {
                    "apiFilterId": {
                        "type": "string"
                    },
                    "externalEndpointId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "urlMatcherPattern": {
                        "type": "string"
                    },
                    "urlMatcherScope": {
                        "type": "string"
                    }
                },
                "required": [
                    "apiFilterId",
                    "externalEndpointId",
                    "urlMatcherPattern",
                    "urlMatcherScope",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getCatalog:getCatalog": {
            "description": "Provides a VMware Cloud Director Catalog data source. A Catalog can be used to manage catalog items and media items.\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_cat = vcd.getCatalog({\n    org: \"my-org\",\n    name: \"my-cat\",\n});\nconst myItem = new vcd.CatalogItem(\"myItem\", {\n    org: my_cat.then(my_cat =\u003e my_cat.org),\n    catalog: my_cat.then(my_cat =\u003e my_cat.name),\n    name: \"myItem\",\n    description: my_cat.then(my_cat =\u003e `Belongs to ${my_cat.id}`),\n    ovaPath: \"/path/to/test_vapp_template.ova\",\n    uploadPieceSize: 5,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_cat = vcd.get_catalog(org=\"my-org\",\n    name=\"my-cat\")\nmy_item = vcd.CatalogItem(\"myItem\",\n    org=my_cat.org,\n    catalog=my_cat.name,\n    name=\"myItem\",\n    description=f\"Belongs to {my_cat.id}\",\n    ova_path=\"/path/to/test_vapp_template.ova\",\n    upload_piece_size=5)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_cat = Vcd.GetCatalog.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-cat\",\n    });\n\n    var myItem = new Vcd.CatalogItem(\"myItem\", new()\n    {\n        Org = my_cat.Apply(my_cat =\u003e my_cat.Apply(getCatalogResult =\u003e getCatalogResult.Org)),\n        Catalog = my_cat.Apply(my_cat =\u003e my_cat.Apply(getCatalogResult =\u003e getCatalogResult.Name)),\n        Name = \"myItem\",\n        Description = my_cat.Apply(my_cat =\u003e $\"Belongs to {my_cat.Apply(getCatalogResult =\u003e getCatalogResult.Id)}\"),\n        OvaPath = \"/path/to/test_vapp_template.ova\",\n        UploadPieceSize = 5,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_cat, err := vcd.LookupCatalog(ctx, \u0026vcd.LookupCatalogArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-cat\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewCatalogItem(ctx, \"myItem\", \u0026vcd.CatalogItemArgs{\n\t\t\tOrg:             pulumi.String(my_cat.Org),\n\t\t\tCatalog:         pulumi.String(my_cat.Name),\n\t\t\tName:            pulumi.String(\"myItem\"),\n\t\t\tDescription:     pulumi.Sprintf(\"Belongs to %v\", my_cat.Id),\n\t\t\tOvaPath:         pulumi.String(\"/path/to/test_vapp_template.ova\"),\n\t\t\tUploadPieceSize: pulumi.Int(5),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetCatalogArgs;\nimport com.pulumi.vcd.CatalogItem;\nimport com.pulumi.vcd.CatalogItemArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-cat = VcdFunctions.getCatalog(GetCatalogArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-cat\")\n            .build());\n\n        var myItem = new CatalogItem(\"myItem\", CatalogItemArgs.builder()\n            .org(my_cat.org())\n            .catalog(my_cat.name())\n            .name(\"myItem\")\n            .description(String.format(\"Belongs to %s\", my_cat.id()))\n            .ovaPath(\"/path/to/test_vapp_template.ova\")\n            .uploadPieceSize(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myItem:\n    type: vcd:CatalogItem\n    properties:\n      org: ${[\"my-cat\"].org}\n      catalog: ${[\"my-cat\"].name}\n      name: myItem\n      description: Belongs to ${[\"my-cat\"].id}\n      ovaPath: /path/to/test_vapp_template.ova\n      uploadPieceSize: 5\nvariables:\n  my-cat:\n    fn::invoke:\n      function: vcd:getCatalog\n      arguments:\n        org: my-org\n        name: my-cat\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Metadata\n\nThe `metadata_entry` (*v3.8+*) is a set of metadata entries that have the following structure:\n\n* `key` - Key of this metadata entry.\n* `value` - Value of this metadata entry.\n* `type` - Type of this metadata entry. One of: `MetadataStringValue`, `MetadataNumberValue`, `MetadataDateTimeValue`, `MetadataBooleanValue`.\n* `user_access` - User access level for this metadata entry. One of: `PRIVATE` (hidden), `READONLY` (read only), `READWRITE` (read/write).\n* `is_system` - Domain for this metadata entry. true if it belongs to `SYSTEM`, false if it belongs to `GENERAL`.\n\n## Filter arguments\n\n(Supported in provider *v2.9+*)\n\n* `name_regex` (Optional) matches the name using a regular expression.\n* `date` (Optional) is an expression starting with an operator (`\u003e`, `\u003c`, `\u003e=`, `\u003c=`, `==`), followed by a date, with\n  optional spaces in between. For example: `\u003e 2020-02-01 12:35:00.523Z`\n  The filter recognizes several formats, but one of `yyyy-mm-dd [hh:mm[:ss[.nnnZ]]]` or `dd-MMM-yyyy [hh:mm[:ss[.nnnZ]]]`\n  is recommended.\n  Comparison with equality operator (`==`) need to define the date to the microseconds.\n* `latest` (Optional) If `true`, retrieve the latest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the newest item.\n* `earliest` (Optional) If `true`, retrieve the earliest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the oldest item.\n* `metadata` (Optional) One or more parameters that will match metadata contents.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalog.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Catalog description.\n"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogFilter:getCatalogFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Catalog name (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org name\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCatalog.\n",
                "properties": {
                    "cacheEnabled": {
                        "description": "(*v3.6+*) Enable early catalog export to optimize synchronization. Default is `false`.\n",
                        "type": "boolean"
                    },
                    "catalogVersion": {
                        "description": "(*v3.6+*) Version number from this catalog.\n",
                        "type": "integer"
                    },
                    "created": {
                        "description": "(*v3.6+*) Date and time of catalog creation\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "Catalog description.\n",
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogFilter:getCatalogFilter"
                    },
                    "href": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isLocal": {
                        "description": "(*v3.8.1+*) Indicates if this catalog was created in the current organization.\n",
                        "type": "boolean"
                    },
                    "isPublished": {
                        "description": "(*v3.6+*) Indicates if this catalog is shared to all organizations.\n",
                        "type": "boolean"
                    },
                    "isShared": {
                        "description": "(*v3.6+*) Indicates if the catalog is shared.\n",
                        "type": "boolean"
                    },
                    "mediaItemLists": {
                        "description": "(*v3.8+*) List of media item names in this catalog, in alphabetical order.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "description": "(Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata.\n",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries assigned to this Catalog. See Metadata section for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getCatalogMetadataEntry:getCatalogMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "numberOfMedia": {
                        "description": "(*v3.6+*) Number of media items available in this catalog.\n",
                        "type": "integer"
                    },
                    "numberOfVappTemplates": {
                        "description": "(*v3.6+*) Number of vApp templates available in this catalog.\n",
                        "type": "integer"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerName": {
                        "description": "(*v3.6+*) Owner of the catalog.\n",
                        "type": "string"
                    },
                    "preserveIdentityInformation": {
                        "description": "(*v3.6+*) Enable include BIOS UUIDs and MAC addresses in the downloaded OVF package. Preserving the identity information limits the portability of the package and you should use it only when necessary. Default is `false`.\n",
                        "type": "boolean"
                    },
                    "publishEnabled": {
                        "description": "(*v3.6+*) Enable allows to publish a catalog externally to make its vApp templates and media files available for subscription by organizations outside the Cloud Director installation. Default is `false`.\n",
                        "type": "boolean"
                    },
                    "publishSubscriptionType": {
                        "description": "(*v3.6+*) Shows if the catalog is `PUBLISHED`, if it is a subscription from another one (`SUBSCRIBED`), or none of those (`UNPUBLISHED`).\n",
                        "type": "string"
                    },
                    "publishSubscriptionUrl": {
                        "description": "(*v3.8+*) URL to which other catalogs can subscribe.\n",
                        "type": "string"
                    },
                    "storageProfileId": {
                        "type": "string"
                    },
                    "vappTemplateLists": {
                        "description": "(*v3.8+*) List of vApp template names in this catalog, in alphabetical order.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "cacheEnabled",
                    "catalogVersion",
                    "created",
                    "description",
                    "href",
                    "isLocal",
                    "isPublished",
                    "isShared",
                    "mediaItemLists",
                    "metadata",
                    "metadataEntries",
                    "numberOfMedia",
                    "numberOfVappTemplates",
                    "ownerName",
                    "preserveIdentityInformation",
                    "publishEnabled",
                    "publishSubscriptionType",
                    "publishSubscriptionUrl",
                    "storageProfileId",
                    "vappTemplateLists",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getCatalogAccessControl:getCatalogAccessControl": {
            "description": "Provides a data source to read Access Control details from a Catalog in VMware Cloud Director.\n\n\u003e **Note:** Access control reads run in tenant context, meaning that, even if the user is a system administrator,\nin every request it uses headers items that define the tenant context as restricted to the organization to which the Catalog belongs.\n\nSupported in provider *v3.14+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst catalog = vcd.getCatalog({\n    name: \"my-catalog\",\n});\nconst ac = catalog.then(catalog =\u003e vcd.getCatalogAccessControl({\n    catalogId: catalog.id,\n}));\nexport const sharedWith = ac.then(ac =\u003e ac.sharedWiths);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ncatalog = vcd.get_catalog(name=\"my-catalog\")\nac = vcd.get_catalog_access_control(catalog_id=catalog.id)\npulumi.export(\"sharedWith\", ac.shared_withs)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var catalog = Vcd.GetCatalog.Invoke(new()\n    {\n        Name = \"my-catalog\",\n    });\n\n    var ac = Vcd.GetCatalogAccessControl.Invoke(new()\n    {\n        CatalogId = catalog.Apply(getCatalogResult =\u003e getCatalogResult.Id),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"sharedWith\"] = ac.Apply(getCatalogAccessControlResult =\u003e getCatalogAccessControlResult.SharedWiths),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcatalog, err := vcd.LookupCatalog(ctx, \u0026vcd.LookupCatalogArgs{\n\t\t\tName: pulumi.StringRef(\"my-catalog\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tac, err := vcd.LookupCatalogAccessControl(ctx, \u0026vcd.LookupCatalogAccessControlArgs{\n\t\t\tCatalogId: catalog.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"sharedWith\", ac.SharedWiths)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetCatalogArgs;\nimport com.pulumi.vcd.inputs.GetCatalogAccessControlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var catalog = VcdFunctions.getCatalog(GetCatalogArgs.builder()\n            .name(\"my-catalog\")\n            .build());\n\n        final var ac = VcdFunctions.getCatalogAccessControl(GetCatalogAccessControlArgs.builder()\n            .catalogId(catalog.applyValue(getCatalogResult -\u003e getCatalogResult.id()))\n            .build());\n\n        ctx.export(\"sharedWith\", ac.applyValue(getCatalogAccessControlResult -\u003e getCatalogAccessControlResult.sharedWiths()));\n    }\n}\n```\n```yaml\nvariables:\n  catalog:\n    fn::invoke:\n      function: vcd:getCatalog\n      arguments:\n        name: my-catalog\n  ac:\n    fn::invoke:\n      function: vcd:getCatalogAccessControl\n      arguments:\n        catalogId: ${catalog.id}\noutputs:\n  sharedWith: ${ac.sharedWiths}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalogAccessControl.\n",
                "properties": {
                    "catalogId": {
                        "type": "string",
                        "description": "A unique identifier for the Catalog.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the Catalog belongs. Optional if defined at provider level.\n"
                    }
                },
                "type": "object",
                "required": [
                    "catalogId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCatalogAccessControl.\n",
                "properties": {
                    "catalogId": {
                        "type": "string"
                    },
                    "everyoneAccessLevel": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "readOnlySharedWithAllOrgs": {
                        "type": "boolean"
                    },
                    "sharedWithEveryone": {
                        "type": "boolean"
                    },
                    "sharedWiths": {
                        "items": {
                            "$ref": "#/types/vcd:index/getCatalogAccessControlSharedWith:getCatalogAccessControlSharedWith"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "catalogId",
                    "everyoneAccessLevel",
                    "readOnlySharedWithAllOrgs",
                    "sharedWiths",
                    "sharedWithEveryone",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getCatalogItem:getCatalogItem": {
            "description": "\u003e If you only need vApp Template features, you may use [`vcd.CatalogVappTemplate`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) instead.\n\nProvides a VMware Cloud Director Catalog item data source. A Catalog item can be used to reference a catalog item and use its \ndata within other resources or data sources.\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_first_item = vcd.getCatalogItem({\n    org: \"my-org\",\n    catalog: \"my-cat\",\n    name: \"my-first-item\",\n});\nconst my_second_item = new vcd.CatalogItem(\"my-second-item\", {\n    org: my_first_item.then(my_first_item =\u003e my_first_item.org),\n    catalog: my_first_item.then(my_first_item =\u003e my_first_item.catalog),\n    name: \"my-second-item\",\n    description: my_first_item.then(my_first_item =\u003e `Belongs to ${my_first_item.catalog}`),\n    ovaPath: \"/path/to/test_vapp_template.ova\",\n    uploadPieceSize: 5,\n    metadata: my_first_item.then(my_first_item =\u003e my_first_item.metadata),\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_first_item = vcd.get_catalog_item(org=\"my-org\",\n    catalog=\"my-cat\",\n    name=\"my-first-item\")\nmy_second_item = vcd.CatalogItem(\"my-second-item\",\n    org=my_first_item.org,\n    catalog=my_first_item.catalog,\n    name=\"my-second-item\",\n    description=f\"Belongs to {my_first_item.catalog}\",\n    ova_path=\"/path/to/test_vapp_template.ova\",\n    upload_piece_size=5,\n    metadata=my_first_item.metadata)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_first_item = Vcd.GetCatalogItem.Invoke(new()\n    {\n        Org = \"my-org\",\n        Catalog = \"my-cat\",\n        Name = \"my-first-item\",\n    });\n\n    var my_second_item = new Vcd.CatalogItem(\"my-second-item\", new()\n    {\n        Org = my_first_item.Apply(my_first_item =\u003e my_first_item.Apply(getCatalogItemResult =\u003e getCatalogItemResult.Org)),\n        Catalog = my_first_item.Apply(my_first_item =\u003e my_first_item.Apply(getCatalogItemResult =\u003e getCatalogItemResult.Catalog)),\n        Name = \"my-second-item\",\n        Description = my_first_item.Apply(my_first_item =\u003e $\"Belongs to {my_first_item.Apply(getCatalogItemResult =\u003e getCatalogItemResult.Catalog)}\"),\n        OvaPath = \"/path/to/test_vapp_template.ova\",\n        UploadPieceSize = 5,\n        Metadata = my_first_item.Apply(my_first_item =\u003e my_first_item.Apply(getCatalogItemResult =\u003e getCatalogItemResult.Metadata)),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_first_item, err := vcd.LookupCatalogItem(ctx, \u0026vcd.LookupCatalogItemArgs{\n\t\t\tOrg:     pulumi.StringRef(\"my-org\"),\n\t\t\tCatalog: \"my-cat\",\n\t\t\tName:    pulumi.StringRef(\"my-first-item\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewCatalogItem(ctx, \"my-second-item\", \u0026vcd.CatalogItemArgs{\n\t\t\tOrg:             pulumi.String(my_first_item.Org),\n\t\t\tCatalog:         pulumi.String(my_first_item.Catalog),\n\t\t\tName:            pulumi.String(\"my-second-item\"),\n\t\t\tDescription:     pulumi.Sprintf(\"Belongs to %v\", my_first_item.Catalog),\n\t\t\tOvaPath:         pulumi.String(\"/path/to/test_vapp_template.ova\"),\n\t\t\tUploadPieceSize: pulumi.Int(5),\n\t\t\tMetadata:        pulumi.StringMap(my_first_item.Metadata),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetCatalogItemArgs;\nimport com.pulumi.vcd.CatalogItem;\nimport com.pulumi.vcd.CatalogItemArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-first-item = VcdFunctions.getCatalogItem(GetCatalogItemArgs.builder()\n            .org(\"my-org\")\n            .catalog(\"my-cat\")\n            .name(\"my-first-item\")\n            .build());\n\n        var my_second_item = new CatalogItem(\"my-second-item\", CatalogItemArgs.builder()\n            .org(my_first_item.org())\n            .catalog(my_first_item.catalog())\n            .name(\"my-second-item\")\n            .description(String.format(\"Belongs to %s\", my_first_item.catalog()))\n            .ovaPath(\"/path/to/test_vapp_template.ova\")\n            .uploadPieceSize(5)\n            .metadata(my_first_item.metadata())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  my-second-item:\n    type: vcd:CatalogItem\n    properties:\n      org: ${[\"my-first-item\"].org}\n      catalog: ${[\"my-first-item\"].catalog}\n      name: my-second-item\n      description: Belongs to ${[\"my-first-item\"].catalog}\n      ovaPath: /path/to/test_vapp_template.ova\n      uploadPieceSize: 5\n      metadata: ${[\"my-first-item\"].metadata}\nvariables:\n  my-first-item:\n    fn::invoke:\n      function: vcd:getCatalogItem\n      arguments:\n        org: my-org\n        catalog: my-cat\n        name: my-first-item\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Metadata\n\nThe `metadata_entry` (*v3.8+*) is a set of metadata entries that have the following structure:\n\n* `key` - Key of this metadata entry.\n* `value` - Value of this metadata entry.\n* `type` - Type of this metadata entry. One of: `MetadataStringValue`, `MetadataNumberValue`, `MetadataDateTimeValue`, `MetadataBooleanValue`.\n* `user_access` - User access level for this metadata entry. One of: `PRIVATE` (hidden), `READONLY` (read only), `READWRITE` (read/write).\n* `is_system` - Domain for this metadata entry. true if it belongs to `SYSTEM`, false if it belongs to `GENERAL`.\n\n## Filter arguments\n\n(Supported in provider *v2.9+*)\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n* `date` - (Optional) is an expression starting with an operator (`\u003e`, `\u003c`, `\u003e=`, `\u003c=`, `==`), followed by a date, with\n  optional spaces in between. For example: `\u003e 2020-02-01 12:35:00.523Z`\n  The filter recognizes several formats, but one of `yyyy-mm-dd [hh:mm[:ss[.nnnZ]]]` or `dd-MMM-yyyy [hh:mm[:ss[.nnnZ]]]`\n  is recommended.\n  Comparison with equality operator (`==`) need to define the date to the microseconds.\n* `latest` - (Optional) If `true`, retrieve the latest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the newest item.\n* `earliest` - (Optional) If `true`, retrieve the earliest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the oldest item.\n* `metadata` - (Optional) One or more parameters that will match metadata contents.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalogItem.\n",
                "properties": {
                    "catalog": {
                        "type": "string",
                        "description": "Catalog name\n"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogItemFilter:getCatalogItemFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Catalog Item name (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org name\n"
                    }
                },
                "type": "object",
                "required": [
                    "catalog"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCatalogItem.\n",
                "properties": {
                    "catalog": {
                        "type": "string"
                    },
                    "catalogItemMetadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "(Deprecated) Use `metadata_entry` instead. Key value map of metadata assigned to the catalog item.\n",
                        "type": "object"
                    },
                    "created": {
                        "type": "string"
                    },
                    "description": {
                        "description": "Catalog item description.\n",
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogItemFilter:getCatalogItemFilter"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "description": "Key value map of metadata assigned to the associated vApp template.\n",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries assigned to the catalog item. See Metadata section for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getCatalogItemMetadataEntry:getCatalogItemMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "required": [
                    "catalog",
                    "catalogItemMetadata",
                    "created",
                    "description",
                    "metadata",
                    "metadataEntries",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getCatalogMedia:getCatalogMedia": {
            "description": "Provides a VMware Cloud Director Catalog media data source. A Catalog media can be used to reference a catalog media and use its \ndata within other resources or data sources.\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_catalog = vcd.getCatalog({\n    org: \"my-org\",\n    name: \"my-catalog\",\n});\nconst existing_media = my_catalog.then(my_catalog =\u003e vcd.getCatalogMedia({\n    org: \"my-org\",\n    catalogId: my_catalog.id,\n    name: \"my-media\",\n}));\nexport const mediaSize = existing_media.then(existing_media =\u003e existing_media.size);\nexport const typeIsIso = existing_media.then(existing_media =\u003e existing_media.isIso);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_catalog = vcd.get_catalog(org=\"my-org\",\n    name=\"my-catalog\")\nexisting_media = vcd.get_catalog_media(org=\"my-org\",\n    catalog_id=my_catalog.id,\n    name=\"my-media\")\npulumi.export(\"mediaSize\", existing_media.size)\npulumi.export(\"typeIsIso\", existing_media.is_iso)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_catalog = Vcd.GetCatalog.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-catalog\",\n    });\n\n    var existing_media = Vcd.GetCatalogMedia.Invoke(new()\n    {\n        Org = \"my-org\",\n        CatalogId = my_catalog.Apply(getCatalogResult =\u003e getCatalogResult.Id),\n        Name = \"my-media\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"mediaSize\"] = existing_media.Apply(existing_media =\u003e existing_media.Apply(getCatalogMediaResult =\u003e getCatalogMediaResult.Size)),\n        [\"typeIsIso\"] = existing_media.Apply(existing_media =\u003e existing_media.Apply(getCatalogMediaResult =\u003e getCatalogMediaResult.IsIso)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_catalog, err := vcd.LookupCatalog(ctx, \u0026vcd.LookupCatalogArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-catalog\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texisting_media, err := vcd.LookupCatalogMedia(ctx, \u0026vcd.LookupCatalogMediaArgs{\n\t\t\tOrg:       pulumi.StringRef(\"my-org\"),\n\t\t\tCatalogId: pulumi.StringRef(my_catalog.Id),\n\t\t\tName:      pulumi.StringRef(\"my-media\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"mediaSize\", existing_media.Size)\n\t\tctx.Export(\"typeIsIso\", existing_media.IsIso)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetCatalogArgs;\nimport com.pulumi.vcd.inputs.GetCatalogMediaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-catalog = VcdFunctions.getCatalog(GetCatalogArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-catalog\")\n            .build());\n\n        final var existing-media = VcdFunctions.getCatalogMedia(GetCatalogMediaArgs.builder()\n            .org(\"my-org\")\n            .catalogId(my_catalog.id())\n            .name(\"my-media\")\n            .build());\n\n        ctx.export(\"mediaSize\", existing_media.size());\n        ctx.export(\"typeIsIso\", existing_media.isIso());\n    }\n}\n```\n```yaml\nvariables:\n  my-catalog:\n    fn::invoke:\n      function: vcd:getCatalog\n      arguments:\n        org: my-org\n        name: my-catalog\n  existing-media:\n    fn::invoke:\n      function: vcd:getCatalogMedia\n      arguments:\n        org: my-org\n        catalogId: ${[\"my-catalog\"].id}\n        name: my-media\noutputs:\n  mediaSize: ${[\"existing-media\"].size}\n  typeIsIso: ${[\"existing-media\"].isIso}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n(Supported in provider *v2.9+*)\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n* `date` - (Optional) is an expression starting with an operator (`\u003e`, `\u003c`, `\u003e=`, `\u003c=`, `==`), followed by a date, with\n  optional spaces in between. For example: `\u003e 2020-02-01 12:35:00.523Z`\n  The filter recognizes several formats, but one of `yyyy-mm-dd [hh:mm[:ss[.nnnZ]]]` or `dd-MMM-yyyy [hh:mm[:ss[.nnnZ]]]`\n  is recommended.\n  Comparison with equality operator (`==`) need to define the date to the microseconds.\n* `latest` - (Optional) If `true`, retrieve the latest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the newest item.\n* `earliest` - (Optional) If `true`, retrieve the earliest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the oldest item.\n* `metadata` - (Optional) One or more parameters that will match metadata contents.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalogMedia.\n",
                "properties": {
                    "catalog": {
                        "type": "string",
                        "description": "The name of the catalog to which media file belongs. It's mandatory if `catalog_id` is not used.\n",
                        "deprecationMessage": "use catalog_id instead, especially if using a shared catalog"
                    },
                    "catalogId": {
                        "type": "string",
                        "description": "The ID of the catalog to which the media file belongs. It's mandatory if `catalog` field is not used.\n"
                    },
                    "downloadToFile": {
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogMediaFilter:getCatalogMediaFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Media name in catalog (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCatalogMedia.\n",
                "properties": {
                    "catalog": {
                        "deprecationMessage": "use catalog_id instead, especially if using a shared catalog",
                        "type": "string"
                    },
                    "catalogId": {
                        "type": "string"
                    },
                    "catalogItemId": {
                        "type": "string"
                    },
                    "creationDate": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "downloadToFile": {
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogMediaFilter:getCatalogMediaFilter"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isIso": {
                        "type": "boolean"
                    },
                    "isPublished": {
                        "type": "boolean"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getCatalogMediaMetadataEntry:getCatalogMediaMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerName": {
                        "type": "string"
                    },
                    "size": {
                        "type": "integer"
                    },
                    "status": {
                        "type": "string"
                    },
                    "storageProfileName": {
                        "type": "string"
                    }
                },
                "required": [
                    "catalog",
                    "catalogItemId",
                    "creationDate",
                    "description",
                    "isIso",
                    "isPublished",
                    "metadata",
                    "metadataEntries",
                    "ownerName",
                    "size",
                    "status",
                    "storageProfileName",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getCatalogVappTemplate:getCatalogVappTemplate": {
            "description": "Provides a VMware Cloud Director vApp Template data source. A vApp Template can be used to reference an already existing\nvApp Template in VCD and use its data within other resources or data sources.\n\nSupported in provider *v3.8+*\n\n## Example: Fetching a vApp Template from a Catalog\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_catalog = vcd.getCatalog({\n    org: \"my-org\",\n    name: \"my-catalog\",\n});\nconst my_first_vapp_template = my_catalog.then(my_catalog =\u003e vcd.getCatalogVappTemplate({\n    org: \"my-org\",\n    catalogId: my_catalog.id,\n    name: \"my-first-vapp-template\",\n}));\nconst my_second_vappTemplate = new vcd.CatalogVappTemplate(\"my-second-vapp_template\", {\n    metadataEntries: Object.entries(photon.metadataEntry).map(([k, v]) =\u003e ({key: k, value: v})).map(entry =\u003e ({\n        key: entry.value.key,\n        value: entry.value.value,\n        type: entry.value.type,\n        isSystem: entry.value.is_system,\n        userAccess: entry.value.user_access,\n    })),\n    org: my_first_vapp_template.then(my_first_vapp_template =\u003e my_first_vapp_template.org),\n    catalogId: my_first_vapp_template.then(my_first_vapp_template =\u003e my_first_vapp_template.catalogId),\n    name: \"my-second-item\",\n    description: my_catalog.then(my_catalog =\u003e `Belongs to ${my_catalog.name}`),\n    ovaPath: \"/path/to/test_vapp_template.ova\",\n    uploadPieceSize: 5,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_catalog = vcd.get_catalog(org=\"my-org\",\n    name=\"my-catalog\")\nmy_first_vapp_template = vcd.get_catalog_vapp_template(org=\"my-org\",\n    catalog_id=my_catalog.id,\n    name=\"my-first-vapp-template\")\nmy_second_vapp_template = vcd.CatalogVappTemplate(\"my-second-vapp_template\",\n    metadata_entries=[{\n        \"key\": entry[\"value\"][\"key\"],\n        \"value\": entry[\"value\"][\"value\"],\n        \"type\": entry[\"value\"][\"type\"],\n        \"is_system\": entry[\"value\"][\"is_system\"],\n        \"user_access\": entry[\"value\"][\"user_access\"],\n    } for entry in [{\"key\": k, \"value\": v} for k, v in photon[\"metadataEntry\"]]],\n    org=my_first_vapp_template.org,\n    catalog_id=my_first_vapp_template.catalog_id,\n    name=\"my-second-item\",\n    description=f\"Belongs to {my_catalog.name}\",\n    ova_path=\"/path/to/test_vapp_template.ova\",\n    upload_piece_size=5)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_catalog = Vcd.GetCatalog.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-catalog\",\n    });\n\n    var my_first_vapp_template = Vcd.GetCatalogVappTemplate.Invoke(new()\n    {\n        Org = \"my-org\",\n        CatalogId = my_catalog.Apply(getCatalogResult =\u003e getCatalogResult.Id),\n        Name = \"my-first-vapp-template\",\n    });\n\n    var my_second_vappTemplate = new Vcd.CatalogVappTemplate(\"my-second-vapp_template\", new()\n    {\n        MetadataEntries = .Select(entry =\u003e \n        {\n            return new Vcd.Inputs.CatalogVappTemplateMetadataEntryArgs\n            {\n                Key = entry.Value.Key,\n                Value = entry.Value.Value,\n                Type = entry.Value.Type,\n                IsSystem = entry.Value.Is_system,\n                UserAccess = entry.Value.User_access,\n            };\n        }).ToList(),\n        Org = my_first_vapp_template.Apply(my_first_vapp_template =\u003e my_first_vapp_template.Apply(getCatalogVappTemplateResult =\u003e getCatalogVappTemplateResult.Org)),\n        CatalogId = my_first_vapp_template.Apply(my_first_vapp_template =\u003e my_first_vapp_template.Apply(getCatalogVappTemplateResult =\u003e getCatalogVappTemplateResult.CatalogId)),\n        Name = \"my-second-item\",\n        Description = my_catalog.Apply(my_catalog =\u003e $\"Belongs to {my_catalog.Apply(getCatalogResult =\u003e getCatalogResult.Name)}\"),\n        OvaPath = \"/path/to/test_vapp_template.ova\",\n        UploadPieceSize = 5,\n    });\n\n});\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example: Fetching a vApp Template from a VDC\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_vdc = vcd.getOrgVdc({\n    org: \"my-org\",\n    name: \"my-vdc\",\n});\nconst my_first_vapp_template = my_vdc.then(my_vdc =\u003e vcd.getCatalogVappTemplate({\n    org: \"my-org\",\n    vdcId: my_vdc.id,\n    name: \"my-first-vapp-template\",\n}));\nconst my_second_vappTemplate = new vcd.CatalogVappTemplate(\"my-second-vapp_template\", {\n    metadataEntries: Object.entries(photon.metadataEntry).map(([k, v]) =\u003e ({key: k, value: v})).map(entry =\u003e ({\n        key: entry.value.key,\n        value: entry.value.value,\n        type: entry.value.type,\n        isSystem: entry.value.is_system,\n        userAccess: entry.value.user_access,\n    })),\n    org: my_first_vapp_template.then(my_first_vapp_template =\u003e my_first_vapp_template.org),\n    catalogId: my_first_vapp_template.then(my_first_vapp_template =\u003e my_first_vapp_template.catalogId),\n    name: \"my-second-item\",\n    description: my_vdc.then(my_vdc =\u003e `Belongs to ${my_vdc.name}`),\n    ovaPath: \"/path/to/test_vapp_template.ova\",\n    uploadPieceSize: 5,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_vdc = vcd.get_org_vdc(org=\"my-org\",\n    name=\"my-vdc\")\nmy_first_vapp_template = vcd.get_catalog_vapp_template(org=\"my-org\",\n    vdc_id=my_vdc.id,\n    name=\"my-first-vapp-template\")\nmy_second_vapp_template = vcd.CatalogVappTemplate(\"my-second-vapp_template\",\n    metadata_entries=[{\n        \"key\": entry[\"value\"][\"key\"],\n        \"value\": entry[\"value\"][\"value\"],\n        \"type\": entry[\"value\"][\"type\"],\n        \"is_system\": entry[\"value\"][\"is_system\"],\n        \"user_access\": entry[\"value\"][\"user_access\"],\n    } for entry in [{\"key\": k, \"value\": v} for k, v in photon[\"metadataEntry\"]]],\n    org=my_first_vapp_template.org,\n    catalog_id=my_first_vapp_template.catalog_id,\n    name=\"my-second-item\",\n    description=f\"Belongs to {my_vdc.name}\",\n    ova_path=\"/path/to/test_vapp_template.ova\",\n    upload_piece_size=5)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_vdc = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-vdc\",\n    });\n\n    var my_first_vapp_template = Vcd.GetCatalogVappTemplate.Invoke(new()\n    {\n        Org = \"my-org\",\n        VdcId = my_vdc.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"my-first-vapp-template\",\n    });\n\n    var my_second_vappTemplate = new Vcd.CatalogVappTemplate(\"my-second-vapp_template\", new()\n    {\n        MetadataEntries = .Select(entry =\u003e \n        {\n            return new Vcd.Inputs.CatalogVappTemplateMetadataEntryArgs\n            {\n                Key = entry.Value.Key,\n                Value = entry.Value.Value,\n                Type = entry.Value.Type,\n                IsSystem = entry.Value.Is_system,\n                UserAccess = entry.Value.User_access,\n            };\n        }).ToList(),\n        Org = my_first_vapp_template.Apply(my_first_vapp_template =\u003e my_first_vapp_template.Apply(getCatalogVappTemplateResult =\u003e getCatalogVappTemplateResult.Org)),\n        CatalogId = my_first_vapp_template.Apply(my_first_vapp_template =\u003e my_first_vapp_template.Apply(getCatalogVappTemplateResult =\u003e getCatalogVappTemplateResult.CatalogId)),\n        Name = \"my-second-item\",\n        Description = my_vdc.Apply(my_vdc =\u003e $\"Belongs to {my_vdc.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Name)}\"),\n        OvaPath = \"/path/to/test_vapp_template.ova\",\n        UploadPieceSize = 5,\n    });\n\n});\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n* `date` - (Optional) is an expression starting with an operator (`\u003e`, `\u003c`, `\u003e=`, `\u003c=`, `==`), followed by a date, with\n  optional spaces in between. For example: `\u003e 2020-02-01 12:35:00.523Z`\n  The filter recognizes several formats, but one of `yyyy-mm-dd [hh:mm[:ss[.nnnZ]]]` or `dd-MMM-yyyy [hh:mm[:ss[.nnnZ]]]`\n  is recommended.\n  Comparison with equality operator (`==`) need to define the date to the microseconds.\n* `latest` - (Optional) If `true`, retrieve the latest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the newest item.\n* `earliest` - (Optional) If `true`, retrieve the earliest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the oldest item.\n* `metadata` - (Optional) One or more parameters that will match metadata contents.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalogVappTemplate.\n",
                "properties": {
                    "catalogId": {
                        "type": "string",
                        "description": "ID of the catalog containing the vApp Template. Can't be used if a specific VDC identifier is set (`vdc_id`).\n"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogVappTemplateFilter:getCatalogVappTemplateFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "vApp Template name (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org name\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "ID of the VDC to which the vApp Template belongs. Can't be used if a specific Catalog is set (`catalog_id`).\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCatalogVappTemplate.\n",
                "properties": {
                    "catalogId": {
                        "type": "string"
                    },
                    "catalogItemId": {
                        "type": "string"
                    },
                    "created": {
                        "type": "string"
                    },
                    "description": {
                        "description": "vApp Template description\n",
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getCatalogVappTemplateFilter:getCatalogVappTemplateFilter"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inheritedMetadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "leases": {
                        "description": "(*v3.11+*) - The information about the vApp Template lease. It includes the following field:\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getCatalogVappTemplateLease:getCatalogVappTemplateLease"
                        },
                        "type": "array"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "description": "(Deprecated) Use `metadata_entry` instead. Key/value map of metadata for the associated vApp template.\n",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries assigned to this vApp Template. See [Metadata](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/catalog_vapp_template#metadata) section for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getCatalogVappTemplateMetadataEntry:getCatalogVappTemplateMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    },
                    "vmNames": {
                        "description": "Set of VM names within the vApp template\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "catalogItemId",
                    "created",
                    "description",
                    "inheritedMetadata",
                    "leases",
                    "metadata",
                    "metadataEntries",
                    "vmNames",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getCseKubernetesCluster:getCseKubernetesCluster": {
            "description": "Provides a data source to read Kubernetes clusters in VMware Cloud Director with Container Service Extension (CSE) installed and running.\n\nSupported in provider *v3.12+*\n\nSupports the following **Container Service Extension** versions:\n\n* 4.1.0\n* 4.1.1 / 4.1.1a\n* 4.2.0\n* 4.2.1\n* 4.2.2\n* 4.2.3\n\n\u003e To install CSE in VMware Cloud Director, please follow [this guide](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/container_service_extension_4_x_install)\n\n## Example Usage\n\n### With ID\n\nThe cluster ID identifies unequivocally the cluster within VCD, and can be obtained with the CSE Kubernetes Clusters UI Plugin, by selecting\nthe desired cluster and obtaining the ID from the displayed information.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myCluster = vcd.getCseKubernetesCluster({\n    clusterId: \"urn:vcloud:entity:vmware:capvcdCluster:e8e82bcc-50a1-484f-9dd0-20965ab3e865\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_cluster = vcd.get_cse_kubernetes_cluster(cluster_id=\"urn:vcloud:entity:vmware:capvcdCluster:e8e82bcc-50a1-484f-9dd0-20965ab3e865\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = Vcd.GetCseKubernetesCluster.Invoke(new()\n    {\n        ClusterId = \"urn:vcloud:entity:vmware:capvcdCluster:e8e82bcc-50a1-484f-9dd0-20965ab3e865\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupCseKubernetesCluster(ctx, \u0026vcd.LookupCseKubernetesClusterArgs{\n\t\t\tClusterId: pulumi.StringRef(\"urn:vcloud:entity:vmware:capvcdCluster:e8e82bcc-50a1-484f-9dd0-20965ab3e865\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetCseKubernetesClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myCluster = VcdFunctions.getCseKubernetesCluster(GetCseKubernetesClusterArgs.builder()\n            .clusterId(\"urn:vcloud:entity:vmware:capvcdCluster:e8e82bcc-50a1-484f-9dd0-20965ab3e865\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myCluster:\n    fn::invoke:\n      function: vcd:getCseKubernetesCluster\n      arguments:\n        clusterId: urn:vcloud:entity:vmware:capvcdCluster:e8e82bcc-50a1-484f-9dd0-20965ab3e865\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCseKubernetesCluster.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "Unequivocally identifies a cluster in VCD. Either `cluster_id` or `name` must be set.\n"
                    },
                    "cseVersion": {
                        "type": "string",
                        "description": "Specifies the CSE Version of the cluster to find when `name` is used instead of `cluster_id`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the Organization to which the Kubernetes cluster belongs. Only used if `cluster_id` is not set. Must be present if `name` is used.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCseKubernetesCluster.\n",
                "properties": {
                    "autoRepairOnErrors": {
                        "type": "boolean"
                    },
                    "capvcdVersion": {
                        "type": "string"
                    },
                    "clusterId": {
                        "type": "string"
                    },
                    "clusterResourceSetBindings": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "controlPlanes": {
                        "items": {
                            "$ref": "#/types/vcd:index/getCseKubernetesClusterControlPlane:getCseKubernetesClusterControlPlane"
                        },
                        "type": "array"
                    },
                    "cpiVersion": {
                        "type": "string"
                    },
                    "cseVersion": {
                        "type": "string"
                    },
                    "csiVersion": {
                        "type": "string"
                    },
                    "defaultStorageClasses": {
                        "items": {
                            "$ref": "#/types/vcd:index/getCseKubernetesClusterDefaultStorageClass:getCseKubernetesClusterDefaultStorageClass"
                        },
                        "type": "array"
                    },
                    "events": {
                        "items": {
                            "$ref": "#/types/vcd:index/getCseKubernetesClusterEvent:getCseKubernetesClusterEvent"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "kubeconfig": {
                        "secret": true,
                        "type": "string"
                    },
                    "kubernetesTemplateId": {
                        "type": "string"
                    },
                    "kubernetesVersion": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkId": {
                        "type": "string"
                    },
                    "nodeHealthCheck": {
                        "type": "boolean"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "owner": {
                        "type": "string"
                    },
                    "podsCidr": {
                        "type": "string"
                    },
                    "runtime": {
                        "type": "string"
                    },
                    "servicesCidr": {
                        "type": "string"
                    },
                    "sshPublicKey": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    },
                    "supportedUpgrades": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "tkgProductVersion": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    },
                    "virtualIpSubnet": {
                        "type": "string"
                    },
                    "workerPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getCseKubernetesClusterWorkerPool:getCseKubernetesClusterWorkerPool"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "autoRepairOnErrors",
                    "capvcdVersion",
                    "clusterResourceSetBindings",
                    "controlPlanes",
                    "cpiVersion",
                    "csiVersion",
                    "defaultStorageClasses",
                    "events",
                    "kubeconfig",
                    "kubernetesTemplateId",
                    "kubernetesVersion",
                    "networkId",
                    "nodeHealthCheck",
                    "owner",
                    "podsCidr",
                    "runtime",
                    "servicesCidr",
                    "sshPublicKey",
                    "state",
                    "supportedUpgrades",
                    "tkgProductVersion",
                    "vdcId",
                    "virtualIpSubnet",
                    "workerPools",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getDseRegistryConfiguration:getDseRegistryConfiguration": {
            "description": "Supported in provider *v3.13+* with Data Solution Extension.\n\nProvides a data source to read Data Solution Extension (DSE) registry configuration.\n\n\u003e Only `System Administrator` can use this data source.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst mongodb = vcd.getDseRegistryConfiguration({\n    name: \"MongoDB\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmongodb = vcd.get_dse_registry_configuration(name=\"MongoDB\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mongodb = Vcd.GetDseRegistryConfiguration.Invoke(new()\n    {\n        Name = \"MongoDB\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupDseRegistryConfiguration(ctx, \u0026vcd.LookupDseRegistryConfigurationArgs{\n\t\t\tName: \"MongoDB\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetDseRegistryConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var mongodb = VcdFunctions.getDseRegistryConfiguration(GetDseRegistryConfigurationArgs.builder()\n            .name(\"MongoDB\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  mongodb:\n    fn::invoke:\n      function: vcd:getDseRegistryConfiguration\n      arguments:\n        name: MongoDB\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDseRegistryConfiguration.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of Data Solution as it appears in repository configuration\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDseRegistryConfiguration.\n",
                "properties": {
                    "chartRepository": {
                        "type": "string"
                    },
                    "compatibleVersionConstraints": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "containerRegistries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getDseRegistryConfigurationContainerRegistry:getDseRegistryConfigurationContainerRegistry"
                        },
                        "type": "array"
                    },
                    "defaultChartRepository": {
                        "type": "string"
                    },
                    "defaultPackageName": {
                        "type": "string"
                    },
                    "defaultRepository": {
                        "type": "string"
                    },
                    "defaultVersion": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "packageName": {
                        "type": "string"
                    },
                    "packageRepository": {
                        "type": "string"
                    },
                    "rdeState": {
                        "type": "string"
                    },
                    "requiresVersionCompatibility": {
                        "type": "boolean"
                    },
                    "type": {
                        "type": "string"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "required": [
                    "chartRepository",
                    "compatibleVersionConstraints",
                    "containerRegistries",
                    "defaultChartRepository",
                    "defaultPackageName",
                    "defaultRepository",
                    "defaultVersion",
                    "name",
                    "packageName",
                    "packageRepository",
                    "rdeState",
                    "requiresVersionCompatibility",
                    "type",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getDseSolutionPublish:getDseSolutionPublish": {
            "description": "Supported in provider *v3.13+* with Data Solution Extension.\n\nProvides a data source to read Data Solution publishing settings for a particular tenant.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst tenant_org = vcd.getOrg({\n    name: \"tenant_org\",\n});\nconst mongodb_community = tenant_org.then(tenant_org =\u003e vcd.getDseSolutionPublish({\n    dataSolutionId: mongodb_communityVcdDseRegistryConfiguration.id,\n    orgId: tenant_org.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntenant_org = vcd.get_org(name=\"tenant_org\")\nmongodb_community = vcd.get_dse_solution_publish(data_solution_id=mongodb_community_vcd_dse_registry_configuration[\"id\"],\n    org_id=tenant_org.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tenant_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"tenant_org\",\n    });\n\n    var mongodb_community = Vcd.GetDseSolutionPublish.Invoke(new()\n    {\n        DataSolutionId = mongodb_communityVcdDseRegistryConfiguration.Id,\n        OrgId = tenant_org.Apply(getOrgResult =\u003e getOrgResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttenant_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"tenant_org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupDseSolutionPublish(ctx, \u0026vcd.LookupDseSolutionPublishArgs{\n\t\t\tDataSolutionId: mongodb_communityVcdDseRegistryConfiguration.Id,\n\t\t\tOrgId:          tenant_org.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetDseSolutionPublishArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tenant-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"tenant_org\")\n            .build());\n\n        final var mongodb-community = VcdFunctions.getDseSolutionPublish(GetDseSolutionPublishArgs.builder()\n            .dataSolutionId(mongodb_communityVcdDseRegistryConfiguration.id())\n            .orgId(tenant_org.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  mongodb-community:\n    fn::invoke:\n      function: vcd:getDseSolutionPublish\n      arguments:\n        dataSolutionId: ${[\"mongodb-communityVcdDseRegistryConfiguration\"].id}\n        orgId: ${[\"tenant-org\"].id}\n  tenant-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: tenant_org\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDseSolutionPublish.\n",
                "properties": {
                    "dataSolutionId": {
                        "type": "string",
                        "description": "ID of Data Solution\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Organization ID\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "dataSolutionId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDseSolutionPublish.\n",
                "properties": {
                    "confluentLicenseType": {
                        "type": "string"
                    },
                    "dataSolutionId": {
                        "type": "string"
                    },
                    "dsOrgConfigId": {
                        "type": "string"
                    },
                    "dsoAclId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "templateAclIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "confluentLicenseType",
                    "dataSolutionId",
                    "dsOrgConfigId",
                    "dsoAclId",
                    "orgId",
                    "templateAclIds",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getEdgegateway:getEdgegateway": {
            "description": "Provides a VMware Cloud Director NSX-V edge gateway data source, directly connected to one or more external networks. This can be used to reference\nedge gateways for Org VDC networks to connect.\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst mygw = vcd.getEdgegateway({\n    name: \"mygw\",\n    org: \"myorg\",\n    vdc: \"myvdc\",\n});\nexport const edgeGatewayId = mygw.then(mygw =\u003e mygw.id);\n// Get the name of the default gateway from the data source\n// and use it to establish a second data source\nconst externalNetwork1 = mygw.then(mygw =\u003e vcd.getExternalNetwork({\n    name: mygw.externalNetworks?.name,\n}));\nexport const gateway = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.gateway);\nexport const netmask = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.netmask);\nexport const DNS = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.dns1);\nexport const externalIp = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.staticIpPools?.[0]?.startAddress);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmygw = vcd.get_edgegateway(name=\"mygw\",\n    org=\"myorg\",\n    vdc=\"myvdc\")\npulumi.export(\"edgeGatewayId\", mygw.id)\n# Get the name of the default gateway from the data source\n# and use it to establish a second data source\nexternal_network1 = vcd.get_external_network(name=mygw.external_networks.name)\npulumi.export(\"gateway\", external_network1.ip_scopes[0].gateway)\npulumi.export(\"netmask\", external_network1.ip_scopes[0].netmask)\npulumi.export(\"DNS\", external_network1.ip_scopes[0].dns1)\npulumi.export(\"externalIp\", external_network1.ip_scopes[0].static_ip_pools[0].start_address)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mygw = Vcd.GetEdgegateway.Invoke(new()\n    {\n        Name = \"mygw\",\n        Org = \"myorg\",\n        Vdc = \"myvdc\",\n    });\n\n    // Get the name of the default gateway from the data source\n    // and use it to establish a second data source\n    var externalNetwork1 = Vcd.GetExternalNetwork.Invoke(new()\n    {\n        Name = mygw.Apply(getEdgegatewayResult =\u003e getEdgegatewayResult.ExternalNetworks?.Name),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"edgeGatewayId\"] = mygw.Apply(getEdgegatewayResult =\u003e getEdgegatewayResult.Id),\n        [\"gateway\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.Gateway),\n        [\"netmask\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.Netmask),\n        [\"DNS\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.Dns1),\n        [\"externalIp\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.StaticIpPools[0]?.StartAddress),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmygw, err := vcd.LookupEdgegateway(ctx, \u0026vcd.LookupEdgegatewayArgs{\n\t\t\tName: pulumi.StringRef(\"mygw\"),\n\t\t\tOrg:  pulumi.StringRef(\"myorg\"),\n\t\t\tVdc:  pulumi.StringRef(\"myvdc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"edgeGatewayId\", mygw.Id)\n\t\t// Get the name of the default gateway from the data source\n\t\t// and use it to establish a second data source\n\t\texternalNetwork1, err := vcd.LookupExternalNetwork(ctx, \u0026vcd.LookupExternalNetworkArgs{\n\t\t\tName: mygw.ExternalNetworks.Name,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"gateway\", externalNetwork1.IpScopes[0].Gateway)\n\t\tctx.Export(\"netmask\", externalNetwork1.IpScopes[0].Netmask)\n\t\tctx.Export(\"DNS\", externalNetwork1.IpScopes[0].Dns1)\n\t\tctx.Export(\"externalIp\", externalNetwork1.IpScopes[0].StaticIpPools[0].StartAddress)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetExternalNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var mygw = VcdFunctions.getEdgegateway(GetEdgegatewayArgs.builder()\n            .name(\"mygw\")\n            .org(\"myorg\")\n            .vdc(\"myvdc\")\n            .build());\n\n        ctx.export(\"edgeGatewayId\", mygw.applyValue(getEdgegatewayResult -\u003e getEdgegatewayResult.id()));\n        // Get the name of the default gateway from the data source\n        // and use it to establish a second data source\n        final var externalNetwork1 = VcdFunctions.getExternalNetwork(GetExternalNetworkArgs.builder()\n            .name(mygw.applyValue(getEdgegatewayResult -\u003e getEdgegatewayResult.externalNetworks().name()))\n            .build());\n\n        ctx.export(\"gateway\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].gateway()));\n        ctx.export(\"netmask\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].netmask()));\n        ctx.export(\"DNS\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].dns1()));\n        ctx.export(\"externalIp\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].staticIpPools()[0].startAddress()));\n    }\n}\n```\n```yaml\nvariables:\n  mygw:\n    fn::invoke:\n      function: vcd:getEdgegateway\n      arguments:\n        name: mygw\n        org: myorg\n        vdc: myvdc\n  # Get the name of the default gateway from the data source\n  # and use it to establish a second data source\n  externalNetwork1:\n    fn::invoke:\n      function: vcd:getExternalNetwork\n      arguments:\n        name: ${mygw.externalNetworks.name}\noutputs:\n  edgeGatewayId: ${mygw.id}\n  # From the second data source we extract the basic networking info\n  gateway: ${externalNetwork1.ipScopes[0].gateway}\n  netmask: ${externalNetwork1.ipScopes[0].netmask}\n  DNS: ${externalNetwork1.ipScopes[0].dns1}\n  externalIp: ${externalNetwork1.ipScopes[0].staticIpPools[0].startAddress}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n(Supported in provider *v2.9+*)\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEdgegateway.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/vcd:index/getEdgegatewayFilter:getEdgegatewayFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the edge gateway (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC that owns the edge gateway. Optional if defined at provider level.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getEdgegateway.\n",
                "properties": {
                    "configuration": {
                        "type": "string"
                    },
                    "defaultExternalNetworkIp": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "distributedRouting": {
                        "type": "boolean"
                    },
                    "externalNetworkIps": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "externalNetworks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getEdgegatewayExternalNetwork:getEdgegatewayExternalNetwork"
                        },
                        "type": "array"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getEdgegatewayFilter:getEdgegatewayFilter"
                    },
                    "fipsModeEnabled": {
                        "type": "boolean"
                    },
                    "fwDefaultRuleAction": {
                        "type": "string"
                    },
                    "fwDefaultRuleLoggingEnabled": {
                        "type": "boolean"
                    },
                    "fwEnabled": {
                        "type": "boolean"
                    },
                    "haEnabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lbAccelerationEnabled": {
                        "type": "boolean"
                    },
                    "lbEnabled": {
                        "type": "boolean"
                    },
                    "lbLoggingEnabled": {
                        "type": "boolean"
                    },
                    "lbLoglevel": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "useDefaultRouteForDnsRelay": {
                        "type": "boolean"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "configuration",
                    "defaultExternalNetworkIp",
                    "description",
                    "distributedRouting",
                    "externalNetworks",
                    "externalNetworkIps",
                    "fipsModeEnabled",
                    "fwDefaultRuleAction",
                    "fwDefaultRuleLoggingEnabled",
                    "fwEnabled",
                    "haEnabled",
                    "lbAccelerationEnabled",
                    "lbEnabled",
                    "lbLoggingEnabled",
                    "lbLoglevel",
                    "useDefaultRouteForDnsRelay",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getExternalEndpoint:getExternalEndpoint": {
            "description": "Supported in provider *v3.14+* and VCD 10.4.3+.\n\nProvides a data source to read External Endpoints in VMware Cloud Director. An External Endpoint holds information for the\nHTTPS endpoint which requests will be proxied to when using a [`vcd.ApiFilter`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_filter).\n\n\u003e Only `System Administrator` can use this data source.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst externalEndpoint1 = vcd.getExternalEndpoint({\n    vendor: \"vmware\",\n    name: \"my-endpoint\",\n    version: \"1.0.0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexternal_endpoint1 = vcd.get_external_endpoint(vendor=\"vmware\",\n    name=\"my-endpoint\",\n    version=\"1.0.0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var externalEndpoint1 = Vcd.GetExternalEndpoint.Invoke(new()\n    {\n        Vendor = \"vmware\",\n        Name = \"my-endpoint\",\n        Version = \"1.0.0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupExternalEndpoint(ctx, \u0026vcd.LookupExternalEndpointArgs{\n\t\t\tVendor:  \"vmware\",\n\t\t\tName:    \"my-endpoint\",\n\t\t\tVersion: \"1.0.0\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetExternalEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var externalEndpoint1 = VcdFunctions.getExternalEndpoint(GetExternalEndpointArgs.builder()\n            .vendor(\"vmware\")\n            .name(\"my-endpoint\")\n            .version(\"1.0.0\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  externalEndpoint1:\n    fn::invoke:\n      function: vcd:getExternalEndpoint\n      arguments:\n        vendor: vmware\n        name: my-endpoint\n        version: 1.0.0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getExternalEndpoint.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the External Endpoint\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor name of the External Endpoint\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the External Endpoint\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vendor",
                    "version"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExternalEndpoint.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "vendor": {
                        "type": "string"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "enabled",
                    "name",
                    "rootUrl",
                    "vendor",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getExternalNetwork:getExternalNetwork": {
            "description": "Provides a VMware Cloud Director external network data source. This can be used to reference external networks and their properties.\n\nSupported in provider *v2.5+*\n\n\u003e This resource is deprecated in favor of [`vcd.ExternalNetworkV2`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst tf_external_network = vcd.getExternalNetwork({\n    name: \"my-extnet\",\n});\nconst tf_nat_rule = new vcd.index.Dnat(\"tf-nat-rule\", {\n    org: \"tf-org\",\n    vdc: \"tf-vdc\",\n    networkName: tf_external_network.name,\n    networkType: \"ext\",\n    edgeGateway: \"tf-gw\",\n    externalIp: extnet_datacloud.ipScope[0].staticIpPool[0].startAddress,\n    port: 7777,\n    protocol: \"tcp\",\n    internalIp: \"10.10.102.60\",\n    translatedPort: 77,\n    description: \"test run\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntf_external_network = vcd.get_external_network(name=\"my-extnet\")\ntf_nat_rule = vcd.index.Dnat(\"tf-nat-rule\",\n    org=tf-org,\n    vdc=tf-vdc,\n    network_name=tf_external_network.name,\n    network_type=ext,\n    edge_gateway=tf-gw,\n    external_ip=extnet_datacloud.ip_scope[0].static_ip_pool[0].start_address,\n    port=7777,\n    protocol=tcp,\n    internal_ip=10.10.102.60,\n    translated_port=77,\n    description=test run)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tf_external_network = Vcd.GetExternalNetwork.Invoke(new()\n    {\n        Name = \"my-extnet\",\n    });\n\n    var tf_nat_rule = new Vcd.Index.Dnat(\"tf-nat-rule\", new()\n    {\n        Org = \"tf-org\",\n        Vdc = \"tf-vdc\",\n        NetworkName = tf_external_network.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.Name),\n        NetworkType = \"ext\",\n        EdgeGateway = \"tf-gw\",\n        ExternalIp = extnet_datacloud.IpScope[0].StaticIpPool[0].StartAddress,\n        Port = 7777,\n        Protocol = \"tcp\",\n        InternalIp = \"10.10.102.60\",\n        TranslatedPort = 77,\n        Description = \"test run\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttf_external_network, err := vcd.LookupExternalNetwork(ctx, \u0026vcd.LookupExternalNetworkArgs{\n\t\t\tName: \"my-extnet\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewDnat(ctx, \"tf-nat-rule\", \u0026vcd.DnatArgs{\n\t\t\tOrg:            \"tf-org\",\n\t\t\tVdc:            \"tf-vdc\",\n\t\t\tNetworkName:    tf_external_network.Name,\n\t\t\tNetworkType:    \"ext\",\n\t\t\tEdgeGateway:    \"tf-gw\",\n\t\t\tExternalIp:     extnet_datacloud.IpScope[0].StaticIpPool[0].StartAddress,\n\t\t\tPort:           7777,\n\t\t\tProtocol:       \"tcp\",\n\t\t\tInternalIp:     \"10.10.102.60\",\n\t\t\tTranslatedPort: 77,\n\t\t\tDescription:    \"test run\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetExternalNetworkArgs;\nimport com.pulumi.vcd.dnat;\nimport com.pulumi.vcd.DnatArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tf-external-network = VcdFunctions.getExternalNetwork(GetExternalNetworkArgs.builder()\n            .name(\"my-extnet\")\n            .build());\n\n        var tf_nat_rule = new Dnat(\"tf-nat-rule\", DnatArgs.builder()\n            .org(\"tf-org\")\n            .vdc(\"tf-vdc\")\n            .networkName(tf_external_network.name())\n            .networkType(\"ext\")\n            .edgeGateway(\"tf-gw\")\n            .externalIp(extnet_datacloud.ipScope()[0].staticIpPool()[0].startAddress())\n            .port(7777)\n            .protocol(\"tcp\")\n            .internalIp(\"10.10.102.60\")\n            .translatedPort(77)\n            .description(\"test run\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tf-nat-rule:\n    type: vcd:dnat\n    properties:\n      org: tf-org\n      vdc: tf-vdc\n      networkName: ${[\"tf-external-network\"].name}\n      networkType: ext\n      edgeGateway: tf-gw\n      externalIp: ${[\"extnet-datacloud\"].ipScope[0].staticIpPool[0].startAddress}\n      port: 7777\n      protocol: tcp\n      internalIp: 10.10.102.60\n      translatedPort: 77\n      description: test run\nvariables:\n  tf-external-network:\n    fn::invoke:\n      function: vcd:getExternalNetwork\n      arguments:\n        name: my-extnet\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getExternalNetwork.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "external network name\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExternalNetwork.\n",
                "properties": {
                    "description": {
                        "description": "Network friendly description\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipScopes": {
                        "description": "A list of IP scopes for the network. See [IP Scope](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/external_network#ipscope)\nfor details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getExternalNetworkIpScope:getExternalNetworkIpScope"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "retainNetInfoAcrossDeployments": {
                        "description": "Specifies whether the network resources such as IP/MAC of router will be \nretained across deployments.\n",
                        "type": "boolean"
                    },
                    "vsphereNetworks": {
                        "description": "A list of DV_PORTGROUP or NETWORK objects names that back this network. Each referenced \nDV_PORTGROUP or NETWORK must exist on a vCenter server registered with the system.\nSee [vSphere Network](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/external_network#vspherenetwork) for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getExternalNetworkVsphereNetwork:getExternalNetworkVsphereNetwork"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "description",
                    "ipScopes",
                    "name",
                    "retainNetInfoAcrossDeployments",
                    "vsphereNetworks",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getExternalNetworkV2:getExternalNetworkV2": {
            "description": "Provides a VMware Cloud Director External Network data source (version 2). New version of this data source uses new VCD\nAPI and is capable of handling NSX-T backed external networks as well as port group backed ones.\n\n\u003e **Note:** This resource uses new VMware Cloud Director\n[OpenAPI](https://code.vmware.com/docs/11982/getting-started-with-vmware-cloud-director-openapi) and\nrequires at least VCD *10.0+*. It supports both NSX-T and NSX-V backed networks (NSX-T *3.0+* requires VCD *10.1.1+*)\n\nSupported in provider *v3.0+*.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst extNet = vcd.getExternalNetworkV2({\n    name: \"my-nsxt-net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\next_net = vcd.get_external_network_v2(name=\"my-nsxt-net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var extNet = Vcd.GetExternalNetworkV2.Invoke(new()\n    {\n        Name = \"my-nsxt-net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupExternalNetworkV2(ctx, \u0026vcd.LookupExternalNetworkV2Args{\n\t\t\tName: \"my-nsxt-net\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetExternalNetworkV2Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var extNet = VcdFunctions.getExternalNetworkV2(GetExternalNetworkV2Args.builder()\n            .name(\"my-nsxt-net\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  extNet:\n    fn::invoke:\n      function: vcd:getExternalNetworkV2\n      arguments:\n        name: my-nsxt-net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getExternalNetworkV2.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "external network name\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExternalNetworkV2.\n",
                "properties": {
                    "dedicatedOrgId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipScopes": {
                        "items": {
                            "$ref": "#/types/vcd:index/getExternalNetworkV2IpScope:getExternalNetworkV2IpScope"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "natAndFirewallServiceIntention": {
                        "type": "string"
                    },
                    "nsxtNetworks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getExternalNetworkV2NsxtNetwork:getExternalNetworkV2NsxtNetwork"
                        },
                        "type": "array"
                    },
                    "routeAdvertisementIntention": {
                        "type": "string"
                    },
                    "useIpSpaces": {
                        "type": "boolean"
                    },
                    "vsphereNetworks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getExternalNetworkV2VsphereNetwork:getExternalNetworkV2VsphereNetwork"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "dedicatedOrgId",
                    "description",
                    "ipScopes",
                    "name",
                    "natAndFirewallServiceIntention",
                    "nsxtNetworks",
                    "routeAdvertisementIntention",
                    "useIpSpaces",
                    "vsphereNetworks",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getGlobalRole:getGlobalRole": {
            "description": "Provides a VMware Cloud Director global role data source. This can be used to read global roles.\n\nSupported in provider *v3.3+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst vapp_author = vcd.getGlobalRole({\n    name: \"vApp Author\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nvapp_author = vcd.get_global_role(name=\"vApp Author\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vapp_author = Vcd.GetGlobalRole.Invoke(new()\n    {\n        Name = \"vApp Author\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupGlobalRole(ctx, \u0026vcd.LookupGlobalRoleArgs{\n\t\t\tName: \"vApp Author\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetGlobalRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vapp-author = VcdFunctions.getGlobalRole(GetGlobalRoleArgs.builder()\n            .name(\"vApp Author\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vapp-author:\n    fn::invoke:\n      function: vcd:getGlobalRole\n      arguments:\n        name: vApp Author\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n```\nSample output:\n\nglobal-role-vapp = {\n  \"bundle_key\" = \"ROLE_VAPP_AUTHOR\"\n  \"description\" = \"Rights given to a user who uses catalogs and creates vApps\"\n  \"id\" = \"urn:vcloud:globalRole:1bf4457f-a253-3cf1-b163-f319f1a31802\"\n  \"name\" = \"vApp Author\"\n  \"publish_to_all_tenants\" = true\n  \"read_only\" = false\n  \"rights\" = toset([\n    \"Catalog: Add vApp from My Cloud\",\n    \"Catalog: View Private and Shared Catalogs\",\n    \"Organization vDC Compute Policy: View\",\n    \"Organization vDC Named Disk: Create\",\n    \"Organization vDC Named Disk: Delete\",\n    \"Organization vDC Named Disk: Edit Properties\",\n    \"Organization vDC Named Disk: View Encryption Status\",\n    \"Organization vDC Named Disk: View Properties\",\n    \"Organization vDC Network: View Properties\",\n    \"Organization vDC: VM-VM Affinity Edit\",\n    \"Organization: View\",\n    \"UI Plugins: View\",\n    \"VAPP_VM_METADATA_TO_VCENTER\",\n    \"vApp Template / Media: Copy\",\n    \"vApp Template / Media: Edit\",\n    \"vApp Template / Media: View\",\n    \"vApp Template: Checkout\",\n    \"vApp: Copy\",\n    \"vApp: Create / Reconfigure\",\n    \"vApp: Delete\",\n    \"vApp: Download\",\n    \"vApp: Edit Properties\",\n    \"vApp: Edit VM CPU\",\n    \"vApp: Edit VM Compute Policy\",\n    \"vApp: Edit VM Hard Disk\",\n    \"vApp: Edit VM Memory\",\n    \"vApp: Edit VM Network\",\n    \"vApp: Edit VM Properties\",\n    \"vApp: Manage VM Password Settings\",\n    \"vApp: Power Operations\",\n    \"vApp: Sharing\",\n    \"vApp: Snapshot Operations\",\n    \"vApp: Upload\",\n    \"vApp: Use Console\",\n    \"vApp: VM Boot Options\",\n    \"vApp: View ACL\",\n    \"vApp: View VM and VM's Disks Encryption Status\",\n    \"vApp: View VM metrics\",\n  ])\n  \"tenants\" = toset([\n    \"org1\",\n    \"org2\",\n  ])\n}\n```\n\n\n## More information\n\nSee [Roles management](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/roles_management) for a broader description of how global roles and\nrights work together.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGlobalRole.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the global role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGlobalRole.\n",
                "properties": {
                    "bundleKey": {
                        "description": "Key used for internationalization.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "A description of the global role\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "publishToAllTenants": {
                        "description": "When true, publishes the global role to all tenants\n",
                        "type": "boolean"
                    },
                    "readOnly": {
                        "description": "Whether this global role is read-only\n",
                        "type": "boolean"
                    },
                    "rights": {
                        "description": "List of rights assigned to this role\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "tenants": {
                        "description": "List of tenants to which this global role gets published. Ignored if `publish_to_all_tenants` is true.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "bundleKey",
                    "description",
                    "name",
                    "publishToAllTenants",
                    "readOnly",
                    "rights",
                    "tenants",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getIndependentDisk:getIndependentDisk": {
            "description": "Provides a VMware Cloud Director Independent disk data source. An independent disk data source can be used to reference an independent disk and use its \ndata within other resources or data sources.\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nexport = async () =\u003e {\n    const existing_disk = await vcd.getIndependentDisk({\n        org: \"my-org\",\n        vdc: \"my-vdc\",\n        id: \"urn:vcloud:disk:1bbc273d-7701-4f06-97be-428b46b0805e\",\n        name: \"my-disk\",\n    });\n    return {\n        \"disk-iops\": existing_disk.iops,\n        typeIsAttached: existing_disk.isAttached,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting_disk = vcd.get_independent_disk(org=\"my-org\",\n    vdc=\"my-vdc\",\n    id=\"urn:vcloud:disk:1bbc273d-7701-4f06-97be-428b46b0805e\",\n    name=\"my-disk\")\npulumi.export(\"disk-iops\", existing_disk.iops)\npulumi.export(\"typeIsAttached\", existing_disk.is_attached)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing_disk = Vcd.GetIndependentDisk.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n        Id = \"urn:vcloud:disk:1bbc273d-7701-4f06-97be-428b46b0805e\",\n        Name = \"my-disk\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"disk-iops\"] = existing_disk.Apply(existing_disk =\u003e existing_disk.Apply(getIndependentDiskResult =\u003e getIndependentDiskResult.Iops)),\n        [\"typeIsAttached\"] = existing_disk.Apply(existing_disk =\u003e existing_disk.Apply(getIndependentDiskResult =\u003e getIndependentDiskResult.IsAttached)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting_disk, err := vcd.LookupIndependentDisk(ctx, \u0026vcd.LookupIndependentDiskArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"my-vdc\"),\n\t\t\tId:   pulumi.StringRef(\"urn:vcloud:disk:1bbc273d-7701-4f06-97be-428b46b0805e\"),\n\t\t\tName: pulumi.StringRef(\"my-disk\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"disk-iops\", existing_disk.Iops)\n\t\tctx.Export(\"typeIsAttached\", existing_disk.IsAttached)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetIndependentDiskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing-disk = VcdFunctions.getIndependentDisk(GetIndependentDiskArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .id(\"urn:vcloud:disk:1bbc273d-7701-4f06-97be-428b46b0805e\")\n            .name(\"my-disk\")\n            .build());\n\n        ctx.export(\"disk-iops\", existing_disk.iops());\n        ctx.export(\"typeIsAttached\", existing_disk.isAttached());\n    }\n}\n```\n```yaml\nvariables:\n  existing-disk:\n    fn::invoke:\n      function: vcd:getIndependentDisk\n      arguments:\n        org: my-org\n        vdc: my-vdc\n        id: urn:vcloud:disk:1bbc273d-7701-4f06-97be-428b46b0805e\n        name: my-disk\noutputs:\n  disk-iops: ${[\"existing-disk\"].iops}\n  typeIsAttached: ${[\"existing-disk\"].isAttached}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIndependentDisk.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "Disk id or name is required. If both provided - Id is used. Id can be found by using import function [Listing independent disk IDs](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/independent_disk#listing-independent-disk-ids)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Disk name.  **Warning** please use `id` as there is possibility to have more than one independent disk with same name. As result data source will fail.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIndependentDisk.\n",
                "properties": {
                    "attachedVmIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "busSubType": {
                        "type": "string"
                    },
                    "busType": {
                        "type": "string"
                    },
                    "datastoreName": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "encrypted": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string"
                    },
                    "iops": {
                        "type": "integer"
                    },
                    "isAttached": {
                        "type": "boolean"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getIndependentDiskMetadataEntry:getIndependentDiskMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerName": {
                        "type": "string"
                    },
                    "sharingType": {
                        "type": "string"
                    },
                    "sizeInMb": {
                        "type": "integer"
                    },
                    "storageProfile": {
                        "type": "string"
                    },
                    "uuid": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "attachedVmIds",
                    "busSubType",
                    "busType",
                    "datastoreName",
                    "description",
                    "encrypted",
                    "iops",
                    "isAttached",
                    "metadata",
                    "metadataEntries",
                    "ownerName",
                    "sharingType",
                    "sizeInMb",
                    "storageProfile",
                    "uuid"
                ],
                "type": "object"
            }
        },
        "vcd:index/getIpSpace:getIpSpace": {
            "description": "Provides a data source to read IP Spaces. IP Spaces provide structured approach to allocating public\nand private IP addresses by preventing the use of overlapping IP addresses across organizations and\norganization VDCs.\n\nIP Spaces require VCD 10.4.1+ with NSX-T.\n\n## Example Usage\n\n### Private IP Space Within An Org)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst space1 = vcd.getIpSpace({\n    orgId: org1.id,\n    name: \"private-ip-space\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nspace1 = vcd.get_ip_space(org_id=org1[\"id\"],\n    name=\"private-ip-space\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var space1 = Vcd.GetIpSpace.Invoke(new()\n    {\n        OrgId = org1.Id,\n        Name = \"private-ip-space\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupIpSpace(ctx, \u0026vcd.LookupIpSpaceArgs{\n\t\t\tOrgId: pulumi.StringRef(org1.Id),\n\t\t\tName:  \"private-ip-space\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetIpSpaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var space1 = VcdFunctions.getIpSpace(GetIpSpaceArgs.builder()\n            .orgId(org1.id())\n            .name(\"private-ip-space\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  space1:\n    fn::invoke:\n      function: vcd:getIpSpace\n      arguments:\n        orgId: ${org1.id}\n        name: private-ip-space\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Public Or Shared IP Space)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst space1 = vcd.getIpSpace({\n    name: \"public-or-shared-ip-space\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nspace1 = vcd.get_ip_space(name=\"public-or-shared-ip-space\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var space1 = Vcd.GetIpSpace.Invoke(new()\n    {\n        Name = \"public-or-shared-ip-space\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupIpSpace(ctx, \u0026vcd.LookupIpSpaceArgs{\n\t\t\tName: \"public-or-shared-ip-space\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetIpSpaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var space1 = VcdFunctions.getIpSpace(GetIpSpaceArgs.builder()\n            .name(\"public-or-shared-ip-space\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  space1:\n    fn::invoke:\n      function: vcd:getIpSpace\n      arguments:\n        name: public-or-shared-ip-space\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIpSpace.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of IP Space.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Org ID for Private IP Space.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIpSpace.\n",
                "properties": {
                    "defaultFirewallRuleCreationEnabled": {
                        "type": "boolean"
                    },
                    "defaultNoSnatRuleCreationEnabled": {
                        "type": "boolean"
                    },
                    "defaultSnatRuleCreationEnabled": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "externalScope": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "internalScopes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "ipPrefixes": {
                        "items": {
                            "$ref": "#/types/vcd:index/getIpSpaceIpPrefix:getIpSpaceIpPrefix"
                        },
                        "type": "array"
                    },
                    "ipRangeQuota": {
                        "type": "string"
                    },
                    "ipRanges": {
                        "items": {
                            "$ref": "#/types/vcd:index/getIpSpaceIpRange:getIpSpaceIpRange"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "routeAdvertisementEnabled": {
                        "type": "boolean"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "defaultFirewallRuleCreationEnabled",
                    "defaultNoSnatRuleCreationEnabled",
                    "defaultSnatRuleCreationEnabled",
                    "description",
                    "externalScope",
                    "internalScopes",
                    "ipPrefixes",
                    "ipRanges",
                    "ipRangeQuota",
                    "name",
                    "routeAdvertisementEnabled",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getIpSpaceCustomQuota:getIpSpaceCustomQuota": {
            "description": "Provides a data source to read Custom Quotas for a given Org in a particular IP Space.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst org1 = vcd.getIpSpaceCustomQuota({\n    orgId: org1VcdOrg.id,\n    ipSpaceId: space1.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\norg1 = vcd.get_ip_space_custom_quota(org_id=org1_vcd_org[\"id\"],\n    ip_space_id=space1[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var org1 = Vcd.GetIpSpaceCustomQuota.Invoke(new()\n    {\n        OrgId = org1VcdOrg.Id,\n        IpSpaceId = space1.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupIpSpaceCustomQuota(ctx, \u0026vcd.LookupIpSpaceCustomQuotaArgs{\n\t\t\tOrgId:     org1VcdOrg.Id,\n\t\t\tIpSpaceId: space1.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetIpSpaceCustomQuotaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var org1 = VcdFunctions.getIpSpaceCustomQuota(GetIpSpaceCustomQuotaArgs.builder()\n            .orgId(org1VcdOrg.id())\n            .ipSpaceId(space1.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  org1:\n    fn::invoke:\n      function: vcd:getIpSpaceCustomQuota\n      arguments:\n        orgId: ${org1VcdOrg.id}\n        ipSpaceId: ${space1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIpSpaceCustomQuota.\n",
                "properties": {
                    "ipSpaceId": {
                        "type": "string",
                        "description": "IP Space ID to read Custom Quotas\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Organization ID, for which the Custom Quota should be read\n"
                    }
                },
                "type": "object",
                "required": [
                    "ipSpaceId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIpSpaceCustomQuota.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipPrefixQuotas": {
                        "items": {
                            "$ref": "#/types/vcd:index/getIpSpaceCustomQuotaIpPrefixQuota:getIpSpaceCustomQuotaIpPrefixQuota"
                        },
                        "type": "array"
                    },
                    "ipRangeQuota": {
                        "type": "string"
                    },
                    "ipSpaceId": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "required": [
                    "ipPrefixQuotas",
                    "ipRangeQuota",
                    "ipSpaceId",
                    "orgId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getIpSpaceIpAllocation:getIpSpaceIpAllocation": {
            "description": "Provides a data source to read IP Allocations within IP Spaces. It supports both - Floating IPs\n(IPs from IP Ranges) and IP Prefix (subnet) allocations with manual and automatic reservations.\n\nIP Spaces require VCD 10.4.1+ with NSX-T.\n\n## Example Usage\n\n### IP Space IP Prefix Allocation)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst ip_prefix = vcd.getIpSpaceIpAllocation({\n    orgId: org1.id,\n    ipSpaceId: space1.id,\n    type: \"IP_PREFIX\",\n    ipAddress: \"192.168.1.1/24\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nip_prefix = vcd.get_ip_space_ip_allocation(org_id=org1[\"id\"],\n    ip_space_id=space1[\"id\"],\n    type=\"IP_PREFIX\",\n    ip_address=\"192.168.1.1/24\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ip_prefix = Vcd.GetIpSpaceIpAllocation.Invoke(new()\n    {\n        OrgId = org1.Id,\n        IpSpaceId = space1.Id,\n        Type = \"IP_PREFIX\",\n        IpAddress = \"192.168.1.1/24\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupIpSpaceIpAllocation(ctx, \u0026vcd.LookupIpSpaceIpAllocationArgs{\n\t\t\tOrgId:     org1.Id,\n\t\t\tIpSpaceId: space1.Id,\n\t\t\tType:      \"IP_PREFIX\",\n\t\t\tIpAddress: \"192.168.1.1/24\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetIpSpaceIpAllocationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ip-prefix = VcdFunctions.getIpSpaceIpAllocation(GetIpSpaceIpAllocationArgs.builder()\n            .orgId(org1.id())\n            .ipSpaceId(space1.id())\n            .type(\"IP_PREFIX\")\n            .ipAddress(\"192.168.1.1/24\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  ip-prefix:\n    fn::invoke:\n      function: vcd:getIpSpaceIpAllocation\n      arguments:\n        orgId: ${org1.id}\n        ipSpaceId: ${space1.id}\n        type: IP_PREFIX\n        ipAddress: 192.168.1.1/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### IP Space Floating IP Allocation)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst floating_ip = vcd.getIpSpaceIpAllocation({\n    orgId: org1.id,\n    ipSpaceId: space1.id,\n    type: \"FLOATING_IP\",\n    ipAddress: \"192.168.1.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nfloating_ip = vcd.get_ip_space_ip_allocation(org_id=org1[\"id\"],\n    ip_space_id=space1[\"id\"],\n    type=\"FLOATING_IP\",\n    ip_address=\"192.168.1.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var floating_ip = Vcd.GetIpSpaceIpAllocation.Invoke(new()\n    {\n        OrgId = org1.Id,\n        IpSpaceId = space1.Id,\n        Type = \"FLOATING_IP\",\n        IpAddress = \"192.168.1.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupIpSpaceIpAllocation(ctx, \u0026vcd.LookupIpSpaceIpAllocationArgs{\n\t\t\tOrgId:     org1.Id,\n\t\t\tIpSpaceId: space1.Id,\n\t\t\tType:      \"FLOATING_IP\",\n\t\t\tIpAddress: \"192.168.1.1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetIpSpaceIpAllocationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var floating-ip = VcdFunctions.getIpSpaceIpAllocation(GetIpSpaceIpAllocationArgs.builder()\n            .orgId(org1.id())\n            .ipSpaceId(space1.id())\n            .type(\"FLOATING_IP\")\n            .ipAddress(\"192.168.1.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  floating-ip:\n    fn::invoke:\n      function: vcd:getIpSpaceIpAllocation\n      arguments:\n        orgId: ${org1.id}\n        ipSpaceId: ${space1.id}\n        type: FLOATING_IP\n        ipAddress: 192.168.1.1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIpSpaceIpAllocation.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "IP Address or CIDR of IP allocation (e.g. \"192.168.1.1/24\", \"192.168.1.1\")\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSpaceId": {
                        "type": "string",
                        "description": "Parent IP Space ID of IP Allocation\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Parent Org ID of IP Allocation\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of IP Allocation. One of `FLOATING_IP` or `IP_PREFIX`\n"
                    },
                    "usageState": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "ipAddress",
                    "ipSpaceId",
                    "orgId",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIpSpaceIpAllocation.\n",
                "properties": {
                    "allocationDate": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ip": {
                        "type": "string"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "ipSpaceId": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "prefixLength": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "usageState": {
                        "type": "string"
                    },
                    "usedById": {
                        "type": "string"
                    }
                },
                "required": [
                    "allocationDate",
                    "description",
                    "ip",
                    "ipAddress",
                    "ipSpaceId",
                    "orgId",
                    "prefixLength",
                    "type",
                    "usageState",
                    "usedById",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getIpSpaceUplink:getIpSpaceUplink": {
            "description": "Provides a data source to read IP Space Uplinks in External Networks (Provider Gateways).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst u1 = vcd.getIpSpaceUplink({\n    name: \"ip-space-uplink-1\",\n    externalNetworkId: provider_gateway.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nu1 = vcd.get_ip_space_uplink(name=\"ip-space-uplink-1\",\n    external_network_id=provider_gateway[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var u1 = Vcd.GetIpSpaceUplink.Invoke(new()\n    {\n        Name = \"ip-space-uplink-1\",\n        ExternalNetworkId = provider_gateway.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupIpSpaceUplink(ctx, \u0026vcd.LookupIpSpaceUplinkArgs{\n\t\t\tName:              \"ip-space-uplink-1\",\n\t\t\tExternalNetworkId: provider_gateway.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetIpSpaceUplinkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var u1 = VcdFunctions.getIpSpaceUplink(GetIpSpaceUplinkArgs.builder()\n            .name(\"ip-space-uplink-1\")\n            .externalNetworkId(provider_gateway.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  u1:\n    fn::invoke:\n      function: vcd:getIpSpaceUplink\n      arguments:\n        name: ip-space-uplink-1\n        externalNetworkId: ${[\"provider-gateway\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIpSpaceUplink.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "externalNetworkId": {
                        "type": "string",
                        "description": "Parent External Network ID\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of IP Space Uplink\n"
                    }
                },
                "type": "object",
                "required": [
                    "externalNetworkId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIpSpaceUplink.\n",
                "properties": {
                    "associatedInterfaceIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "externalNetworkId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipSpaceId": {
                        "type": "string"
                    },
                    "ipSpaceType": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    }
                },
                "required": [
                    "associatedInterfaceIds",
                    "externalNetworkId",
                    "ipSpaceId",
                    "ipSpaceType",
                    "name",
                    "status",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getLbAppProfile:getLbAppProfile": {
            "description": "Provides a VMware Cloud Director Edge Gateway Load Balancer Application Profile data source. An\napplication profile defines the behavior of the load balancer for a particular type of network\ntraffic. After configuring a profile, you associate it with a virtual server. The virtual server\nthen processes traffic according to the values specified in the profile.\n\n\u003e **Note:** See additional support notes in [application profile resource page]\n(/providers/vmware/vcd/latest/docs/resources/lb_app_profile).\n\nSupported in provider *v2.4+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_profile = vcd.getLbAppProfile({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    name: \"not-managed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_profile = vcd.get_lb_app_profile(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    name=\"not-managed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_profile = Vcd.GetLbAppProfile.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        Name = \"not-managed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupLbAppProfile(ctx, \u0026vcd.LookupLbAppProfileArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tName:        \"not-managed\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetLbAppProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-profile = VcdFunctions.getLbAppProfile(GetLbAppProfileArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .name(\"not-managed\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-profile:\n    fn::invoke:\n      function: vcd:getLbAppProfile\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        name: not-managed\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLbAppProfile.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the service monitor is defined\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Application profile name for identifying the exact application profile\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLbAppProfile.\n",
                "properties": {
                    "cookieMode": {
                        "type": "string"
                    },
                    "cookieName": {
                        "type": "string"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "enablePoolSideSsl": {
                        "type": "boolean"
                    },
                    "enableSslPassthrough": {
                        "type": "boolean"
                    },
                    "expiration": {
                        "type": "integer"
                    },
                    "httpRedirectUrl": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "insertXForwardedHttpHeader": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "persistenceMechanism": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "cookieMode",
                    "cookieName",
                    "edgeGateway",
                    "enablePoolSideSsl",
                    "enableSslPassthrough",
                    "expiration",
                    "httpRedirectUrl",
                    "insertXForwardedHttpHeader",
                    "name",
                    "persistenceMechanism",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getLbAppRule:getLbAppRule": {
            "description": "Provides a VMware Cloud Director Edge Gateway Load Balancer Application Rule data source. An application\nrule allows to directly manipulate and manage IP application traffic with load balancer.\n\n\u003e **Note:** See additional support notes in [application rule resource page]\n(/providers/vmware/vcd/latest/docs/resources/lb_app_rule).\n\nSupported in provider *v2.4+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_rule = vcd.getLbAppRule({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    name: \"not-managed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_rule = vcd.get_lb_app_rule(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    name=\"not-managed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_rule = Vcd.GetLbAppRule.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        Name = \"not-managed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupLbAppRule(ctx, \u0026vcd.LookupLbAppRuleArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tName:        \"not-managed\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetLbAppRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-rule = VcdFunctions.getLbAppRule(GetLbAppRuleArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .name(\"not-managed\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-rule:\n    fn::invoke:\n      function: vcd:getLbAppRule\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        name: not-managed\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLbAppRule.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the service monitor is defined\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Application rule name for identifying the exact application rule\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLbAppRule.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "script": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "edgeGateway",
                    "name",
                    "script",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getLbServerPool:getLbServerPool": {
            "description": "Provides a VMware Cloud Director Edge Gateway Load Balancer Server Pool data source. A Server Pool defines\na group of backend servers (defined as pool members), manages load balancer distribution methods, and has a service \nmonitor attached to it for health check parameters.\n\n\u003e **Note:** See additional support notes in [server pool resource page](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/lb_server_pool).\n\nSupported in provider *v2.4+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst sp_ds = vcd.getLbServerPool({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    name: \"not-managed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsp_ds = vcd.get_lb_server_pool(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    name=\"not-managed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sp_ds = Vcd.GetLbServerPool.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        Name = \"not-managed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupLbServerPool(ctx, \u0026vcd.LookupLbServerPoolArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tName:        \"not-managed\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetLbServerPoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var sp-ds = VcdFunctions.getLbServerPool(GetLbServerPoolArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .name(\"not-managed\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  sp-ds:\n    fn::invoke:\n      function: vcd:getLbServerPool\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        name: not-managed\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLbServerPool.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the server pool is defined\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Server Pool name for identifying the exact server pool\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLbServerPool.\n",
                "properties": {
                    "algorithm": {
                        "type": "string"
                    },
                    "algorithmParameters": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "enableTransparency": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "members": {
                        "items": {
                            "$ref": "#/types/vcd:index/getLbServerPoolMember:getLbServerPoolMember"
                        },
                        "type": "array"
                    },
                    "monitorId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "algorithm",
                    "algorithmParameters",
                    "description",
                    "edgeGateway",
                    "enableTransparency",
                    "members",
                    "monitorId",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getLbServiceMonitor:getLbServiceMonitor": {
            "description": "Provides a VMware Cloud Director Edge Gateway Load Balancer Service Monitor data source. A service monitor \ndefines health check parameters for a particular type of network traffic. It can be associated with\na pool. Pool members are monitored according to the service monitor parameters. See example usage of\nthis data source in [server pool resource page](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/lb_server_pool).\n\n\u003e **Note:** See additional support notes in [service monitor resource page](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/lb_service_monitor).\n\nSupported in provider *v2.4+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_monitor = vcd.getLbServiceMonitor({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    name: \"not-managed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_monitor = vcd.get_lb_service_monitor(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    name=\"not-managed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_monitor = Vcd.GetLbServiceMonitor.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        Name = \"not-managed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupLbServiceMonitor(ctx, \u0026vcd.LookupLbServiceMonitorArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tName:        \"not-managed\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetLbServiceMonitorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-monitor = VcdFunctions.getLbServiceMonitor(GetLbServiceMonitorArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .name(\"not-managed\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-monitor:\n    fn::invoke:\n      function: vcd:getLbServiceMonitor\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        name: not-managed\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLbServiceMonitor.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the service monitor is defined\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Service Monitor name for identifying the exact service monitor\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLbServiceMonitor.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string"
                    },
                    "expected": {
                        "type": "string"
                    },
                    "extension": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "interval": {
                        "type": "integer"
                    },
                    "maxRetries": {
                        "type": "integer"
                    },
                    "method": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "receive": {
                        "type": "string"
                    },
                    "send": {
                        "type": "string"
                    },
                    "timeout": {
                        "type": "integer"
                    },
                    "type": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "edgeGateway",
                    "expected",
                    "extension",
                    "interval",
                    "maxRetries",
                    "method",
                    "name",
                    "receive",
                    "send",
                    "timeout",
                    "type",
                    "url",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getLbVirtualServer:getLbVirtualServer": {
            "description": "Provides a VMware Cloud Director edge gateway load balancer virtual server data source. Adds an edge gateway\ninternal or uplink interface as a virtual server. A virtual server has a public IP address and services all incoming client requests. \n\n\u003e **Note:** To make load balancing work one must ensure that load balancing is enabled on edge gateway (edge gateway must be advanced).\nThis depends on NSX version to work properly. Please refer to [VMware Product Interoperability Matrices](https://www.vmware.com/resources/compatibility/sim/interop_matrix.php#interop\u002629=\u002693=) \nto check supported VMware Cloud Director and NSX for vSphere configurations.\n\n\u003e **Note:** The VMware Cloud Director API for NSX supports a subset of the operations and objects defined in the NSX vSphere \nAPI Guide. The API supports NSX 6.2, 6.3, and 6.4.\n\nSupported in provider *v2.4+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_vs = vcd.getLbVirtualServer({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    name: \"not-managed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_vs = vcd.get_lb_virtual_server(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    name=\"not-managed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_vs = Vcd.GetLbVirtualServer.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        Name = \"not-managed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupLbVirtualServer(ctx, \u0026vcd.LookupLbVirtualServerArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tName:        \"not-managed\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetLbVirtualServerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-vs = VcdFunctions.getLbVirtualServer(GetLbVirtualServerArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .name(\"not-managed\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-vs:\n    fn::invoke:\n      function: vcd:getLbVirtualServer\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        name: not-managed\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLbVirtualServer.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which the virtual server is defined\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name for identifying the exact virtual server\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLbVirtualServer.\n",
                "properties": {
                    "appProfileId": {
                        "type": "string"
                    },
                    "appRuleIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "connectionLimit": {
                        "type": "integer"
                    },
                    "connectionRateLimit": {
                        "type": "integer"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "enableAcceleration": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "port": {
                        "type": "integer"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "serverPoolId": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "appProfileId",
                    "appRuleIds",
                    "connectionLimit",
                    "connectionRateLimit",
                    "description",
                    "edgeGateway",
                    "enableAcceleration",
                    "enabled",
                    "ipAddress",
                    "name",
                    "port",
                    "protocol",
                    "serverPoolId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getLibraryCertificate:getLibraryCertificate": {
            "inputs": {
                "description": "A collection of arguments for invoking getLibraryCertificate.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "certificate": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getLibraryCertificate.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "certificate": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "required": [
                    "alias",
                    "certificate",
                    "description",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getMultisiteOrgAssociation:getMultisiteOrgAssociation": {
            "description": "Provides a data source to read a VMware Cloud Director Org association information.\n\nSupported in provider *v3.13+*\n\n## Example Usage\n\n### 1\n\nRetrieving an Org association using the associated Org ID.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org = vcd.getOrg({\n    name: \"my-org\",\n});\nconst org1_org2 = my_org.then(my_org =\u003e vcd.getMultisiteOrgAssociation({\n    orgId: my_org.id,\n    associatedOrgId: \"urn:vcloud:org:3901d87d-1596-4a5a-a74b-57a7313737cf\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\norg1_org2 = vcd.get_multisite_org_association(org_id=my_org.id,\n    associated_org_id=\"urn:vcloud:org:3901d87d-1596-4a5a-a74b-57a7313737cf\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var org1_org2 = Vcd.GetMultisiteOrgAssociation.Invoke(new()\n    {\n        OrgId = my_org.Apply(getOrgResult =\u003e getOrgResult.Id),\n        AssociatedOrgId = \"urn:vcloud:org:3901d87d-1596-4a5a-a74b-57a7313737cf\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupMultisiteOrgAssociation(ctx, \u0026vcd.LookupMultisiteOrgAssociationArgs{\n\t\t\tOrgId:           my_org.Id,\n\t\t\tAssociatedOrgId: pulumi.StringRef(\"urn:vcloud:org:3901d87d-1596-4a5a-a74b-57a7313737cf\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetMultisiteOrgAssociationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        final var org1-org2 = VcdFunctions.getMultisiteOrgAssociation(GetMultisiteOrgAssociationArgs.builder()\n            .orgId(my_org.id())\n            .associatedOrgId(\"urn:vcloud:org:3901d87d-1596-4a5a-a74b-57a7313737cf\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n  org1-org2:\n    fn::invoke:\n      function: vcd:getMultisiteOrgAssociation\n      arguments:\n        orgId: ${[\"my-org\"].id}\n        associatedOrgId: urn:vcloud:org:3901d87d-1596-4a5a-a74b-57a7313737cf\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### 2\n\nRetrieving an Org association using the association data file.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org = vcd.getOrg({\n    name: \"my-org\",\n});\nconst org1_org2 = my_org.then(my_org =\u003e vcd.getMultisiteOrgAssociation({\n    orgId: my_org.id,\n    associationDataFile: \"remote-org.xml\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\norg1_org2 = vcd.get_multisite_org_association(org_id=my_org.id,\n    association_data_file=\"remote-org.xml\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var org1_org2 = Vcd.GetMultisiteOrgAssociation.Invoke(new()\n    {\n        OrgId = my_org.Apply(getOrgResult =\u003e getOrgResult.Id),\n        AssociationDataFile = \"remote-org.xml\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupMultisiteOrgAssociation(ctx, \u0026vcd.LookupMultisiteOrgAssociationArgs{\n\t\t\tOrgId:               my_org.Id,\n\t\t\tAssociationDataFile: pulumi.StringRef(\"remote-org.xml\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetMultisiteOrgAssociationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        final var org1-org2 = VcdFunctions.getMultisiteOrgAssociation(GetMultisiteOrgAssociationArgs.builder()\n            .orgId(my_org.id())\n            .associationDataFile(\"remote-org.xml\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n  org1-org2:\n    fn::invoke:\n      function: vcd:getMultisiteOrgAssociation\n      arguments:\n        orgId: ${[\"my-org\"].id}\n        associationDataFile: remote-org.xml\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## More information\n\nSee [Site and Org association](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/site_org_association) for a broader description\nof association workflows.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMultisiteOrgAssociation.\n",
                "properties": {
                    "associatedOrgId": {
                        "type": "string",
                        "description": "ID of the remote organization associated with the current one. (Used in alternative to\n`associated_data_file`)\n"
                    },
                    "associationDataFile": {
                        "type": "string",
                        "description": "Name of the file containing the data used to associate this Org to another one.\n(Used when `associated_org_id` is not known)\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the organization for which we need to collect the data.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMultisiteOrgAssociation.\n",
                "properties": {
                    "associatedOrgId": {
                        "type": "string"
                    },
                    "associatedOrgName": {
                        "description": "The name of the associated Org.\n",
                        "type": "string"
                    },
                    "associatedSiteId": {
                        "description": "The ID of the associated site.\n",
                        "type": "string"
                    },
                    "associationDataFile": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "status": {
                        "description": "The status of the association (one of `ASYMMETRIC`, `ACTIVE`, `UNREACHABLE`, `ERROR`)\n",
                        "type": "string"
                    }
                },
                "required": [
                    "associatedOrgName",
                    "associatedSiteId",
                    "orgId",
                    "status",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getMultisiteOrgData:getMultisiteOrgData": {
            "description": "Provides a data source to read a VMware Cloud Director Org association data to be used for association with another Org.\n\nSupported in provider *v3.13+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org = vcd.getOrg({\n    name: \"my-org\",\n});\nconst currentOrg = my_org.then(my_org =\u003e vcd.getMultisiteOrgData({\n    orgId: my_org.id,\n    downloadToFile: \"filename.xml\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\ncurrent_org = vcd.get_multisite_org_data(org_id=my_org.id,\n    download_to_file=\"filename.xml\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var currentOrg = Vcd.GetMultisiteOrgData.Invoke(new()\n    {\n        OrgId = my_org.Apply(getOrgResult =\u003e getOrgResult.Id),\n        DownloadToFile = \"filename.xml\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetMultisiteOrgData(ctx, \u0026vcd.GetMultisiteOrgDataArgs{\n\t\t\tOrgId:          my_org.Id,\n\t\t\tDownloadToFile: pulumi.StringRef(\"filename.xml\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetMultisiteOrgDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        final var currentOrg = VcdFunctions.getMultisiteOrgData(GetMultisiteOrgDataArgs.builder()\n            .orgId(my_org.id())\n            .downloadToFile(\"filename.xml\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n  currentOrg:\n    fn::invoke:\n      function: vcd:getMultisiteOrgData\n      arguments:\n        orgId: ${[\"my-org\"].id}\n        downloadToFile: filename.xml\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## More information\n\nSee [Site and Org association](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/site_org_association) for a broader description\nof association workflows.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMultisiteOrgData.\n",
                "properties": {
                    "downloadToFile": {
                        "type": "string",
                        "description": "Name of the file that will contain the data needed to associate this Org to another one, \neither on the same VCD or in a different one.\nContains the same data returned in `association_data`.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the organization for which we need to collect the data.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMultisiteOrgData.\n",
                "properties": {
                    "associationData": {
                        "description": "The data needed to associate this Org to another one. Contains the same data that would be saved into\nthe file defined in `download_to_file`.\n",
                        "type": "string"
                    },
                    "associations": {
                        "description": "An alphabetically sorted list of current associations.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "downloadToFile": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "numberOfAssociations": {
                        "description": "The number of current associations with other Orgs.\n",
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "required": [
                    "associationData",
                    "associations",
                    "numberOfAssociations",
                    "orgId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getMultisiteSite:getMultisiteSite": {
            "description": "Provides a data source to read a VMware Cloud Director Site in the context of multi-site operatioos\n\nSupported in provider *v3.13+*\n\n\u003e Note: this data source requires System Administrator privileges\n\n## Example Usage\n\nNote: there is only one site available for each VCD. No ID or name is necessary to identify it.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst currentSite = vcd.getMultisiteSite({});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ncurrent_site = vcd.get_multisite_site()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var currentSite = Vcd.GetMultisiteSite.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetMultisiteSite(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var currentSite = VcdFunctions.getMultisiteSite();\n\n    }\n}\n```\n```yaml\nvariables:\n  currentSite:\n    fn::invoke:\n      function: vcd:getMultisiteSite\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## More information\n\nSee [Site and Org association](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/site_org_association) for a broader description\nof association workflows.\n",
            "outputs": {
                "description": "A collection of values returned by getMultisiteSite.\n",
                "properties": {
                    "associations": {
                        "description": "An alphabetically sorted list of current associations.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "description": {
                        "description": "An optional description of the site.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the site, which usually corresponds to its host name.\n",
                        "type": "string"
                    },
                    "numberOfAssociations": {
                        "description": "The number of current associations with other sites.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "associations",
                    "description",
                    "name",
                    "numberOfAssociations",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getMultisiteSiteAssociation:getMultisiteSiteAssociation": {
            "description": "Provides a data source to read a VMware Cloud Director site association information.\n\n\u003e Note: this data source requires System Administrator privileges\n\nSupported in provider *v3.13+*\n\n## Example Usage\n\n### 1\n\nRetrieving a site association using the associated site ID.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst site1_site2 = vcd.getMultisiteSiteAssociation({\n    associatedSiteId: \"urn:vcloud:site:dca02216-fcf3-414a-be95-a3e26cf1296b\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsite1_site2 = vcd.get_multisite_site_association(associated_site_id=\"urn:vcloud:site:dca02216-fcf3-414a-be95-a3e26cf1296b\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var site1_site2 = Vcd.GetMultisiteSiteAssociation.Invoke(new()\n    {\n        AssociatedSiteId = \"urn:vcloud:site:dca02216-fcf3-414a-be95-a3e26cf1296b\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupMultisiteSiteAssociation(ctx, \u0026vcd.LookupMultisiteSiteAssociationArgs{\n\t\t\tAssociatedSiteId: pulumi.StringRef(\"urn:vcloud:site:dca02216-fcf3-414a-be95-a3e26cf1296b\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetMultisiteSiteAssociationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var site1-site2 = VcdFunctions.getMultisiteSiteAssociation(GetMultisiteSiteAssociationArgs.builder()\n            .associatedSiteId(\"urn:vcloud:site:dca02216-fcf3-414a-be95-a3e26cf1296b\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  site1-site2:\n    fn::invoke:\n      function: vcd:getMultisiteSiteAssociation\n      arguments:\n        associatedSiteId: urn:vcloud:site:dca02216-fcf3-414a-be95-a3e26cf1296b\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### 2\n\nRetrieving a site association using the association data file.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst site1_site2 = vcd.getMultisiteSiteAssociation({\n    associationDataFile: \"remote-site.xml\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsite1_site2 = vcd.get_multisite_site_association(association_data_file=\"remote-site.xml\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var site1_site2 = Vcd.GetMultisiteSiteAssociation.Invoke(new()\n    {\n        AssociationDataFile = \"remote-site.xml\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupMultisiteSiteAssociation(ctx, \u0026vcd.LookupMultisiteSiteAssociationArgs{\n\t\t\tAssociationDataFile: pulumi.StringRef(\"remote-site.xml\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetMultisiteSiteAssociationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var site1-site2 = VcdFunctions.getMultisiteSiteAssociation(GetMultisiteSiteAssociationArgs.builder()\n            .associationDataFile(\"remote-site.xml\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  site1-site2:\n    fn::invoke:\n      function: vcd:getMultisiteSiteAssociation\n      arguments:\n        associationDataFile: remote-site.xml\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## More information\n\nSee [Site and Org association](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/site_org_association) for a broader description\nof association workflows.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMultisiteSiteAssociation.\n",
                "properties": {
                    "associatedSiteId": {
                        "type": "string",
                        "description": "ID of the remote site associated with the current one. (Used in alternative to\n`associated_data_file`)\n"
                    },
                    "associationDataFile": {
                        "type": "string",
                        "description": "Name of the file containing the data used to associate this site to another one.\n(Used when `associated_site_id` is not known)\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getMultisiteSiteAssociation.\n",
                "properties": {
                    "associatedSiteHref": {
                        "description": "The URL of the associated site.\n",
                        "type": "string"
                    },
                    "associatedSiteId": {
                        "type": "string"
                    },
                    "associatedSiteName": {
                        "description": "The name of the associated site.\n",
                        "type": "string"
                    },
                    "associationDataFile": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "The status of the association (one of `ASYMMETRIC`, `ACTIVE`, `UNREACHABLE`, `ERROR`)\n",
                        "type": "string"
                    }
                },
                "required": [
                    "associatedSiteHref",
                    "associatedSiteName",
                    "status",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getMultisiteSiteData:getMultisiteSiteData": {
            "description": "Provides a data source to read a VMware Cloud Director Site association data to be used for association with another site.\n\nSupported in provider *v3.13+*\n\n## Example Usage\n\nNote: there is only one site available for each VCD. No ID or name is necessary to identify it.\n\n\u003e Note: this data source requires System Administrator privileges\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst currentSite = vcd.getMultisiteSiteData({\n    downloadToFile: \"filename.xml\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ncurrent_site = vcd.get_multisite_site_data(download_to_file=\"filename.xml\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var currentSite = Vcd.GetMultisiteSiteData.Invoke(new()\n    {\n        DownloadToFile = \"filename.xml\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetMultisiteSiteData(ctx, \u0026vcd.GetMultisiteSiteDataArgs{\n\t\t\tDownloadToFile: pulumi.StringRef(\"filename.xml\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetMultisiteSiteDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var currentSite = VcdFunctions.getMultisiteSiteData(GetMultisiteSiteDataArgs.builder()\n            .downloadToFile(\"filename.xml\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  currentSite:\n    fn::invoke:\n      function: vcd:getMultisiteSiteData\n      arguments:\n        downloadToFile: filename.xml\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMultisiteSiteData.\n",
                "properties": {
                    "downloadToFile": {
                        "type": "string",
                        "description": "Name of the file that will contain the data needed to associate this site to a remote one.\nContains the same data returned in `association_data`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getMultisiteSiteData.\n",
                "properties": {
                    "associationData": {
                        "description": "The data needed to associate this site to another one. Contains the same data that would be saved into\nthe file defined in `download_to_file`.\n",
                        "type": "string"
                    },
                    "downloadToFile": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "associationData",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNetworkDirect:getNetworkDirect": {
            "description": "Provides a VMware Cloud Director Org VDC Network data source directly connected to an external network. This can be used to reference\ninternal networks for vApps to connect.\n\nSupported in provider *v2.5+*\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst net = vcd.getNetworkDirect({\n    org: \"my-org\",\n    vdc: \"my-vdc\",\n    name: \"my-net\",\n});\nexport const externalNetwork = net.then(net =\u003e net.externalNetwork);\nconst externalNetwork1 = net.then(net =\u003e vcd.getExternalNetwork({\n    name: net.externalNetwork,\n}));\nexport const gateway = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.gateway);\nexport const externalNetworkGateway = net.then(net =\u003e net.externalNetworkGateway);\nexport const netmask = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.netmask);\nexport const externalNetworkNetmask = net.then(net =\u003e net.externalNetworkNetmask);\nexport const DNS = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.dns1);\nexport const externalNetworkDns = net.then(net =\u003e net.externalNetworkDns1);\nexport const externalIp = externalNetwork1.then(externalNetwork1 =\u003e externalNetwork1.ipScopes?.[0]?.staticIpPools?.[0]?.startAddress);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnet = vcd.get_network_direct(org=\"my-org\",\n    vdc=\"my-vdc\",\n    name=\"my-net\")\npulumi.export(\"externalNetwork\", net.external_network)\nexternal_network1 = vcd.get_external_network(name=net.external_network)\npulumi.export(\"gateway\", external_network1.ip_scopes[0].gateway)\npulumi.export(\"externalNetworkGateway\", net.external_network_gateway)\npulumi.export(\"netmask\", external_network1.ip_scopes[0].netmask)\npulumi.export(\"externalNetworkNetmask\", net.external_network_netmask)\npulumi.export(\"DNS\", external_network1.ip_scopes[0].dns1)\npulumi.export(\"externalNetworkDns\", net.external_network_dns1)\npulumi.export(\"externalIp\", external_network1.ip_scopes[0].static_ip_pools[0].start_address)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var net = Vcd.GetNetworkDirect.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n        Name = \"my-net\",\n    });\n\n    var externalNetwork1 = Vcd.GetExternalNetwork.Invoke(new()\n    {\n        Name = net.Apply(getNetworkDirectResult =\u003e getNetworkDirectResult.ExternalNetwork),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"externalNetwork\"] = net.Apply(getNetworkDirectResult =\u003e getNetworkDirectResult.ExternalNetwork),\n        [\"gateway\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.Gateway),\n        [\"externalNetworkGateway\"] = net.Apply(getNetworkDirectResult =\u003e getNetworkDirectResult.ExternalNetworkGateway),\n        [\"netmask\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.Netmask),\n        [\"externalNetworkNetmask\"] = net.Apply(getNetworkDirectResult =\u003e getNetworkDirectResult.ExternalNetworkNetmask),\n        [\"DNS\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.Dns1),\n        [\"externalNetworkDns\"] = net.Apply(getNetworkDirectResult =\u003e getNetworkDirectResult.ExternalNetworkDns1),\n        [\"externalIp\"] = externalNetwork1.Apply(getExternalNetworkResult =\u003e getExternalNetworkResult.IpScopes[0]?.StaticIpPools[0]?.StartAddress),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnet, err := vcd.LookupNetworkDirect(ctx, \u0026vcd.LookupNetworkDirectArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"my-vdc\"),\n\t\t\tName: pulumi.StringRef(\"my-net\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"externalNetwork\", net.ExternalNetwork)\n\t\texternalNetwork1, err := vcd.LookupExternalNetwork(ctx, \u0026vcd.LookupExternalNetworkArgs{\n\t\t\tName: net.ExternalNetwork,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"gateway\", externalNetwork1.IpScopes[0].Gateway)\n\t\tctx.Export(\"externalNetworkGateway\", net.ExternalNetworkGateway)\n\t\tctx.Export(\"netmask\", externalNetwork1.IpScopes[0].Netmask)\n\t\tctx.Export(\"externalNetworkNetmask\", net.ExternalNetworkNetmask)\n\t\tctx.Export(\"DNS\", externalNetwork1.IpScopes[0].Dns1)\n\t\tctx.Export(\"externalNetworkDns\", net.ExternalNetworkDns1)\n\t\tctx.Export(\"externalIp\", externalNetwork1.IpScopes[0].StaticIpPools[0].StartAddress)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNetworkDirectArgs;\nimport com.pulumi.vcd.inputs.GetExternalNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var net = VcdFunctions.getNetworkDirect(GetNetworkDirectArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .name(\"my-net\")\n            .build());\n\n        ctx.export(\"externalNetwork\", net.applyValue(getNetworkDirectResult -\u003e getNetworkDirectResult.externalNetwork()));\n        final var externalNetwork1 = VcdFunctions.getExternalNetwork(GetExternalNetworkArgs.builder()\n            .name(net.applyValue(getNetworkDirectResult -\u003e getNetworkDirectResult.externalNetwork()))\n            .build());\n\n        ctx.export(\"gateway\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].gateway()));\n        ctx.export(\"externalNetworkGateway\", net.applyValue(getNetworkDirectResult -\u003e getNetworkDirectResult.externalNetworkGateway()));\n        ctx.export(\"netmask\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].netmask()));\n        ctx.export(\"externalNetworkNetmask\", net.applyValue(getNetworkDirectResult -\u003e getNetworkDirectResult.externalNetworkNetmask()));\n        ctx.export(\"DNS\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].dns1()));\n        ctx.export(\"externalNetworkDns\", net.applyValue(getNetworkDirectResult -\u003e getNetworkDirectResult.externalNetworkDns1()));\n        ctx.export(\"externalIp\", externalNetwork1.applyValue(getExternalNetworkResult -\u003e getExternalNetworkResult.ipScopes()[0].staticIpPools()[0].startAddress()));\n    }\n}\n```\n```yaml\nvariables:\n  net:\n    fn::invoke:\n      function: vcd:getNetworkDirect\n      arguments:\n        org: my-org\n        vdc: my-vdc\n        name: my-net\n  externalNetwork1:\n    fn::invoke:\n      function: vcd:getExternalNetwork\n      arguments:\n        name: ${net.externalNetwork}\noutputs:\n  # Get the name of the external network from the data source\n  # and use it to establish a second data source\n  externalNetwork: ${net.externalNetwork}\n  # From the second data source we extract the basic networking info\n  gateway: ${externalNetwork1.ipScopes[0].gateway}\n  # equivalent to\n  externalNetworkGateway: ${net.externalNetworkGateway}\n  netmask: ${externalNetwork1.ipScopes[0].netmask}\n  # equivalent to\n  externalNetworkNetmask: ${net.externalNetworkNetmask}\n  DNS: ${externalNetwork1.ipScopes[0].dns1}\n  # equivalent to\n  externalNetworkDns: ${net.externalNetworkDns1}\n  externalIp: ${externalNetwork1.ipScopes[0].staticIpPools[0].startAddress}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n(Supported in provider *v2.9+*)\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n* `ip` - (Optional) matches the IP of the resource using a regular expression.\n* `metadata` - (Optional) One or more parameters that will match metadata contents.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkDirect.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkDirectFilter:getNetworkDirectFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkDirect.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "externalNetwork": {
                        "description": "The name of the external network.\n",
                        "type": "string"
                    },
                    "externalNetworkDns1": {
                        "type": "string"
                    },
                    "externalNetworkDns2": {
                        "type": "string"
                    },
                    "externalNetworkDnsSuffix": {
                        "type": "string"
                    },
                    "externalNetworkGateway": {
                        "type": "string"
                    },
                    "externalNetworkNetmask": {
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkDirectFilter:getNetworkDirectFilter"
                    },
                    "href": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkDirectMetadataEntry:getNetworkDirectMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "shared": {
                        "description": "Defines if this network is shared between multiple vDCs in the vOrg.\n",
                        "type": "boolean"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "externalNetwork",
                    "externalNetworkDns1",
                    "externalNetworkDns2",
                    "externalNetworkDnsSuffix",
                    "externalNetworkGateway",
                    "externalNetworkNetmask",
                    "href",
                    "metadata",
                    "metadataEntries",
                    "shared",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNetworkIsolated:getNetworkIsolated": {
            "description": "Provides a VMware Cloud Director Org VDC isolated Network data source. This can be used to reference\ninternal networks for vApps to connect. This network is not attached to external networks or routers.\n\nSupported in provider *v2.5+*\n\n\u003e **Note:** This data source supports only NSX-V backed Org VDC networks.\nPlease use newer [`vcd.NetworkIsolatedV2`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/network_isolated_v2)\ndata source which is compatible with NSX-T.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkIsolated.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkIsolatedFilter:getNetworkIsolatedFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkIsolated.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "dhcpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkIsolatedDhcpPool:getNetworkIsolatedDhcpPool"
                        },
                        "type": "array"
                    },
                    "dns1": {
                        "type": "string"
                    },
                    "dns2": {
                        "type": "string"
                    },
                    "dnsSuffix": {
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkIsolatedFilter:getNetworkIsolatedFilter"
                    },
                    "gateway": {
                        "type": "string"
                    },
                    "href": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkIsolatedMetadataEntry:getNetworkIsolatedMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "netmask": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "shared": {
                        "type": "boolean"
                    },
                    "staticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkIsolatedStaticIpPool:getNetworkIsolatedStaticIpPool"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "dhcpPools",
                    "dns1",
                    "dns2",
                    "dnsSuffix",
                    "gateway",
                    "href",
                    "metadata",
                    "metadataEntries",
                    "netmask",
                    "shared",
                    "staticIpPools",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNetworkIsolatedV2:getNetworkIsolatedV2": {
            "description": "Provides a VMware Cloud Director Org VDC isolated Network data source to read data or reference existing network.\n\nSupported in provider *v3.2+* for both NSX-T and NSX-V VDCs.\n\n## Example Usage\n\n### Looking Up Isolated Network In VDC)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getOrgVdc({\n    org: \"my-org\",\n    name: \"main-edge\",\n});\nconst net = main.then(main =\u003e vcd.getNetworkIsolatedV2({\n    org: \"my-org\",\n    ownerId: main.id,\n    name: \"my-net\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_org_vdc(org=\"my-org\",\n    name=\"main-edge\")\nnet = vcd.get_network_isolated_v2(org=\"my-org\",\n    owner_id=main.id,\n    name=\"my-net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-edge\",\n    });\n\n    var net = Vcd.GetNetworkIsolatedV2.Invoke(new()\n    {\n        Org = \"my-org\",\n        OwnerId = main.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"my-net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"main-edge\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNetworkIsolatedV2(ctx, \u0026vcd.LookupNetworkIsolatedV2Args{\n\t\t\tOrg:     pulumi.StringRef(\"my-org\"),\n\t\t\tOwnerId: pulumi.StringRef(main.Id),\n\t\t\tName:    pulumi.StringRef(\"my-net\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNetworkIsolatedV2Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-edge\")\n            .build());\n\n        final var net = VcdFunctions.getNetworkIsolatedV2(GetNetworkIsolatedV2Args.builder()\n            .org(\"my-org\")\n            .ownerId(main.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"my-net\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: my-org\n        name: main-edge\n  net:\n    fn::invoke:\n      function: vcd:getNetworkIsolatedV2\n      arguments:\n        org: my-org\n        ownerId: ${main.id}\n        name: my-net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Looking Up Isolated Network In VDC Group)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getVdcGroup({\n    org: \"my-org\",\n    name: \"main-group\",\n});\nconst net = main.then(main =\u003e vcd.getNetworkIsolatedV2({\n    org: \"my-org\",\n    ownerId: main.id,\n    name: \"my-net\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_vdc_group(org=\"my-org\",\n    name=\"main-group\")\nnet = vcd.get_network_isolated_v2(org=\"my-org\",\n    owner_id=main.id,\n    name=\"my-net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-group\",\n    });\n\n    var net = Vcd.GetNetworkIsolatedV2.Invoke(new()\n    {\n        Org = \"my-org\",\n        OwnerId = main.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"my-net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"main-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNetworkIsolatedV2(ctx, \u0026vcd.LookupNetworkIsolatedV2Args{\n\t\t\tOrg:     pulumi.StringRef(\"my-org\"),\n\t\t\tOwnerId: pulumi.StringRef(main.Id),\n\t\t\tName:    pulumi.StringRef(\"my-net\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNetworkIsolatedV2Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-group\")\n            .build());\n\n        final var net = VcdFunctions.getNetworkIsolatedV2(GetNetworkIsolatedV2Args.builder()\n            .org(\"my-org\")\n            .ownerId(main.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"my-net\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: my-org\n        name: main-group\n  net:\n    fn::invoke:\n      function: vcd:getNetworkIsolatedV2\n      arguments:\n        org: my-org\n        ownerId: ${main.id}\n        name: my-net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n* `ip` - (Optional) matches the IP of the resource using a regular expression.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkIsolatedV2.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkIsolatedV2Filter:getNetworkIsolatedV2Filter",
                        "description": "Retrieves the data source using one or more filter parameters. **Note**\nfilters do not support searching for networks in VDC Groups.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkIsolatedV2.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "dns1": {
                        "type": "string"
                    },
                    "dns2": {
                        "type": "string"
                    },
                    "dnsSuffix": {
                        "type": "string"
                    },
                    "dualStackEnabled": {
                        "type": "boolean"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkIsolatedV2Filter:getNetworkIsolatedV2Filter"
                    },
                    "gateway": {
                        "type": "string"
                    },
                    "guestVlanAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isShared": {
                        "type": "boolean"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkIsolatedV2MetadataEntry:getNetworkIsolatedV2MetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerId": {
                        "type": "string"
                    },
                    "prefixLength": {
                        "type": "integer"
                    },
                    "secondaryGateway": {
                        "type": "string"
                    },
                    "secondaryPrefixLength": {
                        "type": "string"
                    },
                    "secondaryStaticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkIsolatedV2SecondaryStaticIpPool:getNetworkIsolatedV2SecondaryStaticIpPool"
                        },
                        "type": "array"
                    },
                    "staticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkIsolatedV2StaticIpPool:getNetworkIsolatedV2StaticIpPool"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "dns1",
                    "dns2",
                    "dnsSuffix",
                    "dualStackEnabled",
                    "gateway",
                    "guestVlanAllowed",
                    "isShared",
                    "metadata",
                    "metadataEntries",
                    "ownerId",
                    "prefixLength",
                    "secondaryGateway",
                    "secondaryPrefixLength",
                    "secondaryStaticIpPools",
                    "staticIpPools",
                    "vdc",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNetworkPool:getNetworkPool": {
            "description": "Provides a data source for a network pool attached to a VCD.\n\nSupported in provider *v3.10+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst np1 = vcd.getNetworkPool({\n    name: \"NSX-T Overlay 1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnp1 = vcd.get_network_pool(name=\"NSX-T Overlay 1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var np1 = Vcd.GetNetworkPool.Invoke(new()\n    {\n        Name = \"NSX-T Overlay 1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNetworkPool(ctx, \u0026vcd.LookupNetworkPoolArgs{\n\t\t\tName: \"NSX-T Overlay 1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNetworkPoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var np1 = VcdFunctions.getNetworkPool(GetNetworkPoolArgs.builder()\n            .name(\"NSX-T Overlay 1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  np1:\n    fn::invoke:\n      function: vcd:getNetworkPool\n      arguments:\n        name: NSX-T Overlay 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkPool.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "network pool name.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkPool.\n",
                "properties": {
                    "backings": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkPoolBacking:getNetworkPoolBacking"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkProviderId": {
                        "type": "string"
                    },
                    "networkProviderName": {
                        "type": "string"
                    },
                    "networkProviderType": {
                        "type": "string"
                    },
                    "promiscuousMode": {
                        "type": "boolean"
                    },
                    "status": {
                        "type": "string"
                    },
                    "totalBackingsCount": {
                        "type": "integer"
                    },
                    "type": {
                        "type": "string"
                    },
                    "usedBackingsCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "backings",
                    "description",
                    "name",
                    "networkProviderId",
                    "networkProviderName",
                    "networkProviderType",
                    "promiscuousMode",
                    "status",
                    "totalBackingsCount",
                    "type",
                    "usedBackingsCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNetworkRouted:getNetworkRouted": {
            "description": "Provides a VMware Cloud Director Org VDC routed Network data source. This can be used to reference internal networks for vApps to connect.\n\nSupported in provider *v2.5+*\n\n\u003e **Note:** This data source supports only NSX-V backed Org VDC networks.\nPlease use newer [`vcd.NetworkRoutedV2`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/network_routed_v2)\ndata source which is compatible with NSX-T.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkRouted.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkRoutedFilter:getNetworkRoutedFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkRouted.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "dhcpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkRoutedDhcpPool:getNetworkRoutedDhcpPool"
                        },
                        "type": "array"
                    },
                    "dns1": {
                        "type": "string"
                    },
                    "dns2": {
                        "type": "string"
                    },
                    "dnsSuffix": {
                        "type": "string"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkRoutedFilter:getNetworkRoutedFilter"
                    },
                    "gateway": {
                        "type": "string"
                    },
                    "href": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "interfaceType": {
                        "type": "string"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkRoutedMetadataEntry:getNetworkRoutedMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "netmask": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "shared": {
                        "type": "boolean"
                    },
                    "staticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkRoutedStaticIpPool:getNetworkRoutedStaticIpPool"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "dhcpPools",
                    "dns1",
                    "dns2",
                    "dnsSuffix",
                    "edgeGateway",
                    "gateway",
                    "href",
                    "interfaceType",
                    "metadata",
                    "metadataEntries",
                    "netmask",
                    "shared",
                    "staticIpPools",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNetworkRoutedV2:getNetworkRoutedV2": {
            "description": "Provides a VMware Cloud Director Org VDC routed Network data source to read data or reference  existing network\n(backed by NSX-T or NSX-V).\n\nSupported in provider *v3.2+* for both NSX-T and NSX-V VDCs.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    name: \"main-edge\",\n});\nconst net = main.then(main =\u003e vcd.getNetworkRoutedV2({\n    org: \"my-org\",\n    edgeGatewayId: main.id,\n    name: \"my-net\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    name=\"main-edge\")\nnet = vcd.get_network_routed_v2(org=\"my-org\",\n    edge_gateway_id=main.id,\n    name=\"my-net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-edge\",\n    });\n\n    var net = Vcd.GetNetworkRoutedV2.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = main.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n        Name = \"my-net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"main-edge\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNetworkRoutedV2(ctx, \u0026vcd.LookupNetworkRoutedV2Args{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: pulumi.StringRef(main.Id),\n\t\t\tName:          pulumi.StringRef(\"my-net\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNetworkRoutedV2Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-edge\")\n            .build());\n\n        final var net = VcdFunctions.getNetworkRoutedV2(GetNetworkRoutedV2Args.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(main.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .name(\"my-net\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        name: main-edge\n  net:\n    fn::invoke:\n      function: vcd:getNetworkRoutedV2\n      arguments:\n        org: my-org\n        edgeGatewayId: ${main.id}\n        name: my-net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n* `ip` - (Optional) matches the IP of the resource using a regular expression.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkRoutedV2.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "Replaces `vdc` field and helps to identify exact Org\nNetwork\n"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkRoutedV2Filter:getNetworkRoutedV2Filter",
                        "description": "Retrieves the data source using one or more filter parameters. **Note**\nfilters do not support searching for networks in VDC Groups.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. Routed networks will inherit VDC from parent Edge Gateway.",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkRoutedV2.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "dns1": {
                        "type": "string"
                    },
                    "dns2": {
                        "type": "string"
                    },
                    "dnsSuffix": {
                        "type": "string"
                    },
                    "dualStackEnabled": {
                        "type": "boolean"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getNetworkRoutedV2Filter:getNetworkRoutedV2Filter"
                    },
                    "gateway": {
                        "type": "string"
                    },
                    "guestVlanAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "interfaceType": {
                        "type": "string"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkRoutedV2MetadataEntry:getNetworkRoutedV2MetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerId": {
                        "description": "Parent VDC or VDC Group ID.\n",
                        "type": "string"
                    },
                    "prefixLength": {
                        "type": "integer"
                    },
                    "routeAdvertisementEnabled": {
                        "type": "boolean"
                    },
                    "secondaryGateway": {
                        "type": "string"
                    },
                    "secondaryPrefixLength": {
                        "type": "string"
                    },
                    "secondaryStaticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkRoutedV2SecondaryStaticIpPool:getNetworkRoutedV2SecondaryStaticIpPool"
                        },
                        "type": "array"
                    },
                    "staticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNetworkRoutedV2StaticIpPool:getNetworkRoutedV2StaticIpPool"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. Routed networks will inherit VDC from parent Edge Gateway.",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "dns1",
                    "dns2",
                    "dnsSuffix",
                    "dualStackEnabled",
                    "edgeGatewayId",
                    "gateway",
                    "guestVlanAllowed",
                    "interfaceType",
                    "metadata",
                    "metadataEntries",
                    "ownerId",
                    "prefixLength",
                    "routeAdvertisementEnabled",
                    "secondaryGateway",
                    "secondaryPrefixLength",
                    "secondaryStaticIpPools",
                    "staticIpPools",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbCloud:getNsxtAlbCloud": {
            "description": "Supported in provider *v3.4+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a data source to manage ALB Clouds for Providers. An NSX-T Cloud is a service provider-level construct that\nconsists of an NSX-T Manager and an NSX-T Data Center transport zone.\n\n\u003e Only `System Administrator` can use this data source.\n\n\u003e VCD 10.3.0 has a caching bug which prevents listing importable clouds immediately (retrieved using\n[`vcd.getNsxtAlbImportableCloud`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_alb_importable_cloud)) after ALB\nController is created. This data should be available 15 minutes after the Controller is created.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst first = vcd.getNsxtAlbCloud({\n    name: \"cloud-one\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nfirst = vcd.get_nsxt_alb_cloud(name=\"cloud-one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var first = Vcd.GetNsxtAlbCloud.Invoke(new()\n    {\n        Name = \"cloud-one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtAlbCloud(ctx, \u0026vcd.LookupNsxtAlbCloudArgs{\n\t\t\tName: \"cloud-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAlbCloudArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var first = VcdFunctions.getNsxtAlbCloud(GetNsxtAlbCloudArgs.builder()\n            .name(\"cloud-one\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  first:\n    fn::invoke:\n      function: vcd:getNsxtAlbCloud\n      arguments:\n        name: cloud-one\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbCloud.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of ALB Cloud\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbCloud.\n",
                "properties": {
                    "controllerId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "healthMessage": {
                        "type": "string"
                    },
                    "healthStatus": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "importableCloudId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkPoolId": {
                        "type": "string"
                    },
                    "networkPoolName": {
                        "type": "string"
                    }
                },
                "required": [
                    "controllerId",
                    "description",
                    "healthMessage",
                    "healthStatus",
                    "importableCloudId",
                    "name",
                    "networkPoolId",
                    "networkPoolName",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbController:getNsxtAlbController": {
            "description": "Supported in provider *v3.4+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a data source to read ALB Controller for Providers. It helps to integrate VMware Cloud Director with\nAvi Load Balancer deployment. Controller instances are registered with VMware Cloud Director instance.\nController instances serve as a central control plane for the load-balancing services provided by Avi Load\nBalancer.\n\n\u003e Only `System Administrator` can use this data source.\n\n\u003e VCD 10.3.0 has a caching bug which prevents listing importable clouds immediately (retrieved using\n[`vcd.getNsxtAlbImportableCloud`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_alb_importable_cloud)) after ALB\nController is created. This data should be available 15 minutes after the Controller is created.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst first = vcd.getNsxtAlbController({\n    name: \"avi controller\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nfirst = vcd.get_nsxt_alb_controller(name=\"avi controller\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var first = Vcd.GetNsxtAlbController.Invoke(new()\n    {\n        Name = \"avi controller\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtAlbController(ctx, \u0026vcd.LookupNsxtAlbControllerArgs{\n\t\t\tName: \"avi controller\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAlbControllerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var first = VcdFunctions.getNsxtAlbController(GetNsxtAlbControllerArgs.builder()\n            .name(\"avi controller\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  first:\n    fn::invoke:\n      function: vcd:getNsxtAlbController\n      arguments:\n        name: avi controller\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbController.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Unique name of existing ALB Controller.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbController.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "licenseType": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "licenseType",
                    "name",
                    "url",
                    "username",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbEdgegatewayServiceEngineGroup:getNsxtAlbEdgegatewayServiceEngineGroup": {
            "description": "Supported in provider *v3.5+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a datasource to read ALB Service Engine Group assignment to NSX-T Edge Gateway.\n\n## Example Usage\n\n### Referencing Service Engine Group By ID)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    vdc: \"nsxt-vdc\",\n    name: \"nsxt-gw\",\n});\nconst first = vcd.getNsxtAlbServiceEngineGroup({\n    name: \"first-se\",\n});\nconst test = Promise.all([existing, first]).then(([existing, first]) =\u003e vcd.getNsxtAlbEdgegatewayServiceEngineGroup({\n    edgeGatewayId: existing.id,\n    serviceEngineGroupId: first.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    vdc=\"nsxt-vdc\",\n    name=\"nsxt-gw\")\nfirst = vcd.get_nsxt_alb_service_engine_group(name=\"first-se\")\ntest = vcd.get_nsxt_alb_edgegateway_service_engine_group(edge_gateway_id=existing.id,\n    service_engine_group_id=first.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"nsxt-vdc\",\n        Name = \"nsxt-gw\",\n    });\n\n    var first = Vcd.GetNsxtAlbServiceEngineGroup.Invoke(new()\n    {\n        Name = \"first-se\",\n    });\n\n    var test = Vcd.GetNsxtAlbEdgegatewayServiceEngineGroup.Invoke(new()\n    {\n        EdgeGatewayId = existing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n        ServiceEngineGroupId = first.Apply(getNsxtAlbServiceEngineGroupResult =\u003e getNsxtAlbServiceEngineGroupResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"nsxt-vdc\"),\n\t\t\tName: \"nsxt-gw\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfirst, err := vcd.LookupNsxtAlbServiceEngineGroup(ctx, \u0026vcd.LookupNsxtAlbServiceEngineGroupArgs{\n\t\t\tName: \"first-se\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtAlbEdgegatewayServiceEngineGroup(ctx, \u0026vcd.LookupNsxtAlbEdgegatewayServiceEngineGroupArgs{\n\t\t\tEdgeGatewayId:        existing.Id,\n\t\t\tServiceEngineGroupId: pulumi.StringRef(first.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAlbServiceEngineGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAlbEdgegatewayServiceEngineGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"nsxt-vdc\")\n            .name(\"nsxt-gw\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtAlbServiceEngineGroup(GetNsxtAlbServiceEngineGroupArgs.builder()\n            .name(\"first-se\")\n            .build());\n\n        final var test = VcdFunctions.getNsxtAlbEdgegatewayServiceEngineGroup(GetNsxtAlbEdgegatewayServiceEngineGroupArgs.builder()\n            .edgeGatewayId(existing.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .serviceEngineGroupId(first.applyValue(getNsxtAlbServiceEngineGroupResult -\u003e getNsxtAlbServiceEngineGroupResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        vdc: nsxt-vdc\n        name: nsxt-gw\n  first:\n    fn::invoke:\n      function: vcd:getNsxtAlbServiceEngineGroup\n      arguments:\n        name: first-se\n  test:\n    fn::invoke:\n      function: vcd:getNsxtAlbEdgegatewayServiceEngineGroup\n      arguments:\n        edgeGatewayId: ${existing.id}\n        serviceEngineGroupId: ${first.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Referencing Service Engine Group By Name)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    vdc: \"nsxt-vdc\",\n    name: \"nsxt-gw\",\n});\nconst test = existing.then(existing =\u003e vcd.getNsxtAlbEdgegatewayServiceEngineGroup({\n    edgeGatewayId: existing.id,\n    serviceEngineGroupName: \"known-service-engine-group-name\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    vdc=\"nsxt-vdc\",\n    name=\"nsxt-gw\")\ntest = vcd.get_nsxt_alb_edgegateway_service_engine_group(edge_gateway_id=existing.id,\n    service_engine_group_name=\"known-service-engine-group-name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"nsxt-vdc\",\n        Name = \"nsxt-gw\",\n    });\n\n    var test = Vcd.GetNsxtAlbEdgegatewayServiceEngineGroup.Invoke(new()\n    {\n        EdgeGatewayId = existing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n        ServiceEngineGroupName = \"known-service-engine-group-name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"nsxt-vdc\"),\n\t\t\tName: \"nsxt-gw\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtAlbEdgegatewayServiceEngineGroup(ctx, \u0026vcd.LookupNsxtAlbEdgegatewayServiceEngineGroupArgs{\n\t\t\tEdgeGatewayId:          existing.Id,\n\t\t\tServiceEngineGroupName: pulumi.StringRef(\"known-service-engine-group-name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAlbEdgegatewayServiceEngineGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"nsxt-vdc\")\n            .name(\"nsxt-gw\")\n            .build());\n\n        final var test = VcdFunctions.getNsxtAlbEdgegatewayServiceEngineGroup(GetNsxtAlbEdgegatewayServiceEngineGroupArgs.builder()\n            .edgeGatewayId(existing.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .serviceEngineGroupName(\"known-service-engine-group-name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        vdc: nsxt-vdc\n        name: nsxt-gw\n  test:\n    fn::invoke:\n      function: vcd:getNsxtAlbEdgegatewayServiceEngineGroup\n      arguments:\n        edgeGatewayId: ${existing.id}\n        serviceEngineGroupName: known-service-engine-group-name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbEdgegatewayServiceEngineGroup.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceEngineGroupId": {
                        "type": "string",
                        "description": "An ID of NSX-T Service Engine Group. Can be looked up using\n[vcd.NsxtAlbServiceEngineGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_alb_service_engine_group) data\nsource. **Note** Either `service_engine_group_name` or `service_engine_group_id` require it.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceEngineGroupName": {
                        "type": "string",
                        "description": "A Name of NSX-T Service Engine Group. **Note** Either\n`service_engine_group_name` or `service_engine_group_id` require it.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbEdgegatewayServiceEngineGroup.\n",
                "properties": {
                    "deployedVirtualServices": {
                        "type": "integer"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "maxVirtualServices": {
                        "type": "integer"
                    },
                    "org": {
                        "type": "string"
                    },
                    "reservedVirtualServices": {
                        "type": "string"
                    },
                    "serviceEngineGroupId": {
                        "type": "string"
                    },
                    "serviceEngineGroupName": {
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field",
                        "type": "string"
                    }
                },
                "required": [
                    "deployedVirtualServices",
                    "edgeGatewayId",
                    "maxVirtualServices",
                    "reservedVirtualServices",
                    "serviceEngineGroupId",
                    "serviceEngineGroupName",
                    "vdc",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbImportableCloud:getNsxtAlbImportableCloud": {
            "description": "Supported in provider *v3.4+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a data source to reference existing ALB Importable Clouds. An NSX-T Importable Cloud is a reference to a\nCloud configured in ALB Controller.\n\n\u003e Only `System Administrator` can use this data source.\n\n\u003e VCD 10.3.0 has a caching bug which prevents listing importable clouds immediately after [ALB\nController](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_alb_controller) is created. This data should be\navailable 15 minutes after the Controller is created.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst first = vcd.getNsxtAlbController({\n    name: \"alb-controller\",\n});\nconst cld = first.then(first =\u003e vcd.getNsxtAlbImportableCloud({\n    name: \"NSXT Importable Cloud\",\n    controllerId: first.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nfirst = vcd.get_nsxt_alb_controller(name=\"alb-controller\")\ncld = vcd.get_nsxt_alb_importable_cloud(name=\"NSXT Importable Cloud\",\n    controller_id=first.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var first = Vcd.GetNsxtAlbController.Invoke(new()\n    {\n        Name = \"alb-controller\",\n    });\n\n    var cld = Vcd.GetNsxtAlbImportableCloud.Invoke(new()\n    {\n        Name = \"NSXT Importable Cloud\",\n        ControllerId = first.Apply(getNsxtAlbControllerResult =\u003e getNsxtAlbControllerResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfirst, err := vcd.LookupNsxtAlbController(ctx, \u0026vcd.LookupNsxtAlbControllerArgs{\n\t\t\tName: \"alb-controller\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtAlbImportableCloud(ctx, \u0026vcd.GetNsxtAlbImportableCloudArgs{\n\t\t\tName:         \"NSXT Importable Cloud\",\n\t\t\tControllerId: first.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAlbControllerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAlbImportableCloudArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var first = VcdFunctions.getNsxtAlbController(GetNsxtAlbControllerArgs.builder()\n            .name(\"alb-controller\")\n            .build());\n\n        final var cld = VcdFunctions.getNsxtAlbImportableCloud(GetNsxtAlbImportableCloudArgs.builder()\n            .name(\"NSXT Importable Cloud\")\n            .controllerId(first.applyValue(getNsxtAlbControllerResult -\u003e getNsxtAlbControllerResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  first:\n    fn::invoke:\n      function: vcd:getNsxtAlbController\n      arguments:\n        name: alb-controller\n  cld:\n    fn::invoke:\n      function: vcd:getNsxtAlbImportableCloud\n      arguments:\n        name: NSXT Importable Cloud\n        controllerId: ${first.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbImportableCloud.\n",
                "properties": {
                    "controllerId": {
                        "type": "string",
                        "description": "ALB Controller ID\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of ALB Importable Cloud\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "controllerId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbImportableCloud.\n",
                "properties": {
                    "alreadyImported": {
                        "description": "boolean value which displays if the ALB Importable Cloud is already consumed\n",
                        "type": "boolean"
                    },
                    "controllerId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkPoolId": {
                        "description": "backing network pool ID\n",
                        "type": "string"
                    },
                    "networkPoolName": {
                        "description": "backing network pool ID\n",
                        "type": "string"
                    },
                    "transportZoneName": {
                        "description": "backing transport zone name\n",
                        "type": "string"
                    }
                },
                "required": [
                    "alreadyImported",
                    "controllerId",
                    "name",
                    "networkPoolId",
                    "networkPoolName",
                    "transportZoneName",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbPool:getNsxtAlbPool": {
            "description": "Supported in provider *v3.5+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a data source to read ALB Pools for particular NSX-T Edge Gateway. Pools maintain the list of servers\nassigned to them and perform health monitoring, load balancing, persistence. A pool may only be used or referenced by\nonly one virtual service at a time.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    vdc: \"nsxt-vdc\",\n    name: \"nsxt-gw\",\n});\nconst test = vcd.getNsxtAlbPool({\n    org: \"my-org\",\n    edgeGatewayId: existingVcdNsxtAlbSettings.edgeGatewayId,\n    name: \"existing-alb-pool-1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    vdc=\"nsxt-vdc\",\n    name=\"nsxt-gw\")\ntest = vcd.get_nsxt_alb_pool(org=\"my-org\",\n    edge_gateway_id=existing_vcd_nsxt_alb_settings[\"edgeGatewayId\"],\n    name=\"existing-alb-pool-1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"nsxt-vdc\",\n        Name = \"nsxt-gw\",\n    });\n\n    var test = Vcd.GetNsxtAlbPool.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = existingVcdNsxtAlbSettings.EdgeGatewayId,\n        Name = \"existing-alb-pool-1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"nsxt-vdc\"),\n\t\t\tName: \"nsxt-gw\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtAlbPool(ctx, \u0026vcd.LookupNsxtAlbPoolArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: existingVcdNsxtAlbSettings.EdgeGatewayId,\n\t\t\tName:          \"existing-alb-pool-1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAlbPoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"nsxt-vdc\")\n            .name(\"nsxt-gw\")\n            .build());\n\n        final var test = VcdFunctions.getNsxtAlbPool(GetNsxtAlbPoolArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(existingVcdNsxtAlbSettings.edgeGatewayId())\n            .name(\"existing-alb-pool-1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        vdc: nsxt-vdc\n        name: nsxt-gw\n  test:\n    fn::invoke:\n      function: vcd:getNsxtAlbPool\n      arguments:\n        org: my-org\n        edgeGatewayId: ${existingVcdNsxtAlbSettings.edgeGatewayId}\n        name: existing-alb-pool-1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbPool.\n",
                "properties": {
                    "associatedVirtualServiceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of existing ALB Pool.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "passiveMonitoringEnabled": {
                        "type": "boolean"
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbPool.\n",
                "properties": {
                    "algorithm": {
                        "type": "string"
                    },
                    "associatedVirtualServiceIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "associatedVirtualServices": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "caCertificateIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "cnCheckEnabled": {
                        "type": "boolean"
                    },
                    "defaultPort": {
                        "type": "integer"
                    },
                    "description": {
                        "type": "string"
                    },
                    "domainNames": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "enabledMemberCount": {
                        "type": "integer"
                    },
                    "gracefulTimeoutPeriod": {
                        "type": "integer"
                    },
                    "healthMessage": {
                        "type": "string"
                    },
                    "healthMonitors": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAlbPoolHealthMonitor:getNsxtAlbPoolHealthMonitor"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "memberCount": {
                        "type": "integer"
                    },
                    "memberGroupId": {
                        "type": "string"
                    },
                    "members": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAlbPoolMember:getNsxtAlbPoolMember"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "passiveMonitoringEnabled": {
                        "type": "boolean"
                    },
                    "persistenceProfiles": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAlbPoolPersistenceProfile:getNsxtAlbPoolPersistenceProfile"
                        },
                        "type": "array"
                    },
                    "sslEnabled": {
                        "type": "boolean"
                    },
                    "upMemberCount": {
                        "type": "integer"
                    },
                    "vdc": {
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field",
                        "type": "string"
                    }
                },
                "required": [
                    "algorithm",
                    "associatedVirtualServices",
                    "caCertificateIds",
                    "cnCheckEnabled",
                    "defaultPort",
                    "description",
                    "domainNames",
                    "edgeGatewayId",
                    "enabled",
                    "enabledMemberCount",
                    "gracefulTimeoutPeriod",
                    "healthMessage",
                    "healthMonitors",
                    "members",
                    "memberCount",
                    "memberGroupId",
                    "name",
                    "persistenceProfiles",
                    "sslEnabled",
                    "upMemberCount",
                    "vdc",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbServiceEngineGroup:getNsxtAlbServiceEngineGroup": {
            "description": "Supported in provider *v3.4+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a data source to read ALB Service Engine Groups. A Service Engine Group is an isolation domain that also\ndefines shared service engine properties, such as size, network access, and failover. Resources in a service engine\ngroup can be used for different virtual services, depending on your tenant needs. These resources cannot be shared\nbetween different service engine groups.\n\n\u003e Only `System Administrator` can use this data source.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst demo = vcd.getNsxtAlbServiceEngineGroup({\n    name: \"configured-service-engine-group\",\n    syncOnRefresh: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ndemo = vcd.get_nsxt_alb_service_engine_group(name=\"configured-service-engine-group\",\n    sync_on_refresh=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demo = Vcd.GetNsxtAlbServiceEngineGroup.Invoke(new()\n    {\n        Name = \"configured-service-engine-group\",\n        SyncOnRefresh = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtAlbServiceEngineGroup(ctx, \u0026vcd.LookupNsxtAlbServiceEngineGroupArgs{\n\t\t\tName:          \"configured-service-engine-group\",\n\t\t\tSyncOnRefresh: pulumi.BoolRef(false),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAlbServiceEngineGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var demo = VcdFunctions.getNsxtAlbServiceEngineGroup(GetNsxtAlbServiceEngineGroupArgs.builder()\n            .name(\"configured-service-engine-group\")\n            .syncOnRefresh(false)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  demo:\n    fn::invoke:\n      function: vcd:getNsxtAlbServiceEngineGroup\n      arguments:\n        name: configured-service-engine-group\n        syncOnRefresh: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbServiceEngineGroup.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of Service Engine Group.\n"
                    },
                    "overallocated": {
                        "type": "boolean"
                    },
                    "syncOnRefresh": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbServiceEngineGroup.\n",
                "properties": {
                    "albCloudId": {
                        "type": "string"
                    },
                    "deployedVirtualServices": {
                        "type": "integer"
                    },
                    "description": {
                        "type": "string"
                    },
                    "haMode": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "maxVirtualServices": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "overallocated": {
                        "type": "boolean"
                    },
                    "reservationModel": {
                        "type": "string"
                    },
                    "reservedVirtualServices": {
                        "type": "integer"
                    },
                    "supportedFeatureSet": {
                        "type": "string"
                    },
                    "syncOnRefresh": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "albCloudId",
                    "deployedVirtualServices",
                    "description",
                    "haMode",
                    "maxVirtualServices",
                    "name",
                    "reservationModel",
                    "reservedVirtualServices",
                    "supportedFeatureSet",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbSettings:getNsxtAlbSettings": {
            "description": "Supported in provider *v3.5+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a data source to read ALB General Settings for particular NSX-T Edge Gateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    vdc: \"nsxt-vdc\",\n    name: \"nsxt-gw\",\n});\nconst test = existing.then(existing =\u003e vcd.getNsxtAlbSettings({\n    org: \"my-org\",\n    edgeGatewayId: existing.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    vdc=\"nsxt-vdc\",\n    name=\"nsxt-gw\")\ntest = vcd.get_nsxt_alb_settings(org=\"my-org\",\n    edge_gateway_id=existing.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"nsxt-vdc\",\n        Name = \"nsxt-gw\",\n    });\n\n    var test = Vcd.GetNsxtAlbSettings.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = existing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"nsxt-vdc\"),\n\t\t\tName: \"nsxt-gw\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtAlbSettings(ctx, \u0026vcd.LookupNsxtAlbSettingsArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: existing.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAlbSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"nsxt-vdc\")\n            .name(\"nsxt-gw\")\n            .build());\n\n        final var test = VcdFunctions.getNsxtAlbSettings(GetNsxtAlbSettingsArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(existing.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        vdc: nsxt-vdc\n        name: nsxt-gw\n  test:\n    fn::invoke:\n      function: vcd:getNsxtAlbSettings\n      arguments:\n        org: my-org\n        edgeGatewayId: ${existing.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbSettings.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceNetworkSpecification": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbSettings.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipv6ServiceNetworkSpecification": {
                        "type": "string"
                    },
                    "isActive": {
                        "type": "boolean"
                    },
                    "isTransparentModeEnabled": {
                        "type": "boolean"
                    },
                    "org": {
                        "type": "string"
                    },
                    "serviceNetworkSpecification": {
                        "type": "string"
                    },
                    "supportedFeatureSet": {
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field",
                        "type": "string"
                    }
                },
                "required": [
                    "edgeGatewayId",
                    "ipv6ServiceNetworkSpecification",
                    "isActive",
                    "isTransparentModeEnabled",
                    "serviceNetworkSpecification",
                    "supportedFeatureSet",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbVirtualService:getNsxtAlbVirtualService": {
            "description": "Supported in provider *v3.5+* and VCD 10.2+ with NSX-T and ALB.\n\nProvides a data source to read ALB Virtual services for particular NSX-T Edge Gateway. A virtual service\nadvertises an IP address and ports to the external world and listens for client traffic. When a virtual service receives\ntraffic, it directs it to members in ALB Pool.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    vdc: \"nsxt-vdc\",\n    name: \"nsxt-gw\",\n});\nconst test = vcd.getNsxtAlbVirtualService({\n    org: \"dainius\",\n    edgeGatewayId: existingVcdNsxtEdgegateway.id,\n    name: \"virutal-service-name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    vdc=\"nsxt-vdc\",\n    name=\"nsxt-gw\")\ntest = vcd.get_nsxt_alb_virtual_service(org=\"dainius\",\n    edge_gateway_id=existing_vcd_nsxt_edgegateway[\"id\"],\n    name=\"virutal-service-name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"nsxt-vdc\",\n        Name = \"nsxt-gw\",\n    });\n\n    var test = Vcd.GetNsxtAlbVirtualService.Invoke(new()\n    {\n        Org = \"dainius\",\n        EdgeGatewayId = existingVcdNsxtEdgegateway.Id,\n        Name = \"virutal-service-name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"nsxt-vdc\"),\n\t\t\tName: \"nsxt-gw\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtAlbVirtualService(ctx, \u0026vcd.LookupNsxtAlbVirtualServiceArgs{\n\t\t\tOrg:           pulumi.StringRef(\"dainius\"),\n\t\t\tEdgeGatewayId: existingVcdNsxtEdgegateway.Id,\n\t\t\tName:          \"virutal-service-name\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAlbVirtualServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"nsxt-vdc\")\n            .name(\"nsxt-gw\")\n            .build());\n\n        final var test = VcdFunctions.getNsxtAlbVirtualService(GetNsxtAlbVirtualServiceArgs.builder()\n            .org(\"dainius\")\n            .edgeGatewayId(existingVcdNsxtEdgegateway.id())\n            .name(\"virutal-service-name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        vdc: nsxt-vdc\n        name: nsxt-gw\n  test:\n    fn::invoke:\n      function: vcd:getNsxtAlbVirtualService\n      arguments:\n        org: dainius\n        edgeGatewayId: ${existingVcdNsxtEdgegateway.id}\n        name: virutal-service-name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbVirtualService.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of ALB Virtual Service\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbVirtualService.\n",
                "properties": {
                    "applicationProfileType": {
                        "type": "string"
                    },
                    "caCertificateId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipv6VirtualIpAddress": {
                        "type": "string"
                    },
                    "isTransparentModeEnabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "poolId": {
                        "type": "string"
                    },
                    "serviceEngineGroupId": {
                        "type": "string"
                    },
                    "servicePorts": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceServicePort:getNsxtAlbVirtualServiceServicePort"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field",
                        "type": "string"
                    },
                    "virtualIpAddress": {
                        "type": "string"
                    }
                },
                "required": [
                    "applicationProfileType",
                    "caCertificateId",
                    "description",
                    "edgeGatewayId",
                    "enabled",
                    "ipv6VirtualIpAddress",
                    "isTransparentModeEnabled",
                    "name",
                    "poolId",
                    "serviceEngineGroupId",
                    "servicePorts",
                    "vdc",
                    "virtualIpAddress",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpReqRules:getNsxtAlbVirtualServiceHttpReqRules": {
            "description": "Supported in provider *v3.14+* and VCD 10.5+ with NSX-T and ALB.\n\nProvides a data source to read ALB Service Engine Groups policies for HTTP requests. HTTP request \nrules modify requests before they are either forwarded to the application, used as a basis for \ncontent switching, or discarded.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst request_rules = vcd.getNsxtAlbVirtualServiceHttpReqRules({\n    virtualServiceId: test.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nrequest_rules = vcd.get_nsxt_alb_virtual_service_http_req_rules(virtual_service_id=test[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var request_rules = Vcd.GetNsxtAlbVirtualServiceHttpReqRules.Invoke(new()\n    {\n        VirtualServiceId = test.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtAlbVirtualServiceHttpReqRules(ctx, \u0026vcd.LookupNsxtAlbVirtualServiceHttpReqRulesArgs{\n\t\t\tVirtualServiceId: test.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAlbVirtualServiceHttpReqRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var request-rules = VcdFunctions.getNsxtAlbVirtualServiceHttpReqRules(GetNsxtAlbVirtualServiceHttpReqRulesArgs.builder()\n            .virtualServiceId(test.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  request-rules:\n    fn::invoke:\n      function: vcd:getNsxtAlbVirtualServiceHttpReqRules\n      arguments:\n        virtualServiceId: ${test.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbVirtualServiceHttpReqRules.\n",
                "properties": {
                    "virtualServiceId": {
                        "type": "string",
                        "description": "An ID of existing ALB Virtual Service.\n"
                    }
                },
                "type": "object",
                "required": [
                    "virtualServiceId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbVirtualServiceHttpReqRules.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "rules": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpReqRulesRule:getNsxtAlbVirtualServiceHttpReqRulesRule"
                        },
                        "type": "array"
                    },
                    "virtualServiceId": {
                        "type": "string"
                    }
                },
                "required": [
                    "rules",
                    "virtualServiceId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpRespRules:getNsxtAlbVirtualServiceHttpRespRules": {
            "description": "Supported in provider *v3.14+* and VCD 10.5+ with NSX-T and ALB.\n\nProvides a data source to read ALB Service Engine Groups policies for HTTP responses. HTTP response \nrules can be used to to evaluate and modify the response and response attributes that the\napplication returns.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst response_rules = vcd.getNsxtAlbVirtualServiceHttpRespRules({\n    virtualServiceId: test.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nresponse_rules = vcd.get_nsxt_alb_virtual_service_http_resp_rules(virtual_service_id=test[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var response_rules = Vcd.GetNsxtAlbVirtualServiceHttpRespRules.Invoke(new()\n    {\n        VirtualServiceId = test.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtAlbVirtualServiceHttpRespRules(ctx, \u0026vcd.LookupNsxtAlbVirtualServiceHttpRespRulesArgs{\n\t\t\tVirtualServiceId: test.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAlbVirtualServiceHttpRespRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var response-rules = VcdFunctions.getNsxtAlbVirtualServiceHttpRespRules(GetNsxtAlbVirtualServiceHttpRespRulesArgs.builder()\n            .virtualServiceId(test.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  response-rules:\n    fn::invoke:\n      function: vcd:getNsxtAlbVirtualServiceHttpRespRules\n      arguments:\n        virtualServiceId: ${test.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbVirtualServiceHttpRespRules.\n",
                "properties": {
                    "virtualServiceId": {
                        "type": "string",
                        "description": "An ID of existing ALB Virtual Service.\n"
                    }
                },
                "type": "object",
                "required": [
                    "virtualServiceId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbVirtualServiceHttpRespRules.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "rules": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpRespRulesRule:getNsxtAlbVirtualServiceHttpRespRulesRule"
                        },
                        "type": "array"
                    },
                    "virtualServiceId": {
                        "type": "string"
                    }
                },
                "required": [
                    "rules",
                    "virtualServiceId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAlbVirtualServiceHttpSecRules:getNsxtAlbVirtualServiceHttpSecRules": {
            "description": "Supported in provider *v3.14+* and VCD 10.5+ with NSX-T and ALB.\n\nProvides a data source to read ALB Service Engine Groups policies for HTTP requests. HTTP security \nrules allow users to configure allowing or denying certain requests, to close the TCP connection, \nto redirect a request to HTTPS, or to apply a rate limit.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst security_rules = vcd.getNsxtAlbVirtualServiceHttpSecRules({\n    virtualServiceId: test.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsecurity_rules = vcd.get_nsxt_alb_virtual_service_http_sec_rules(virtual_service_id=test[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var security_rules = Vcd.GetNsxtAlbVirtualServiceHttpSecRules.Invoke(new()\n    {\n        VirtualServiceId = test.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtAlbVirtualServiceHttpSecRules(ctx, \u0026vcd.LookupNsxtAlbVirtualServiceHttpSecRulesArgs{\n\t\t\tVirtualServiceId: test.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAlbVirtualServiceHttpSecRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var security-rules = VcdFunctions.getNsxtAlbVirtualServiceHttpSecRules(GetNsxtAlbVirtualServiceHttpSecRulesArgs.builder()\n            .virtualServiceId(test.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  security-rules:\n    fn::invoke:\n      function: vcd:getNsxtAlbVirtualServiceHttpSecRules\n      arguments:\n        virtualServiceId: ${test.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAlbVirtualServiceHttpSecRules.\n",
                "properties": {
                    "virtualServiceId": {
                        "type": "string",
                        "description": "An ID of existing ALB Virtual Service.\n"
                    }
                },
                "type": "object",
                "required": [
                    "virtualServiceId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAlbVirtualServiceHttpSecRules.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "rules": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAlbVirtualServiceHttpSecRulesRule:getNsxtAlbVirtualServiceHttpSecRulesRule"
                        },
                        "type": "array"
                    },
                    "virtualServiceId": {
                        "type": "string"
                    }
                },
                "required": [
                    "rules",
                    "virtualServiceId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtAppPortProfile:getNsxtAppPortProfile": {
            "description": "Supported in provider *v3.3+* and VCD 10.1+ with NSX-T backed VDCs.\n\nProvides a data source to read NSX-T Application Port Profiles. Application Port Profiles include a\ncombination of a protocol and a port, or a group of ports, that is used for Firewall and NAT\nservices on the Edge Gateway.\n\n## Example Usage\n\n### 1 (Find An Application Port Profile Defined By Provider)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst custom = vcd.getNsxtAppPortProfile({\n    org: \"System\",\n    contextId: first.id,\n    name: \"WINS\",\n    scope: \"PROVIDER\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ncustom = vcd.get_nsxt_app_port_profile(org=\"System\",\n    context_id=first[\"id\"],\n    name=\"WINS\",\n    scope=\"PROVIDER\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var custom = Vcd.GetNsxtAppPortProfile.Invoke(new()\n    {\n        Org = \"System\",\n        ContextId = first.Id,\n        Name = \"WINS\",\n        Scope = \"PROVIDER\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtAppPortProfile(ctx, \u0026vcd.LookupNsxtAppPortProfileArgs{\n\t\t\tOrg:       pulumi.StringRef(\"System\"),\n\t\t\tContextId: pulumi.StringRef(first.Id),\n\t\t\tName:      \"WINS\",\n\t\t\tScope:     \"PROVIDER\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtAppPortProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var custom = VcdFunctions.getNsxtAppPortProfile(GetNsxtAppPortProfileArgs.builder()\n            .org(\"System\")\n            .contextId(first.id())\n            .name(\"WINS\")\n            .scope(\"PROVIDER\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  custom:\n    fn::invoke:\n      function: vcd:getNsxtAppPortProfile\n      arguments:\n        org: System\n        contextId: ${first.id}\n        name: WINS\n        scope: PROVIDER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### 2 (Find An Application Port Profile Defined By Tenant In A VDC Group)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst g1 = vcd.getVdcGroup({\n    org: \"myOrg\",\n    name: \"myVDC\",\n});\nconst custom = g1.then(g1 =\u003e vcd.getNsxtAppPortProfile({\n    org: \"my-org\",\n    contextId: g1.id,\n    name: \"SSH-custom\",\n    scope: \"TENANT\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ng1 = vcd.get_vdc_group(org=\"myOrg\",\n    name=\"myVDC\")\ncustom = vcd.get_nsxt_app_port_profile(org=\"my-org\",\n    context_id=g1.id,\n    name=\"SSH-custom\",\n    scope=\"TENANT\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var g1 = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"myOrg\",\n        Name = \"myVDC\",\n    });\n\n    var custom = Vcd.GetNsxtAppPortProfile.Invoke(new()\n    {\n        Org = \"my-org\",\n        ContextId = g1.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"SSH-custom\",\n        Scope = \"TENANT\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tg1, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"myOrg\"),\n\t\t\tName: pulumi.StringRef(\"myVDC\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtAppPortProfile(ctx, \u0026vcd.LookupNsxtAppPortProfileArgs{\n\t\t\tOrg:       pulumi.StringRef(\"my-org\"),\n\t\t\tContextId: pulumi.StringRef(g1.Id),\n\t\t\tName:      \"SSH-custom\",\n\t\t\tScope:     \"TENANT\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAppPortProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var g1 = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"myOrg\")\n            .name(\"myVDC\")\n            .build());\n\n        final var custom = VcdFunctions.getNsxtAppPortProfile(GetNsxtAppPortProfileArgs.builder()\n            .org(\"my-org\")\n            .contextId(g1.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"SSH-custom\")\n            .scope(\"TENANT\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  g1:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: myOrg\n        name: myVDC\n  custom:\n    fn::invoke:\n      function: vcd:getNsxtAppPortProfile\n      arguments:\n        org: my-org\n        contextId: ${g1.id}\n        name: SSH-custom\n        scope: TENANT\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### 3 (Find A System Defined Application Port Profile)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst vdc1 = vcd.getOrgVdc({\n    org: \"myOrg\",\n    name: \"myVDC\",\n});\nconst custom = vdc1.then(vdc1 =\u003e vcd.getNsxtAppPortProfile({\n    contextId: vdc1.id,\n    scope: \"SYSTEM\",\n    name: \"SSH\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nvdc1 = vcd.get_org_vdc(org=\"myOrg\",\n    name=\"myVDC\")\ncustom = vcd.get_nsxt_app_port_profile(context_id=vdc1.id,\n    scope=\"SYSTEM\",\n    name=\"SSH\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vdc1 = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"myOrg\",\n        Name = \"myVDC\",\n    });\n\n    var custom = Vcd.GetNsxtAppPortProfile.Invoke(new()\n    {\n        ContextId = vdc1.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Scope = \"SYSTEM\",\n        Name = \"SSH\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tvdc1, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"myOrg\"),\n\t\t\tName: \"myVDC\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtAppPortProfile(ctx, \u0026vcd.LookupNsxtAppPortProfileArgs{\n\t\t\tContextId: pulumi.StringRef(vdc1.Id),\n\t\t\tScope:     \"SYSTEM\",\n\t\t\tName:      \"SSH\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtAppPortProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vdc1 = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"myOrg\")\n            .name(\"myVDC\")\n            .build());\n\n        final var custom = VcdFunctions.getNsxtAppPortProfile(GetNsxtAppPortProfileArgs.builder()\n            .contextId(vdc1.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .scope(\"SYSTEM\")\n            .name(\"SSH\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vdc1:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: myOrg\n        name: myVDC\n  custom:\n    fn::invoke:\n      function: vcd:getNsxtAppPortProfile\n      arguments:\n        contextId: ${vdc1.id}\n        scope: SYSTEM\n        name: SSH\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtAppPortProfile.\n",
                "properties": {
                    "contextId": {
                        "type": "string",
                        "description": "ID of NSX-T Manager, VDC or VDC Group. Replaces deprecated field `vdc`. Required if using more than one NSX-T Manager.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Unique name of existing Security Group.\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "deprecationMessage": "Deprecated in favor of 'context_id'",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "scope": {
                        "type": "string",
                        "description": "`SYSTEM`, `PROVIDER`, or `TENANT`.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\nDeprecated and replaced by `context_id`\n",
                        "deprecationMessage": "Deprecated in favor of 'context_id'",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "scope"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtAppPortProfile.\n",
                "properties": {
                    "appPorts": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtAppPortProfileAppPort:getNsxtAppPortProfileAppPort"
                        },
                        "type": "array"
                    },
                    "contextId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "deprecationMessage": "Deprecated in favor of 'context_id'",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "scope": {
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "Deprecated in favor of 'context_id'",
                        "type": "string"
                    }
                },
                "required": [
                    "appPorts",
                    "contextId",
                    "description",
                    "name",
                    "scope",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtDistributedFirewall:getNsxtDistributedFirewall": {
            "description": "The Distributed Firewall data source reads all defined rules for a particular VDC Group.\n\n\u003e There is a different data source\n[`vcd.NsxtDistributedFirewallRule`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_distributed_firewall_rule)\nresource are available that can fetch a single firewall rule by name.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst g1 = vcd.getVdcGroup({\n    org: \"my-org\",\n    name: \"my-vdc-group\",\n});\nconst t1 = g1.then(g1 =\u003e vcd.getNsxtDistributedFirewall({\n    org: \"my-org\",\n    vdcGroupId: g1.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ng1 = vcd.get_vdc_group(org=\"my-org\",\n    name=\"my-vdc-group\")\nt1 = vcd.get_nsxt_distributed_firewall(org=\"my-org\",\n    vdc_group_id=g1.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var g1 = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-vdc-group\",\n    });\n\n    var t1 = Vcd.GetNsxtDistributedFirewall.Invoke(new()\n    {\n        Org = \"my-org\",\n        VdcGroupId = g1.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tg1, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-vdc-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtDistributedFirewall(ctx, \u0026vcd.LookupNsxtDistributedFirewallArgs{\n\t\t\tOrg:        pulumi.StringRef(\"my-org\"),\n\t\t\tVdcGroupId: g1.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtDistributedFirewallArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var g1 = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-vdc-group\")\n            .build());\n\n        final var t1 = VcdFunctions.getNsxtDistributedFirewall(GetNsxtDistributedFirewallArgs.builder()\n            .org(\"my-org\")\n            .vdcGroupId(g1.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  g1:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: my-org\n        name: my-vdc-group\n  t1:\n    fn::invoke:\n      function: vcd:getNsxtDistributedFirewall\n      arguments:\n        org: my-org\n        vdcGroupId: ${g1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtDistributedFirewall.\n",
                "properties": {
                    "org": {
                        "type": "string",
                        "description": "The name of organization in which Distributed Firewall is located. Optional if\ndefined at provider level.\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "The ID of a VDC Group\n"
                    }
                },
                "type": "object",
                "required": [
                    "vdcGroupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtDistributedFirewall.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "rules": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtDistributedFirewallRule:getNsxtDistributedFirewallRule"
                        },
                        "type": "array"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    }
                },
                "required": [
                    "rules",
                    "vdcGroupId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtDistributedFirewallRule:getNsxtDistributedFirewallRule": {
            "description": "The Distributed Firewall data source reads a single rule for a particular VDC Group.\n\n\u003e There is a different data source\n[`vcd.NsxtDistributedFirewall`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_distributed_firewall)\nresource available that can fetch all firewall rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst g1 = vcd.getVdcGroup({\n    org: \"my-org\",\n    name: \"my-vdc-group\",\n});\nconst r1 = g1.then(g1 =\u003e vcd.getNsxtDistributedFirewallRule({\n    org: \"my-org\",\n    vdcGroupId: g1.id,\n    name: \"rule1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ng1 = vcd.get_vdc_group(org=\"my-org\",\n    name=\"my-vdc-group\")\nr1 = vcd.get_nsxt_distributed_firewall_rule(org=\"my-org\",\n    vdc_group_id=g1.id,\n    name=\"rule1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var g1 = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-vdc-group\",\n    });\n\n    var r1 = Vcd.GetNsxtDistributedFirewallRule.Invoke(new()\n    {\n        Org = \"my-org\",\n        VdcGroupId = g1.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"rule1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tg1, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-vdc-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtDistributedFirewallRule(ctx, \u0026vcd.LookupNsxtDistributedFirewallRuleArgs{\n\t\t\tOrg:        pulumi.StringRef(\"my-org\"),\n\t\t\tVdcGroupId: g1.Id,\n\t\t\tName:       \"rule1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtDistributedFirewallRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var g1 = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-vdc-group\")\n            .build());\n\n        final var r1 = VcdFunctions.getNsxtDistributedFirewallRule(GetNsxtDistributedFirewallRuleArgs.builder()\n            .org(\"my-org\")\n            .vdcGroupId(g1.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"rule1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  g1:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: my-org\n        name: my-vdc-group\n  r1:\n    fn::invoke:\n      function: vcd:getNsxtDistributedFirewallRule\n      arguments:\n        org: my-org\n        vdcGroupId: ${g1.id}\n        name: rule1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtDistributedFirewallRule.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of firewall rule\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization in which Distributed Firewall is located. Optional if\ndefined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "The ID of a VDC Group\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vdcGroupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtDistributedFirewallRule.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "appPortProfileIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "destinationGroupsExcluded": {
                        "type": "boolean"
                    },
                    "destinationIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "direction": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipProtocol": {
                        "type": "string"
                    },
                    "logging": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkContextProfileIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "org": {
                        "type": "string"
                    },
                    "sourceGroupsExcluded": {
                        "type": "boolean"
                    },
                    "sourceIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    }
                },
                "required": [
                    "action",
                    "appPortProfileIds",
                    "comment",
                    "description",
                    "destinationGroupsExcluded",
                    "destinationIds",
                    "direction",
                    "enabled",
                    "ipProtocol",
                    "logging",
                    "name",
                    "networkContextProfileIds",
                    "sourceGroupsExcluded",
                    "sourceIds",
                    "vdcGroupId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtDynamicSecurityGroup:getNsxtDynamicSecurityGroup": {
            "description": "Supported in provider *v3.7+* and VCD 10.3+ with NSX-T backed VDC Groups.\n\nProvides a data source to read NSX-T Dynamic Security Groups. Dynamic Security Groups group Virtual\nMachines based on specific criteria (VM Names or Security tags) to which Distributed Firewall Rules\napply.\n\n## Example Usage\n\n### 1 (Existing Dynamic Security Group Lookup)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst group1 = vcd.getVdcGroup({\n    org: \"cloud\",\n    name: \"vdc-group-cloud\",\n});\nconst group1GetNsxtDynamicSecurityGroup = group1.then(group1 =\u003e vcd.getNsxtDynamicSecurityGroup({\n    org: \"cloud\",\n    vdcGroupId: group1.id,\n    name: \"cloud-dynamic-security-group\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ngroup1 = vcd.get_vdc_group(org=\"cloud\",\n    name=\"vdc-group-cloud\")\ngroup1_get_nsxt_dynamic_security_group = vcd.get_nsxt_dynamic_security_group(org=\"cloud\",\n    vdc_group_id=group1.id,\n    name=\"cloud-dynamic-security-group\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var group1 = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"cloud\",\n        Name = \"vdc-group-cloud\",\n    });\n\n    var group1GetNsxtDynamicSecurityGroup = Vcd.GetNsxtDynamicSecurityGroup.Invoke(new()\n    {\n        Org = \"cloud\",\n        VdcGroupId = group1.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"cloud-dynamic-security-group\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup1, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"cloud\"),\n\t\t\tName: pulumi.StringRef(\"vdc-group-cloud\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtDynamicSecurityGroup(ctx, \u0026vcd.LookupNsxtDynamicSecurityGroupArgs{\n\t\t\tOrg:        pulumi.StringRef(\"cloud\"),\n\t\t\tVdcGroupId: group1.Id,\n\t\t\tName:       \"cloud-dynamic-security-group\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtDynamicSecurityGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var group1 = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"cloud\")\n            .name(\"vdc-group-cloud\")\n            .build());\n\n        final var group1GetNsxtDynamicSecurityGroup = VcdFunctions.getNsxtDynamicSecurityGroup(GetNsxtDynamicSecurityGroupArgs.builder()\n            .org(\"cloud\")\n            .vdcGroupId(group1.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"cloud-dynamic-security-group\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  group1:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: cloud\n        name: vdc-group-cloud\n  group1GetNsxtDynamicSecurityGroup:\n    fn::invoke:\n      function: vcd:getNsxtDynamicSecurityGroup\n      arguments:\n        org: cloud\n        vdcGroupId: ${group1.id}\n        name: cloud-dynamic-security-group\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtDynamicSecurityGroup.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for existing Dynamic Security Group\n\nAll the arguments and attributes defined in\n[`vcd.NsxtDynamicSecurityGroup`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxt_dynamic_security_group) resource are available.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "VDC Group ID hosting existing Dynamic Security Group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vdcGroupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtDynamicSecurityGroup.\n",
                "properties": {
                    "criterias": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtDynamicSecurityGroupCriteria:getNsxtDynamicSecurityGroupCriteria"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "memberVms": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtDynamicSecurityGroupMemberVm:getNsxtDynamicSecurityGroupMemberVm"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    }
                },
                "required": [
                    "criterias",
                    "memberVms",
                    "name",
                    "vdcGroupId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgeCluster:getNsxtEdgeCluster": {
            "description": "Provides a data source for available NSX-T Edge Clusters.\n\nSupported in provider *v3.1+*\n\n\u003e **Note:** This data source uses new VMware Cloud Director\n[OpenAPI](https://code.vmware.com/docs/11982/getting-started-with-vmware-cloud-director-openapi) and\nrequires at least VCD *10.1.1+* and NSX-T *3.0+*.\n\n## Example Usage\n\n### With VDC ID)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getOrgVdc({\n    org: \"my-org\",\n    name: \"nsxt-vdc-1\",\n});\nconst first = existing.then(existing =\u003e vcd.getNsxtEdgeCluster({\n    org: \"my-org\",\n    vdcId: existing.id,\n    name: \"edge-cluster-one\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_org_vdc(org=\"my-org\",\n    name=\"nsxt-vdc-1\")\nfirst = vcd.get_nsxt_edge_cluster(org=\"my-org\",\n    vdc_id=existing.id,\n    name=\"edge-cluster-one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"nsxt-vdc-1\",\n    });\n\n    var first = Vcd.GetNsxtEdgeCluster.Invoke(new()\n    {\n        Org = \"my-org\",\n        VdcId = existing.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"edge-cluster-one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"nsxt-vdc-1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtEdgeCluster(ctx, \u0026vcd.GetNsxtEdgeClusterArgs{\n\t\t\tOrg:   pulumi.StringRef(\"my-org\"),\n\t\t\tVdcId: pulumi.StringRef(existing.Id),\n\t\t\tName:  \"edge-cluster-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgeClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"my-org\")\n            .name(\"nsxt-vdc-1\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtEdgeCluster(GetNsxtEdgeClusterArgs.builder()\n            .org(\"my-org\")\n            .vdcId(existing.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"edge-cluster-one\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: my-org\n        name: nsxt-vdc-1\n  first:\n    fn::invoke:\n      function: vcd:getNsxtEdgeCluster\n      arguments:\n        org: my-org\n        vdcId: ${existing.id}\n        name: edge-cluster-one\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With VDC Group ID)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getVdcGroup({\n    org: \"my-org\",\n    name: \"nsxt-vdc-group-1\",\n});\nconst first = existing.then(existing =\u003e vcd.getNsxtEdgeCluster({\n    org: \"my-org\",\n    vdcGroupId: existing.id,\n    name: \"edge-cluster-one\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_vdc_group(org=\"my-org\",\n    name=\"nsxt-vdc-group-1\")\nfirst = vcd.get_nsxt_edge_cluster(org=\"my-org\",\n    vdc_group_id=existing.id,\n    name=\"edge-cluster-one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"nsxt-vdc-group-1\",\n    });\n\n    var first = Vcd.GetNsxtEdgeCluster.Invoke(new()\n    {\n        Org = \"my-org\",\n        VdcGroupId = existing.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"edge-cluster-one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"nsxt-vdc-group-1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtEdgeCluster(ctx, \u0026vcd.GetNsxtEdgeClusterArgs{\n\t\t\tOrg:        pulumi.StringRef(\"my-org\"),\n\t\t\tVdcGroupId: pulumi.StringRef(existing.Id),\n\t\t\tName:       \"edge-cluster-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgeClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"my-org\")\n            .name(\"nsxt-vdc-group-1\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtEdgeCluster(GetNsxtEdgeClusterArgs.builder()\n            .org(\"my-org\")\n            .vdcGroupId(existing.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"edge-cluster-one\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: my-org\n        name: nsxt-vdc-group-1\n  first:\n    fn::invoke:\n      function: vcd:getNsxtEdgeCluster\n      arguments:\n        org: my-org\n        vdcGroupId: ${existing.id}\n        name: edge-cluster-one\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With Provider VDC ID)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt_pvdc = vcd.getProviderVdc({\n    name: \"nsxt-provider-vdc\",\n});\nconst first = nsxt_pvdc.then(nsxt_pvdc =\u003e vcd.getNsxtEdgeCluster({\n    org: \"my-org\",\n    providerVdcId: nsxt_pvdc.id,\n    name: \"edge-cluster-one\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt_pvdc = vcd.get_provider_vdc(name=\"nsxt-provider-vdc\")\nfirst = vcd.get_nsxt_edge_cluster(org=\"my-org\",\n    provider_vdc_id=nsxt_pvdc.id,\n    name=\"edge-cluster-one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt_pvdc = Vcd.GetProviderVdc.Invoke(new()\n    {\n        Name = \"nsxt-provider-vdc\",\n    });\n\n    var first = Vcd.GetNsxtEdgeCluster.Invoke(new()\n    {\n        Org = \"my-org\",\n        ProviderVdcId = nsxt_pvdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Id),\n        Name = \"edge-cluster-one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnsxt_pvdc, err := vcd.LookupProviderVdc(ctx, \u0026vcd.LookupProviderVdcArgs{\n\t\t\tName: \"nsxt-provider-vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtEdgeCluster(ctx, \u0026vcd.GetNsxtEdgeClusterArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tProviderVdcId: pulumi.StringRef(nsxt_pvdc.Id),\n\t\t\tName:          \"edge-cluster-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetProviderVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgeClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt-pvdc = VcdFunctions.getProviderVdc(GetProviderVdcArgs.builder()\n            .name(\"nsxt-provider-vdc\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtEdgeCluster(GetNsxtEdgeClusterArgs.builder()\n            .org(\"my-org\")\n            .providerVdcId(nsxt_pvdc.id())\n            .name(\"edge-cluster-one\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt-pvdc:\n    fn::invoke:\n      function: vcd:getProviderVdc\n      arguments:\n        name: nsxt-provider-vdc\n  first:\n    fn::invoke:\n      function: vcd:getNsxtEdgeCluster\n      arguments:\n        org: my-org\n        providerVdcId: ${[\"nsxt-pvdc\"].id}\n        name: edge-cluster-one\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgeCluster.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "NSX-T Edge Cluster name. **Note.** NSX-T does allow to have duplicate names therefore to be able\nto correctly use this data source there should not be multiple NSX-T Edge Clusters with the same name defined.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which edge cluster belongs. Optional if defined at provider level.\n"
                    },
                    "providerVdcId": {
                        "type": "string",
                        "description": "The ID of VDC Group for lookup. Data source `vcd.ProviderVdc` can be used to get ID.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC that owns the edge cluster. Optional if defined at provider level.\n",
                        "deprecationMessage": "This field is deprecated in favor of 'vdc_id', 'vdc_group_id', and 'provider_vdc_id' which accept IDs of VDC, VDC Group and Provider VDC respectively"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "The ID of VDC Group for lookup. Data source `vcd.VdcGroup` can be used to get ID.\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of VDC for lookup. Data source `vcd.OrgVdc` can be used to get ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgeCluster.\n",
                "properties": {
                    "deploymentType": {
                        "description": "Deployment type of Edge Cluster.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "Edge Cluster description in NSX-T manager.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nodeCount": {
                        "description": "Number of nodes in Edge Cluster.\n",
                        "type": "integer"
                    },
                    "nodeType": {
                        "description": "Type of nodes in Edge Cluster.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "providerVdcId": {
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "This field is deprecated in favor of 'vdc_id', 'vdc_group_id', and 'provider_vdc_id' which accept IDs of VDC, VDC Group and Provider VDC respectively",
                        "type": "string"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "deploymentType",
                    "description",
                    "name",
                    "nodeCount",
                    "nodeType",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegateway:getNsxtEdgegateway": {
            "description": "Provides a VMware Cloud Director NSX-T edge gateway data source. This can be used to read NSX-T edge gateway configurations.\n\nSupported in provider *v3.1+*.\n\n## Example Usage\n\n### NSX-T Edge Gateway Belonging To VDC Group)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst group1 = vcd.getVdcGroup({\n    name: \"existing-group\",\n});\nconst t1 = group1.then(group1 =\u003e vcd.getNsxtEdgegateway({\n    org: \"myorg\",\n    ownerId: group1.id,\n    name: \"nsxt-edge-gateway\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ngroup1 = vcd.get_vdc_group(name=\"existing-group\")\nt1 = vcd.get_nsxt_edgegateway(org=\"myorg\",\n    owner_id=group1.id,\n    name=\"nsxt-edge-gateway\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var group1 = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Name = \"existing-group\",\n    });\n\n    var t1 = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"myorg\",\n        OwnerId = group1.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"nsxt-edge-gateway\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup1, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tName: pulumi.StringRef(\"existing-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:     pulumi.StringRef(\"myorg\"),\n\t\t\tOwnerId: pulumi.StringRef(group1.Id),\n\t\t\tName:    \"nsxt-edge-gateway\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var group1 = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .name(\"existing-group\")\n            .build());\n\n        final var t1 = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"myorg\")\n            .ownerId(group1.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"nsxt-edge-gateway\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  group1:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        name: existing-group\n  t1:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: myorg\n        ownerId: ${group1.id}\n        name: nsxt-edge-gateway\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### NSX-T Edge Gateway Belonging To VDC)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst vdc1 = vcd.getOrgVdc({\n    name: \"existing-vdc\",\n});\nconst t1 = vdc1.then(vdc1 =\u003e vcd.getNsxtEdgegateway({\n    org: \"myorg\",\n    ownerId: vdc1.id,\n    name: \"nsxt-edge-gateway\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nvdc1 = vcd.get_org_vdc(name=\"existing-vdc\")\nt1 = vcd.get_nsxt_edgegateway(org=\"myorg\",\n    owner_id=vdc1.id,\n    name=\"nsxt-edge-gateway\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vdc1 = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Name = \"existing-vdc\",\n    });\n\n    var t1 = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"myorg\",\n        OwnerId = vdc1.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"nsxt-edge-gateway\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tvdc1, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tName: \"existing-vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:     pulumi.StringRef(\"myorg\"),\n\t\t\tOwnerId: pulumi.StringRef(vdc1.Id),\n\t\t\tName:    \"nsxt-edge-gateway\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vdc1 = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .name(\"existing-vdc\")\n            .build());\n\n        final var t1 = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"myorg\")\n            .ownerId(vdc1.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"nsxt-edge-gateway\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vdc1:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        name: existing-vdc\n  t1:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: myorg\n        ownerId: ${vdc1.id}\n        name: nsxt-edge-gateway\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegateway.\n",
                "properties": {
                    "edgeClusterId": {
                        "type": "string"
                    },
                    "ipCountReadLimit": {
                        "type": "integer",
                        "description": "Sets a limit of IPs to count for\n`used_ip_count` and `unused_ip_count` attributes to avoid exhausting compute resource while\ncounting IPs in large IPv6 subnets. It does not affect operation of Edge Gateway configuration,\nonly IP count reporting. Defaults to `1000000`. While it is unlikely that a single Edge Gateway\ncan effectively manage more IPs, one can specify `0` for *unlimited* value.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway name.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the NSX-T Edge Gateway belongs. Optional if\ndefined at provider level.\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "The ID of VDC or VDC Group. **Note:** Data sources\n[vcd.VdcGroup](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/vdc_group) or\n[vcd.OrgVdc](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org_vdc) can be used to lookup IDs by\nname.\n\n\u003e Only one of `vdc` or `owner_id` can be specified. `owner_id` takes precedence over `vdc`\ndefinition at provider level.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "**Deprecated** - please use `owner_id` field. The name of VDC that owns the\nNSX-T Edge Gateway. Optional if defined at provider level.\n",
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegateway.\n",
                "properties": {
                    "dedicateExternalNetwork": {
                        "type": "boolean"
                    },
                    "deploymentMode": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeClusterId": {
                        "type": "string"
                    },
                    "externalNetworkAllocatedIpCount": {
                        "type": "integer"
                    },
                    "externalNetworkId": {
                        "type": "string"
                    },
                    "externalNetworks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewayExternalNetwork:getNsxtEdgegatewayExternalNetwork"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipCountReadLimit": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nonDistributedRoutingEnabled": {
                        "type": "boolean"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerId": {
                        "type": "string"
                    },
                    "primaryIp": {
                        "type": "string"
                    },
                    "subnetWithIpCounts": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewaySubnetWithIpCount:getNsxtEdgegatewaySubnetWithIpCount"
                        },
                        "type": "array"
                    },
                    "subnetWithTotalIpCounts": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewaySubnetWithTotalIpCount:getNsxtEdgegatewaySubnetWithTotalIpCount"
                        },
                        "type": "array"
                    },
                    "subnets": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewaySubnet:getNsxtEdgegatewaySubnet"
                        },
                        "type": "array"
                    },
                    "totalAllocatedIpCount": {
                        "type": "integer"
                    },
                    "unusedIpCount": {
                        "type": "integer"
                    },
                    "useIpSpaces": {
                        "type": "boolean"
                    },
                    "usedIpCount": {
                        "type": "integer"
                    },
                    "vdc": {
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs",
                        "type": "string"
                    }
                },
                "required": [
                    "dedicateExternalNetwork",
                    "deploymentMode",
                    "description",
                    "externalNetworks",
                    "externalNetworkAllocatedIpCount",
                    "externalNetworkId",
                    "name",
                    "nonDistributedRoutingEnabled",
                    "ownerId",
                    "primaryIp",
                    "subnets",
                    "subnetWithIpCounts",
                    "subnetWithTotalIpCounts",
                    "totalAllocatedIpCount",
                    "unusedIpCount",
                    "useIpSpaces",
                    "usedIpCount",
                    "vdc",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayBgpConfiguration:getNsxtEdgegatewayBgpConfiguration": {
            "description": "Provides a data source to read BGP configuration on NSX-T Edge Gateway that has a dedicated Tier-0\nGateway or VRF. BGP makes core routing decisions by using a table of IP networks, or prefixes, which\ndesignate multiple routes between autonomous systems (AS).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt_vdc = vcd.getOrgVdc({\n    org: \"my-org\",\n    name: \"my-vdc\",\n});\nconst existing = nsxt_vdc.then(nsxt_vdc =\u003e vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    ownerId: nsxt_vdc.id,\n    name: \"main\",\n}));\nconst testing = existing.then(existing =\u003e vcd.getNsxtEdgegatewayBgpConfiguration({\n    org: \"my-org\",\n    edgeGatewayId: existing.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt_vdc = vcd.get_org_vdc(org=\"my-org\",\n    name=\"my-vdc\")\nexisting = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    owner_id=nsxt_vdc.id,\n    name=\"main\")\ntesting = vcd.get_nsxt_edgegateway_bgp_configuration(org=\"my-org\",\n    edge_gateway_id=existing.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt_vdc = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-vdc\",\n    });\n\n    var existing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        OwnerId = nsxt_vdc.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"main\",\n    });\n\n    var testing = Vcd.GetNsxtEdgegatewayBgpConfiguration.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = existing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnsxt_vdc, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"my-vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texisting, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:     pulumi.StringRef(\"my-org\"),\n\t\t\tOwnerId: pulumi.StringRef(nsxt_vdc.Id),\n\t\t\tName:    \"main\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtEdgegatewayBgpConfiguration(ctx, \u0026vcd.LookupNsxtEdgegatewayBgpConfigurationArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: existing.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayBgpConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt-vdc = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-vdc\")\n            .build());\n\n        final var existing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .ownerId(nsxt_vdc.id())\n            .name(\"main\")\n            .build());\n\n        final var testing = VcdFunctions.getNsxtEdgegatewayBgpConfiguration(GetNsxtEdgegatewayBgpConfigurationArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(existing.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt-vdc:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: my-org\n        name: my-vdc\n  existing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        ownerId: ${[\"nsxt-vdc\"].id}\n        name: main\n  testing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayBgpConfiguration\n      arguments:\n        org: my-org\n        edgeGatewayId: ${existing.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayBgpConfiguration.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayBgpConfiguration.\n",
                "properties": {
                    "ecmpEnabled": {
                        "type": "boolean"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "gracefulRestartMode": {
                        "type": "string"
                    },
                    "gracefulRestartTimer": {
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "localAsNumber": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "staleRouteTimer": {
                        "type": "integer"
                    }
                },
                "required": [
                    "ecmpEnabled",
                    "edgeGatewayId",
                    "enabled",
                    "gracefulRestartMode",
                    "gracefulRestartTimer",
                    "localAsNumber",
                    "staleRouteTimer",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayBgpIpPrefixList:getNsxtEdgegatewayBgpIpPrefixList": {
            "description": "Supported in provider *v3.7+* and VCD 10.2+ with NSX-T\n\nProvides a resource to manage NSX-T Edge Gateway BGP IP Prefix Lists. IP prefix lists can contain \nsingle or multiple IP addresses and can be used to assign BGP neighbors with access permissions \nfor route advertisement.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst g1 = vcd.getVdcGroup({\n    org: \"my-org\",\n    name: \"my-vdc-group\",\n});\nconst testing = g1.then(g1 =\u003e vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    ownerId: g1.id,\n    name: \"my-edge-gateway\",\n}));\nconst testingGetNsxtEdgegatewayBgpIpPrefixList = testing.then(testing =\u003e vcd.getNsxtEdgegatewayBgpIpPrefixList({\n    org: \"my-org\",\n    edgeGatewayId: testing.id,\n    name: \"my-bgp-prefix-list\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ng1 = vcd.get_vdc_group(org=\"my-org\",\n    name=\"my-vdc-group\")\ntesting = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    owner_id=g1.id,\n    name=\"my-edge-gateway\")\ntesting_get_nsxt_edgegateway_bgp_ip_prefix_list = vcd.get_nsxt_edgegateway_bgp_ip_prefix_list(org=\"my-org\",\n    edge_gateway_id=testing.id,\n    name=\"my-bgp-prefix-list\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var g1 = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-vdc-group\",\n    });\n\n    var testing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        OwnerId = g1.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"my-edge-gateway\",\n    });\n\n    var testingGetNsxtEdgegatewayBgpIpPrefixList = Vcd.GetNsxtEdgegatewayBgpIpPrefixList.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = testing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n        Name = \"my-bgp-prefix-list\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tg1, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-vdc-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttesting, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:     pulumi.StringRef(\"my-org\"),\n\t\t\tOwnerId: pulumi.StringRef(g1.Id),\n\t\t\tName:    \"my-edge-gateway\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtEdgegatewayBgpIpPrefixList(ctx, \u0026vcd.LookupNsxtEdgegatewayBgpIpPrefixListArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: testing.Id,\n\t\t\tName:          \"my-bgp-prefix-list\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayBgpIpPrefixListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var g1 = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-vdc-group\")\n            .build());\n\n        final var testing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .ownerId(g1.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"my-edge-gateway\")\n            .build());\n\n        final var testingGetNsxtEdgegatewayBgpIpPrefixList = VcdFunctions.getNsxtEdgegatewayBgpIpPrefixList(GetNsxtEdgegatewayBgpIpPrefixListArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(testing.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .name(\"my-bgp-prefix-list\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  g1:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: my-org\n        name: my-vdc-group\n  testing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        ownerId: ${g1.id}\n        name: my-edge-gateway\n  testingGetNsxtEdgegatewayBgpIpPrefixList:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayBgpIpPrefixList\n      arguments:\n        org: my-org\n        edgeGatewayId: ${testing.id}\n        name: my-bgp-prefix-list\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayBgpIpPrefixList.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A name of existing BGP IP Prefix List in specified Edge Gateway\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayBgpIpPrefixList.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipPrefixes": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewayBgpIpPrefixListIpPrefix:getNsxtEdgegatewayBgpIpPrefixListIpPrefix"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "edgeGatewayId",
                    "ipPrefixes",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayBgpNeighbor:getNsxtEdgegatewayBgpNeighbor": {
            "description": "Supported in provider *v3.7+* and VCD 10.2+ with NSX-T\n\nProvides a data source to read NSX-T Edge Gateway BGP Neighbors and their configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayBgpNeighborArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"nsxt-vdc\")\n            .name(\"nsxt-gw\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtEdgegatewayBgpNeighbor(GetNsxtEdgegatewayBgpNeighborArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"nsxt-vdc\")\n            .edgeGatewayId(existing.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .ipAddress(\"192.168.102.45\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        vdc: nsxt-vdc\n        name: nsxt-gw\n  first:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayBgpNeighbor\n      arguments:\n        org: my-org\n        vdc: nsxt-vdc\n        edgeGatewayId: ${existing.id}\n        ipAddress: 192.168.102.45\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayBgpNeighbor.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n",
                        "willReplaceOnChanges": true
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "An IP Address (IPv4 or IPv6) of existing BGP Neighbor in specified Edge Gateway\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "ipAddress"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayBgpNeighbor.\n",
                "properties": {
                    "allowAsIn": {
                        "type": "boolean"
                    },
                    "bfdDeadMultiple": {
                        "type": "integer"
                    },
                    "bfdEnabled": {
                        "type": "boolean"
                    },
                    "bfdInterval": {
                        "type": "integer"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "gracefulRestartMode": {
                        "type": "string"
                    },
                    "holdDownTimer": {
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inFilterIpPrefixListId": {
                        "type": "string"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "keepAliveTimer": {
                        "type": "integer"
                    },
                    "org": {
                        "type": "string"
                    },
                    "outFilterIpPrefixListId": {
                        "type": "string"
                    },
                    "password": {
                        "secret": true,
                        "type": "string"
                    },
                    "remoteAsNumber": {
                        "type": "string"
                    },
                    "routeFiltering": {
                        "type": "string"
                    }
                },
                "required": [
                    "allowAsIn",
                    "bfdDeadMultiple",
                    "bfdEnabled",
                    "bfdInterval",
                    "edgeGatewayId",
                    "gracefulRestartMode",
                    "holdDownTimer",
                    "inFilterIpPrefixListId",
                    "ipAddress",
                    "keepAliveTimer",
                    "outFilterIpPrefixListId",
                    "password",
                    "remoteAsNumber",
                    "routeFiltering",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayDhcpForwarding:getNsxtEdgegatewayDhcpForwarding": {
            "description": "Supported in provider *v3.10+* and VCD 10.3.1+ with NSX-T.\n\nProvides a data source to read NSX-T Edge Gateway DHCP forwarding configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst v1 = vcd.getOrgVdc({\n    org: \"datacloud\",\n    name: \"nsxt-vdc-datacloud\",\n});\nconst testing_in_vdc = v1.then(v1 =\u003e vcd.getNsxtEdgegateway({\n    org: \"datacloud\",\n    ownerId: v1.id,\n    name: \"nsxt-gw-datacloud\",\n}));\nconst testing_in_vdcGetNsxtEdgegatewayDhcpForwarding = testing_in_vdc.then(testing_in_vdc =\u003e vcd.getNsxtEdgegatewayDhcpForwarding({\n    org: \"datacloud\",\n    edgeGatewayId: testing_in_vdc.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nv1 = vcd.get_org_vdc(org=\"datacloud\",\n    name=\"nsxt-vdc-datacloud\")\ntesting_in_vdc = vcd.get_nsxt_edgegateway(org=\"datacloud\",\n    owner_id=v1.id,\n    name=\"nsxt-gw-datacloud\")\ntesting_in_vdc_get_nsxt_edgegateway_dhcp_forwarding = vcd.get_nsxt_edgegateway_dhcp_forwarding(org=\"datacloud\",\n    edge_gateway_id=testing_in_vdc.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var v1 = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"datacloud\",\n        Name = \"nsxt-vdc-datacloud\",\n    });\n\n    var testing_in_vdc = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"datacloud\",\n        OwnerId = v1.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"nsxt-gw-datacloud\",\n    });\n\n    var testing_in_vdcGetNsxtEdgegatewayDhcpForwarding = Vcd.GetNsxtEdgegatewayDhcpForwarding.Invoke(new()\n    {\n        Org = \"datacloud\",\n        EdgeGatewayId = testing_in_vdc.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tv1, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"datacloud\"),\n\t\t\tName: \"nsxt-vdc-datacloud\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttesting_in_vdc, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:     pulumi.StringRef(\"datacloud\"),\n\t\t\tOwnerId: pulumi.StringRef(v1.Id),\n\t\t\tName:    \"nsxt-gw-datacloud\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtEdgegatewayDhcpForwarding(ctx, \u0026vcd.LookupNsxtEdgegatewayDhcpForwardingArgs{\n\t\t\tOrg:           pulumi.StringRef(\"datacloud\"),\n\t\t\tEdgeGatewayId: testing_in_vdc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayDhcpForwardingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var v1 = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"datacloud\")\n            .name(\"nsxt-vdc-datacloud\")\n            .build());\n\n        final var testing-in-vdc = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"datacloud\")\n            .ownerId(v1.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"nsxt-gw-datacloud\")\n            .build());\n\n        final var testing-in-vdcGetNsxtEdgegatewayDhcpForwarding = VcdFunctions.getNsxtEdgegatewayDhcpForwarding(GetNsxtEdgegatewayDhcpForwardingArgs.builder()\n            .org(\"datacloud\")\n            .edgeGatewayId(testing_in_vdc.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  v1:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: datacloud\n        name: nsxt-vdc-datacloud\n  testing-in-vdc:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: datacloud\n        ownerId: ${v1.id}\n        name: nsxt-gw-datacloud\n  testing-in-vdcGetNsxtEdgegatewayDhcpForwarding:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayDhcpForwarding\n      arguments:\n        org: datacloud\n        edgeGatewayId: ${[\"testing-in-vdc\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayDhcpForwarding.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org in which the NSX-T Edge Gateway is located, required\nif not set in the provider section.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayDhcpForwarding.\n",
                "properties": {
                    "dhcpServers": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "required": [
                    "dhcpServers",
                    "edgeGatewayId",
                    "enabled",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayDhcpv6:getNsxtEdgegatewayDhcpv6": {
            "description": "Provides a data source to read DHCPv6 configuration for NSX-T Edge Gateways.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst testing_in_vdc = vcd.getNsxtEdgegatewayDhcpv6({\n    org: \"datacloud\",\n    edgeGatewayId: testing_in_vdcVcdNsxtEdgegateway.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntesting_in_vdc = vcd.get_nsxt_edgegateway_dhcpv6(org=\"datacloud\",\n    edge_gateway_id=testing_in_vdc_vcd_nsxt_edgegateway[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testing_in_vdc = Vcd.GetNsxtEdgegatewayDhcpv6.Invoke(new()\n    {\n        Org = \"datacloud\",\n        EdgeGatewayId = testing_in_vdcVcdNsxtEdgegateway.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtEdgegatewayDhcpv6(ctx, \u0026vcd.LookupNsxtEdgegatewayDhcpv6Args{\n\t\t\tOrg:           pulumi.StringRef(\"datacloud\"),\n\t\t\tEdgeGatewayId: testing_in_vdcVcdNsxtEdgegateway.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayDhcpv6Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testing-in-vdc = VcdFunctions.getNsxtEdgegatewayDhcpv6(GetNsxtEdgegatewayDhcpv6Args.builder()\n            .org(\"datacloud\")\n            .edgeGatewayId(testing_in_vdcVcdNsxtEdgegateway.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  testing-in-vdc:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayDhcpv6\n      arguments:\n        org: datacloud\n        edgeGatewayId: ${[\"testing-in-vdcVcdNsxtEdgegateway\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayDhcpv6.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "An ID of NSX-T Edge Gateway. Can be looked up using\n[vcd.NsxtEdgegateway](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if defined at provider level.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayDhcpv6.\n",
                "properties": {
                    "dnsServers": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "domainNames": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "required": [
                    "dnsServers",
                    "domainNames",
                    "edgeGatewayId",
                    "mode",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayDns:getNsxtEdgegatewayDns": {
            "description": "Supported in provider *v3.11+* and VCD *10.4+* with NSX-T.\n\nProvides a data source to read NSX-T Edge Gateway DNS forwarder configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getOrgVdc({\n    name: \"existing-vdc\",\n});\nconst testing = existing.then(existing =\u003e vcd.getNsxtEdgegateway({\n    ownerId: existing.id,\n    name: \"server-testing\",\n}));\nconst dns_service = testing.then(testing =\u003e vcd.getNsxtEdgegatewayDns({\n    org: \"datacloud\",\n    edgeGatewayId: testing.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_org_vdc(name=\"existing-vdc\")\ntesting = vcd.get_nsxt_edgegateway(owner_id=existing.id,\n    name=\"server-testing\")\ndns_service = vcd.get_nsxt_edgegateway_dns(org=\"datacloud\",\n    edge_gateway_id=testing.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Name = \"existing-vdc\",\n    });\n\n    var testing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        OwnerId = existing.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"server-testing\",\n    });\n\n    var dns_service = Vcd.GetNsxtEdgegatewayDns.Invoke(new()\n    {\n        Org = \"datacloud\",\n        EdgeGatewayId = testing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tName: \"existing-vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttesting, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOwnerId: pulumi.StringRef(existing.Id),\n\t\t\tName:    \"server-testing\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtEdgegatewayDns(ctx, \u0026vcd.LookupNsxtEdgegatewayDnsArgs{\n\t\t\tOrg:           pulumi.StringRef(\"datacloud\"),\n\t\t\tEdgeGatewayId: testing.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayDnsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .name(\"existing-vdc\")\n            .build());\n\n        final var testing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .ownerId(existing.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"server-testing\")\n            .build());\n\n        final var dns-service = VcdFunctions.getNsxtEdgegatewayDns(GetNsxtEdgegatewayDnsArgs.builder()\n            .org(\"datacloud\")\n            .edgeGatewayId(testing.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        name: existing-vdc\n  testing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        ownerId: ${existing.id}\n        name: server-testing\n  dns-service:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayDns\n      arguments:\n        org: datacloud\n        edgeGatewayId: ${testing.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayDns.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). \nCan be looked up using [`vcd.NsxtEdgegateway`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at \nprovider level. Useful when connected as sysadmin working across different organisations\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayDns.\n",
                "properties": {
                    "conditionalForwarderZones": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewayDnsConditionalForwarderZone:getNsxtEdgegatewayDnsConditionalForwarderZone"
                        },
                        "type": "array"
                    },
                    "defaultForwarderZones": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewayDnsDefaultForwarderZone:getNsxtEdgegatewayDnsDefaultForwarderZone"
                        },
                        "type": "array"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "listenerIp": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "snatRuleEnabled": {
                        "type": "boolean"
                    },
                    "snatRuleIpAddress": {
                        "type": "string"
                    }
                },
                "required": [
                    "conditionalForwarderZones",
                    "defaultForwarderZones",
                    "edgeGatewayId",
                    "enabled",
                    "listenerIp",
                    "snatRuleEnabled",
                    "snatRuleIpAddress",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayL2VpnTunnel:getNsxtEdgegatewayL2VpnTunnel": {
            "description": "Supported in provider *v3.11+* and VCD *10.4+* with NSX-T.\n\nProvides a data source to read NSX-T Edge Gateway L2 VPN Tunnel sessions and their configurations.\n\n## Example Usage\n\n### Reading A Tunnel's Server Session To Get The Peer Code For The Client Session)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getOrgVdc({\n    name: \"existing-vdc\",\n});\nconst server_testing = existing.then(existing =\u003e vcd.getNsxtEdgegateway({\n    ownerId: existing.id,\n    name: \"server-testing\",\n}));\nconst client_testing = existing.then(existing =\u003e vcd.getNsxtEdgegateway({\n    ownerId: existing.id,\n    name: \"client-testing\",\n}));\nconst server_session = server_testing.then(server_testing =\u003e vcd.getNsxtEdgegatewayL2VpnTunnel({\n    org: \"datacloud\",\n    edgeGatewayId: server_testing.id,\n    name: \"server-session\",\n}));\nconst client_session = new vcd.NsxtEdgegatewayL2VpnTunnel(\"client-session\", {\n    org: \"datacloud\",\n    edgeGatewayId: client_testing.then(client_testing =\u003e client_testing.id),\n    sessionMode: \"CLIENT\",\n    enabled: true,\n    localEndpointIp: \"101.22.30.3\",\n    remoteEndpointIp: \"1.2.2.3\",\n    peerCode: server_session.then(server_session =\u003e server_session.peerCode),\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_org_vdc(name=\"existing-vdc\")\nserver_testing = vcd.get_nsxt_edgegateway(owner_id=existing.id,\n    name=\"server-testing\")\nclient_testing = vcd.get_nsxt_edgegateway(owner_id=existing.id,\n    name=\"client-testing\")\nserver_session = vcd.get_nsxt_edgegateway_l2_vpn_tunnel(org=\"datacloud\",\n    edge_gateway_id=server_testing.id,\n    name=\"server-session\")\nclient_session = vcd.NsxtEdgegatewayL2VpnTunnel(\"client-session\",\n    org=\"datacloud\",\n    edge_gateway_id=client_testing.id,\n    session_mode=\"CLIENT\",\n    enabled=True,\n    local_endpoint_ip=\"101.22.30.3\",\n    remote_endpoint_ip=\"1.2.2.3\",\n    peer_code=server_session.peer_code)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Name = \"existing-vdc\",\n    });\n\n    var server_testing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        OwnerId = existing.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"server-testing\",\n    });\n\n    var client_testing = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        OwnerId = existing.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"client-testing\",\n    });\n\n    var server_session = Vcd.GetNsxtEdgegatewayL2VpnTunnel.Invoke(new()\n    {\n        Org = \"datacloud\",\n        EdgeGatewayId = server_testing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n        Name = \"server-session\",\n    });\n\n    var client_session = new Vcd.NsxtEdgegatewayL2VpnTunnel(\"client-session\", new()\n    {\n        Org = \"datacloud\",\n        EdgeGatewayId = client_testing.Apply(client_testing =\u003e client_testing.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id)),\n        SessionMode = \"CLIENT\",\n        Enabled = true,\n        LocalEndpointIp = \"101.22.30.3\",\n        RemoteEndpointIp = \"1.2.2.3\",\n        PeerCode = server_session.Apply(server_session =\u003e server_session.Apply(getNsxtEdgegatewayL2VpnTunnelResult =\u003e getNsxtEdgegatewayL2VpnTunnelResult.PeerCode)),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tName: \"existing-vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserver_testing, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOwnerId: pulumi.StringRef(existing.Id),\n\t\t\tName:    \"server-testing\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient_testing, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOwnerId: pulumi.StringRef(existing.Id),\n\t\t\tName:    \"client-testing\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserver_session, err := vcd.LookupNsxtEdgegatewayL2VpnTunnel(ctx, \u0026vcd.LookupNsxtEdgegatewayL2VpnTunnelArgs{\n\t\t\tOrg:           pulumi.StringRef(\"datacloud\"),\n\t\t\tEdgeGatewayId: server_testing.Id,\n\t\t\tName:          \"server-session\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewNsxtEdgegatewayL2VpnTunnel(ctx, \"client-session\", \u0026vcd.NsxtEdgegatewayL2VpnTunnelArgs{\n\t\t\tOrg:              pulumi.String(\"datacloud\"),\n\t\t\tEdgeGatewayId:    pulumi.String(client_testing.Id),\n\t\t\tSessionMode:      pulumi.String(\"CLIENT\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tLocalEndpointIp:  pulumi.String(\"101.22.30.3\"),\n\t\t\tRemoteEndpointIp: pulumi.String(\"1.2.2.3\"),\n\t\t\tPeerCode:         pulumi.String(server_session.PeerCode),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayL2VpnTunnelArgs;\nimport com.pulumi.vcd.NsxtEdgegatewayL2VpnTunnel;\nimport com.pulumi.vcd.NsxtEdgegatewayL2VpnTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .name(\"existing-vdc\")\n            .build());\n\n        final var server-testing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .ownerId(existing.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"server-testing\")\n            .build());\n\n        final var client-testing = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .ownerId(existing.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"client-testing\")\n            .build());\n\n        final var server-session = VcdFunctions.getNsxtEdgegatewayL2VpnTunnel(GetNsxtEdgegatewayL2VpnTunnelArgs.builder()\n            .org(\"datacloud\")\n            .edgeGatewayId(server_testing.id())\n            .name(\"server-session\")\n            .build());\n\n        var client_session = new NsxtEdgegatewayL2VpnTunnel(\"client-session\", NsxtEdgegatewayL2VpnTunnelArgs.builder()\n            .org(\"datacloud\")\n            .edgeGatewayId(client_testing.id())\n            .sessionMode(\"CLIENT\")\n            .enabled(true)\n            .localEndpointIp(\"101.22.30.3\")\n            .remoteEndpointIp(\"1.2.2.3\")\n            .peerCode(server_session.peerCode())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  client-session:\n    type: vcd:NsxtEdgegatewayL2VpnTunnel\n    properties:\n      org: datacloud\n      edgeGatewayId: ${[\"client-testing\"].id}\n      sessionMode: CLIENT\n      enabled: true # must be sub-allocated on the Edge Gateway\n      localEndpointIp: 101.22.30.3\n      remoteEndpointIp: 1.2.2.3\n      peerCode: ${[\"server-session\"].peerCode}\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        name: existing-vdc\n  server-testing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        ownerId: ${existing.id}\n        name: server-testing\n  client-testing:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        ownerId: ${existing.id}\n        name: client-testing\n  server-session:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayL2VpnTunnel\n      arguments:\n        org: datacloud\n        edgeGatewayId: ${[\"server-testing\"].id}\n        name: server-session\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayL2VpnTunnel.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). \nCan be looked up using [`vcd.NsxtEdgegateway`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edgegateway) data source\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tunnel.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at \nprovider level. Useful when connected as sysadmin working across different organisations\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayL2VpnTunnel.\n",
                "properties": {
                    "connectorInitiationMode": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "localEndpointIp": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "peerCode": {
                        "type": "string"
                    },
                    "preSharedKey": {
                        "type": "string"
                    },
                    "remoteEndpointIp": {
                        "type": "string"
                    },
                    "sessionMode": {
                        "type": "string"
                    },
                    "stretchedNetworks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewayL2VpnTunnelStretchedNetwork:getNsxtEdgegatewayL2VpnTunnelStretchedNetwork"
                        },
                        "type": "array"
                    },
                    "tunnelInterface": {
                        "type": "string"
                    }
                },
                "required": [
                    "connectorInitiationMode",
                    "description",
                    "edgeGatewayId",
                    "enabled",
                    "localEndpointIp",
                    "name",
                    "peerCode",
                    "preSharedKey",
                    "remoteEndpointIp",
                    "sessionMode",
                    "stretchedNetworks",
                    "tunnelInterface",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayQosProfile:getNsxtEdgegatewayQosProfile": {
            "description": "Supported in provider *v3.9+* and VCD 10.3.2+ with NSX-T.\n\nProvides a data source to read NSX-T Edge Gateway QoS profiles, which can be used to modify NSX-T\nEdge Gateway Rate Limiting (QoS) configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst first = vcd.getNsxtManager({\n    name: \"nsxt-manager-name\",\n});\nconst qos_1 = vcd.getNsxtEdgegatewayQosProfile({\n    nsxtManagerId: firstNsxtManagerId.id,\n    name: \"qos-profile-1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nfirst = vcd.get_nsxt_manager(name=\"nsxt-manager-name\")\nqos_1 = vcd.get_nsxt_edgegateway_qos_profile(nsxt_manager_id=first_nsxt_manager_id[\"id\"],\n    name=\"qos-profile-1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var first = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxt-manager-name\",\n    });\n\n    var qos_1 = Vcd.GetNsxtEdgegatewayQosProfile.Invoke(new()\n    {\n        NsxtManagerId = firstNsxtManagerId.Id,\n        Name = \"qos-profile-1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxt-manager-name\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtEdgegatewayQosProfile(ctx, \u0026vcd.GetNsxtEdgegatewayQosProfileArgs{\n\t\t\tNsxtManagerId: firstNsxtManagerId.Id,\n\t\t\tName:          \"qos-profile-1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayQosProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var first = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxt-manager-name\")\n            .build());\n\n        final var qos-1 = VcdFunctions.getNsxtEdgegatewayQosProfile(GetNsxtEdgegatewayQosProfileArgs.builder()\n            .nsxtManagerId(firstNsxtManagerId.id())\n            .name(\"qos-profile-1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  first:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxt-manager-name\n  qos-1:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayQosProfile\n      arguments:\n        nsxtManagerId: ${firstNsxtManagerId.id}\n        name: qos-profile-1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayQosProfile.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "QoS Profile Name\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "NSX-T Manager where the QoS profile is defined in (can be looked up\nusing `vcd.getNsxtManager` data source)\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "nsxtManagerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayQosProfile.\n",
                "properties": {
                    "burstSize": {
                        "description": "Burst size defined in bytes\n",
                        "type": "integer"
                    },
                    "committedBandwidth": {
                        "description": "Committed bandwith specificd in Mb/s\n",
                        "type": "integer"
                    },
                    "description": {
                        "description": "Description of QoS Profile\n",
                        "type": "string"
                    },
                    "excessAction": {
                        "description": "Excess action defines action on traffic exceeding bandwidth\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    }
                },
                "required": [
                    "burstSize",
                    "committedBandwidth",
                    "description",
                    "excessAction",
                    "name",
                    "nsxtManagerId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayRateLimiting:getNsxtEdgegatewayRateLimiting": {
            "description": "Supported in provider *v3.9+* and VCD 10.3.2+ with NSX-T.\n\nProvides a data source to read NSX-T Edge Gateway Rate Limiting (QoS) configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst v1 = vcd.getOrgVdc({\n    org: \"datacloud\",\n    name: \"nsxt-vdc-datacloud\",\n});\nconst in_vdc = v1.then(v1 =\u003e vcd.getNsxtEdgegateway({\n    org: \"datacloud\",\n    ownerId: v1.id,\n    name: \"nsxt-gw-datacloud\",\n}));\nconst in_vdcGetNsxtEdgegatewayRateLimiting = in_vdc.then(in_vdc =\u003e vcd.getNsxtEdgegatewayRateLimiting({\n    org: \"datacloud\",\n    edgeGatewayId: in_vdc.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nv1 = vcd.get_org_vdc(org=\"datacloud\",\n    name=\"nsxt-vdc-datacloud\")\nin_vdc = vcd.get_nsxt_edgegateway(org=\"datacloud\",\n    owner_id=v1.id,\n    name=\"nsxt-gw-datacloud\")\nin_vdc_get_nsxt_edgegateway_rate_limiting = vcd.get_nsxt_edgegateway_rate_limiting(org=\"datacloud\",\n    edge_gateway_id=in_vdc.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var v1 = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"datacloud\",\n        Name = \"nsxt-vdc-datacloud\",\n    });\n\n    var in_vdc = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"datacloud\",\n        OwnerId = v1.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"nsxt-gw-datacloud\",\n    });\n\n    var in_vdcGetNsxtEdgegatewayRateLimiting = Vcd.GetNsxtEdgegatewayRateLimiting.Invoke(new()\n    {\n        Org = \"datacloud\",\n        EdgeGatewayId = in_vdc.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tv1, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"datacloud\"),\n\t\t\tName: \"nsxt-vdc-datacloud\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tin_vdc, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:     pulumi.StringRef(\"datacloud\"),\n\t\t\tOwnerId: pulumi.StringRef(v1.Id),\n\t\t\tName:    \"nsxt-gw-datacloud\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtEdgegatewayRateLimiting(ctx, \u0026vcd.LookupNsxtEdgegatewayRateLimitingArgs{\n\t\t\tOrg:           pulumi.StringRef(\"datacloud\"),\n\t\t\tEdgeGatewayId: in_vdc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayRateLimitingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var v1 = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"datacloud\")\n            .name(\"nsxt-vdc-datacloud\")\n            .build());\n\n        final var in-vdc = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"datacloud\")\n            .ownerId(v1.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"nsxt-gw-datacloud\")\n            .build());\n\n        final var in-vdcGetNsxtEdgegatewayRateLimiting = VcdFunctions.getNsxtEdgegatewayRateLimiting(GetNsxtEdgegatewayRateLimitingArgs.builder()\n            .org(\"datacloud\")\n            .edgeGatewayId(in_vdc.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  v1:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: datacloud\n        name: nsxt-vdc-datacloud\n  in-vdc:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: datacloud\n        ownerId: ${v1.id}\n        name: nsxt-gw-datacloud\n  in-vdcGetNsxtEdgegatewayRateLimiting:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayRateLimiting\n      arguments:\n        org: datacloud\n        edgeGatewayId: ${[\"in-vdc\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayRateLimiting.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org in which the NSX-T Edge Gateway is located\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayRateLimiting.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "egressProfileId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ingressProfileId": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "required": [
                    "edgeGatewayId",
                    "egressProfileId",
                    "ingressProfileId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtEdgegatewayStaticRoute:getNsxtEdgegatewayStaticRoute": {
            "description": "Supported in provider *v3.10+* and VCD 10.4.0+ with NSX-T.\n\nProvides a data source to read NSX-T Edge Gateway Static Routes.\n\n## Example Usage\n\n### By Name Only)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst by_name = vcd.getNsxtEdgegatewayStaticRoute({\n    edgeGatewayId: existing.id,\n    name: \"existing-static-route\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nby_name = vcd.get_nsxt_edgegateway_static_route(edge_gateway_id=existing[\"id\"],\n    name=\"existing-static-route\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var by_name = Vcd.GetNsxtEdgegatewayStaticRoute.Invoke(new()\n    {\n        EdgeGatewayId = existing.Id,\n        Name = \"existing-static-route\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtEdgegatewayStaticRoute(ctx, \u0026vcd.LookupNsxtEdgegatewayStaticRouteArgs{\n\t\t\tEdgeGatewayId: existing.Id,\n\t\t\tName:          \"existing-static-route\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayStaticRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var by-name = VcdFunctions.getNsxtEdgegatewayStaticRoute(GetNsxtEdgegatewayStaticRouteArgs.builder()\n            .edgeGatewayId(existing.id())\n            .name(\"existing-static-route\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  by-name:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayStaticRoute\n      arguments:\n        edgeGatewayId: ${existing.id}\n        name: existing-static-route\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### By Name And Network CIDR )\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst by_name_and_cidr = vcd.getNsxtEdgegatewayStaticRoute({\n    edgeGatewayId: existing.id,\n    name: \"duplicate-name-sr\",\n    networkCidr: \"10.10.11.0/24\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nby_name_and_cidr = vcd.get_nsxt_edgegateway_static_route(edge_gateway_id=existing[\"id\"],\n    name=\"duplicate-name-sr\",\n    network_cidr=\"10.10.11.0/24\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var by_name_and_cidr = Vcd.GetNsxtEdgegatewayStaticRoute.Invoke(new()\n    {\n        EdgeGatewayId = existing.Id,\n        Name = \"duplicate-name-sr\",\n        NetworkCidr = \"10.10.11.0/24\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtEdgegatewayStaticRoute(ctx, \u0026vcd.LookupNsxtEdgegatewayStaticRouteArgs{\n\t\t\tEdgeGatewayId: existing.Id,\n\t\t\tName:          \"duplicate-name-sr\",\n\t\t\tNetworkCidr:   pulumi.StringRef(\"10.10.11.0/24\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayStaticRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var by-name-and-cidr = VcdFunctions.getNsxtEdgegatewayStaticRoute(GetNsxtEdgegatewayStaticRouteArgs.builder()\n            .edgeGatewayId(existing.id())\n            .name(\"duplicate-name-sr\")\n            .networkCidr(\"10.10.11.0/24\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  by-name-and-cidr:\n    fn::invoke:\n      function: vcd:getNsxtEdgegatewayStaticRoute\n      arguments:\n        edgeGatewayId: ${existing.id}\n        name: duplicate-name-sr\n        networkCidr: 10.10.11.0/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtEdgegatewayStaticRoute.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of Static Route. **Note** names *can be duplicate* and one can use\n`network_cidr` to make filtering more precise\n"
                    },
                    "networkCidr": {
                        "type": "string",
                        "description": "Network CIDR for Static Route\n\n\u003e It may happen that there are multiple NSX-T Static Routes with the same `name`. In such a case, a\ndata source will return an error as it expects to find only one entity. If this happens, one can\nmake the filtering more precise by supplying `network_cidr` in addition to `name`.\n"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtEdgegatewayStaticRoute.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkCidr": {
                        "type": "string"
                    },
                    "nextHops": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtEdgegatewayStaticRouteNextHop:getNsxtEdgegatewayStaticRouteNextHop"
                        },
                        "type": "array"
                    },
                    "org": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "edgeGatewayId",
                    "name",
                    "networkCidr",
                    "nextHops",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtFirewall:getNsxtFirewall": {
            "description": "Supported in provider *v3.3+* and VCD 10.1+ with NSX-T backed Edge Gateways.\n\nProvides a data source to read NSX-T Firewall configuration of an Edge Gateway. Firewalls allow \nuser to control the incoming and outgoing network traffic to and from an NSX-T Data Center \nEdge Gateway.\n\n\n## Example Usage\n\n### Read A List Of Firewall Rules On Edge Gateway)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst testing = vcd.getNsxtFirewall({\n    org: \"my-org\",\n    edgeGatewayId: testingVcdNsxtEdgegateway.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntesting = vcd.get_nsxt_firewall(org=\"my-org\",\n    edge_gateway_id=testing_vcd_nsxt_edgegateway[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testing = Vcd.GetNsxtFirewall.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = testingVcdNsxtEdgegateway.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtFirewall(ctx, \u0026vcd.LookupNsxtFirewallArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: testingVcdNsxtEdgegateway.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtFirewallArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testing = VcdFunctions.getNsxtFirewall(GetNsxtFirewallArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(testingVcdNsxtEdgegateway.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  testing:\n    fn::invoke:\n      function: vcd:getNsxtFirewall\n      arguments:\n        org: my-org\n        edgeGatewayId: ${testingVcdNsxtEdgegateway.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtFirewall.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n`vcd.NsxtEdgegateway` data source\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organizations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtFirewall.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "rules": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtFirewallRule:getNsxtFirewallRule"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field",
                        "type": "string"
                    }
                },
                "required": [
                    "edgeGatewayId",
                    "rules",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtGlobalDefaultSegmentProfileTemplate:getNsxtGlobalDefaultSegmentProfileTemplate": {
            "description": "Provides a resource to manage Global Default NSX-T Segment Profile Templates.\n\nSupported in provider *v3.11+* and VCD 10.4.0+ with NSX-T. Requires System Administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst singleton = new vcd.NsxtGlobalDefaultSegmentProfileTemplate(\"singleton\", {});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsingleton = vcd.NsxtGlobalDefaultSegmentProfileTemplate(\"singleton\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var singleton = new Vcd.NsxtGlobalDefaultSegmentProfileTemplate(\"singleton\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.NewNsxtGlobalDefaultSegmentProfileTemplate(ctx, \"singleton\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.NsxtGlobalDefaultSegmentProfileTemplate;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var singleton = new NsxtGlobalDefaultSegmentProfileTemplate(\"singleton\");\n\n    }\n}\n```\n```yaml\nresources:\n  singleton:\n    type: vcd:NsxtGlobalDefaultSegmentProfileTemplate\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getNsxtGlobalDefaultSegmentProfileTemplate.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "vappNetworksDefaultSegmentProfileTemplateId": {
                        "description": "Global Default Segment Profile\nTemplate ID for all vApp Networks\n",
                        "type": "string"
                    },
                    "vdcNetworksDefaultSegmentProfileTemplateId": {
                        "description": "Global Default Segment Profile\nTemplate ID for all VDC Networks\n",
                        "type": "string"
                    }
                },
                "required": [
                    "vappNetworksDefaultSegmentProfileTemplateId",
                    "vdcNetworksDefaultSegmentProfileTemplateId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtIpSet:getNsxtIpSet": {
            "description": "Supported in provider *v3.3+* and VCD 10.1+ with NSX-T backed VDCs.\n\nProvides a data source to read NSX-T IP Set. IP Sets are groups of objects to which the firewall rules apply. Combining\nmultiple objects into IP Sets helps reduce the total number of firewall rules to be created.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    name: \"main-edge\",\n});\nconst my_set_1 = main.then(main =\u003e vcd.getNsxtIpSet({\n    org: \"my-org\",\n    edgeGatewayId: main.id,\n    name: \"frontend-servers\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    name=\"main-edge\")\nmy_set_1 = vcd.get_nsxt_ip_set(org=\"my-org\",\n    edge_gateway_id=main.id,\n    name=\"frontend-servers\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-edge\",\n    });\n\n    var my_set_1 = Vcd.GetNsxtIpSet.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = main.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n        Name = \"frontend-servers\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"main-edge\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtIpSet(ctx, \u0026vcd.LookupNsxtIpSetArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: main.Id,\n\t\t\tName:          \"frontend-servers\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtIpSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-edge\")\n            .build());\n\n        final var my-set-1 = VcdFunctions.getNsxtIpSet(GetNsxtIpSetArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(main.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .name(\"frontend-servers\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        name: main-edge\n  my-set-1:\n    fn::invoke:\n      function: vcd:getNsxtIpSet\n      arguments:\n        org: my-org\n        edgeGatewayId: ${main.id}\n        name: frontend-servers\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtIpSet.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Unique name of existing IP Set.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. IP Set will inherit VDC from parent Edge Gateway.",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtIpSet.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipAddresses": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerId": {
                        "description": "Parent VDC or VDC Group ID.\n",
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. IP Set will inherit VDC from parent Edge Gateway.",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "edgeGatewayId",
                    "ipAddresses",
                    "name",
                    "ownerId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtIpsecVpnTunnel:getNsxtIpsecVpnTunnel": {
            "description": "Supported in provider *v3.3+* and VCD 10.1+ with NSX-T backed VDCs.\n\nProvides a data source to read NSX-T IPsec VPN Tunnel. You can configure site-to-site connectivity between an NSX-T Data\nCenter Edge Gateway and remote sites. The remote sites must use NSX-T Data Center, have third-party hardware routers,\nor VPN gateways that support IPSec.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst tunnel1 = vcd.getNsxtIpsecVpnTunnel({\n    org: \"my-org\",\n    edgeGatewayId: existing.id,\n    name: \"tunnel-1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntunnel1 = vcd.get_nsxt_ipsec_vpn_tunnel(org=\"my-org\",\n    edge_gateway_id=existing[\"id\"],\n    name=\"tunnel-1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tunnel1 = Vcd.GetNsxtIpsecVpnTunnel.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = existing.Id,\n        Name = \"tunnel-1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtIpsecVpnTunnel(ctx, \u0026vcd.LookupNsxtIpsecVpnTunnelArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: existing.Id,\n\t\t\tName:          \"tunnel-1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtIpsecVpnTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tunnel1 = VcdFunctions.getNsxtIpsecVpnTunnel(GetNsxtIpsecVpnTunnelArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(existing.id())\n            .name(\"tunnel-1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  tunnel1:\n    fn::invoke:\n      function: vcd:getNsxtIpsecVpnTunnel\n      arguments:\n        org: my-org\n        edgeGatewayId: ${existing.id}\n        name: tunnel-1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtIpsecVpnTunnel.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using `vcd.NsxtEdgegateway`\ndata source\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of existing IPsec VPN Tunnel\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtIpsecVpnTunnel.\n",
                "properties": {
                    "authenticationMode": {
                        "type": "string"
                    },
                    "caCertificateId": {
                        "type": "string"
                    },
                    "certificateId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ikeFailReason": {
                        "type": "string"
                    },
                    "ikeServiceStatus": {
                        "type": "string"
                    },
                    "localIpAddress": {
                        "type": "string"
                    },
                    "localNetworks": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "logging": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "preSharedKey": {
                        "type": "string"
                    },
                    "remoteId": {
                        "type": "string"
                    },
                    "remoteIpAddress": {
                        "type": "string"
                    },
                    "remoteNetworks": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "securityProfile": {
                        "type": "string"
                    },
                    "securityProfileCustomizations": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtIpsecVpnTunnelSecurityProfileCustomization:getNsxtIpsecVpnTunnelSecurityProfileCustomization"
                        },
                        "type": "array"
                    },
                    "status": {
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field",
                        "type": "string"
                    }
                },
                "required": [
                    "authenticationMode",
                    "caCertificateId",
                    "certificateId",
                    "description",
                    "edgeGatewayId",
                    "enabled",
                    "ikeFailReason",
                    "ikeServiceStatus",
                    "localIpAddress",
                    "localNetworks",
                    "logging",
                    "name",
                    "preSharedKey",
                    "remoteId",
                    "remoteIpAddress",
                    "remoteNetworks",
                    "securityProfile",
                    "securityProfileCustomizations",
                    "status",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtManager:getNsxtManager": {
            "description": "Provides a data source for NSX-T manager.\n\nSupported in provider *v3.0+*\n\n\u003e **Note:** This resource uses new VMware Cloud Director\n[OpenAPI](https://code.vmware.com/docs/11982/getting-started-with-vmware-cloud-director-openapi) and\nrequires at least VCD *10.1.1+* and NSX-T *3.0+*.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getNsxtManager({\n    name: \"nsxt-manager-one\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_nsxt_manager(name=\"nsxt-manager-one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxt-manager-one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxt-manager-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxt-manager-one\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxt-manager-one\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtManager.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "NSX-T manager name\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtManager.\n",
                "properties": {
                    "href": {
                        "description": "Full URL of the manager\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "href",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtNatRule:getNsxtNatRule": {
            "description": "Supported in provider *v3.3+* and VCD 10.1+ with NSX-T backed VDCs.\n\nProvides a data source to read NSX-T NAT rules. Source NAT (SNAT) rules change the source IP \naddress from a private to a public IP address. Destination NAT (DNAT) rules change the destination\nIP address from a public to a private IP address.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst dnat_ssh = vcd.getNsxtNatRule({\n    org: \"my-org\",\n    edgeGatewayId: existing.id,\n    name: \"dnat-ssh\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ndnat_ssh = vcd.get_nsxt_nat_rule(org=\"my-org\",\n    edge_gateway_id=existing[\"id\"],\n    name=\"dnat-ssh\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dnat_ssh = Vcd.GetNsxtNatRule.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = existing.Id,\n        Name = \"dnat-ssh\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtNatRule(ctx, \u0026vcd.LookupNsxtNatRuleArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: existing.Id,\n\t\t\tName:          \"dnat-ssh\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtNatRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dnat-ssh = VcdFunctions.getNsxtNatRule(GetNsxtNatRuleArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(existing.id())\n            .name(\"dnat-ssh\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  dnat-ssh:\n    fn::invoke:\n      function: vcd:getNsxtNatRule\n      arguments:\n        org: my-org\n        edgeGatewayId: ${existing.id}\n        name: dnat-ssh\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtNatRule.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of existing NAT Rule.\n\n\u003e Name uniqueness is not enforced in NSX-T NAT rules, but for this data source to work properly\nnames should be unique so that they can be distinguished.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organizations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtNatRule.\n",
                "properties": {
                    "appPortProfileId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "dnatExternalPort": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "externalAddress": {
                        "type": "string"
                    },
                    "firewallMatch": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "internalAddress": {
                        "type": "string"
                    },
                    "logging": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "ruleType": {
                        "type": "string"
                    },
                    "snatDestinationAddress": {
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "Edge Gateway will be looked up based on 'edge_gateway_id' field",
                        "type": "string"
                    }
                },
                "required": [
                    "appPortProfileId",
                    "description",
                    "dnatExternalPort",
                    "edgeGatewayId",
                    "enabled",
                    "externalAddress",
                    "firewallMatch",
                    "internalAddress",
                    "logging",
                    "name",
                    "priority",
                    "ruleType",
                    "snatDestinationAddress",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtNetworkContextProfile:getNsxtNetworkContextProfile": {
            "description": "Provides a data source for NSX-T Network Context Profile lookup to later be used in Distributed\nFirewall.\n\n## Example Usage\n\n### SYSTEM Scope Network Context Profile Lookup In A VDC Group)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existing = vcd.getVdcGroup({\n    org: \"my-org\",\n    name: \"main-vdc-group\",\n});\nconst cp1 = existing.then(existing =\u003e vcd.getNsxtNetworkContextProfile({\n    contextId: existing.id,\n    name: \"CTRXICA\",\n    scope: \"SYSTEM\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting = vcd.get_vdc_group(org=\"my-org\",\n    name=\"main-vdc-group\")\ncp1 = vcd.get_nsxt_network_context_profile(context_id=existing.id,\n    name=\"CTRXICA\",\n    scope=\"SYSTEM\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existing = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-vdc-group\",\n    });\n\n    var cp1 = Vcd.GetNsxtNetworkContextProfile.Invoke(new()\n    {\n        ContextId = existing.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"CTRXICA\",\n        Scope = \"SYSTEM\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texisting, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"main-vdc-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtNetworkContextProfile(ctx, \u0026vcd.GetNsxtNetworkContextProfileArgs{\n\t\t\tContextId: existing.Id,\n\t\t\tName:      \"CTRXICA\",\n\t\t\tScope:     pulumi.StringRef(\"SYSTEM\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkContextProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existing = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-vdc-group\")\n            .build());\n\n        final var cp1 = VcdFunctions.getNsxtNetworkContextProfile(GetNsxtNetworkContextProfileArgs.builder()\n            .contextId(existing.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"CTRXICA\")\n            .scope(\"SYSTEM\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  existing:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: my-org\n        name: main-vdc-group\n  cp1:\n    fn::invoke:\n      function: vcd:getNsxtNetworkContextProfile\n      arguments:\n        contextId: ${existing.id}\n        name: CTRXICA\n        scope: SYSTEM\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### SYSTEM Profile Lookup In An NSX-T Manager)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getNsxtManager({\n    name: \"first-nsxt-manager\",\n});\nconst p = main.then(main =\u003e vcd.getNsxtNetworkContextProfile({\n    contextId: main.id,\n    name: \"CTRXICA\",\n    scope: \"SYSTEM\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_nsxt_manager(name=\"first-nsxt-manager\")\np = vcd.get_nsxt_network_context_profile(context_id=main.id,\n    name=\"CTRXICA\",\n    scope=\"SYSTEM\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"first-nsxt-manager\",\n    });\n\n    var p = Vcd.GetNsxtNetworkContextProfile.Invoke(new()\n    {\n        ContextId = main.Apply(getNsxtManagerResult =\u003e getNsxtManagerResult.Id),\n        Name = \"CTRXICA\",\n        Scope = \"SYSTEM\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"first-nsxt-manager\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtNetworkContextProfile(ctx, \u0026vcd.GetNsxtNetworkContextProfileArgs{\n\t\t\tContextId: main.Id,\n\t\t\tName:      \"CTRXICA\",\n\t\t\tScope:     pulumi.StringRef(\"SYSTEM\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkContextProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"first-nsxt-manager\")\n            .build());\n\n        final var p = VcdFunctions.getNsxtNetworkContextProfile(GetNsxtNetworkContextProfileArgs.builder()\n            .contextId(main.applyValue(getNsxtManagerResult -\u003e getNsxtManagerResult.id()))\n            .name(\"CTRXICA\")\n            .scope(\"SYSTEM\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: first-nsxt-manager\n  p:\n    fn::invoke:\n      function: vcd:getNsxtNetworkContextProfile\n      arguments:\n        contextId: ${main.id}\n        name: CTRXICA\n        scope: SYSTEM\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtNetworkContextProfile.\n",
                "properties": {
                    "contextId": {
                        "type": "string",
                        "description": "Context ID specifies the context for Network Context Profile look up.\nThis ID can be one of `VDC Group ID` (data source `vcd.VdcGroup`), `Org VDC ID` (data source\n`vcd.OrgVdc`), or `NSX-T Manager ID` (data source `vcd.getNsxtManager`)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of Network Context Profile\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Can be one of `SYSTEM`, `TENANT`, `PROVIDER`. (default `SYSTEM`)\n"
                    }
                },
                "type": "object",
                "required": [
                    "contextId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtNetworkContextProfile.\n",
                "properties": {
                    "contextId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "scope": {
                        "type": "string"
                    }
                },
                "required": [
                    "contextId",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtNetworkDhcp:getNsxtNetworkDhcp": {
            "description": "Provides a data source to read DHCP pools for NSX-T Org VDC networks.\n\n## Example Usage\n\n### 1\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst parent = vcd.getNetworkRoutedV2({\n    org: \"my-org\",\n    vdc: \"my-vdc\",\n    name: \"my-parent-network\",\n});\nconst pools = parent.then(parent =\u003e vcd.getNsxtNetworkDhcp({\n    org: \"my-org\",\n    orgNetworkId: parent.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nparent = vcd.get_network_routed_v2(org=\"my-org\",\n    vdc=\"my-vdc\",\n    name=\"my-parent-network\")\npools = vcd.get_nsxt_network_dhcp(org=\"my-org\",\n    org_network_id=parent.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var parent = Vcd.GetNetworkRoutedV2.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n        Name = \"my-parent-network\",\n    });\n\n    var pools = Vcd.GetNsxtNetworkDhcp.Invoke(new()\n    {\n        Org = \"my-org\",\n        OrgNetworkId = parent.Apply(getNetworkRoutedV2Result =\u003e getNetworkRoutedV2Result.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tparent, err := vcd.LookupNetworkRoutedV2(ctx, \u0026vcd.LookupNetworkRoutedV2Args{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"my-vdc\"),\n\t\t\tName: pulumi.StringRef(\"my-parent-network\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtNetworkDhcp(ctx, \u0026vcd.LookupNsxtNetworkDhcpArgs{\n\t\t\tOrg:          pulumi.StringRef(\"my-org\"),\n\t\t\tOrgNetworkId: parent.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNetworkRoutedV2Args;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkDhcpArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var parent = VcdFunctions.getNetworkRoutedV2(GetNetworkRoutedV2Args.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .name(\"my-parent-network\")\n            .build());\n\n        final var pools = VcdFunctions.getNsxtNetworkDhcp(GetNsxtNetworkDhcpArgs.builder()\n            .org(\"my-org\")\n            .orgNetworkId(parent.applyValue(getNetworkRoutedV2Result -\u003e getNetworkRoutedV2Result.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  parent:\n    fn::invoke:\n      function: vcd:getNetworkRoutedV2\n      arguments:\n        org: my-org\n        vdc: my-vdc\n        name: my-parent-network\n  pools:\n    fn::invoke:\n      function: vcd:getNsxtNetworkDhcp\n      arguments:\n        org: my-org\n        orgNetworkId: ${parent.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtNetworkDhcp.\n",
                "properties": {
                    "dnsServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkId": {
                        "type": "string",
                        "description": "ID of parent Org VDC Routed network\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "deprecationMessage": "Org network will be looked up based on 'org_network_id' field"
                    }
                },
                "type": "object",
                "required": [
                    "orgNetworkId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtNetworkDhcp.\n",
                "properties": {
                    "dnsServers": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "leaseTime": {
                        "type": "integer"
                    },
                    "listenerIpAddress": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "orgNetworkId": {
                        "type": "string"
                    },
                    "pools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtNetworkDhcpPool:getNsxtNetworkDhcpPool"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "deprecationMessage": "Org network will be looked up based on 'org_network_id' field",
                        "type": "string"
                    }
                },
                "required": [
                    "leaseTime",
                    "listenerIpAddress",
                    "mode",
                    "orgNetworkId",
                    "pools",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtNetworkDhcpBinding:getNsxtNetworkDhcpBinding": {
            "description": "Provides a data source to read NSX-T Org VDC network DHCP bindings.\n\n\u003e This data source requires VCD 10.3.1+\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst pools = vcd.getNsxtNetworkDhcp({\n    org: \"cloud\",\n    orgNetworkId: parent.id,\n});\nconst binding1 = pools.then(pools =\u003e vcd.getNsxtNetworkDhcpBinding({\n    org: \"cloud\",\n    orgNetworkId: pools.id,\n    name: \"Binding-one\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\npools = vcd.get_nsxt_network_dhcp(org=\"cloud\",\n    org_network_id=parent[\"id\"])\nbinding1 = vcd.get_nsxt_network_dhcp_binding(org=\"cloud\",\n    org_network_id=pools.id,\n    name=\"Binding-one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pools = Vcd.GetNsxtNetworkDhcp.Invoke(new()\n    {\n        Org = \"cloud\",\n        OrgNetworkId = parent.Id,\n    });\n\n    var binding1 = Vcd.GetNsxtNetworkDhcpBinding.Invoke(new()\n    {\n        Org = \"cloud\",\n        OrgNetworkId = pools.Apply(getNsxtNetworkDhcpResult =\u003e getNsxtNetworkDhcpResult.Id),\n        Name = \"Binding-one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpools, err := vcd.LookupNsxtNetworkDhcp(ctx, \u0026vcd.LookupNsxtNetworkDhcpArgs{\n\t\t\tOrg:          pulumi.StringRef(\"cloud\"),\n\t\t\tOrgNetworkId: parent.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtNetworkDhcpBinding(ctx, \u0026vcd.LookupNsxtNetworkDhcpBindingArgs{\n\t\t\tOrg:          pulumi.StringRef(\"cloud\"),\n\t\t\tOrgNetworkId: pools.Id,\n\t\t\tName:         \"Binding-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkDhcpArgs;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkDhcpBindingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var pools = VcdFunctions.getNsxtNetworkDhcp(GetNsxtNetworkDhcpArgs.builder()\n            .org(\"cloud\")\n            .orgNetworkId(parent.id())\n            .build());\n\n        final var binding1 = VcdFunctions.getNsxtNetworkDhcpBinding(GetNsxtNetworkDhcpBindingArgs.builder()\n            .org(\"cloud\")\n            .orgNetworkId(pools.applyValue(getNsxtNetworkDhcpResult -\u003e getNsxtNetworkDhcpResult.id()))\n            .name(\"Binding-one\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  pools:\n    fn::invoke:\n      function: vcd:getNsxtNetworkDhcp\n      arguments:\n        org: cloud\n        orgNetworkId: ${parent.id}\n  binding1:\n    fn::invoke:\n      function: vcd:getNsxtNetworkDhcpBinding\n      arguments:\n        org: cloud\n        orgNetworkId: ${pools.id}\n        name: Binding-one\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtNetworkDhcpBinding.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "A name of DHCP binding\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization. Optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkId": {
                        "type": "string",
                        "description": "The ID of an Org VDC network. **Note**  `.id` field of\n`vcd.NetworkIsolatedV2`, `vcd.NetworkRoutedV2` or `vcd.NsxtNetworkDhcp` can be referenced\nhere\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "orgNetworkId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtNetworkDhcpBinding.\n",
                "properties": {
                    "bindingType": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "dhcpV4Configs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtNetworkDhcpBindingDhcpV4Config:getNsxtNetworkDhcpBindingDhcpV4Config"
                        },
                        "type": "array"
                    },
                    "dhcpV6Configs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtNetworkDhcpBindingDhcpV6Config:getNsxtNetworkDhcpBindingDhcpV6Config"
                        },
                        "type": "array"
                    },
                    "dnsServers": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "leaseTime": {
                        "type": "integer"
                    },
                    "macAddress": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "orgNetworkId": {
                        "type": "string"
                    }
                },
                "required": [
                    "bindingType",
                    "description",
                    "dhcpV4Configs",
                    "dhcpV6Configs",
                    "dnsServers",
                    "ipAddress",
                    "leaseTime",
                    "macAddress",
                    "name",
                    "orgNetworkId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtNetworkImported:getNsxtNetworkImported": {
            "description": "## Example Usage\n\n### Looking Up Imported Network In VDC)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getOrgVdc({\n    org: \"my-org\",\n    name: \"main-edge\",\n});\nconst net = main.then(main =\u003e vcd.getNsxtNetworkImported({\n    org: \"my-org\",\n    ownerId: main.id,\n    name: \"my-net\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_org_vdc(org=\"my-org\",\n    name=\"main-edge\")\nnet = vcd.get_nsxt_network_imported(org=\"my-org\",\n    owner_id=main.id,\n    name=\"my-net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-edge\",\n    });\n\n    var net = Vcd.GetNsxtNetworkImported.Invoke(new()\n    {\n        Org = \"my-org\",\n        OwnerId = main.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n        Name = \"my-net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"main-edge\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtNetworkImported(ctx, \u0026vcd.LookupNsxtNetworkImportedArgs{\n\t\t\tOrg:     pulumi.StringRef(\"my-org\"),\n\t\t\tOwnerId: pulumi.StringRef(main.Id),\n\t\t\tName:    pulumi.StringRef(\"my-net\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkImportedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-edge\")\n            .build());\n\n        final var net = VcdFunctions.getNsxtNetworkImported(GetNsxtNetworkImportedArgs.builder()\n            .org(\"my-org\")\n            .ownerId(main.applyValue(getOrgVdcResult -\u003e getOrgVdcResult.id()))\n            .name(\"my-net\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: my-org\n        name: main-edge\n  net:\n    fn::invoke:\n      function: vcd:getNsxtNetworkImported\n      arguments:\n        org: my-org\n        ownerId: ${main.id}\n        name: my-net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Looking Up Imported Network In VDC Group)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getVdcGroup({\n    org: \"my-org\",\n    name: \"main-group\",\n});\nconst net = main.then(main =\u003e vcd.getNsxtNetworkImported({\n    org: \"my-org\",\n    ownerId: main.id,\n    name: \"my-net\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_vdc_group(org=\"my-org\",\n    name=\"main-group\")\nnet = vcd.get_nsxt_network_imported(org=\"my-org\",\n    owner_id=main.id,\n    name=\"my-net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-group\",\n    });\n\n    var net = Vcd.GetNsxtNetworkImported.Invoke(new()\n    {\n        Org = \"my-org\",\n        OwnerId = main.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"my-net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"main-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtNetworkImported(ctx, \u0026vcd.LookupNsxtNetworkImportedArgs{\n\t\t\tOrg:     pulumi.StringRef(\"my-org\"),\n\t\t\tOwnerId: pulumi.StringRef(main.Id),\n\t\t\tName:    pulumi.StringRef(\"my-net\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkImportedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-group\")\n            .build());\n\n        final var net = VcdFunctions.getNsxtNetworkImported(GetNsxtNetworkImportedArgs.builder()\n            .org(\"my-org\")\n            .ownerId(main.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"my-net\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: my-org\n        name: main-group\n  net:\n    fn::invoke:\n      function: vcd:getNsxtNetworkImported\n      arguments:\n        org: my-org\n        ownerId: ${main.id}\n        name: my-net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n* `name_regex` - (Optional) matches the name using a regular expression.\n* `ip` - (Optional) matches the IP of the resource using a regular expression.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtNetworkImported.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/vcd:index/getNsxtNetworkImportedFilter:getNsxtNetworkImportedFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the network (optional when `filter` is used)\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "ownerId": {
                        "type": "string",
                        "description": "VDC or VDC Group ID. Always takes precedence over `vdc` fields (in resource\nand inherited from provider configuration)\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use. **Deprecated**  in favor of new field\n`owner_id` which supports VDC and VDC Group IDs.\n",
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtNetworkImported.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "dns1": {
                        "type": "string"
                    },
                    "dns2": {
                        "type": "string"
                    },
                    "dnsSuffix": {
                        "type": "string"
                    },
                    "dualStackEnabled": {
                        "type": "boolean"
                    },
                    "dvpgId": {
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getNsxtNetworkImportedFilter:getNsxtNetworkImportedFilter"
                    },
                    "gateway": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtLogicalSwitchId": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerId": {
                        "type": "string"
                    },
                    "prefixLength": {
                        "type": "integer"
                    },
                    "secondaryGateway": {
                        "type": "string"
                    },
                    "secondaryPrefixLength": {
                        "type": "string"
                    },
                    "secondaryStaticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtNetworkImportedSecondaryStaticIpPool:getNsxtNetworkImportedSecondaryStaticIpPool"
                        },
                        "type": "array"
                    },
                    "staticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtNetworkImportedStaticIpPool:getNsxtNetworkImportedStaticIpPool"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "deprecationMessage": "This field is deprecated in favor of 'owner_id' which supports both - VDC and VDC Group IDs",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "dns1",
                    "dns2",
                    "dnsSuffix",
                    "dualStackEnabled",
                    "dvpgId",
                    "gateway",
                    "nsxtLogicalSwitchId",
                    "ownerId",
                    "prefixLength",
                    "secondaryGateway",
                    "secondaryPrefixLength",
                    "secondaryStaticIpPools",
                    "staticIpPools",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtNetworkSegmentProfile:getNsxtNetworkSegmentProfile": {
            "description": "Provides a data source to read Segment Profile configuration for NSX-T Org VDC networks.\n\nSupported in provider *v3.11+* and VCD 10.4.0+ with NSX-T.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst custom_prof = vcd.getNsxtNetworkSegmentProfile({\n    org: \"my-org\",\n    orgNetworkId: net1.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ncustom_prof = vcd.get_nsxt_network_segment_profile(org=\"my-org\",\n    org_network_id=net1[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var custom_prof = Vcd.GetNsxtNetworkSegmentProfile.Invoke(new()\n    {\n        Org = \"my-org\",\n        OrgNetworkId = net1.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtNetworkSegmentProfile(ctx, \u0026vcd.LookupNsxtNetworkSegmentProfileArgs{\n\t\t\tOrg:          pulumi.StringRef(\"my-org\"),\n\t\t\tOrgNetworkId: net1.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtNetworkSegmentProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var custom-prof = VcdFunctions.getNsxtNetworkSegmentProfile(GetNsxtNetworkSegmentProfileArgs.builder()\n            .org(\"my-org\")\n            .orgNetworkId(net1.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  custom-prof:\n    fn::invoke:\n      function: vcd:getNsxtNetworkSegmentProfile\n      arguments:\n        org: my-org\n        orgNetworkId: ${net1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtNetworkSegmentProfile.\n",
                "properties": {
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "orgNetworkId": {
                        "type": "string",
                        "description": "Org VDC Network ID\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgNetworkId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtNetworkSegmentProfile.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipDiscoveryProfileId": {
                        "type": "string"
                    },
                    "macDiscoveryProfileId": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "orgNetworkId": {
                        "type": "string"
                    },
                    "qosProfileId": {
                        "type": "string"
                    },
                    "segmentProfileTemplateId": {
                        "type": "string"
                    },
                    "segmentProfileTemplateName": {
                        "type": "string"
                    },
                    "segmentSecurityProfileId": {
                        "type": "string"
                    },
                    "spoofGuardProfileId": {
                        "type": "string"
                    }
                },
                "required": [
                    "ipDiscoveryProfileId",
                    "macDiscoveryProfileId",
                    "orgNetworkId",
                    "qosProfileId",
                    "segmentProfileTemplateId",
                    "segmentProfileTemplateName",
                    "segmentSecurityProfileId",
                    "spoofGuardProfileId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtRouteAdvertisement:getNsxtRouteAdvertisement": {
            "description": "Provides a VMware Cloud Director data source for reading route advertisement in an NSX-T Edge Gateway.\n\n## Example Usage\n\n### Reading Route Advertisement From NSX-T Edge Gateway)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst group1 = vcd.getVdcGroup({\n    name: \"my-vdc-group\",\n});\nconst t1 = group1.then(group1 =\u003e vcd.getNsxtEdgegateway({\n    ownerId: group1.id,\n    name: \"my-nsxt-edge-gateway\",\n}));\nconst routeAdvertisement = t1.then(t1 =\u003e vcd.getNsxtRouteAdvertisement({\n    edgeGatewayId: t1.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ngroup1 = vcd.get_vdc_group(name=\"my-vdc-group\")\nt1 = vcd.get_nsxt_edgegateway(owner_id=group1.id,\n    name=\"my-nsxt-edge-gateway\")\nroute_advertisement = vcd.get_nsxt_route_advertisement(edge_gateway_id=t1.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var group1 = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Name = \"my-vdc-group\",\n    });\n\n    var t1 = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        OwnerId = group1.Apply(getVdcGroupResult =\u003e getVdcGroupResult.Id),\n        Name = \"my-nsxt-edge-gateway\",\n    });\n\n    var routeAdvertisement = Vcd.GetNsxtRouteAdvertisement.Invoke(new()\n    {\n        EdgeGatewayId = t1.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup1, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tName: pulumi.StringRef(\"my-vdc-group\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt1, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOwnerId: pulumi.StringRef(group1.Id),\n\t\t\tName:    \"my-nsxt-edge-gateway\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtRouteAdvertisement(ctx, \u0026vcd.LookupNsxtRouteAdvertisementArgs{\n\t\t\tEdgeGatewayId: t1.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtRouteAdvertisementArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var group1 = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .name(\"my-vdc-group\")\n            .build());\n\n        final var t1 = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .ownerId(group1.applyValue(getVdcGroupResult -\u003e getVdcGroupResult.id()))\n            .name(\"my-nsxt-edge-gateway\")\n            .build());\n\n        final var routeAdvertisement = VcdFunctions.getNsxtRouteAdvertisement(GetNsxtRouteAdvertisementArgs.builder()\n            .edgeGatewayId(t1.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  group1:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        name: my-vdc-group\n  t1:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        ownerId: ${group1.id}\n        name: my-nsxt-edge-gateway\n  routeAdvertisement:\n    fn::invoke:\n      function: vcd:getNsxtRouteAdvertisement\n      arguments:\n        edgeGatewayId: ${t1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtRouteAdvertisement.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "NSX-T Edge Gateway ID in which route advertisement is located.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organizations.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtRouteAdvertisement.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "subnets": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "edgeGatewayId",
                    "enabled",
                    "subnets",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtSecurityGroup:getNsxtSecurityGroup": {
            "description": "Supported in provider *v3.3+* and VCD 10.1+ with NSX-T backed VDCs.\n\nProvides a data source to access NSX-T Security Group configuration. Security Groups are groups of\ndata center group networks to which distributed firewall rules apply. Grouping networks helps you to\nreduce the total number of distributed firewall rules to be created.\n\n## Example Usage\n\n### 1\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getNsxtEdgegateway({\n    org: \"my-org\",\n    name: \"main-edge\",\n});\nconst group1 = main.then(main =\u003e vcd.getNsxtSecurityGroup({\n    org: \"my-org\",\n    edgeGatewayId: main.id,\n    name: \"test-security-group-changed\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_nsxt_edgegateway(org=\"my-org\",\n    name=\"main-edge\")\ngroup1 = vcd.get_nsxt_security_group(org=\"my-org\",\n    edge_gateway_id=main.id,\n    name=\"test-security-group-changed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetNsxtEdgegateway.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"main-edge\",\n    });\n\n    var group1 = Vcd.GetNsxtSecurityGroup.Invoke(new()\n    {\n        Org = \"my-org\",\n        EdgeGatewayId = main.Apply(getNsxtEdgegatewayResult =\u003e getNsxtEdgegatewayResult.Id),\n        Name = \"test-security-group-changed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.LookupNsxtEdgegateway(ctx, \u0026vcd.LookupNsxtEdgegatewayArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"main-edge\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxtSecurityGroup(ctx, \u0026vcd.LookupNsxtSecurityGroupArgs{\n\t\t\tOrg:           pulumi.StringRef(\"my-org\"),\n\t\t\tEdgeGatewayId: main.Id,\n\t\t\tName:          \"test-security-group-changed\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtEdgegatewayArgs;\nimport com.pulumi.vcd.inputs.GetNsxtSecurityGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getNsxtEdgegateway(GetNsxtEdgegatewayArgs.builder()\n            .org(\"my-org\")\n            .name(\"main-edge\")\n            .build());\n\n        final var group1 = VcdFunctions.getNsxtSecurityGroup(GetNsxtSecurityGroupArgs.builder()\n            .org(\"my-org\")\n            .edgeGatewayId(main.applyValue(getNsxtEdgegatewayResult -\u003e getNsxtEdgegatewayResult.id()))\n            .name(\"test-security-group-changed\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getNsxtEdgegateway\n      arguments:\n        org: my-org\n        name: main-edge\n  group1:\n    fn::invoke:\n      function: vcd:getNsxtSecurityGroup\n      arguments:\n        org: my-org\n        edgeGatewayId: ${main.id}\n        name: test-security-group-changed\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtSecurityGroup.\n",
                "properties": {
                    "edgeGatewayId": {
                        "type": "string",
                        "description": "The ID of the Edge Gateway (NSX-T only). Can be looked up using\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Unique name of existing Security Group.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level. **Deprecated**\nin favor of `edge_gateway_id` field.\n",
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. Security Group will inherit VDC from parent Edge Gateway."
                    }
                },
                "type": "object",
                "required": [
                    "edgeGatewayId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtSecurityGroup.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "edgeGatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "memberOrgNetworkIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "memberVms": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxtSecurityGroupMemberVm:getNsxtSecurityGroupMemberVm"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerId": {
                        "description": "Parent VDC or VDC Group ID.\n",
                        "type": "string"
                    },
                    "vdc": {
                        "deprecationMessage": "Deprecated in favor of `edge_gateway_id`. Security Group will inherit VDC from parent Edge Gateway.",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "edgeGatewayId",
                    "memberOrgNetworkIds",
                    "memberVms",
                    "name",
                    "ownerId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtSegmentIpDiscoveryProfile:getNsxtSegmentIpDiscoveryProfile": {
            "description": "Provides a VMware Cloud Director NSX-T IP Discovery Profile data source. This can be used to read NSX-T Segment Profile definitions.\n\nSupported in provider *v3.11+*.\n\n## Example Usage\n\n### IP Discovery Profile)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt = vcd.getNsxtManager({\n    name: \"nsxManager1\",\n});\nconst first = nsxt.then(nsxt =\u003e vcd.getNsxtSegmentIpDiscoveryProfile({\n    name: \"ip-discovery-profile-0\",\n    nsxtManagerId: nsxt.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt = vcd.get_nsxt_manager(name=\"nsxManager1\")\nfirst = vcd.get_nsxt_segment_ip_discovery_profile(name=\"ip-discovery-profile-0\",\n    nsxt_manager_id=nsxt.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxManager1\",\n    });\n\n    var first = Vcd.GetNsxtSegmentIpDiscoveryProfile.Invoke(new()\n    {\n        Name = \"ip-discovery-profile-0\",\n        NsxtManagerId = nsxt.Apply(getNsxtManagerResult =\u003e getNsxtManagerResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnsxt, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxManager1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtSegmentIpDiscoveryProfile(ctx, \u0026vcd.GetNsxtSegmentIpDiscoveryProfileArgs{\n\t\t\tName:          \"ip-discovery-profile-0\",\n\t\t\tNsxtManagerId: pulumi.StringRef(nsxt.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtSegmentIpDiscoveryProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxManager1\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtSegmentIpDiscoveryProfile(GetNsxtSegmentIpDiscoveryProfileArgs.builder()\n            .name(\"ip-discovery-profile-0\")\n            .nsxtManagerId(nsxt.applyValue(getNsxtManagerResult -\u003e getNsxtManagerResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxManager1\n  first:\n    fn::invoke:\n      function: vcd:getNsxtSegmentIpDiscoveryProfile\n      arguments:\n        name: ip-discovery-profile-0\n        nsxtManagerId: ${nsxt.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtSegmentIpDiscoveryProfile.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of Segment Profile\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by NSX-T manager\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC group\n\n\u003e Note: only one of `nsxt_manager_id`, `vdc_id`, `vdc_group_id` can be used\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtSegmentIpDiscoveryProfile.\n",
                "properties": {
                    "arpBindingLimit": {
                        "description": "Indicates the number of ARP snooped IP addresses to be remembered per\nlogical port\n",
                        "type": "integer"
                    },
                    "arpBindingTimeout": {
                        "description": "ARP and ND (Neighbor Discovery) cache timeout (in minutes)\n",
                        "type": "integer"
                    },
                    "description": {
                        "description": "Description of IP Discovery Profile\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isArpSnoopingEnabled": {
                        "description": "Defines whether ARP snooping is enabled\n",
                        "type": "boolean"
                    },
                    "isDhcpSnoopingV4Enabled": {
                        "description": "Defines whether DHCP snooping for IPv4 is enabled\n",
                        "type": "boolean"
                    },
                    "isDhcpSnoopingV6Enabled": {
                        "description": "Defines whether DHCP snooping for IPv6 is enabled\n",
                        "type": "boolean"
                    },
                    "isDuplicateIpDetectionEnabled": {
                        "description": "Defines whether duplicate IP detection is enabled. Duplicate\nIP detection is used to determine if there is any IP conflict with any other port on the same\nlogical switch. If a conflict is detected, then the IP is marked as a duplicate on the port where\nthe IP was discovered last\n",
                        "type": "boolean"
                    },
                    "isNdSnoopingEnabled": {
                        "description": "Defines whether ND (Neighbor Discovery) snooping is enabled. If true,\nthis method will snoop the NS (Neighbor Solicitation) and NA (Neighbor Advertisement) messages in\nthe ND (Neighbor Discovery Protocol) family of messages which are transmitted by a VM. From the NS\nmessages, we will learn about the source which sent this NS message. From the NA message, we will\nlearn the resolved address in the message which the VM is a recipient of. Addresses snooped by\nthis method are subject to TOFU\n",
                        "type": "boolean"
                    },
                    "isTofuEnabled": {
                        "description": "Defines whether `Trust on First Use(TOFU)` paradigm is enabled\n",
                        "type": "boolean"
                    },
                    "isVmtoolsV4Enabled": {
                        "description": "Defines whether fetching IPv4 address using vm-tools is enabled. This\noption is only supported on ESX where vm-tools is installed\n",
                        "type": "boolean"
                    },
                    "isVmtoolsV6Enabled": {
                        "description": "Defines whether fetching IPv6 address using vm-tools is enabled. This\nwill learn the IPv6 addresses which are configured on interfaces of a VM with the help of the\nVMTools software\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "ndSnoopingLimit": {
                        "description": "Maximum number of ND (Neighbor Discovery Protocol) snooped IPv6 addresses\n",
                        "type": "integer"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "arpBindingLimit",
                    "arpBindingTimeout",
                    "description",
                    "isArpSnoopingEnabled",
                    "isDhcpSnoopingV4Enabled",
                    "isDhcpSnoopingV6Enabled",
                    "isDuplicateIpDetectionEnabled",
                    "isNdSnoopingEnabled",
                    "isTofuEnabled",
                    "isVmtoolsV4Enabled",
                    "isVmtoolsV6Enabled",
                    "name",
                    "ndSnoopingLimit",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtSegmentMacDiscoveryProfile:getNsxtSegmentMacDiscoveryProfile": {
            "description": "Provides a VMware Cloud Director NSX-T MAC Discovery Profile data source. This can be used to read NSX-T Segment Profile definitions.\n\nSupported in provider *v3.11+*.\n\n## Example Usage\n\n### MAC Discovery Profile)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt = vcd.getNsxtManager({\n    name: \"nsxManager1\",\n});\nconst first = nsxt.then(nsxt =\u003e vcd.getNsxtSegmentMacDiscoveryProfile({\n    name: \"mac-discovery-profile-0\",\n    nsxtManagerId: nsxt.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt = vcd.get_nsxt_manager(name=\"nsxManager1\")\nfirst = vcd.get_nsxt_segment_mac_discovery_profile(name=\"mac-discovery-profile-0\",\n    nsxt_manager_id=nsxt.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxManager1\",\n    });\n\n    var first = Vcd.GetNsxtSegmentMacDiscoveryProfile.Invoke(new()\n    {\n        Name = \"mac-discovery-profile-0\",\n        NsxtManagerId = nsxt.Apply(getNsxtManagerResult =\u003e getNsxtManagerResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnsxt, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxManager1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtSegmentMacDiscoveryProfile(ctx, \u0026vcd.GetNsxtSegmentMacDiscoveryProfileArgs{\n\t\t\tName:          \"mac-discovery-profile-0\",\n\t\t\tNsxtManagerId: pulumi.StringRef(nsxt.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtSegmentMacDiscoveryProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxManager1\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtSegmentMacDiscoveryProfile(GetNsxtSegmentMacDiscoveryProfileArgs.builder()\n            .name(\"mac-discovery-profile-0\")\n            .nsxtManagerId(nsxt.applyValue(getNsxtManagerResult -\u003e getNsxtManagerResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxManager1\n  first:\n    fn::invoke:\n      function: vcd:getNsxtSegmentMacDiscoveryProfile\n      arguments:\n        name: mac-discovery-profile-0\n        nsxtManagerId: ${nsxt.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtSegmentMacDiscoveryProfile.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of Segment Profile\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by NSX-T manager\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC group\n\n\u003e Note: only one of `nsxt_manager_id`, `vdc_id`, `vdc_group_id` can be used\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtSegmentMacDiscoveryProfile.\n",
                "properties": {
                    "description": {
                        "description": "Description of MAC Discovery Profile\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isMacChangeEnabled": {
                        "description": "Defines whether source MAC address change is enabled\n",
                        "type": "boolean"
                    },
                    "isMacLearningEnabled": {
                        "description": "Defines whether source MAC address learning is enabled\n",
                        "type": "boolean"
                    },
                    "isUnknownUnicastFloodingEnabled": {
                        "description": "Defines whether unknown unicast flooding rule is enabled\nThis allows flooding for unlearned MAC for ingress traffic\n",
                        "type": "boolean"
                    },
                    "macLearningAgingTime": {
                        "description": "Aging time in seconds for learned MAC address. Indicates how long\nlearned MAC address remain\n",
                        "type": "integer"
                    },
                    "macLimit": {
                        "description": "The maximum number of MAC addresses that can be learned on this port\n",
                        "type": "integer"
                    },
                    "macPolicy": {
                        "description": "The policy after MAC Limit is exceeded. It can be either `ALLOW` or `DROP`\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "isMacChangeEnabled",
                    "isMacLearningEnabled",
                    "isUnknownUnicastFloodingEnabled",
                    "macLearningAgingTime",
                    "macLimit",
                    "macPolicy",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtSegmentProfileTemplate:getNsxtSegmentProfileTemplate": {
            "description": "Provides a data source to read NSX-T Segment Profile Templates.\n\nSupported in provider *v3.11+* and VCD 10.4.0+ with NSX-T. Requires System Administrator privileges.\n\n## Example Usage\n\n### Complete Example With All Segment Profiles)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst complete = vcd.getNsxtSegmentProfileTemplate({\n    name: \"my-segment-profile-template-name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ncomplete = vcd.get_nsxt_segment_profile_template(name=\"my-segment-profile-template-name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var complete = Vcd.GetNsxtSegmentProfileTemplate.Invoke(new()\n    {\n        Name = \"my-segment-profile-template-name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxtSegmentProfileTemplate(ctx, \u0026vcd.LookupNsxtSegmentProfileTemplateArgs{\n\t\t\tName: \"my-segment-profile-template-name\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtSegmentProfileTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var complete = VcdFunctions.getNsxtSegmentProfileTemplate(GetNsxtSegmentProfileTemplateArgs.builder()\n            .name(\"my-segment-profile-template-name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  complete:\n    fn::invoke:\n      function: vcd:getNsxtSegmentProfileTemplate\n      arguments:\n        name: my-segment-profile-template-name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtSegmentProfileTemplate.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of existing Segment Profile Template\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtSegmentProfileTemplate.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipDiscoveryProfileId": {
                        "type": "string"
                    },
                    "macDiscoveryProfileId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    },
                    "qosProfileId": {
                        "type": "string"
                    },
                    "segmentSecurityProfileId": {
                        "type": "string"
                    },
                    "spoofGuardProfileId": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "ipDiscoveryProfileId",
                    "macDiscoveryProfileId",
                    "name",
                    "nsxtManagerId",
                    "qosProfileId",
                    "segmentSecurityProfileId",
                    "spoofGuardProfileId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtSegmentQosProfile:getNsxtSegmentQosProfile": {
            "description": "Provides a VMware Cloud Director NSX-T QoS Profile data source. This can be used to read NSX-T Segment Profile definitions.\n\nSupported in provider *v3.11+*.\n\n## Example Usage\n\n### QoS Profile)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt = vcd.getNsxtManager({\n    name: \"nsxManager1\",\n});\nconst first = nsxt.then(nsxt =\u003e vcd.getNsxtSegmentQosProfile({\n    name: \"qos-profile-0\",\n    nsxtManagerId: nsxt.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt = vcd.get_nsxt_manager(name=\"nsxManager1\")\nfirst = vcd.get_nsxt_segment_qos_profile(name=\"qos-profile-0\",\n    nsxt_manager_id=nsxt.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxManager1\",\n    });\n\n    var first = Vcd.GetNsxtSegmentQosProfile.Invoke(new()\n    {\n        Name = \"qos-profile-0\",\n        NsxtManagerId = nsxt.Apply(getNsxtManagerResult =\u003e getNsxtManagerResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnsxt, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxManager1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtSegmentQosProfile(ctx, \u0026vcd.GetNsxtSegmentQosProfileArgs{\n\t\t\tName:          \"qos-profile-0\",\n\t\t\tNsxtManagerId: pulumi.StringRef(nsxt.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtSegmentQosProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxManager1\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtSegmentQosProfile(GetNsxtSegmentQosProfileArgs.builder()\n            .name(\"qos-profile-0\")\n            .nsxtManagerId(nsxt.applyValue(getNsxtManagerResult -\u003e getNsxtManagerResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxManager1\n  first:\n    fn::invoke:\n      function: vcd:getNsxtSegmentQosProfile\n      arguments:\n        name: qos-profile-0\n        nsxtManagerId: ${nsxt.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtSegmentQosProfile.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of Segment Profile\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by NSX-T manager\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC group\n\n\u003e Note: only one of `nsxt_manager_id`, `vdc_id`, `vdc_group_id` can be used\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtSegmentQosProfile.\n",
                "properties": {
                    "classOfService": {
                        "description": "Class of service groups similar types of traffic in the network and each type\nof traffic is treated as a class with its own level of service priority. The lower priority\ntraffic is slowed down or in some cases dropped to provide better throughput for higher priority\ntraffic.\n",
                        "type": "integer"
                    },
                    "description": {
                        "description": "Description of QoS Profile\n",
                        "type": "string"
                    },
                    "dscpPriority": {
                        "description": "A Differentiated Services Code Point (DSCP) priority\nProfile.\n",
                        "type": "integer"
                    },
                    "dscpTrustMode": {
                        "description": "A Differentiated Services Code Point (DSCP) trust mode. Values are below:\n* `TRUSTED` - With Trusted mode the inner header DSCP value is applied to the outer IP header for\nIP/IPv6 traffic. For non IP/IPv6 traffic, the outer IP header takes the default value.\n* `UNTRUSTED` - Untrusted mode is supported on overlay-based and VLAN-based logical port.\n",
                        "type": "string"
                    },
                    "egressRateLimiterAvgBandwidth": {
                        "description": "Average egress bandwidth in Mb/s.\n",
                        "type": "integer"
                    },
                    "egressRateLimiterBurstSize": {
                        "description": "Egress burst size in bytes.\n",
                        "type": "integer"
                    },
                    "egressRateLimiterPeakBandwidth": {
                        "description": "Peak egress bandwidth in Mb/s.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ingressBroadcastRateLimiterAvgBandwidth": {
                        "description": "Average ingress broadcast bandwidth in Mb/s.\n",
                        "type": "integer"
                    },
                    "ingressBroadcastRateLimiterBurstSize": {
                        "description": "Ingress broadcast burst size in bytes.\n",
                        "type": "integer"
                    },
                    "ingressBroadcastRateLimiterPeakBandwidth": {
                        "description": "Peak ingress broadcast bandwidth in Mb/s.\n",
                        "type": "integer"
                    },
                    "ingressRateLimiterAvgBandwidth": {
                        "description": "Average ingress bandwidth in Mb/s.\n",
                        "type": "integer"
                    },
                    "ingressRateLimiterBurstSize": {
                        "description": "Ingress burst size in bytes.\n",
                        "type": "integer"
                    },
                    "ingressRateLimiterPeakBandwidth": {
                        "description": "Peak ingress broadcast bandwidth in Mb/s.\n",
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "classOfService",
                    "description",
                    "dscpPriority",
                    "dscpTrustMode",
                    "egressRateLimiterAvgBandwidth",
                    "egressRateLimiterBurstSize",
                    "egressRateLimiterPeakBandwidth",
                    "ingressBroadcastRateLimiterAvgBandwidth",
                    "ingressBroadcastRateLimiterBurstSize",
                    "ingressBroadcastRateLimiterPeakBandwidth",
                    "ingressRateLimiterAvgBandwidth",
                    "ingressRateLimiterBurstSize",
                    "ingressRateLimiterPeakBandwidth",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtSegmentSecurityProfile:getNsxtSegmentSecurityProfile": {
            "description": "Provides a VMware Cloud Director NSX-T Segment Security Profile data source. This can be used to read NSX-T Segment Profile definitions.\n\nSupported in provider *v3.11+*.\n\n## Example Usage\n\n### Segment Security Profile)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt = vcd.getNsxtManager({\n    name: \"nsxManager1\",\n});\nconst first = nsxt.then(nsxt =\u003e vcd.getNsxtSegmentSecurityProfile({\n    name: \"segment-security-profile-0\",\n    nsxtManagerId: nsxt.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt = vcd.get_nsxt_manager(name=\"nsxManager1\")\nfirst = vcd.get_nsxt_segment_security_profile(name=\"segment-security-profile-0\",\n    nsxt_manager_id=nsxt.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxManager1\",\n    });\n\n    var first = Vcd.GetNsxtSegmentSecurityProfile.Invoke(new()\n    {\n        Name = \"segment-security-profile-0\",\n        NsxtManagerId = nsxt.Apply(getNsxtManagerResult =\u003e getNsxtManagerResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnsxt, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxManager1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtSegmentSecurityProfile(ctx, \u0026vcd.GetNsxtSegmentSecurityProfileArgs{\n\t\t\tName:          \"segment-security-profile-0\",\n\t\t\tNsxtManagerId: pulumi.StringRef(nsxt.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtSegmentSecurityProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxManager1\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtSegmentSecurityProfile(GetNsxtSegmentSecurityProfileArgs.builder()\n            .name(\"segment-security-profile-0\")\n            .nsxtManagerId(nsxt.applyValue(getNsxtManagerResult -\u003e getNsxtManagerResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxManager1\n  first:\n    fn::invoke:\n      function: vcd:getNsxtSegmentSecurityProfile\n      arguments:\n        name: segment-security-profile-0\n        nsxtManagerId: ${nsxt.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtSegmentSecurityProfile.\n",
                "properties": {
                    "bpduFilterAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Pre-defined list of allowed MAC addresses to be excluded from BPDU filtering.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of Segment Profile\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by NSX-T manager\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC group\n\n\u003e Note: only one of `nsxt_manager_id`, `vdc_id`, `vdc_group_id` can be used\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtSegmentSecurityProfile.\n",
                "properties": {
                    "bpduFilterAllowLists": {
                        "description": "Pre-defined list of allowed MAC addresses to be excluded from BPDU filtering.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "description": {
                        "description": "Description of Segment Security Profile\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isBpduFilterEnabled": {
                        "description": "Defines whether BPDU filter is enabled.\n",
                        "type": "boolean"
                    },
                    "isDhcpV4ClientBlockEnabled": {
                        "description": "Defines whether DHCP Client block IPv4 is enabled. This filters DHCP Client IPv4 traffic.\n",
                        "type": "boolean"
                    },
                    "isDhcpV4ServerBlockEnabled": {
                        "description": "Defines whether DHCP Server block IPv4 is enabled. This filters DHCP Server IPv4 traffic.\n",
                        "type": "boolean"
                    },
                    "isDhcpV6ClientBlockEnabled": {
                        "description": "Defines whether DHCP Client block IPv6 is enabled. This filters DHCP Client IPv6 traffic.\n",
                        "type": "boolean"
                    },
                    "isDhcpV6ServerBlockEnabled": {
                        "description": "Defines whether DHCP Server block IPv6 is enabled. This filters DHCP Server IPv6 traffic.\n",
                        "type": "boolean"
                    },
                    "isNonIpTrafficBlockEnabled": {
                        "description": "Defines whether non IP traffic block is enabled. If true, it blocks all traffic except IP/(G)ARP/BPDU.\n",
                        "type": "boolean"
                    },
                    "isRaGuardEnabled": {
                        "description": "Defines whether Router Advertisement Guard is enabled. This filters DHCP Server IPv6 traffic.\n",
                        "type": "boolean"
                    },
                    "isRateLimittingEnabled": {
                        "description": "Defines whether Rate Limiting is enabled.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    },
                    "rxBroadcastLimit": {
                        "description": "Incoming broadcast traffic limit in packets per second.\n",
                        "type": "integer"
                    },
                    "rxMulticastLimit": {
                        "description": "Incoming multicast traffic limit in packets per second.\n",
                        "type": "integer"
                    },
                    "txBroadcastLimit": {
                        "description": "Outgoing broadcast traffic limit in packets per second.\n",
                        "type": "integer"
                    },
                    "txMulticastLimit": {
                        "description": "Outgoing multicast traffic limit in packets per second.\n",
                        "type": "integer"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "isBpduFilterEnabled",
                    "isDhcpV4ClientBlockEnabled",
                    "isDhcpV4ServerBlockEnabled",
                    "isDhcpV6ClientBlockEnabled",
                    "isDhcpV6ServerBlockEnabled",
                    "isNonIpTrafficBlockEnabled",
                    "isRaGuardEnabled",
                    "isRateLimittingEnabled",
                    "name",
                    "rxBroadcastLimit",
                    "rxMulticastLimit",
                    "txBroadcastLimit",
                    "txMulticastLimit",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtSegmentSpoofGuardProfile:getNsxtSegmentSpoofGuardProfile": {
            "description": "Provides a VMware Cloud Director Spoof Guard Profile data source. This can be used to read NSX-T Segment Profile definitions.\n\nSupported in provider *v3.11+*.\n\n## Example Usage\n\n### IP Discovery Profile)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt = vcd.getNsxtManager({\n    name: \"nsxManager1\",\n});\nconst first = nsxt.then(nsxt =\u003e vcd.getNsxtSegmentSpoofGuardProfile({\n    name: \"spoof-guard-profile-0\",\n    nsxtManagerId: nsxt.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt = vcd.get_nsxt_manager(name=\"nsxManager1\")\nfirst = vcd.get_nsxt_segment_spoof_guard_profile(name=\"spoof-guard-profile-0\",\n    nsxt_manager_id=nsxt.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxManager1\",\n    });\n\n    var first = Vcd.GetNsxtSegmentSpoofGuardProfile.Invoke(new()\n    {\n        Name = \"spoof-guard-profile-0\",\n        NsxtManagerId = nsxt.Apply(getNsxtManagerResult =\u003e getNsxtManagerResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnsxt, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxManager1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtSegmentSpoofGuardProfile(ctx, \u0026vcd.GetNsxtSegmentSpoofGuardProfileArgs{\n\t\t\tName:          \"spoof-guard-profile-0\",\n\t\t\tNsxtManagerId: pulumi.StringRef(nsxt.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtSegmentSpoofGuardProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxManager1\")\n            .build());\n\n        final var first = VcdFunctions.getNsxtSegmentSpoofGuardProfile(GetNsxtSegmentSpoofGuardProfileArgs.builder()\n            .name(\"spoof-guard-profile-0\")\n            .nsxtManagerId(nsxt.applyValue(getNsxtManagerResult -\u003e getNsxtManagerResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxManager1\n  first:\n    fn::invoke:\n      function: vcd:getNsxtSegmentSpoofGuardProfile\n      arguments:\n        name: spoof-guard-profile-0\n        nsxtManagerId: ${nsxt.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtSegmentSpoofGuardProfile.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of Segment Profile\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by NSX-T manager\n"
                    },
                    "vdcGroupId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC group\n\n\u003e Note: only one of `nsxt_manager_id`, `vdc_id`, `vdc_group_id` can be used\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "Segment Profile search context. Use when searching by VDC\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtSegmentSpoofGuardProfile.\n",
                "properties": {
                    "description": {
                        "description": "Description of Spoof Guard profile\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isAddressBindingWhitelistEnabled": {
                        "description": "Whether Spoof Guard is enabled. If true, it only allows\nVM sending traffic with the IPs in the whitelist\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    },
                    "vdcGroupId": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "isAddressBindingWhitelistEnabled",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtTier0Router:getNsxtTier0Router": {
            "description": "Provides a data source for available NSX-T Tier-0 routers.\n\nSupported in provider *v3.0+*\n\n\u003e **Note:** This resource uses new VMware Cloud Director\n[OpenAPI](https://code.vmware.com/docs/11982/getting-started-with-vmware-cloud-director-openapi) and\nrequires at least VCD *10.1.1+* and NSX-T *3.0+*.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst main = vcd.getNsxtManager({\n    name: \"nsxt-manager-one\",\n});\nconst router = main.then(main =\u003e vcd.getNsxtTier0Router({\n    name: \"nsxt-tier0-router\",\n    nsxtManagerId: main.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmain = vcd.get_nsxt_manager(name=\"nsxt-manager-one\")\nrouter = vcd.get_nsxt_tier0_router(name=\"nsxt-tier0-router\",\n    nsxt_manager_id=main.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Vcd.GetNsxtManager.Invoke(new()\n    {\n        Name = \"nsxt-manager-one\",\n    });\n\n    var router = Vcd.GetNsxtTier0Router.Invoke(new()\n    {\n        Name = \"nsxt-tier0-router\",\n        NsxtManagerId = main.Apply(getNsxtManagerResult =\u003e getNsxtManagerResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := vcd.GetNsxtManager(ctx, \u0026vcd.GetNsxtManagerArgs{\n\t\t\tName: \"nsxt-manager-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetNsxtTier0Router(ctx, \u0026vcd.GetNsxtTier0RouterArgs{\n\t\t\tName:          \"nsxt-tier0-router\",\n\t\t\tNsxtManagerId: main.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxtManagerArgs;\nimport com.pulumi.vcd.inputs.GetNsxtTier0RouterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = VcdFunctions.getNsxtManager(GetNsxtManagerArgs.builder()\n            .name(\"nsxt-manager-one\")\n            .build());\n\n        final var router = VcdFunctions.getNsxtTier0Router(GetNsxtTier0RouterArgs.builder()\n            .name(\"nsxt-tier0-router\")\n            .nsxtManagerId(main.applyValue(getNsxtManagerResult -\u003e getNsxtManagerResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      function: vcd:getNsxtManager\n      arguments:\n        name: nsxt-manager-one\n  router:\n    fn::invoke:\n      function: vcd:getNsxtTier0Router\n      arguments:\n        name: nsxt-tier0-router\n        nsxtManagerId: ${main.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtTier0Router.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "NSX-T Tier-0 router name. **Note**. Tier-0 router name must be unique inside NSX-T manager because\nAPI does not allow to filter by other fields.\n"
                    },
                    "nsxtManagerId": {
                        "type": "string",
                        "description": "NSX-T manager should be referenced.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "nsxtManagerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtTier0Router.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isAssigned": {
                        "description": "Boolean value reflecting if Tier-0 router is already consumed by external network.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nsxtManagerId": {
                        "type": "string"
                    }
                },
                "required": [
                    "isAssigned",
                    "name",
                    "nsxtManagerId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxtTier0RouterInterface:getNsxtTier0RouterInterface": {
            "description": "Supported in provider *v3.14+* and VCD 10.5+ with NSX-T IP Spaces.\n\nProvides a data source to read NSX-T Tier-0 Router Interface that can be associated with IP Space\nUplink.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxtTier0RouterInterface.\n",
                "properties": {
                    "externalNetworkId": {
                        "type": "string",
                        "description": "The ID of Provider Gateway. Can be looked up using\n[vcd.ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2) data\nsource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of organization to which the edge gateway belongs. Optional if\ndefined at provider level.\n"
                    }
                },
                "type": "object",
                "required": [
                    "externalNetworkId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxtTier0RouterInterface.\n",
                "properties": {
                    "description": {
                        "description": "The description of Tier-0 Router Interface in NSX-T.\n",
                        "type": "string"
                    },
                    "externalNetworkId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "description": "The type of Tier-0 Router Interface in NSX-T. One of `EXTERNAL`, `SERVICE` or `LOOPBACK`\n",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "externalNetworkId",
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvApplication:getNsxvApplication": {
            "description": "Provides a VMware Cloud Director data source for reading NSX-V distributed firewall applications.\n\nSupported in provider *v3.9+*\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvApplication.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the application\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of VDC to use\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vdcId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvApplication.\n",
                "properties": {
                    "appGuid": {
                        "description": "The application identifier, when available\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The identifier of the application\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "ports": {
                        "description": "The ports used by the application. Could be a number, a list of numbers, or a range\n",
                        "type": "string"
                    },
                    "protocol": {
                        "description": "The protocol used by the application\n",
                        "type": "string"
                    },
                    "sourcePort": {
                        "description": "The source port used by this application. Not all applications provide one\n",
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "appGuid",
                    "id",
                    "name",
                    "ports",
                    "protocol",
                    "sourcePort",
                    "vdcId"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvApplicationFinder:getNsxvApplicationFinder": {
            "description": "Provides a VMware Cloud Director NSX-V distributed firewall applications and application groups finder\nused to retrieve existing ones by regular expressions.\n\nSupported in provider *v3.9+*\n\n## Example Usage\n\n### 2\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst applications = vcd.getNsxvApplicationFinder({\n    vdcId: my_vdc.id,\n    searchExpression: \"dns\",\n    caseSensitive: false,\n    type: \"application\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\napplications = vcd.get_nsxv_application_finder(vdc_id=my_vdc[\"id\"],\n    search_expression=\"dns\",\n    case_sensitive=False,\n    type=\"application\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var applications = Vcd.GetNsxvApplicationFinder.Invoke(new()\n    {\n        VdcId = my_vdc.Id,\n        SearchExpression = \"dns\",\n        CaseSensitive = false,\n        Type = \"application\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetNsxvApplicationFinder(ctx, \u0026vcd.GetNsxvApplicationFinderArgs{\n\t\t\tVdcId:            my_vdc.Id,\n\t\t\tSearchExpression: \"dns\",\n\t\t\tCaseSensitive:    pulumi.BoolRef(false),\n\t\t\tType:             \"application\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxvApplicationFinderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var applications = VcdFunctions.getNsxvApplicationFinder(GetNsxvApplicationFinderArgs.builder()\n            .vdcId(my_vdc.id())\n            .searchExpression(\"dns\")\n            .caseSensitive(false)\n            .type(\"application\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  applications:\n    fn::invoke:\n      function: vcd:getNsxvApplicationFinder\n      arguments:\n        vdcId: ${[\"my-vdc\"].id}\n        searchExpression: dns\n        caseSensitive: false\n        type: application\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nSample output:\n\n```\napplications = {\n  \"case_sensitive\" = false\n  \"id\" = \"urn:vcloud:vdc:e5680ceb-1c15-48a8-9a54-e0bbc6fe909f\"\n  \"objects\" = toset([\n    {\n      \"name\" = \"APP_DNS\"\n      \"type\" = \"Application\"\n      \"value\" = \"application-297\"\n    },\n    {\n      \"name\" = \"DNS\"\n      \"type\" = \"Application\"\n      \"value\" = \"application-136\"\n    },\n    {\n      \"name\" = \"DNS-UDP\"\n      \"type\" = \"Application\"\n      \"value\" = \"application-286\"\n    },\n  ])\n  \"search_expression\" = \"dns\"\n  \"type\" = \"application\"\n  \"vdc_id\" = \"urn:vcloud:vdc:e5680ceb-1c15-48a8-9a54-e0bbc6fe909f\"\n}\n```\n\n## Search expressions\n\nTo search for an application or application group, we can use simple or complex [regular expressions](https://en.wikipedia.org/wiki/Regular_expression).\nThe expressions in this data source follow the [PCRE](https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions) standard.\n\nA **simple** regular expression is a (short) text that we expect to find within the application name. For example, the\nexpression `sql` will find, among others, `Oracle i*SQLPlus` and `MSSQL Server Database Engine`, because the search, by default,\nignores the case of the searched text.\n\nA more complex regular expression could use meta-characters and regular expression directives to search more precisely.\nFor example, the expression `^server` tells the search to find a name that starts (`^`) with \"server\", thus finding\n\"Server Message Block (SMB)\" (starts with `server`), but not  \"SAP MDM Server\" (where `server` is not at the beginning\nof the name).\n\nIf we want to search with even more accuracy, we could set the property `case_sensitive = true`, where the case of the\ntext matters. Thus, searching for `VMware` would find `VMware-SRM-Replication` and `VMware-VCO-Messaging`, but not\n`Vmware-VC-WebAccess` (lowercase `m` after `V`).\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvApplicationFinder.\n",
                "properties": {
                    "caseSensitive": {
                        "type": "boolean",
                        "description": "Makes the search case-sensitive. By default, it is false\n"
                    },
                    "searchExpression": {
                        "type": "string",
                        "description": "The regular expression that will be used to search the applications. See Search Expressions below\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "What kind of application we seek. One of `application`, `application_group`\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of VDC to use\n"
                    }
                },
                "type": "object",
                "required": [
                    "searchExpression",
                    "type",
                    "vdcId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvApplicationFinder.\n",
                "properties": {
                    "caseSensitive": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "objects": {
                        "description": "A list of objects found by the search expression. Each one contains the following properties:\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxvApplicationFinderObject:getNsxvApplicationFinderObject"
                        },
                        "type": "array"
                    },
                    "searchExpression": {
                        "type": "string"
                    },
                    "type": {
                        "description": "the type of the object (`Application` or `ApplicationGroup`)\n",
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "objects",
                    "searchExpression",
                    "type",
                    "vdcId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvApplicationGroup:getNsxvApplicationGroup": {
            "description": "Provides a VMware Cloud Director NSX-V Distributed Firewall data source used to read an existing application group.\n\nSupported in provider *v3.9+*\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvApplicationGroup.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the application group\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of VDC to use\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vdcId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvApplicationGroup.\n",
                "properties": {
                    "applications": {
                        "description": "The list of the applications belonging to this group. For each one we get the following:\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxvApplicationGroupApplication:getNsxvApplicationGroupApplication"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The identifier of the application groups\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the application\n",
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "applications",
                    "id",
                    "name",
                    "vdcId"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvDhcpRelay:getNsxvDhcpRelay": {
            "description": "Provides a VMware Cloud Director Edge Gateway DHCP relay configuration data source. The DHCP relay\ncapability provided by NSX in VMware Cloud Director environment allows to leverage existing DHCP\ninfrastructure from within VMware Cloud Director environment without any interruption to the IP address\nmanagement in existing DHCP infrastructure. DHCP messages are relayed from virtual machines to the\ndesignated DHCP servers in your physical DHCP infrastructure, which allows IP addresses controlled\nby the NSX software to continue to be in sync with IP addresses in the rest of your DHCP-controlled\nenvironments. \n\nSupported in provider *v2.6+*\n\n## Example Usage\n\n### 1\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst relayConfig = vcd.getNsxvDhcpRelay({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nrelay_config = vcd.get_nsxv_dhcp_relay(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var relayConfig = Vcd.GetNsxvDhcpRelay.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxvDhcpRelay(ctx, \u0026vcd.LookupNsxvDhcpRelayArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxvDhcpRelayArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var relayConfig = VcdFunctions.getNsxvDhcpRelay(GetNsxvDhcpRelayArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  relayConfig:\n    fn::invoke:\n      function: vcd:getNsxvDhcpRelay\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvDhcpRelay.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which DHCP relay is to be configured.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvDhcpRelay.\n",
                "properties": {
                    "domainNames": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipAddresses": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "ipSets": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "org": {
                        "type": "string"
                    },
                    "relayAgents": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxvDhcpRelayRelayAgent:getNsxvDhcpRelayRelayAgent"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "domainNames",
                    "edgeGateway",
                    "ipAddresses",
                    "ipSets",
                    "relayAgents",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvDistributedFirewall:getNsxvDistributedFirewall": {
            "description": "The NSX-V Distributed Firewall data source reads all defined rules for a particular VDC.\n\nSupported in provider *v3.9+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_vdc = vcd.getOrgVdc({\n    org: \"my-org\",\n    name: \"my-vdc\",\n});\nconst dfw1 = my_vdc.then(my_vdc =\u003e vcd.getNsxvDistributedFirewall({\n    vdcId: my_vdc.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_vdc = vcd.get_org_vdc(org=\"my-org\",\n    name=\"my-vdc\")\ndfw1 = vcd.get_nsxv_distributed_firewall(vdc_id=my_vdc.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_vdc = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-vdc\",\n    });\n\n    var dfw1 = Vcd.GetNsxvDistributedFirewall.Invoke(new()\n    {\n        VdcId = my_vdc.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_vdc, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"my-vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupNsxvDistributedFirewall(ctx, \u0026vcd.LookupNsxvDistributedFirewallArgs{\n\t\t\tVdcId: my_vdc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetNsxvDistributedFirewallArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-vdc = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-vdc\")\n            .build());\n\n        final var dfw1 = VcdFunctions.getNsxvDistributedFirewall(GetNsxvDistributedFirewallArgs.builder()\n            .vdcId(my_vdc.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-vdc:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: my-org\n        name: my-vdc\n  dfw1:\n    fn::invoke:\n      function: vcd:getNsxvDistributedFirewall\n      arguments:\n        vdcId: ${[\"my-vdc\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Attributes reference\n\nAll the arguments and attributes defined for the `vcd.NsxvDistributedFirewall` resource are reported as attributes for this data source.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvDistributedFirewall.\n",
                "properties": {
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of VDC to manage the Distributed Firewall in. Can be looked up using a `vcd.OrgVdc` data source\n"
                    }
                },
                "type": "object",
                "required": [
                    "vdcId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvDistributedFirewall.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "rules": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxvDistributedFirewallRule:getNsxvDistributedFirewallRule"
                        },
                        "type": "array"
                    },
                    "vdcId": {
                        "type": "string"
                    }
                },
                "required": [
                    "enabled",
                    "rules",
                    "vdcId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvDnat:getNsxvDnat": {
            "description": "Provides a VMware Cloud Director DNAT data source for advanced edge gateways (NSX-V). This can be used to\nread existing rule by ID and use its attributes in other resources.\n\n\u003e **Note:** This data source requires advanced edge gateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_rule = vcd.getNsxvDnat({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    ruleId: \"197864\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_rule = vcd.get_nsxv_dnat(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    rule_id=\"197864\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_rule = Vcd.GetNsxvDnat.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        RuleId = \"197864\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxvDnat(ctx, \u0026vcd.LookupNsxvDnatArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tRuleId:      \"197864\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxvDnatArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-rule = VcdFunctions.getNsxvDnat(GetNsxvDnatArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .ruleId(\"197864\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-rule:\n    fn::invoke:\n      function: vcd:getNsxvDnat\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        ruleId: '197864'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvDnat.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which to apply the DNAT rule.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleId": {
                        "type": "string",
                        "description": "ID of DNAT rule as shown in the UI.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "ruleId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvDnat.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "icmpType": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "loggingEnabled": {
                        "type": "boolean"
                    },
                    "networkName": {
                        "type": "string"
                    },
                    "networkType": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "originalAddress": {
                        "type": "string"
                    },
                    "originalPort": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "ruleId": {
                        "type": "string"
                    },
                    "ruleTag": {
                        "type": "integer"
                    },
                    "ruleType": {
                        "type": "string"
                    },
                    "translatedAddress": {
                        "type": "string"
                    },
                    "translatedPort": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "edgeGateway",
                    "enabled",
                    "icmpType",
                    "loggingEnabled",
                    "networkName",
                    "networkType",
                    "originalAddress",
                    "originalPort",
                    "protocol",
                    "ruleId",
                    "ruleTag",
                    "ruleType",
                    "translatedAddress",
                    "translatedPort",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvFirewallRule:getNsxvFirewallRule": {
            "description": "Provides a VMware Cloud Director firewall rule data source for advanced edge gateways (NSX-V). This can be\nused to read existing rules by ID and use its attributes in other resources.\n\n\u003e **Note:** This data source requires advanced edge gateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_rule = vcd.getNsxvFirewallRule({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    ruleId: \"133048\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_rule = vcd.get_nsxv_firewall_rule(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    rule_id=\"133048\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_rule = Vcd.GetNsxvFirewallRule.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        RuleId = \"133048\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxvFirewallRule(ctx, \u0026vcd.LookupNsxvFirewallRuleArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tRuleId:      \"133048\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxvFirewallRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-rule = VcdFunctions.getNsxvFirewallRule(GetNsxvFirewallRuleArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .ruleId(\"133048\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-rule:\n    fn::invoke:\n      function: vcd:getNsxvFirewallRule\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        ruleId: '133048'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvFirewallRule.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which to apply the DNAT rule.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n"
                    },
                    "ruleId": {
                        "type": "string",
                        "description": "ID of firewall rule (not UI number). See more information about firewall\nrule ID in `vcd.NsxvFirewallRule` [import section](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/nsxv_firewall_rule#listing-real-firewall-rule-ids).\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "ruleId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvFirewallRule.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "destinations": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxvFirewallRuleDestination:getNsxvFirewallRuleDestination"
                        },
                        "type": "array"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "loggingEnabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ruleId": {
                        "type": "string"
                    },
                    "ruleTag": {
                        "type": "integer"
                    },
                    "ruleType": {
                        "type": "string"
                    },
                    "services": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxvFirewallRuleService:getNsxvFirewallRuleService"
                        },
                        "type": "array"
                    },
                    "sources": {
                        "items": {
                            "$ref": "#/types/vcd:index/getNsxvFirewallRuleSource:getNsxvFirewallRuleSource"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "action",
                    "destinations",
                    "edgeGateway",
                    "enabled",
                    "loggingEnabled",
                    "name",
                    "ruleId",
                    "ruleTag",
                    "ruleType",
                    "services",
                    "sources",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvIpSet:getNsxvIpSet": {
            "description": "Provides a VMware Cloud Director IP set data source. An IP set is a group of IP addresses that you can add\n  as the source or destination in a firewall rule or in DHCP relay configuration.\n\nSupported in provider *v2.6+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst ip_set_DS = vcd.getNsxvIpSet({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    name: \"not-managed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nip_set__ds = vcd.get_nsxv_ip_set(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    name=\"not-managed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ip_set_DS = Vcd.GetNsxvIpSet.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        Name = \"not-managed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxvIpSet(ctx, \u0026vcd.LookupNsxvIpSetArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tName: \"not-managed\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxvIpSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ip-set-DS = VcdFunctions.getNsxvIpSet(GetNsxvIpSetArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .name(\"not-managed\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  ip-set-DS:\n    fn::invoke:\n      function: vcd:getNsxvIpSet\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        name: not-managed\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvIpSet.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "IP set name for identifying the exact IP set\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvIpSet.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipAddresses": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "isInheritanceAllowed": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "ipAddresses",
                    "isInheritanceAllowed",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getNsxvSnat:getNsxvSnat": {
            "description": "Provides a VMware Cloud Director SNAT data source for advanced edge gateways (NSX-V). This can be used to\nread existing rule by ID and use its attributes in other resources.\n\n\u003e **Note:** This data source requires advanced edge gateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_rule = vcd.getNsxvSnat({\n    org: \"my-org\",\n    vdc: \"my-org-vdc\",\n    edgeGateway: \"my-edge-gw\",\n    ruleId: \"197867\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_rule = vcd.get_nsxv_snat(org=\"my-org\",\n    vdc=\"my-org-vdc\",\n    edge_gateway=\"my-edge-gw\",\n    rule_id=\"197867\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_rule = Vcd.GetNsxvSnat.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-org-vdc\",\n        EdgeGateway = \"my-edge-gw\",\n        RuleId = \"197867\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupNsxvSnat(ctx, \u0026vcd.LookupNsxvSnatArgs{\n\t\t\tOrg:         pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:         pulumi.StringRef(\"my-org-vdc\"),\n\t\t\tEdgeGateway: \"my-edge-gw\",\n\t\t\tRuleId:      \"197867\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetNsxvSnatArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-rule = VcdFunctions.getNsxvSnat(GetNsxvSnatArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-org-vdc\")\n            .edgeGateway(\"my-edge-gw\")\n            .ruleId(\"197867\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-rule:\n    fn::invoke:\n      function: vcd:getNsxvSnat\n      arguments:\n        org: my-org\n        vdc: my-org-vdc\n        edgeGateway: my-edge-gw\n        ruleId: '197867'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNsxvSnat.\n",
                "properties": {
                    "edgeGateway": {
                        "type": "string",
                        "description": "The name of the edge gateway on which to apply the SNAT rule.\n",
                        "willReplaceOnChanges": true
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleId": {
                        "type": "string",
                        "description": "ID of SNAT rule as shown in the UI.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "edgeGateway",
                    "ruleId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNsxvSnat.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "edgeGateway": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "loggingEnabled": {
                        "type": "boolean"
                    },
                    "networkName": {
                        "type": "string"
                    },
                    "networkType": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "originalAddress": {
                        "type": "string"
                    },
                    "ruleId": {
                        "type": "string"
                    },
                    "ruleTag": {
                        "type": "integer"
                    },
                    "ruleType": {
                        "type": "string"
                    },
                    "translatedAddress": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "edgeGateway",
                    "enabled",
                    "loggingEnabled",
                    "networkName",
                    "networkType",
                    "originalAddress",
                    "ruleId",
                    "ruleTag",
                    "ruleType",
                    "translatedAddress",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrg:getOrg": {
            "description": "Provides a VMware Cloud Director Org data source. An organization can be used to manage catalogs, virtual\ndata centers, and users.\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org = vcd.getOrg({\n    name: \"my-org\",\n});\nconst my_org_clone = new vcd.Org(\"my-org-clone\", {\n    name: \"my-org-clone\",\n    fullName: my_org.then(my_org =\u003e my_org.fullName),\n    canPublishCatalogs: my_org.then(my_org =\u003e my_org.canPublishCatalogs),\n    deployedVmQuota: my_org.then(my_org =\u003e my_org.deployedVmQuota),\n    storedVmQuota: my_org.then(my_org =\u003e my_org.storedVmQuota),\n    isEnabled: my_org.then(my_org =\u003e my_org.isEnabled),\n    deleteForce: true,\n    deleteRecursive: true,\n    vappLease: {\n        maximumRuntimeLeaseInSec: my_org.then(my_org =\u003e my_org.vappLeases?.[0]?.maximumRuntimeLeaseInSec),\n        powerOffOnRuntimeLeaseExpiration: my_org.then(my_org =\u003e my_org.vappLeases?.[0]?.powerOffOnRuntimeLeaseExpiration),\n        maximumStorageLeaseInSec: my_org.then(my_org =\u003e my_org.vappLeases?.[0]?.maximumStorageLeaseInSec),\n        deleteOnStorageLeaseExpiration: my_org.then(my_org =\u003e my_org.vappLeases?.[0]?.deleteOnStorageLeaseExpiration),\n    },\n    vappTemplateLease: {\n        maximumStorageLeaseInSec: my_org.then(my_org =\u003e my_org.vappTemplateLeases?.[0]?.maximumStorageLeaseInSec),\n        deleteOnStorageLeaseExpiration: my_org.then(my_org =\u003e my_org.vappTemplateLeases?.[0]?.deleteOnStorageLeaseExpiration),\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\nmy_org_clone = vcd.Org(\"my-org-clone\",\n    name=\"my-org-clone\",\n    full_name=my_org.full_name,\n    can_publish_catalogs=my_org.can_publish_catalogs,\n    deployed_vm_quota=my_org.deployed_vm_quota,\n    stored_vm_quota=my_org.stored_vm_quota,\n    is_enabled=my_org.is_enabled,\n    delete_force=True,\n    delete_recursive=True,\n    vapp_lease={\n        \"maximum_runtime_lease_in_sec\": my_org.vapp_leases[0].maximum_runtime_lease_in_sec,\n        \"power_off_on_runtime_lease_expiration\": my_org.vapp_leases[0].power_off_on_runtime_lease_expiration,\n        \"maximum_storage_lease_in_sec\": my_org.vapp_leases[0].maximum_storage_lease_in_sec,\n        \"delete_on_storage_lease_expiration\": my_org.vapp_leases[0].delete_on_storage_lease_expiration,\n    },\n    vapp_template_lease={\n        \"maximum_storage_lease_in_sec\": my_org.vapp_template_leases[0].maximum_storage_lease_in_sec,\n        \"delete_on_storage_lease_expiration\": my_org.vapp_template_leases[0].delete_on_storage_lease_expiration,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var my_org_clone = new Vcd.Org(\"my-org-clone\", new()\n    {\n        Name = \"my-org-clone\",\n        FullName = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.FullName)),\n        CanPublishCatalogs = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.CanPublishCatalogs)),\n        DeployedVmQuota = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.DeployedVmQuota)),\n        StoredVmQuota = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.StoredVmQuota)),\n        IsEnabled = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.IsEnabled)),\n        DeleteForce = true,\n        DeleteRecursive = true,\n        VappLease = new Vcd.Inputs.OrgVappLeaseArgs\n        {\n            MaximumRuntimeLeaseInSec = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.VappLeases[0]?.MaximumRuntimeLeaseInSec)),\n            PowerOffOnRuntimeLeaseExpiration = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.VappLeases[0]?.PowerOffOnRuntimeLeaseExpiration)),\n            MaximumStorageLeaseInSec = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.VappLeases[0]?.MaximumStorageLeaseInSec)),\n            DeleteOnStorageLeaseExpiration = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.VappLeases[0]?.DeleteOnStorageLeaseExpiration)),\n        },\n        VappTemplateLease = new Vcd.Inputs.OrgVappTemplateLeaseArgs\n        {\n            MaximumStorageLeaseInSec = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.VappTemplateLeases[0]?.MaximumStorageLeaseInSec)),\n            DeleteOnStorageLeaseExpiration = my_org.Apply(my_org =\u003e my_org.Apply(getOrgResult =\u003e getOrgResult.VappTemplateLeases[0]?.DeleteOnStorageLeaseExpiration)),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.NewOrg(ctx, \"my-org-clone\", \u0026vcd.OrgArgs{\n\t\t\tName:               pulumi.String(\"my-org-clone\"),\n\t\t\tFullName:           pulumi.String(my_org.FullName),\n\t\t\tCanPublishCatalogs: pulumi.Bool(my_org.CanPublishCatalogs),\n\t\t\tDeployedVmQuota:    pulumi.Int(my_org.DeployedVmQuota),\n\t\t\tStoredVmQuota:      pulumi.Int(my_org.StoredVmQuota),\n\t\t\tIsEnabled:          pulumi.Bool(my_org.IsEnabled),\n\t\t\tDeleteForce:        pulumi.Bool(true),\n\t\t\tDeleteRecursive:    pulumi.Bool(true),\n\t\t\tVappLease: \u0026vcd.OrgVappLeaseArgs{\n\t\t\t\tMaximumRuntimeLeaseInSec:         pulumi.Int(my_org.VappLeases[0].MaximumRuntimeLeaseInSec),\n\t\t\t\tPowerOffOnRuntimeLeaseExpiration: pulumi.Bool(my_org.VappLeases[0].PowerOffOnRuntimeLeaseExpiration),\n\t\t\t\tMaximumStorageLeaseInSec:         pulumi.Int(my_org.VappLeases[0].MaximumStorageLeaseInSec),\n\t\t\t\tDeleteOnStorageLeaseExpiration:   pulumi.Bool(my_org.VappLeases[0].DeleteOnStorageLeaseExpiration),\n\t\t\t},\n\t\t\tVappTemplateLease: \u0026vcd.OrgVappTemplateLeaseArgs{\n\t\t\t\tMaximumStorageLeaseInSec:       pulumi.Int(my_org.VappTemplateLeases[0].MaximumStorageLeaseInSec),\n\t\t\t\tDeleteOnStorageLeaseExpiration: pulumi.Bool(my_org.VappTemplateLeases[0].DeleteOnStorageLeaseExpiration),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.Org;\nimport com.pulumi.vcd.OrgArgs;\nimport com.pulumi.vcd.inputs.OrgVappLeaseArgs;\nimport com.pulumi.vcd.inputs.OrgVappTemplateLeaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        var my_org_clone = new Org(\"my-org-clone\", OrgArgs.builder()\n            .name(\"my-org-clone\")\n            .fullName(my_org.fullName())\n            .canPublishCatalogs(my_org.canPublishCatalogs())\n            .deployedVmQuota(my_org.deployedVmQuota())\n            .storedVmQuota(my_org.storedVmQuota())\n            .isEnabled(my_org.isEnabled())\n            .deleteForce(true)\n            .deleteRecursive(true)\n            .vappLease(OrgVappLeaseArgs.builder()\n                .maximumRuntimeLeaseInSec(my_org.vappLeases()[0].maximumRuntimeLeaseInSec())\n                .powerOffOnRuntimeLeaseExpiration(my_org.vappLeases()[0].powerOffOnRuntimeLeaseExpiration())\n                .maximumStorageLeaseInSec(my_org.vappLeases()[0].maximumStorageLeaseInSec())\n                .deleteOnStorageLeaseExpiration(my_org.vappLeases()[0].deleteOnStorageLeaseExpiration())\n                .build())\n            .vappTemplateLease(OrgVappTemplateLeaseArgs.builder()\n                .maximumStorageLeaseInSec(my_org.vappTemplateLeases()[0].maximumStorageLeaseInSec())\n                .deleteOnStorageLeaseExpiration(my_org.vappTemplateLeases()[0].deleteOnStorageLeaseExpiration())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  my-org-clone:\n    type: vcd:Org\n    properties:\n      name: my-org-clone\n      fullName: ${[\"my-org\"].fullName}\n      canPublishCatalogs: ${[\"my-org\"].canPublishCatalogs}\n      deployedVmQuota: ${[\"my-org\"].deployedVmQuota}\n      storedVmQuota: ${[\"my-org\"].storedVmQuota}\n      isEnabled: ${[\"my-org\"].isEnabled}\n      deleteForce: true\n      deleteRecursive: true\n      vappLease:\n        maximumRuntimeLeaseInSec: ${[\"my-org\"].vappLeases[0].maximumRuntimeLeaseInSec}\n        powerOffOnRuntimeLeaseExpiration: ${[\"my-org\"].vappLeases[0].powerOffOnRuntimeLeaseExpiration}\n        maximumStorageLeaseInSec: ${[\"my-org\"].vappLeases[0].maximumStorageLeaseInSec}\n        deleteOnStorageLeaseExpiration: ${[\"my-org\"].vappLeases[0].deleteOnStorageLeaseExpiration}\n      vappTemplateLease:\n        maximumStorageLeaseInSec: ${[\"my-org\"].vappTemplateLeases[0].maximumStorageLeaseInSec}\n        deleteOnStorageLeaseExpiration: ${[\"my-org\"].vappTemplateLeases[0].deleteOnStorageLeaseExpiration}\nvariables:\n  my-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## vApp Lease\n\nThe `vapp_lease` section contains lease parameters for vApps created in the current organization, as defined below:\n\n* `maximum_runtime_lease_in_sec` - How long vApps can run before they are automatically stopped (in seconds)\n* `power_off_on_runtime_lease_expiration` - When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires.\n* `maximum_storage_lease_in_sec` - How long stopped vApps are available before being automatically cleaned up (in seconds)\n* `delete_on_storage_lease_expiration` - If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.\n\n\u003ca id=\"vapp-template-lease\"\u003e\u003c/a\u003e\n## vApp Template Lease\n\nThe `vapp_template_lease` section contains lease parameters for vApp templates created in the current organization, as defined below:\n\n* `maximum_storage_lease_in_sec` - How long vApp templates are available before being automatically cleaned up (in seconds)\n* `delete_on_storage_lease_expiration` - If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted\n\n\u003ca id=\"metadata\"\u003e\u003c/a\u003e\n## Metadata\n\nThe `metadata_entry` (*v3.8+*) is a set of metadata entries that have the following structure:\n\n* `key` - Key of this metadata entry.\n* `value` - Value of this metadata entry.\n* `type` - Type of this metadata entry. One of: `MetadataStringValue`, `MetadataNumberValue`, `MetadataDateTimeValue`, `MetadataBooleanValue`.\n* `user_access` - User access level for this metadata entry. One of: `PRIVATE` (hidden), `READONLY` (read only), `READWRITE` (read/write).\n* `is_system` - Domain for this metadata entry. true if it belongs to `SYSTEM`, false if it belongs to `GENERAL`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrg.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Org name\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrg.\n",
                "properties": {
                    "accountLockouts": {
                        "description": "(*v3.14+*) Contains the account lockout properties of the read organization:\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgAccountLockout:getOrgAccountLockout"
                        },
                        "type": "array"
                    },
                    "canPublishCatalogs": {
                        "description": "True if this organization is allowed to share catalogs.\n",
                        "type": "boolean"
                    },
                    "canPublishExternalCatalogs": {
                        "description": "(*v3.6+*) True if this organization is allowed to publish external catalogs.\n",
                        "type": "boolean"
                    },
                    "canSubscribeExternalCatalogs": {
                        "description": "(*v3.6+*) True if this organization is allowed to subscribe to external catalogs.\n",
                        "type": "boolean"
                    },
                    "delayAfterPowerOnSeconds": {
                        "description": "Specifies this organization's default for virtual machine boot delay after power on.\n",
                        "type": "integer"
                    },
                    "deployedVmQuota": {
                        "description": "Maximum number of virtual machines that can be deployed simultaneously by a member of this organization.\n",
                        "type": "integer"
                    },
                    "description": {
                        "description": "Org description.\n",
                        "type": "string"
                    },
                    "fullName": {
                        "description": "Org full name\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isEnabled": {
                        "description": "True if this organization is enabled (allows login and all other operations).\n",
                        "type": "boolean"
                    },
                    "listOfCatalogs": {
                        "description": "(*v3.11+*) List of catalogs (sorted alphabetically), owned or shared, available to this organization.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "listOfVdcs": {
                        "description": "(*v3.11+*) List of VDCs (sorted alphabetically), owned or shared, available to this organization.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "description": "(Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata assigned to this organization.\n",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries assigned to the organization. See Metadata section for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgMetadataEntry:getOrgMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "numberOfCatalogs": {
                        "description": "(*v3.11+*) Number of catalogs owned or shared, available to this organization.\n",
                        "type": "integer"
                    },
                    "numberOfVdcs": {
                        "description": "(*v3.11+*) Number of VDCs owned or shared, available to this organization.\n",
                        "type": "integer"
                    },
                    "storedVmQuota": {
                        "description": "Maximum number of virtual machines in vApps or vApp templates that can be stored in an undeployed state by a member of this organization.\n",
                        "type": "integer"
                    },
                    "vappLeases": {
                        "description": "(*v2.7+*) Defines lease parameters for vApps created in this organization. See vApp Lease below for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVappLease:getOrgVappLease"
                        },
                        "type": "array"
                    },
                    "vappTemplateLeases": {
                        "description": "(*v2.7+*) Defines lease parameters for vApp templates created in this organization. See vApp Template Lease below for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVappTemplateLease:getOrgVappTemplateLease"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "accountLockouts",
                    "canPublishCatalogs",
                    "canPublishExternalCatalogs",
                    "canSubscribeExternalCatalogs",
                    "delayAfterPowerOnSeconds",
                    "deployedVmQuota",
                    "description",
                    "fullName",
                    "isEnabled",
                    "listOfCatalogs",
                    "listOfVdcs",
                    "metadata",
                    "metadataEntries",
                    "name",
                    "numberOfCatalogs",
                    "numberOfVdcs",
                    "storedVmQuota",
                    "vappLeases",
                    "vappTemplateLeases",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgGroup:getOrgGroup": {
            "description": "Provides a data source for VMware Cloud Director Organization Groups. This can be used to fetch organization groups already defined in `SAML`, `OAUTH` or `LDAP`.\n\nSupported in provider *v3.6+*\n\n## Example Usage\n\n### To Fetch An Organization Group\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst org1 = vcd.getOrgGroup({\n    org: \"org1\",\n    name: \"Org1-AdminGroup\",\n});\nexport const groupRole = org1.then(org1 =\u003e org1.role);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\norg1 = vcd.get_org_group(org=\"org1\",\n    name=\"Org1-AdminGroup\")\npulumi.export(\"groupRole\", org1.role)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var org1 = Vcd.GetOrgGroup.Invoke(new()\n    {\n        Org = \"org1\",\n        Name = \"Org1-AdminGroup\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"groupRole\"] = org1.Apply(getOrgGroupResult =\u003e getOrgGroupResult.Role),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\torg1, err := vcd.LookupOrgGroup(ctx, \u0026vcd.LookupOrgGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"org1\"),\n\t\t\tName: \"Org1-AdminGroup\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"groupRole\", org1.Role)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var org1 = VcdFunctions.getOrgGroup(GetOrgGroupArgs.builder()\n            .org(\"org1\")\n            .name(\"Org1-AdminGroup\")\n            .build());\n\n        ctx.export(\"groupRole\", org1.applyValue(getOrgGroupResult -\u003e getOrgGroupResult.role()));\n    }\n}\n```\n```yaml\nvariables:\n  org1:\n    fn::invoke:\n      function: vcd:getOrgGroup\n      arguments:\n        org: org1\n        name: Org1-AdminGroup\noutputs:\n  groupRole: ${org1.role}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgGroup.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "A unique name for the group.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the VDC belongs. Optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgGroup.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "providerType": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "userNames": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "description",
                    "name",
                    "providerType",
                    "role",
                    "userNames",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgLdap:getOrgLdap": {
            "description": "Supported in provider *v3.8+*.\n\nProvides a data source to read LDAP configuration for an organization.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org = vcd.getOrg({\n    name: \"my-org\",\n});\nconst first = my_org.then(my_org =\u003e vcd.getOrgLdap({\n    orgId: my_org.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\nfirst = vcd.get_org_ldap(org_id=my_org.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var first = Vcd.GetOrgLdap.Invoke(new()\n    {\n        OrgId = my_org.Apply(getOrgResult =\u003e getOrgResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupOrgLdap(ctx, \u0026vcd.LookupOrgLdapArgs{\n\t\t\tOrgId: my_org.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetOrgLdapArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        final var first = VcdFunctions.getOrgLdap(GetOrgLdapArgs.builder()\n            .orgId(my_org.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n  first:\n    fn::invoke:\n      function: vcd:getOrgLdap\n      arguments:\n        orgId: ${[\"my-org\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgLdap.\n",
                "properties": {
                    "orgId": {
                        "type": "string",
                        "description": "ID of the organization containing the LDAP settings\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgLdap.\n",
                "properties": {
                    "customSettings": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgLdapCustomSetting:getOrgLdapCustomSetting"
                        },
                        "type": "array"
                    },
                    "customUserOu": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ldapMode": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "required": [
                    "customSettings",
                    "customUserOu",
                    "ldapMode",
                    "orgId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgOidc:getOrgOidc": {
            "description": "Provides a data source to read the OpenID Connect (OIDC) configuration of an Organization in VMware Cloud Director.\n\nSupported in provider *v3.13+*.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myOrg = vcd.getOrg({\n    name: \"my-org\",\n});\nconst oidcSettings = myOrg.then(myOrg =\u003e vcd.getOrgOidc({\n    orgId: myOrg.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\noidc_settings = vcd.get_org_oidc(org_id=my_org.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myOrg = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var oidcSettings = Vcd.GetOrgOidc.Invoke(new()\n    {\n        OrgId = myOrg.Apply(getOrgResult =\u003e getOrgResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyOrg, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupOrgOidc(ctx, \u0026vcd.LookupOrgOidcArgs{\n\t\t\tOrgId: myOrg.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetOrgOidcArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myOrg = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        final var oidcSettings = VcdFunctions.getOrgOidc(GetOrgOidcArgs.builder()\n            .orgId(myOrg.applyValue(getOrgResult -\u003e getOrgResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myOrg:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n  oidcSettings:\n    fn::invoke:\n      function: vcd:getOrgOidc\n      arguments:\n        orgId: ${myOrg.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgOidc.\n",
                "properties": {
                    "orgId": {
                        "type": "string",
                        "description": "ID of the organization containing the OIDC settings\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgOidc.\n",
                "properties": {
                    "accessTokenEndpoint": {
                        "type": "string"
                    },
                    "claimsMappings": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgOidcClaimsMapping:getOrgOidcClaimsMapping"
                        },
                        "type": "array"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "secret": true,
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "issuerId": {
                        "type": "string"
                    },
                    "keyExpireDurationHours": {
                        "type": "integer"
                    },
                    "keyRefreshEndpoint": {
                        "type": "string"
                    },
                    "keyRefreshPeriodHours": {
                        "type": "integer"
                    },
                    "keyRefreshStrategy": {
                        "type": "string"
                    },
                    "keys": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgOidcKey:getOrgOidcKey"
                        },
                        "type": "array"
                    },
                    "maxClockSkewSeconds": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "preferIdToken": {
                        "type": "boolean"
                    },
                    "redirectUri": {
                        "type": "string"
                    },
                    "scopes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "uiButtonLabel": {
                        "type": "string"
                    },
                    "userAuthorizationEndpoint": {
                        "type": "string"
                    },
                    "userinfoEndpoint": {
                        "type": "string"
                    },
                    "wellknownEndpoint": {
                        "type": "string"
                    }
                },
                "required": [
                    "accessTokenEndpoint",
                    "claimsMappings",
                    "clientId",
                    "clientSecret",
                    "enabled",
                    "issuerId",
                    "keys",
                    "keyExpireDurationHours",
                    "keyRefreshEndpoint",
                    "keyRefreshPeriodHours",
                    "keyRefreshStrategy",
                    "maxClockSkewSeconds",
                    "orgId",
                    "preferIdToken",
                    "redirectUri",
                    "scopes",
                    "uiButtonLabel",
                    "userAuthorizationEndpoint",
                    "userinfoEndpoint",
                    "wellknownEndpoint",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgSaml:getOrgSaml": {
            "description": "Supported in provider *v3.10+*.\n\nProvides a data source to read SAML configuration for an organization.\n\n\u003e **Note:** This data source requires system administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org = vcd.getOrg({\n    name: \"my-org\",\n});\nconst first = my_org.then(my_org =\u003e vcd.getOrgSaml({\n    orgId: my_org.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\nfirst = vcd.get_org_saml(org_id=my_org.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var first = Vcd.GetOrgSaml.Invoke(new()\n    {\n        OrgId = my_org.Apply(getOrgResult =\u003e getOrgResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupOrgSaml(ctx, \u0026vcd.LookupOrgSamlArgs{\n\t\t\tOrgId: my_org.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetOrgSamlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        final var first = VcdFunctions.getOrgSaml(GetOrgSamlArgs.builder()\n            .orgId(my_org.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n  first:\n    fn::invoke:\n      function: vcd:getOrgSaml\n      arguments:\n        orgId: ${[\"my-org\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgSaml.\n",
                "properties": {
                    "orgId": {
                        "type": "string",
                        "description": "ID of the organization containing the SAML settings\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgSaml.\n",
                "properties": {
                    "email": {
                        "description": "The name of the SAML attribute that returns the email address of the user\n",
                        "type": "string"
                    },
                    "enabled": {
                        "description": "Shows whether the SAML identity service is used for authentication\n",
                        "type": "boolean"
                    },
                    "entityId": {
                        "description": "Your service provider entity ID\n",
                        "type": "string"
                    },
                    "firstName": {
                        "description": "The name of the SAML attribute that returns the first name of the user\n",
                        "type": "string"
                    },
                    "fullName": {
                        "description": "The name of the SAML attribute that returns the full name of the user\n",
                        "type": "string"
                    },
                    "group": {
                        "description": "The name of the SAML attribute that returns the identifiers of all the groups of which the user is a member\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "role": {
                        "description": "The name of the SAML attribute that returns the identifiers of all roles of the user\n",
                        "type": "string"
                    },
                    "surname": {
                        "description": "The name of the SAML attribute that returns the surname of the user\n",
                        "type": "string"
                    },
                    "userName": {
                        "description": "The name of the SAML attribute that returns the username of the user\n",
                        "type": "string"
                    }
                },
                "required": [
                    "email",
                    "enabled",
                    "entityId",
                    "firstName",
                    "fullName",
                    "group",
                    "orgId",
                    "role",
                    "surname",
                    "userName",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgSamlMetadata:getOrgSamlMetadata": {
            "description": "Supported in provider *v3.10+*.\n\nProvides a data source to read service provider SAML metadata for an organization.\nThis service provider metadata is used to configure the identity provider.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org = vcd.getOrg({\n    name: \"my-org\",\n});\nconst first = my_org.then(my_org =\u003e vcd.getOrgSamlMetadata({\n    orgId: my_org.id,\n    fileName: \"vcd-metadata.txt\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org = vcd.get_org(name=\"my-org\")\nfirst = vcd.get_org_saml_metadata(org_id=my_org.id,\n    file_name=\"vcd-metadata.txt\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org = Vcd.GetOrg.Invoke(new()\n    {\n        Name = \"my-org\",\n    });\n\n    var first = Vcd.GetOrgSamlMetadata.Invoke(new()\n    {\n        OrgId = my_org.Apply(getOrgResult =\u003e getOrgResult.Id),\n        FileName = \"vcd-metadata.txt\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org, err := vcd.LookupOrg(ctx, \u0026vcd.LookupOrgArgs{\n\t\t\tName: \"my-org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetOrgSamlMetadata(ctx, \u0026vcd.GetOrgSamlMetadataArgs{\n\t\t\tOrgId:    my_org.Id,\n\t\t\tFileName: pulumi.StringRef(\"vcd-metadata.txt\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgArgs;\nimport com.pulumi.vcd.inputs.GetOrgSamlMetadataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org = VcdFunctions.getOrg(GetOrgArgs.builder()\n            .name(\"my-org\")\n            .build());\n\n        final var first = VcdFunctions.getOrgSamlMetadata(GetOrgSamlMetadataArgs.builder()\n            .orgId(my_org.id())\n            .fileName(\"vcd-metadata.txt\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-org:\n    fn::invoke:\n      function: vcd:getOrg\n      arguments:\n        name: my-org\n  first:\n    fn::invoke:\n      function: vcd:getOrgSamlMetadata\n      arguments:\n        orgId: ${[\"my-org\"].id}\n        fileName: vcd-metadata.txt\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgSamlMetadata.\n",
                "properties": {
                    "fileName": {
                        "type": "string",
                        "description": "name of the file where to store the metadata.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "ID of the organization containing the SAML metadata\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgSamlMetadata.\n",
                "properties": {
                    "fileName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "metadataText": {
                        "description": "the text of the metadata for this organization.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "required": [
                    "metadataText",
                    "orgId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgUser:getOrgUser": {
            "description": "Provides a VMware Cloud Director Org User data source. This can be used to read organization users, including org administrators.\n\nSupported in provider *v3.0+*\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org_admin = vcd.getOrgUser({\n    org: \"my-org\",\n    name: \"my-org-admin\",\n});\nconst my_vapp_creator = vcd.getOrgUser({\n    org: \"my-org\",\n    userId: \"urn:vcloud:user:c311eb35-6984-4d26-3ee9-0000deadbeef\",\n});\nexport const adminUser = my_org_admin;\nexport const vappCreatorUser = my_vapp_creator;\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org_admin = vcd.get_org_user(org=\"my-org\",\n    name=\"my-org-admin\")\nmy_vapp_creator = vcd.get_org_user(org=\"my-org\",\n    user_id=\"urn:vcloud:user:c311eb35-6984-4d26-3ee9-0000deadbeef\")\npulumi.export(\"adminUser\", my_org_admin)\npulumi.export(\"vappCreatorUser\", my_vapp_creator)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org_admin = Vcd.GetOrgUser.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-org-admin\",\n    });\n\n    var my_vapp_creator = Vcd.GetOrgUser.Invoke(new()\n    {\n        Org = \"my-org\",\n        UserId = \"urn:vcloud:user:c311eb35-6984-4d26-3ee9-0000deadbeef\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"adminUser\"] = my_org_admin,\n        [\"vappCreatorUser\"] = my_vapp_creator,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org_admin, err := vcd.LookupOrgUser(ctx, \u0026vcd.LookupOrgUserArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: pulumi.StringRef(\"my-org-admin\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmy_vapp_creator, err := vcd.LookupOrgUser(ctx, \u0026vcd.LookupOrgUserArgs{\n\t\t\tOrg:    pulumi.StringRef(\"my-org\"),\n\t\t\tUserId: pulumi.StringRef(\"urn:vcloud:user:c311eb35-6984-4d26-3ee9-0000deadbeef\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"adminUser\", my_org_admin)\n\t\tctx.Export(\"vappCreatorUser\", my_vapp_creator)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org-admin = VcdFunctions.getOrgUser(GetOrgUserArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-org-admin\")\n            .build());\n\n        final var my-vapp-creator = VcdFunctions.getOrgUser(GetOrgUserArgs.builder()\n            .org(\"my-org\")\n            .userId(\"urn:vcloud:user:c311eb35-6984-4d26-3ee9-0000deadbeef\")\n            .build());\n\n        ctx.export(\"adminUser\", my_org_admin);\n        ctx.export(\"vappCreatorUser\", my_vapp_creator);\n    }\n}\n```\n```yaml\nvariables:\n  my-org-admin:\n    fn::invoke:\n      function: vcd:getOrgUser\n      arguments:\n        org: my-org\n        name: my-org-admin\n  my-vapp-creator:\n    fn::invoke:\n      function: vcd:getOrgUser\n      arguments:\n        org: my-org\n        userId: urn:vcloud:user:c311eb35-6984-4d26-3ee9-0000deadbeef\noutputs:\n  adminUser: ${[\"my-org-admin\"]}\n  vappCreatorUser: ${[\"my-vapp-creator\"]}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgUser.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the user. Required if `user_id` is not set.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to which the user belongs. Optional if defined at provider level.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user. Required if `name` is not set.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getOrgUser.\n",
                "properties": {
                    "deployedVmQuota": {
                        "description": "Quota of vApps that this user can deploy. A value of 0 specifies an unlimited quota.\n",
                        "type": "integer"
                    },
                    "description": {
                        "description": "An optional description of the user.\n",
                        "type": "string"
                    },
                    "emailAddress": {
                        "description": "The Org User email address.\n",
                        "type": "string"
                    },
                    "enabled": {
                        "description": "True if the user is enabled and can log in.\n",
                        "type": "boolean"
                    },
                    "fullName": {
                        "description": "The full name of the user.\n",
                        "type": "string"
                    },
                    "groupNames": {
                        "description": "The set of group names to which this user belongs. It's only populated if the users\nare created after the group (with this user having a `depends_on` of the given group).\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "instantMessaging": {
                        "description": "The Org User instant messaging.\n",
                        "type": "string"
                    },
                    "isExternal": {
                        "description": "If the user account was imported from an external resource, like an LDAP.\n",
                        "type": "boolean"
                    },
                    "isGroupRole": {
                        "description": "True if this user has a group role.\n",
                        "type": "boolean"
                    },
                    "isLocked": {
                        "description": "If the user account has been locked due to too many invalid login attempts, the value will be true.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "providerType": {
                        "description": "Identity provider type for this user.\n",
                        "type": "string"
                    },
                    "role": {
                        "description": "The role of the user.\n",
                        "type": "string"
                    },
                    "storedVmQuota": {
                        "description": "Quota of vApps that this user can store. A value of 0 specifies an unlimited quota.\n",
                        "type": "integer"
                    },
                    "telephone": {
                        "description": "The Org User telephone number.\n",
                        "type": "string"
                    },
                    "userId": {
                        "type": "string"
                    }
                },
                "required": [
                    "deployedVmQuota",
                    "description",
                    "emailAddress",
                    "enabled",
                    "fullName",
                    "groupNames",
                    "instantMessaging",
                    "isExternal",
                    "isGroupRole",
                    "isLocked",
                    "providerType",
                    "role",
                    "storedVmQuota",
                    "telephone",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgVdc:getOrgVdc": {
            "description": "Provides a VMware Cloud Director Organization VDC data source. An Organization VDC can be used to\nreference a VDC and use its data within other resources or data sources.\n\n\u003e **Note:** This resource supports NSX-T and NSX-V based Org VDCs\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_org_vdc = vcd.getOrgVdc({\n    org: \"my-org\",\n    name: \"my-vdc\",\n});\nexport const providerVdc = my_org_vdc.then(my_org_vdc =\u003e my_org_vdc.providerVdcName);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_org_vdc = vcd.get_org_vdc(org=\"my-org\",\n    name=\"my-vdc\")\npulumi.export(\"providerVdc\", my_org_vdc.provider_vdc_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_org_vdc = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-vdc\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"providerVdc\"] = my_org_vdc.Apply(my_org_vdc =\u003e my_org_vdc.Apply(getOrgVdcResult =\u003e getOrgVdcResult.ProviderVdcName)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_org_vdc, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"my-vdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"providerVdc\", my_org_vdc.ProviderVdcName)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-org-vdc = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-vdc\")\n            .build());\n\n        ctx.export(\"providerVdc\", my_org_vdc.providerVdcName());\n    }\n}\n```\n```yaml\nvariables:\n  my-org-vdc:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: my-org\n        name: my-vdc\noutputs:\n  providerVdc: ${[\"my-org-vdc\"].providerVdcName}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgVdc.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Organization VDC name\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Org name\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgVdc.\n",
                "properties": {
                    "allocationModel": {
                        "type": "string"
                    },
                    "allowOverCommit": {
                        "type": "boolean"
                    },
                    "computeCapacities": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVdcComputeCapacity:getOrgVdcComputeCapacity"
                        },
                        "type": "array"
                    },
                    "cpuGuaranteed": {
                        "type": "number"
                    },
                    "cpuSpeed": {
                        "type": "integer"
                    },
                    "defaultComputePolicyId": {
                        "type": "string"
                    },
                    "defaultVmSizingPolicyId": {
                        "deprecationMessage": "Use `default_compute_policy_id` attribute instead, which can support VM Sizing Policies, VM Placement Policies and vGPU Policies",
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeClusterId": {
                        "description": "(*v3.8+*, *VCD 10.3+*) An ID of NSX-T Edge Cluster which should provide vApp\nNetworking Services or DHCP for Isolated Networks. This value **might be unavailable** in data\nsource if user has insufficient rights.\n",
                        "type": "string"
                    },
                    "elasticity": {
                        "type": "boolean"
                    },
                    "enableFastProvisioning": {
                        "type": "boolean"
                    },
                    "enableNsxvDistributedFirewall": {
                        "type": "boolean"
                    },
                    "enableThinProvisioning": {
                        "type": "boolean"
                    },
                    "enableVmDiscovery": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "includeVmMemoryOverhead": {
                        "type": "boolean"
                    },
                    "memoryGuaranteed": {
                        "type": "number"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVdcMetadataEntry:getOrgVdcMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkPoolName": {
                        "type": "string"
                    },
                    "networkQuota": {
                        "type": "integer"
                    },
                    "nicQuota": {
                        "type": "integer"
                    },
                    "org": {
                        "type": "string"
                    },
                    "providerVdcName": {
                        "type": "string"
                    },
                    "storageProfiles": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVdcStorageProfile:getOrgVdcStorageProfile"
                        },
                        "type": "array"
                    },
                    "vmPlacementPolicyIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vmQuota": {
                        "type": "integer"
                    },
                    "vmSizingPolicyIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vmVgpuPolicyIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "allocationModel",
                    "allowOverCommit",
                    "computeCapacities",
                    "cpuGuaranteed",
                    "cpuSpeed",
                    "defaultComputePolicyId",
                    "defaultVmSizingPolicyId",
                    "description",
                    "edgeClusterId",
                    "elasticity",
                    "enableFastProvisioning",
                    "enableNsxvDistributedFirewall",
                    "enableThinProvisioning",
                    "enableVmDiscovery",
                    "enabled",
                    "includeVmMemoryOverhead",
                    "memoryGuaranteed",
                    "metadata",
                    "metadataEntries",
                    "name",
                    "networkPoolName",
                    "networkQuota",
                    "nicQuota",
                    "providerVdcName",
                    "storageProfiles",
                    "vmPlacementPolicyIds",
                    "vmQuota",
                    "vmSizingPolicyIds",
                    "vmVgpuPolicyIds",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgVdcNsxtNetworkProfile:getOrgVdcNsxtNetworkProfile": {
            "description": "Provides a data source to read Network Profile for NSX-T VDCs.\n\nSupported in provider *v3.11+* and VCD 10.4.0+ with NSX-T.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst nsxt = vcd.getOrgVdcNsxtNetworkProfile({\n    org: \"my-org\",\n    vdc: \"my-vdc\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnsxt = vcd.get_org_vdc_nsxt_network_profile(org=\"my-org\",\n    vdc=\"my-vdc\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nsxt = Vcd.GetOrgVdcNsxtNetworkProfile.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupOrgVdcNsxtNetworkProfile(ctx, \u0026vcd.LookupOrgVdcNsxtNetworkProfileArgs{\n\t\t\tOrg: pulumi.StringRef(\"my-org\"),\n\t\t\tVdc: pulumi.StringRef(\"my-vdc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcNsxtNetworkProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var nsxt = VcdFunctions.getOrgVdcNsxtNetworkProfile(GetOrgVdcNsxtNetworkProfileArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  nsxt:\n    fn::invoke:\n      function: vcd:getOrgVdcNsxtNetworkProfile\n      arguments:\n        org: my-org\n        vdc: my-vdc\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgVdcNsxtNetworkProfile.\n",
                "properties": {
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getOrgVdcNsxtNetworkProfile.\n",
                "properties": {
                    "edgeClusterId": {
                        "description": "An ID of NSX-T Edge Cluster which should provide vApp\nNetworking Services or DHCP for Isolated Networks. This value **might be unavailable** in data\nsource if user has insufficient rights.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "vappNetworksDefaultSegmentProfileTemplateId": {
                        "description": "Default Segment Profile ID for all vApp\nnetworks withing this VDC\n",
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    },
                    "vdcNetworksDefaultSegmentProfileTemplateId": {
                        "description": "Default Segment Profile ID for all Org VDC\nnetworks withing this VDC\n",
                        "type": "string"
                    }
                },
                "required": [
                    "edgeClusterId",
                    "vappNetworksDefaultSegmentProfileTemplateId",
                    "vdcNetworksDefaultSegmentProfileTemplateId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getOrgVdcTemplate:getOrgVdcTemplate": {
            "description": "Provides a data source to read Organization VDC Templates from VMware Cloud Director.\nCan be used by System Administrators or tenants, only if the template is published in that tenant.\n\nSupported in provider *v3.13+*\n\n\u003e VDC Templates that do not use NSX-T can be read, but may be missing some details.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst template = vcd.getOrgVdcTemplate({\n    name: \"myTemplate\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntemplate = vcd.get_org_vdc_template(name=\"myTemplate\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var template = Vcd.GetOrgVdcTemplate.Invoke(new()\n    {\n        Name = \"myTemplate\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupOrgVdcTemplate(ctx, \u0026vcd.LookupOrgVdcTemplateArgs{\n\t\t\tName: \"myTemplate\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var template = VcdFunctions.getOrgVdcTemplate(GetOrgVdcTemplateArgs.builder()\n            .name(\"myTemplate\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  template:\n    fn::invoke:\n      function: vcd:getOrgVdcTemplate\n      arguments:\n        name: myTemplate\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e Note that when using the data source as a tenant, `name` is the VDC Template name as seen by tenants\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgVdcTemplate.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the existing Organization VDC Template to read\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgVdcTemplate.\n",
                "properties": {
                    "allocationModel": {
                        "type": "string"
                    },
                    "computeConfigurations": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVdcTemplateComputeConfiguration:getOrgVdcTemplateComputeConfiguration"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "edgeGateways": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVdcTemplateEdgeGateway:getOrgVdcTemplateEdgeGateway"
                        },
                        "type": "array"
                    },
                    "enableFastProvisioning": {
                        "type": "boolean"
                    },
                    "enableThinProvisioning": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkPoolId": {
                        "type": "string"
                    },
                    "nicQuota": {
                        "type": "integer"
                    },
                    "providerVdcs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVdcTemplateProviderVdc:getOrgVdcTemplateProviderVdc"
                        },
                        "type": "array"
                    },
                    "provisionedNetworkQuota": {
                        "type": "integer"
                    },
                    "readableByOrgIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "storageProfiles": {
                        "items": {
                            "$ref": "#/types/vcd:index/getOrgVdcTemplateStorageProfile:getOrgVdcTemplateStorageProfile"
                        },
                        "type": "array"
                    },
                    "tenantDescription": {
                        "type": "string"
                    },
                    "tenantName": {
                        "type": "string"
                    },
                    "vmQuota": {
                        "type": "integer"
                    }
                },
                "required": [
                    "allocationModel",
                    "computeConfigurations",
                    "description",
                    "edgeGateways",
                    "enableFastProvisioning",
                    "enableThinProvisioning",
                    "name",
                    "networkPoolId",
                    "nicQuota",
                    "providerVdcs",
                    "provisionedNetworkQuota",
                    "readableByOrgIds",
                    "storageProfiles",
                    "tenantDescription",
                    "tenantName",
                    "vmQuota",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getPortgroup:getPortgroup": {
            "description": "Provides a data source for available vCenter Port Groups.\n\nSupported in provider *v3.0+*\n\n\n## Example Usage\n\n### VSwitch Port Group\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst first_pg_vswitch = vcd.getPortgroup({\n    name: \"pg-name\",\n    type: \"NETWORK\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nfirst_pg_vswitch = vcd.get_portgroup(name=\"pg-name\",\n    type=\"NETWORK\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var first_pg_vswitch = Vcd.GetPortgroup.Invoke(new()\n    {\n        Name = \"pg-name\",\n        Type = \"NETWORK\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetPortgroup(ctx, \u0026vcd.GetPortgroupArgs{\n\t\t\tName: \"pg-name\",\n\t\t\tType: \"NETWORK\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetPortgroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var first-pg-vswitch = VcdFunctions.getPortgroup(GetPortgroupArgs.builder()\n            .name(\"pg-name\")\n            .type(\"NETWORK\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  first-pg-vswitch:\n    fn::invoke:\n      function: vcd:getPortgroup\n      arguments:\n        name: pg-name\n        type: NETWORK\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Distributed Port Group\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst first_pg_dvswitch = vcd.getPortgroup({\n    name: \"pg-name\",\n    type: \"DV_PORTGROUP\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nfirst_pg_dvswitch = vcd.get_portgroup(name=\"pg-name\",\n    type=\"DV_PORTGROUP\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var first_pg_dvswitch = Vcd.GetPortgroup.Invoke(new()\n    {\n        Name = \"pg-name\",\n        Type = \"DV_PORTGROUP\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetPortgroup(ctx, \u0026vcd.GetPortgroupArgs{\n\t\t\tName: \"pg-name\",\n\t\t\tType: \"DV_PORTGROUP\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetPortgroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var first-pg-dvswitch = VcdFunctions.getPortgroup(GetPortgroupArgs.builder()\n            .name(\"pg-name\")\n            .type(\"DV_PORTGROUP\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  first-pg-dvswitch:\n    fn::invoke:\n      function: vcd:getPortgroup\n      arguments:\n        name: pg-name\n        type: DV_PORTGROUP\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPortgroup.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Organization VDC name\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "`NETWORK` for vSwitch port group or `DV_PORTGROUP` for distributed port group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPortgroup.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getProviderVdc:getProviderVdc": {
            "description": "Gives a VMware Cloud Director Provider VDC data source. This data source can be used to reference a Provider VDC and use its \ndata within other resources or data sources.\n\nSupported in provider *v3.8+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_pvdc = vcd.getProviderVdc({\n    name: \"my-pvdc\",\n});\nexport const providerVdc = my_pvdc.then(my_pvdc =\u003e my_pvdc.id);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_pvdc = vcd.get_provider_vdc(name=\"my-pvdc\")\npulumi.export(\"providerVdc\", my_pvdc.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_pvdc = Vcd.GetProviderVdc.Invoke(new()\n    {\n        Name = \"my-pvdc\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"providerVdc\"] = my_pvdc.Apply(my_pvdc =\u003e my_pvdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Id)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_pvdc, err := vcd.LookupProviderVdc(ctx, \u0026vcd.LookupProviderVdcArgs{\n\t\t\tName: \"my-pvdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"providerVdc\", my_pvdc.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetProviderVdcArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-pvdc = VcdFunctions.getProviderVdc(GetProviderVdcArgs.builder()\n            .name(\"my-pvdc\")\n            .build());\n\n        ctx.export(\"providerVdc\", my_pvdc.id());\n    }\n}\n```\n```yaml\nvariables:\n  my-pvdc:\n    fn::invoke:\n      function: vcd:getProviderVdc\n      arguments:\n        name: my-pvdc\noutputs:\n  providerVdc: ${[\"my-pvdc\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Compute Capacity\n\nThe `compute_capacity` attribute is a list with a single item which has the following nested attributes:\n\n* `cpu` - An indicator of CPU. See CPU and memory below.\n* `memory` - An indicator of memory. See CPU and memory below.\n* `is_elastic` -  True if compute capacity can grow or shrink based on demand.\n* `is_ha` - True if compute capacity is highly available.\n\n\u003ca id=\"cpu-and-memory\"\u003e\u003c/a\u003e\n### CPU and memory\n\nThe `cpu` and `memory` indicators have the following nested attributes:\n\n* `allocation` - Allocated CPU/Memory for this Provider VDC.\n* `overhead` - CPU/Memory overhead for this Provider VDC.\n* `reserved` - Reserved CPU/Memory for this Provider VDC.\n* `total` - Total CPU/Memory for this Provider VDC.\n* `units` - Units for the CPU/Memory of this Provider VDC.\n* `used` - Used CPU/Memory in this Provider VDC.\n\n\u003ca id=\"metadata\"\u003e\u003c/a\u003e\n## Metadata\n\nThe `metadata_entry` (*v3.8+*) is a set of metadata entries that have the following structure:\n\n* `key` - Key of this metadata entry.\n* `value` - Value of this metadata entry.\n* `type` - Type of this metadata entry. One of: `MetadataStringValue`, `MetadataNumberValue`, `MetadataDateTimeValue`, `MetadataBooleanValue`.\n* `user_access` - User access level for this metadata entry. One of: `PRIVATE` (hidden), `READONLY` (read only), `READWRITE` (read/write).\n* `is_system` - Domain for this metadata entry. true if it belongs to `SYSTEM`, false if it belongs to `GENERAL`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProviderVdc.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Provider VDC name\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProviderVdc.\n",
                "properties": {
                    "capabilities": {
                        "description": "Set of virtual hardware versions supported by this Provider VDC.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "computeCapacities": {
                        "description": "An indicator of CPU and memory capacity. See Compute Capacity below for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getProviderVdcComputeCapacity:getProviderVdcComputeCapacity"
                        },
                        "type": "array"
                    },
                    "computeProviderScope": {
                        "description": "Represents the compute fault domain for this Provider VDC. This value is a tenant-facing tag that is shown to tenants when viewing fault domains of the child Organization VDCs (for example, a VDC Group).\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "Optional description of the Provider VDC.\n",
                        "type": "string"
                    },
                    "externalNetworkIds": {
                        "description": "Set of IDs of External Networks.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "highestSupportedHardwareVersion": {
                        "description": "The highest virtual hardware version supported by this Provider VDC.\n",
                        "type": "string"
                    },
                    "hostIds": {
                        "description": "Set with all the hosts which are connected to VC server.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isEnabled": {
                        "description": "True if this Provider VDC is enabled and can provide resources to organization VDCs. A Provider VDC is always enabled on creation.\n",
                        "type": "boolean"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "description": "(Deprecated) Use `metadata_entry` instead. Key and value pairs for Provider VDC Metadata.\n",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries assigned to the Provider VDC. See Metadata section for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getProviderVdcMetadataEntry:getProviderVdcMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkPoolIds": {
                        "description": "Set IDs of the Network Pools used by this Provider VDC.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "nsxtManagerId": {
                        "description": "ID of the registered NSX-T Manager that backs networking operations for this Provider VDC.\n",
                        "type": "string"
                    },
                    "resourcePoolIds": {
                        "description": "Set of IDs of the Resource Pools backing this provider VDC.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "status": {
                        "description": "Status of the Provider VDC, it can be -1 (creation failed), 0 (not ready), 1 (ready), 2 (unknown) or 3 (unrecognized).\n",
                        "type": "integer"
                    },
                    "storageContainerIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "storageProfileIds": {
                        "description": "Set of IDs to the Storage Profiles available to this Provider VDC.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "storageProfileNames": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "universalNetworkPoolId": {
                        "description": "ID of the universal network reference.\n",
                        "type": "string"
                    },
                    "vcenterId": {
                        "description": "ID of the vCenter Server that provides the Resource Pools and Datastores.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "capabilities",
                    "computeCapacities",
                    "computeProviderScope",
                    "description",
                    "externalNetworkIds",
                    "highestSupportedHardwareVersion",
                    "hostIds",
                    "isEnabled",
                    "metadata",
                    "metadataEntries",
                    "name",
                    "networkPoolIds",
                    "nsxtManagerId",
                    "resourcePoolIds",
                    "status",
                    "storageContainerIds",
                    "storageProfileIds",
                    "storageProfileNames",
                    "universalNetworkPoolId",
                    "vcenterId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRde:getRde": {
            "description": "Provides the capability of reading an existing Runtime Defined Entity in VMware Cloud Director.\n\n\u003e VCD allows to have multiple RDEs of the same [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type) with\nthe same name, meaning that the data source will not be able to fetch a RDE in this situation, as this data source\ncan only retrieve **unique RDEs**.\n\nSupported in provider *v3.9+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRdeTypeArgs;\nimport com.pulumi.vcd.inputs.GetRdeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myType = VcdFunctions.getRdeType(GetRdeTypeArgs.builder()\n            .vendor(\"bigcorp\")\n            .namespace(\"tech1\")\n            .version(\"1.2.3\")\n            .build());\n\n        final var myRde = VcdFunctions.getRde(GetRdeArgs.builder()\n            .org(\"my-org\")\n            .rdeTypeId(my_type.id())\n            .name(\"My custom RDE\")\n            .build());\n\n        ctx.export(\"rdeOutput\", myRdeVcdRde.entity());\n    }\n}\n```\n```yaml\nvariables:\n  myType:\n    fn::invoke:\n      function: vcd:getRdeType\n      arguments:\n        vendor: bigcorp\n        namespace: tech1\n        version: 1.2.3\n  myRde:\n    fn::invoke:\n      function: vcd:getRde\n      arguments:\n        org: my-org\n        rdeTypeId: ${[\"my-type\"].id}\n        name: My custom RDE\noutputs:\n  rdeOutput: ${myRdeVcdRde.entity}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRde.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the Runtime Defined Entity.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "Name of the [Organization](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org) that owns the RDE, optional if defined at provider level.\n"
                    },
                    "rdeTypeId": {
                        "type": "string",
                        "description": "The ID of the [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/rde_type) of the RDE to fetch.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "rdeTypeId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRde.\n",
                "properties": {
                    "entity": {
                        "description": "The entity JSON.\n",
                        "type": "string"
                    },
                    "externalId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries that belong to the RDE.\nRead the [resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde#metadata) documentation for the details of the sub-attributes.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getRdeMetadataEntry:getRdeMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "orgId": {
                        "description": "The ID of the [Organization](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org) to which the Runtime Defined Entity belongs.\n",
                        "type": "string"
                    },
                    "ownerUserId": {
                        "description": "The ID of the [Organization user](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_user) that owns this Runtime Defined Entity.\n",
                        "type": "string"
                    },
                    "rdeTypeId": {
                        "type": "string"
                    },
                    "state": {
                        "description": "It can be `RESOLVED`, `RESOLUTION_ERROR` or `PRE_CREATED`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "entity",
                    "externalId",
                    "metadataEntries",
                    "name",
                    "orgId",
                    "ownerUserId",
                    "rdeTypeId",
                    "state",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRdeBehaviorInvocation:getRdeBehaviorInvocation": {
            "description": "\u003e This feature is **experimental** and may change in future\n\nProvides the capability of invoking an existing [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior)\nor [RDE Type Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type_behavior) in VMware Cloud Director.\n\nSupported in provider *v3.11+*\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRdeBehaviorInvocation.\n",
                "properties": {
                    "arguments": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map with the arguments of the invocation. Deprecated in favor of `arguments_json`\n",
                        "deprecationMessage": "Use 'arguments_json' instead"
                    },
                    "argumentsJson": {
                        "type": "string",
                        "description": "A JSON string with the arguments of the invocation. The built-in function `jsonencode` can\nbe used to set it.\n"
                    },
                    "behaviorId": {
                        "type": "string",
                        "description": "The ID of the [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior) or\nthe [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type_behavior) to invoke\n"
                    },
                    "invokeOnRefresh": {
                        "type": "boolean"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map with the metadata of the invocation. Deprecated in favor of `metadata_json`\n",
                        "deprecationMessage": "Use 'metadata_json' instead"
                    },
                    "metadataJson": {
                        "type": "string",
                        "description": "A JSON string with the arguments of the invocation. The built-in function `jsonencode` can\nbe used to set it.\n"
                    },
                    "rdeId": {
                        "type": "string",
                        "description": "The ID of the [RDE](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde) which Behavior will be invoked\n"
                    }
                },
                "type": "object",
                "required": [
                    "behaviorId",
                    "rdeId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRdeBehaviorInvocation.\n",
                "properties": {
                    "arguments": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use 'arguments_json' instead",
                        "type": "object"
                    },
                    "argumentsJson": {
                        "type": "string"
                    },
                    "behaviorId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "invokeOnRefresh": {
                        "type": "boolean"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use 'metadata_json' instead",
                        "type": "object"
                    },
                    "metadataJson": {
                        "type": "string"
                    },
                    "rdeId": {
                        "type": "string"
                    },
                    "result": {
                        "description": "The invocation result in plain text\n",
                        "type": "string"
                    }
                },
                "required": [
                    "behaviorId",
                    "rdeId",
                    "result",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRdeInterface:getRdeInterface": {
            "description": "Provides the capability of fetching an existing Runtime Defined Entity Interface from VMware Cloud Director.\n\nSupported in provider *v3.9+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myInterface = vcd.getRdeInterface({\n    vendor: \"bigcorp\",\n    nss: \"tech\",\n    version: \"1.2.3\",\n});\nexport const interfaceName = myInterface.then(myInterface =\u003e myInterface.name);\nexport const interfaceId = myInterface.then(myInterface =\u003e myInterface.id);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_interface = vcd.get_rde_interface(vendor=\"bigcorp\",\n    nss=\"tech\",\n    version=\"1.2.3\")\npulumi.export(\"interfaceName\", my_interface.name)\npulumi.export(\"interfaceId\", my_interface.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myInterface = Vcd.GetRdeInterface.Invoke(new()\n    {\n        Vendor = \"bigcorp\",\n        Nss = \"tech\",\n        Version = \"1.2.3\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"interfaceName\"] = myInterface.Apply(getRdeInterfaceResult =\u003e getRdeInterfaceResult.Name),\n        [\"interfaceId\"] = myInterface.Apply(getRdeInterfaceResult =\u003e getRdeInterfaceResult.Id),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyInterface, err := vcd.LookupRdeInterface(ctx, \u0026vcd.LookupRdeInterfaceArgs{\n\t\t\tVendor:  \"bigcorp\",\n\t\t\tNss:     \"tech\",\n\t\t\tVersion: \"1.2.3\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"interfaceName\", myInterface.Name)\n\t\tctx.Export(\"interfaceId\", myInterface.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRdeInterfaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myInterface = VcdFunctions.getRdeInterface(GetRdeInterfaceArgs.builder()\n            .vendor(\"bigcorp\")\n            .nss(\"tech\")\n            .version(\"1.2.3\")\n            .build());\n\n        ctx.export(\"interfaceName\", myInterface.applyValue(getRdeInterfaceResult -\u003e getRdeInterfaceResult.name()));\n        ctx.export(\"interfaceId\", myInterface.applyValue(getRdeInterfaceResult -\u003e getRdeInterfaceResult.id()));\n    }\n}\n```\n```yaml\nvariables:\n  myInterface:\n    fn::invoke:\n      function: vcd:getRdeInterface\n      arguments:\n        vendor: bigcorp\n        nss: tech\n        version: 1.2.3\noutputs:\n  interfaceName: ${myInterface.name}\n  interfaceId: ${myInterface.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRdeInterface.\n",
                "properties": {
                    "nss": {
                        "type": "string",
                        "description": "A unique namespace associated with the RDE Interface.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor of the RDE Interface.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the RDE Interface. Must follow [semantic versioning](https://semver.org/) syntax.\n"
                    }
                },
                "type": "object",
                "required": [
                    "nss",
                    "vendor",
                    "version"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRdeInterface.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nss": {
                        "type": "string"
                    },
                    "readonly": {
                        "type": "boolean"
                    },
                    "vendor": {
                        "type": "string"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "nss",
                    "readonly",
                    "vendor",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRdeInterfaceBehavior:getRdeInterfaceBehavior": {
            "description": "Provides the capability of fetching an existing RDE Interface Behavior from VMware Cloud Director.\n\nSupported in provider *v3.10+*. Requires System Administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst myInterface = vcd.getRdeInterface({\n    vendor: \"vmware\",\n    nss: \"k8s\",\n    version: \"1.0.0\",\n});\nconst myBehavior = myInterface.then(myInterface =\u003e vcd.getRdeInterfaceBehavior({\n    rdeInterfaceId: myInterface.id,\n    name: \"createKubeConfig\",\n}));\nexport const executionId = myBehavior.then(myBehavior =\u003e myBehavior.execution?.id);\nexport const executionType = myBehavior.then(myBehavior =\u003e myBehavior.execution?.type);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_interface = vcd.get_rde_interface(vendor=\"vmware\",\n    nss=\"k8s\",\n    version=\"1.0.0\")\nmy_behavior = vcd.get_rde_interface_behavior(rde_interface_id=my_interface.id,\n    name=\"createKubeConfig\")\npulumi.export(\"executionId\", my_behavior.execution[\"id\"])\npulumi.export(\"executionType\", my_behavior.execution[\"type\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myInterface = Vcd.GetRdeInterface.Invoke(new()\n    {\n        Vendor = \"vmware\",\n        Nss = \"k8s\",\n        Version = \"1.0.0\",\n    });\n\n    var myBehavior = Vcd.GetRdeInterfaceBehavior.Invoke(new()\n    {\n        RdeInterfaceId = myInterface.Apply(getRdeInterfaceResult =\u003e getRdeInterfaceResult.Id),\n        Name = \"createKubeConfig\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"executionId\"] = myBehavior.Apply(getRdeInterfaceBehaviorResult =\u003e getRdeInterfaceBehaviorResult.Execution?.Id),\n        [\"executionType\"] = myBehavior.Apply(getRdeInterfaceBehaviorResult =\u003e getRdeInterfaceBehaviorResult.Execution?.Type),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyInterface, err := vcd.LookupRdeInterface(ctx, \u0026vcd.LookupRdeInterfaceArgs{\n\t\t\tVendor:  \"vmware\",\n\t\t\tNss:     \"k8s\",\n\t\t\tVersion: \"1.0.0\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmyBehavior, err := vcd.LookupRdeInterfaceBehavior(ctx, \u0026vcd.LookupRdeInterfaceBehaviorArgs{\n\t\t\tRdeInterfaceId: myInterface.Id,\n\t\t\tName:           \"createKubeConfig\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"executionId\", myBehavior.Execution.Id)\n\t\tctx.Export(\"executionType\", myBehavior.Execution.Type)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRdeInterfaceArgs;\nimport com.pulumi.vcd.inputs.GetRdeInterfaceBehaviorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myInterface = VcdFunctions.getRdeInterface(GetRdeInterfaceArgs.builder()\n            .vendor(\"vmware\")\n            .nss(\"k8s\")\n            .version(\"1.0.0\")\n            .build());\n\n        final var myBehavior = VcdFunctions.getRdeInterfaceBehavior(GetRdeInterfaceBehaviorArgs.builder()\n            .rdeInterfaceId(myInterface.applyValue(getRdeInterfaceResult -\u003e getRdeInterfaceResult.id()))\n            .name(\"createKubeConfig\")\n            .build());\n\n        ctx.export(\"executionId\", myBehavior.applyValue(getRdeInterfaceBehaviorResult -\u003e getRdeInterfaceBehaviorResult.execution().id()));\n        ctx.export(\"executionType\", myBehavior.applyValue(getRdeInterfaceBehaviorResult -\u003e getRdeInterfaceBehaviorResult.execution().type()));\n    }\n}\n```\n```yaml\nvariables:\n  myInterface:\n    fn::invoke:\n      function: vcd:getRdeInterface\n      arguments:\n        vendor: vmware\n        nss: k8s\n        version: 1.0.0\n  myBehavior:\n    fn::invoke:\n      function: vcd:getRdeInterfaceBehavior\n      arguments:\n        rdeInterfaceId: ${myInterface.id}\n        name: createKubeConfig\noutputs:\n  executionId: ${myBehavior.execution.id}\n  executionType: ${myBehavior.execution.type}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRdeInterfaceBehavior.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the RDE Interface Behavior to fetch\n"
                    },
                    "rdeInterfaceId": {
                        "type": "string",
                        "description": "The ID of the RDE Interface that owns the Behavior to fetch\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "rdeInterfaceId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRdeInterfaceBehavior.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "execution": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "This argument cannot consider complex execution structures. For that purpose, use 'execution_json' instead",
                        "type": "object"
                    },
                    "executionJson": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rdeInterfaceId": {
                        "type": "string"
                    },
                    "ref": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "execution",
                    "executionJson",
                    "name",
                    "rdeInterfaceId",
                    "ref",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRdeType:getRdeType": {
            "description": "Provides the capability of fetching an existing Runtime Defined Entity Type from VMware Cloud Director.\n\nSupported in provider *v3.9+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nexport = async () =\u003e {\n    const myRdeType = await vcd.getRdeType({\n        vendor: \"bigcorp\",\n        nss: \"tech\",\n        version: \"1.2.3\",\n    });\n    return {\n        \"type-name\": myRdeType.name,\n        \"type-id\": myRdeType.id,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_rde_type = vcd.get_rde_type(vendor=\"bigcorp\",\n    nss=\"tech\",\n    version=\"1.2.3\")\npulumi.export(\"type-name\", my_rde_type.name)\npulumi.export(\"type-id\", my_rde_type.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myRdeType = Vcd.GetRdeType.Invoke(new()\n    {\n        Vendor = \"bigcorp\",\n        Nss = \"tech\",\n        Version = \"1.2.3\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"type-name\"] = myRdeType.Apply(getRdeTypeResult =\u003e getRdeTypeResult.Name),\n        [\"type-id\"] = myRdeType.Apply(getRdeTypeResult =\u003e getRdeTypeResult.Id),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyRdeType, err := vcd.LookupRdeType(ctx, \u0026vcd.LookupRdeTypeArgs{\n\t\t\tVendor:  \"bigcorp\",\n\t\t\tNss:     \"tech\",\n\t\t\tVersion: \"1.2.3\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"type-name\", myRdeType.Name)\n\t\tctx.Export(\"type-id\", myRdeType.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRdeTypeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myRdeType = VcdFunctions.getRdeType(GetRdeTypeArgs.builder()\n            .vendor(\"bigcorp\")\n            .nss(\"tech\")\n            .version(\"1.2.3\")\n            .build());\n\n        ctx.export(\"type-name\", myRdeType.applyValue(getRdeTypeResult -\u003e getRdeTypeResult.name()));\n        ctx.export(\"type-id\", myRdeType.applyValue(getRdeTypeResult -\u003e getRdeTypeResult.id()));\n    }\n}\n```\n```yaml\nvariables:\n  myRdeType:\n    fn::invoke:\n      function: vcd:getRdeType\n      arguments:\n        vendor: bigcorp\n        nss: tech\n        version: 1.2.3\noutputs:\n  type-name: ${myRdeType.name}\n  type-id: ${myRdeType.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRdeType.\n",
                "properties": {
                    "nss": {
                        "type": "string",
                        "description": "A unique namespace associated with the Runtime Defined Entity Type.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor of the Runtime Defined Entity Type.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the Runtime Defined Entity Type. Must follow [semantic versioning](https://semver.org/) syntax.\n"
                    }
                },
                "type": "object",
                "required": [
                    "nss",
                    "vendor",
                    "version"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRdeType.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "externalId": {
                        "type": "string"
                    },
                    "hooks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getRdeTypeHook:getRdeTypeHook"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inheritedVersion": {
                        "type": "string"
                    },
                    "interfaceIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nss": {
                        "type": "string"
                    },
                    "readonly": {
                        "type": "boolean"
                    },
                    "schema": {
                        "type": "string"
                    },
                    "vendor": {
                        "type": "string"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "externalId",
                    "hooks",
                    "inheritedVersion",
                    "interfaceIds",
                    "name",
                    "nss",
                    "readonly",
                    "schema",
                    "vendor",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRdeTypeBehavior:getRdeTypeBehavior": {
            "description": "Provides the capability of reading RDE Type Behaviors in VMware Cloud Director, which override an existing [RDE Interface\nBehavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/rde_interface_behavior).\n\nSupported in provider *v3.10+*. Requires System Administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRdeInterfaceArgs;\nimport com.pulumi.vcd.inputs.GetRdeInterfaceBehaviorArgs;\nimport com.pulumi.vcd.inputs.GetRdeTypeArgs;\nimport com.pulumi.vcd.inputs.GetRdeTypeBehaviorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myInterface = VcdFunctions.getRdeInterface(GetRdeInterfaceArgs.builder()\n            .vendor(\"vmware\")\n            .nss(\"k8s\")\n            .version(\"1.0.0\")\n            .build());\n\n        final var myInterfaceBehavior = VcdFunctions.getRdeInterfaceBehavior(GetRdeInterfaceBehaviorArgs.builder()\n            .interfaceId(myInterface.applyValue(getRdeInterfaceResult -\u003e getRdeInterfaceResult.id()))\n            .name(\"createKubeConfig\")\n            .build());\n\n        final var myType = VcdFunctions.getRdeType(GetRdeTypeArgs.builder()\n            .vendor(\"vmware\")\n            .nss(\"k8s\")\n            .version(\"1.2.0\")\n            .build());\n\n        final var myBehavior = VcdFunctions.getRdeTypeBehavior(GetRdeTypeBehaviorArgs.builder()\n            .rdeTypeId(myType.applyValue(getRdeTypeResult -\u003e getRdeTypeResult.id()))\n            .rdeInterfaceBehaviorId(myInterfaceBehavior.applyValue(getRdeInterfaceBehaviorResult -\u003e getRdeInterfaceBehaviorResult.id()))\n            .build());\n\n        ctx.export(\"executionId\", myBehavior.applyValue(getRdeTypeBehaviorResult -\u003e getRdeTypeBehaviorResult.execution().id()));\n    }\n}\n```\n```yaml\nvariables:\n  myInterface:\n    fn::invoke:\n      function: vcd:getRdeInterface\n      arguments:\n        vendor: vmware\n        nss: k8s\n        version: 1.0.0\n  myInterfaceBehavior:\n    fn::invoke:\n      function: vcd:getRdeInterfaceBehavior\n      arguments:\n        interfaceId: ${myInterface.id}\n        name: createKubeConfig\n  myType:\n    fn::invoke:\n      function: vcd:getRdeType\n      arguments:\n        vendor: vmware\n        nss: k8s\n        version: 1.2.0\n  myBehavior:\n    fn::invoke:\n      function: vcd:getRdeTypeBehavior\n      arguments:\n        rdeTypeId: ${myType.id}\n        rdeInterfaceBehaviorId: ${myInterfaceBehavior.id}\noutputs:\n  executionId: ${myBehavior.execution.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRdeTypeBehavior.\n",
                "properties": {
                    "behaviorId": {
                        "type": "string"
                    },
                    "rdeTypeId": {
                        "type": "string",
                        "description": "The ID of the [RDE Type](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/rde_type) that owns the Behavior override\n"
                    }
                },
                "type": "object",
                "required": [
                    "behaviorId",
                    "rdeTypeId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRdeTypeBehavior.\n",
                "properties": {
                    "behaviorId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "execution": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "This argument cannot consider complex execution structures. For that purpose, use 'execution_json' instead",
                        "type": "object"
                    },
                    "executionJson": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rdeTypeId": {
                        "type": "string"
                    },
                    "ref": {
                        "type": "string"
                    }
                },
                "required": [
                    "behaviorId",
                    "description",
                    "execution",
                    "executionJson",
                    "name",
                    "rdeTypeId",
                    "ref",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRdeTypeBehaviorAcl:getRdeTypeBehaviorAcl": {
            "description": "Provides the capability of fetching the RDE Type Behavior Access Levels from VMware Cloud Director.\n\nSupported in provider *v3.10+*. Requires System Administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRdeInterfaceArgs;\nimport com.pulumi.vcd.inputs.GetRdeInterfaceBehaviorArgs;\nimport com.pulumi.vcd.inputs.GetRdeTypeArgs;\nimport com.pulumi.vcd.inputs.GetRdeTypeBehaviorAclArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myInterface = VcdFunctions.getRdeInterface(GetRdeInterfaceArgs.builder()\n            .vendor(\"vmware\")\n            .nss(\"k8s\")\n            .version(\"1.0.0\")\n            .build());\n\n        final var myInterfaceBehavior = VcdFunctions.getRdeInterfaceBehavior(GetRdeInterfaceBehaviorArgs.builder()\n            .interfaceId(myInterface.applyValue(getRdeInterfaceResult -\u003e getRdeInterfaceResult.id()))\n            .name(\"createKubeConfig\")\n            .build());\n\n        final var myType = VcdFunctions.getRdeType(GetRdeTypeArgs.builder()\n            .vendor(\"vmware\")\n            .nss(\"k8s\")\n            .version(\"1.2.0\")\n            .build());\n\n        final var myBehaviorAcl = VcdFunctions.getRdeTypeBehaviorAcl(GetRdeTypeBehaviorAclArgs.builder()\n            .rdeTypeId(myType.applyValue(getRdeTypeResult -\u003e getRdeTypeResult.id()))\n            .behaviorId(myInterfaceBehavior.applyValue(getRdeInterfaceBehaviorResult -\u003e getRdeInterfaceBehaviorResult.id()))\n            .build());\n\n        ctx.export(\"accessLevels\", myBehaviorAcl.applyValue(getRdeTypeBehaviorAclResult -\u003e getRdeTypeBehaviorAclResult.accessLevelIds()));\n    }\n}\n```\n```yaml\nvariables:\n  myInterface:\n    fn::invoke:\n      function: vcd:getRdeInterface\n      arguments:\n        vendor: vmware\n        nss: k8s\n        version: 1.0.0\n  myInterfaceBehavior:\n    fn::invoke:\n      function: vcd:getRdeInterfaceBehavior\n      arguments:\n        interfaceId: ${myInterface.id}\n        name: createKubeConfig\n  myType:\n    fn::invoke:\n      function: vcd:getRdeType\n      arguments:\n        vendor: vmware\n        nss: k8s\n        version: 1.2.0\n  myBehaviorAcl:\n    fn::invoke:\n      function: vcd:getRdeTypeBehaviorAcl\n      arguments:\n        rdeTypeId: ${myType.id}\n        behaviorId: ${myInterfaceBehavior.id}\noutputs:\n  accessLevels: ${myBehaviorAcl.accessLevelIds}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRdeTypeBehaviorAcl.\n",
                "properties": {
                    "behaviorId": {
                        "type": "string",
                        "description": "The ID of either a [RDE Type Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_type_behavior)\nor a [RDE Interface Behavior](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde_interface_behavior)\n",
                        "willReplaceOnChanges": true
                    },
                    "rdeTypeId": {
                        "type": "string",
                        "description": "The ID of the RDE Type\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "behaviorId",
                    "rdeTypeId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRdeTypeBehaviorAcl.\n",
                "properties": {
                    "accessLevelIds": {
                        "description": "Set of Access Level IDs associated to the Behavior defined in `behavior_id` argument\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "behaviorId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "rdeTypeId": {
                        "type": "string"
                    }
                },
                "required": [
                    "accessLevelIds",
                    "behaviorId",
                    "rdeTypeId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getResourceList:getResourceList": {
            "inputs": {
                "description": "A collection of arguments for invoking getResourceList.\n",
                "properties": {
                    "importFileName": {
                        "type": "string",
                        "description": "Name of the file containing the import block. (Requires `list_mode = \"import\"`).\nSee [Importing resources][import-resources] for more information on importing.\n"
                    },
                    "listMode": {
                        "type": "string",
                        "description": "How the list should be built. One of:\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "An unique name to identify the data source\n"
                    },
                    "nameIdSeparator": {
                        "type": "string",
                        "description": "A string separating name and ID in the list. Default is \"  \" (two spaces)\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "If set, will restrict the list of resources to the ones whose name matches the given regular expression.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level\n"
                    },
                    "parent": {
                        "type": "string",
                        "description": "The resource parent, such as vApp, catalog, or edge gateway name, when needed.\n"
                    },
                    "resourceType": {
                        "type": "string",
                        "description": "Which resource we want to list. Supported keywords are:\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "resourceType"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getResourceList.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "importFileName": {
                        "type": "string"
                    },
                    "listMode": {
                        "type": "string"
                    },
                    "lists": {
                        "description": "(Computed) The list of requested resources in the chosen format.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nameIdSeparator": {
                        "type": "string"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "parent": {
                        "type": "string"
                    },
                    "resourceType": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "lists",
                    "name",
                    "resourceType",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getResourcePool:getResourcePool": {
            "description": "Provides a data source for a resource pool attached to a vCenter. A resource pool is an essential component of a Provider VDC.\n\n\n\u003e Note 1: this data source requires System Administrator privileges\n\n\u003e Note 2: you can create or modify a resource pool using vSphere provider\n\nSupported in provider *v3.10+*\n\n\n## Example Usage\n\n### 1\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst vcenter1 = vcd.getVcenter({\n    name: \"vc1\",\n});\nconst rp1 = vcenter1.then(vcenter1 =\u003e vcd.getResourcePool({\n    name: \"resource-pool-for-vcd-01\",\n    vcenterId: vcenter1.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nvcenter1 = vcd.get_vcenter(name=\"vc1\")\nrp1 = vcd.get_resource_pool(name=\"resource-pool-for-vcd-01\",\n    vcenter_id=vcenter1.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vcenter1 = Vcd.GetVcenter.Invoke(new()\n    {\n        Name = \"vc1\",\n    });\n\n    var rp1 = Vcd.GetResourcePool.Invoke(new()\n    {\n        Name = \"resource-pool-for-vcd-01\",\n        VcenterId = vcenter1.Apply(getVcenterResult =\u003e getVcenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tvcenter1, err := vcd.GetVcenter(ctx, \u0026vcd.GetVcenterArgs{\n\t\t\tName: \"vc1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetResourcePool(ctx, \u0026vcd.GetResourcePoolArgs{\n\t\t\tName:      \"resource-pool-for-vcd-01\",\n\t\t\tVcenterId: vcenter1.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVcenterArgs;\nimport com.pulumi.vcd.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vcenter1 = VcdFunctions.getVcenter(GetVcenterArgs.builder()\n            .name(\"vc1\")\n            .build());\n\n        final var rp1 = VcdFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"resource-pool-for-vcd-01\")\n            .vcenterId(vcenter1.applyValue(getVcenterResult -\u003e getVcenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vcenter1:\n    fn::invoke:\n      function: vcd:getVcenter\n      arguments:\n        name: vc1\n  rp1:\n    fn::invoke:\n      function: vcd:getResourcePool\n      arguments:\n        name: resource-pool-for-vcd-01\n        vcenterId: ${vcenter1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### 2\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst rp1 = vcd.getResourcePool({\n    name: \"common-name\",\n    vcenterId: vcenter1.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nrp1 = vcd.get_resource_pool(name=\"common-name\",\n    vcenter_id=vcenter1[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rp1 = Vcd.GetResourcePool.Invoke(new()\n    {\n        Name = \"common-name\",\n        VcenterId = vcenter1.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetResourcePool(ctx, \u0026vcd.GetResourcePoolArgs{\n\t\t\tName:      \"common-name\",\n\t\t\tVcenterId: vcenter1.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var rp1 = VcdFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"common-name\")\n            .vcenterId(vcenter1.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  rp1:\n    fn::invoke:\n      function: vcd:getResourcePool\n      arguments:\n        name: common-name\n        vcenterId: ${vcenter1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nWhen you receive such error, you can run the script again, but using the resource pool ID instead of the name.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst rp1 = vcd.getResourcePool({\n    name: \"resgroup-241\",\n    vcenterId: vcenter1.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nrp1 = vcd.get_resource_pool(name=\"resgroup-241\",\n    vcenter_id=vcenter1[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rp1 = Vcd.GetResourcePool.Invoke(new()\n    {\n        Name = \"resgroup-241\",\n        VcenterId = vcenter1.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetResourcePool(ctx, \u0026vcd.GetResourcePoolArgs{\n\t\t\tName:      \"resgroup-241\",\n\t\t\tVcenterId: vcenter1.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var rp1 = VcdFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"resgroup-241\")\n            .vcenterId(vcenter1.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  rp1:\n    fn::invoke:\n      function: vcd:getResourcePool\n      arguments:\n        name: resgroup-241\n        vcenterId: ${vcenter1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getResourcePool.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "resource pool name. The name may not be unique within the vCenter. If that happens, you will get an\nerror message with the list of IDs for the pools with the same name, and can subsequently enter the resource pool ID instead of the name.\n(See Example Usage 2)\n"
                    },
                    "vcenterId": {
                        "type": "string",
                        "description": "ID of the vCenter to which this resource pool belongs.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vcenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getResourcePool.\n",
                "properties": {
                    "clusterMoref": {
                        "description": "managed object reference of the vCenter cluster that this resource pool is hosted on.\n",
                        "type": "string"
                    },
                    "hardwareVersion": {
                        "description": "default hardware version available to this resource pool.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "vcenterId": {
                        "type": "string"
                    }
                },
                "required": [
                    "clusterMoref",
                    "hardwareVersion",
                    "name",
                    "vcenterId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getResourceSchema:getResourceSchema": {
            "description": "Provides a VMware Cloud Director generic structure data source. It shows the structure of any VCD resource.\n\nSupported in provider *v3.1+*\n\n## Example Usage\n\n### 1\n\nShowing a structure with simple attributes only \n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nexport = async () =\u003e {\n    const orgStruct = await vcd.getResourceSchema({\n        name: \"org_struct\",\n        resourceType: \"vcd_org\",\n    });\n    return {\n        orgStruct: orgStruct.attributes,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\norg_struct = vcd.get_resource_schema(name=\"org_struct\",\n    resource_type=\"vcd_org\")\npulumi.export(\"orgStruct\", org_struct.attributes)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgStruct = Vcd.GetResourceSchema.Invoke(new()\n    {\n        Name = \"org_struct\",\n        ResourceType = \"vcd_org\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"orgStruct\"] = orgStruct.Apply(getResourceSchemaResult =\u003e getResourceSchemaResult.Attributes),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\torgStruct, err := vcd.GetResourceSchema(ctx, \u0026vcd.GetResourceSchemaArgs{\n\t\t\tName:         \"org_struct\",\n\t\t\tResourceType: \"vcd_org\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"orgStruct\", orgStruct.Attributes)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetResourceSchemaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var orgStruct = VcdFunctions.getResourceSchema(GetResourceSchemaArgs.builder()\n            .name(\"org_struct\")\n            .resourceType(\"vcd_org\")\n            .build());\n\n        ctx.export(\"orgStruct\", orgStruct.applyValue(getResourceSchemaResult -\u003e getResourceSchemaResult.attributes()));\n    }\n}\n```\n```yaml\nvariables:\n  orgStruct:\n    fn::invoke:\n      function: vcd:getResourceSchema\n      arguments:\n        name: org_struct\n        resourceType: vcd_org\noutputs:\n  # Shows the organization attributes\n  orgStruct: ${orgStruct.attributes}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### 2\n\nShowing a structure with both simple and compound attributes\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst networkIsolatedStruct = vcd.getResourceSchema({\n    name: \"net_struct\",\n    resourceType: \"vcd_network_isolated\",\n});\nexport const netStruct = netStructVcdResourceSchema;\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nnetwork_isolated_struct = vcd.get_resource_schema(name=\"net_struct\",\n    resource_type=\"vcd_network_isolated\")\npulumi.export(\"netStruct\", net_struct_vcd_resource_schema)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var networkIsolatedStruct = Vcd.GetResourceSchema.Invoke(new()\n    {\n        Name = \"net_struct\",\n        ResourceType = \"vcd_network_isolated\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"netStruct\"] = netStructVcdResourceSchema,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetResourceSchema(ctx, \u0026vcd.GetResourceSchemaArgs{\n\t\t\tName:         \"net_struct\",\n\t\t\tResourceType: \"vcd_network_isolated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"netStruct\", netStructVcdResourceSchema)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetResourceSchemaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var networkIsolatedStruct = VcdFunctions.getResourceSchema(GetResourceSchemaArgs.builder()\n            .name(\"net_struct\")\n            .resourceType(\"vcd_network_isolated\")\n            .build());\n\n        ctx.export(\"netStruct\", netStructVcdResourceSchema);\n    }\n}\n```\n```yaml\nvariables:\n  networkIsolatedStruct:\n    fn::invoke:\n      function: vcd:getResourceSchema\n      arguments:\n        name: net_struct\n        resourceType: vcd_network_isolated\noutputs:\n  netStruct: ${netStructVcdResourceSchema}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getResourceSchema.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "An unique name to identify the data source\n"
                    },
                    "resourceType": {
                        "type": "string",
                        "description": "Which resource we want to list. It needs to use the full name of the resource (i.e. \"vcd.Org\",\nnot simply \"org\")\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "resourceType"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getResourceSchema.\n",
                "properties": {
                    "attributes": {
                        "description": "(Computed) Same composition of the simple `attributes` above.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getResourceSchemaAttribute:getResourceSchemaAttribute"
                        },
                        "type": "array"
                    },
                    "blockAttributes": {
                        "description": "(Computed) The list of compound attributes\nEach bock attribute is made of:\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getResourceSchemaBlockAttribute:getResourceSchemaBlockAttribute"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "the attribute name\n",
                        "type": "string"
                    },
                    "resourceType": {
                        "type": "string"
                    }
                },
                "required": [
                    "attributes",
                    "blockAttributes",
                    "name",
                    "resourceType",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRight:getRight": {
            "description": "Provides a data source for available rights.\n\nSupported in provider *v3.3+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nexport = async () =\u003e {\n    const some_right = await vcd.getRight({\n        name: \"Catalog: Add vApp from My Cloud\",\n    });\n    return {\n        \"some-right\": some_right,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsome_right = vcd.get_right(name=\"Catalog: Add vApp from My Cloud\")\npulumi.export(\"some-right\", some_right)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var some_right = Vcd.GetRight.Invoke(new()\n    {\n        Name = \"Catalog: Add vApp from My Cloud\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"some-right\"] = some_right,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsome_right, err := vcd.GetRight(ctx, \u0026vcd.GetRightArgs{\n\t\t\tName: \"Catalog: Add vApp from My Cloud\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"some-right\", some_right)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRightArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var some-right = VcdFunctions.getRight(GetRightArgs.builder()\n            .name(\"Catalog: Add vApp from My Cloud\")\n            .build());\n\n        ctx.export(\"some-right\", some_right);\n    }\n}\n```\n```yaml\nvariables:\n  some-right:\n    fn::invoke:\n      function: vcd:getRight\n      arguments:\n        name: 'Catalog: Add vApp from My Cloud'\noutputs:\n  some-right: ${[\"some-right\"]}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n```\nSample output:\n\nsome-right = {\n  \"bundle_key\" = \"RIGHT_CATALOG_ADD_VAPP_FROM_MY_CLOUD\"\n  \"category_id\" = \"urn:vcloud:rightsCategory:c32516ba-bc5b-3c47-ab8c-e1bfc223253c\"\n  \"description\" = \"Add a vApp from My Cloud\"\n  \"id\" = \"urn:vcloud:right:4886663f-ae31-37fc-9a70-3dbe2f24a8c5\"\n  \"implied_rights\" = toset([\n    {\n      \"id\" = \"urn:vcloud:right:1aa46727-6192-365d-b571-5ce51beb3b48\"\n      \"name\" = \"vApp Template / Media: View\"\n    },\n    {\n      \"id\" = \"urn:vcloud:right:3eedbfb4-c4a3-373d-b4b5-d76ca363ab50\"\n      \"name\" = \"vApp Template / Media: Edit\"\n    },\n    {\n      \"id\" = \"urn:vcloud:right:fa4ce8f8-c640-3b65-8fa5-a863b56c3d51\"\n      \"name\" = \"Catalog: View Private and Shared Catalogs\"\n    },\n  ])\n  \"name\" = \"Catalog: Add vApp from My Cloud\"\n  \"right_type\" = \"MODIFY\"\n}\n```\n\n## More information\n\nSee [Roles management](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/roles_management) for a broader description of how roles and\nrights work together.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRight.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the right.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRight.\n",
                "properties": {
                    "bundleKey": {
                        "description": "Key used for internationalization\n* `right type` - Type of the right (VIEW or MODIFY)\n",
                        "type": "string"
                    },
                    "categoryId": {
                        "description": "The ID of the category for this right\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "A description of the right\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "impliedRights": {
                        "description": "List of rights that are implied with this one\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getRightImpliedRight:getRightImpliedRight"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rightType": {
                        "type": "string"
                    }
                },
                "required": [
                    "bundleKey",
                    "categoryId",
                    "description",
                    "impliedRights",
                    "name",
                    "rightType",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRightsBundle:getRightsBundle": {
            "description": "Provides a VMware Cloud Director rights bundle data source. This can be used to read rights bundles.\n\nSupported in provider *v3.3+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst default_set = vcd.getRightsBundle({\n    name: \"Default Rights Bundle\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ndefault_set = vcd.get_rights_bundle(name=\"Default Rights Bundle\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var default_set = Vcd.GetRightsBundle.Invoke(new()\n    {\n        Name = \"Default Rights Bundle\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupRightsBundle(ctx, \u0026vcd.LookupRightsBundleArgs{\n\t\t\tName: \"Default Rights Bundle\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRightsBundleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var default-set = VcdFunctions.getRightsBundle(GetRightsBundleArgs.builder()\n            .name(\"Default Rights Bundle\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  default-set:\n    fn::invoke:\n      function: vcd:getRightsBundle\n      arguments:\n        name: Default Rights Bundle\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n```\nSample output:\n\ndefault-set = {\n  \"bundle_key\" = \"com.vmware.vcloud.undefined.key\"\n  \"description\" = \"Default set of tenant rights\"\n  \"id\" = \"urn:vcloud:rightsBundle:31482daa-c398-4938-895e-5dc6911a0641\"\n  \"name\" = \"Default Rights Bundle\"\n  \"publish_to_all_tenants\" = false\n  \"read_only\" = false\n  \"rights\" = toset([\n    \"Access All Organization VDCs\",\n    \"Catalog: Add vApp from My Cloud\",\n    \"Catalog: CLSP Publish Subscribe\",\n    \"Catalog: Change Owner\",\n    \"Catalog: Create / Delete a Catalog\",\n    \"Catalog: Edit Properties\",\n    \"Catalog: Publish\",\n    \"Catalog: Sharing\",\n    \"Catalog: View ACL\",\n    \"Catalog: View Private and Shared Catalogs\",\n    \"Catalog: View Published Catalogs\",\n    \"Certificate Library: View\",\n    \"Custom entity: View all custom entity instances in org\",\n    \"Custom entity: View custom entity instance\",\n    \"General: Administrator Control\",\n    \"General: Administrator View\",\n    \"General: Send Notification\",\n    \"Group / User: View\",\n    \"Hybrid Cloud Operations: Acquire control ticket\",\n    \"Hybrid Cloud Operations: Acquire from-the-cloud tunnel ticket\",\n    \"Hybrid Cloud Operations: Acquire to-the-cloud tunnel ticket\",\n    \"Hybrid Cloud Operations: Create from-the-cloud tunnel\",\n    \"Hybrid Cloud Operations: Create to-the-cloud tunnel\",\n    \"Hybrid Cloud Operations: Delete from-the-cloud tunnel\",\n    \"Hybrid Cloud Operations: Delete to-the-cloud tunnel\",\n    \"Hybrid Cloud Operations: Update from-the-cloud tunnel endpoint tag\",\n    \"Hybrid Cloud Operations: View from-the-cloud tunnel\",\n    \"Hybrid Cloud Operations: View to-the-cloud tunnel\",\n    \"Organization Network: Edit Properties\",\n    \"Organization Network: View\",\n    \"Organization VDC: view metrics\",\n    \"Organization vDC Compute Policy: View\",\n    \"Organization vDC Distributed Firewall: Configure Rules\",\n    \"Organization vDC Distributed Firewall: View Rules\",\n    \"Organization vDC Gateway: Configure DHCP\",\n    \"Organization vDC Gateway: Configure DNS\",\n    \"Organization vDC Gateway: Configure Firewall\",\n    \"Organization vDC Gateway: Configure IPSec VPN\",\n    \"Organization vDC Gateway: Configure Load Balancer\",\n    \"Organization vDC Gateway: Configure NAT\",\n    \"Organization vDC Gateway: Configure Static Routing\",\n    \"Organization vDC Gateway: Configure Syslog\",\n    \"Organization vDC Gateway: Convert to Advanced Networking\",\n    \"Organization vDC Gateway: View\",\n    \"Organization vDC Gateway: View DHCP\",\n    \"Organization vDC Gateway: View DNS\",\n    \"Organization vDC Gateway: View Firewall\",\n    \"Organization vDC Gateway: View IPSec VPN\",\n    \"Organization vDC Gateway: View Load Balancer\",\n    \"Organization vDC Gateway: View NAT\",\n    \"Organization vDC Gateway: View Static Routing\",\n    \"Organization vDC Named Disk: Change Owner\",\n    \"Organization vDC Named Disk: Create\",\n    \"Organization vDC Named Disk: Delete\",\n    \"Organization vDC Named Disk: Edit Properties\",\n    \"Organization vDC Named Disk: View Properties\",\n    \"Organization vDC Network: Edit Properties\",\n    \"Organization vDC Network: View Properties\",\n    \"Organization vDC Storage Profile: Set Default\",\n    \"Organization vDC: Edit\",\n    \"Organization vDC: Edit ACL\",\n    \"Organization vDC: Manage Firewall\",\n    \"Organization vDC: VM-VM Affinity Edit\",\n    \"Organization vDC: View\",\n    \"Organization vDC: View ACL\",\n    \"Organization: Edit Association Settings\",\n    \"Organization: Edit Federation Settings\",\n    \"Organization: Edit Leases Policy\",\n    \"Organization: Edit OAuth Settings\",\n    \"Organization: Edit Password Policy\",\n    \"Organization: Edit Properties\",\n    \"Organization: Edit Quotas Policy\",\n    \"Organization: Edit SMTP Settings\",\n    \"Organization: Import User/Group from IdP while Editing VDC ACL\",\n    \"Organization: View\",\n    \"Organization: view metrics\",\n    \"Quota Policy Capabilities: View\",\n    \"Role: Create, Edit, Delete, or Copy\",\n    \"SSL: Test Connection\",\n    \"Service Library: View service libraries\",\n    \"Truststore: Manage\",\n    \"Truststore: View\",\n    \"UI Plugins: View\",\n    \"VAPP_VM_METADATA_TO_VCENTER\",\n    \"VDC Template: Instantiate\",\n    \"VDC Template: View\",\n    \"vApp Template / Media: Copy\",\n    \"vApp Template / Media: Create / Upload\",\n    \"vApp Template / Media: Edit\",\n    \"vApp Template / Media: View\",\n    \"vApp Template: Change Owner\",\n    \"vApp Template: Checkout\",\n    \"vApp Template: Download\",\n    \"vApp: Change Owner\",\n    \"vApp: Copy\",\n    \"vApp: Create / Reconfigure\",\n    \"vApp: Delete\",\n    \"vApp: Download\",\n    \"vApp: Edit Properties\",\n    \"vApp: Edit VM CPU\",\n    \"vApp: Edit VM Hard Disk\",\n    \"vApp: Edit VM Memory\",\n    \"vApp: Edit VM Network\",\n    \"vApp: Edit VM Properties\",\n    \"vApp: Manage VM Password Settings\",\n    \"vApp: Power Operations\",\n    \"vApp: Sharing\",\n    \"vApp: Snapshot Operations\",\n    \"vApp: Upload\",\n    \"vApp: Use Console\",\n    \"vApp: VM Boot Options\",\n    \"vApp: View ACL\",\n    \"vApp: View VM metrics\",\n  ])\n  \"tenants\" = toset([\n    \"org1\",\n    \"org2\"\n  ])\n}\n```\n\n\n## More information\n\nSee [Roles management](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/roles_management) for a broader description of how rights bundles and\nrights work together.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRightsBundle.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the rights bundle.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRightsBundle.\n",
                "properties": {
                    "bundleKey": {
                        "description": "Key used for internationalization.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "A description of the rights bundle\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "publishToAllTenants": {
                        "description": "When true, publishes the rights bundle to all tenants\n",
                        "type": "boolean"
                    },
                    "readOnly": {
                        "description": "Whether this rights bundle is read-only\n",
                        "type": "boolean"
                    },
                    "rights": {
                        "description": "Set of rights assigned to this role\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "tenants": {
                        "description": "Set of tenants to which this rights bundle gets published. Ignored if `publish_to_all_tenants` is true.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "bundleKey",
                    "description",
                    "name",
                    "publishToAllTenants",
                    "readOnly",
                    "rights",
                    "tenants",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getRole:getRole": {
            "description": "Provides a VMware Cloud Director role data source. This can be used to read roles.\n\nSupported in provider *v3.3+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst vapp_author = vcd.getRole({\n    org: \"my-org\",\n    name: \"vApp Author\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nvapp_author = vcd.get_role(org=\"my-org\",\n    name=\"vApp Author\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vapp_author = Vcd.GetRole.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"vApp Author\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupRole(ctx, \u0026vcd.LookupRoleArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"vApp Author\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vapp-author = VcdFunctions.getRole(GetRoleArgs.builder()\n            .org(\"my-org\")\n            .name(\"vApp Author\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vapp-author:\n    fn::invoke:\n      function: vcd:getRole\n      arguments:\n        org: my-org\n        name: vApp Author\n```\n\u003c!--End PulumiCodeChooser --\u003e\n```\nSample output:\n\nvapp-author = {\n  \"bundle_key\" = \"ROLE_VAPP_AUTHOR\"\n  \"description\" = \"Rights given to a user who uses catalogs and creates vApps\"\n  \"id\" = \"urn:vcloud:role:53256466-221f-3f1f-8cea-2fcfc7ab9ef7\"\n  \"name\" = \"vApp Author\"\n  \"org\" = \"datacloud\"\n  \"read_only\" = true\n  \"rights\" = toset([\n    \"Catalog: Add vApp from My Cloud\",\n    \"Catalog: View Private and Shared Catalogs\",\n    \"Organization vDC Compute Policy: View\",\n    \"Organization vDC Named Disk: Create\",\n    \"Organization vDC Named Disk: Delete\",\n    \"Organization vDC Named Disk: Edit Properties\",\n    \"Organization vDC Named Disk: View Properties\",\n    \"Organization vDC Network: View Properties\",\n    \"Organization vDC: VM-VM Affinity Edit\",\n    \"Organization: View\",\n    \"UI Plugins: View\",\n    \"VAPP_VM_METADATA_TO_VCENTER\",\n    \"vApp Template / Media: Copy\",\n    \"vApp Template / Media: Edit\",\n    \"vApp Template / Media: View\",\n    \"vApp Template: Checkout\",\n    \"vApp: Copy\",\n    \"vApp: Create / Reconfigure\",\n    \"vApp: Delete\",\n    \"vApp: Download\",\n    \"vApp: Edit Properties\",\n    \"vApp: Edit VM CPU\",\n    \"vApp: Edit VM Hard Disk\",\n    \"vApp: Edit VM Memory\",\n    \"vApp: Edit VM Network\",\n    \"vApp: Edit VM Properties\",\n    \"vApp: Manage VM Password Settings\",\n    \"vApp: Power Operations\",\n    \"vApp: Sharing\",\n    \"vApp: Snapshot Operations\",\n    \"vApp: Upload\",\n    \"vApp: Use Console\",\n    \"vApp: VM Boot Options\",\n    \"vApp: View ACL\",\n    \"vApp: View VM metrics\",\n  ])\n}\n```\n\n\n## More information\n\nSee [Roles management](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/roles_management) for a broader description of how roles and\nrights work together.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "bundleKey": {
                        "description": "Key used for internationalization.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "A description of the role\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "readOnly": {
                        "description": "Whether this role is read-only\n",
                        "type": "boolean"
                    },
                    "rights": {
                        "description": "Set of rights assigned to this role\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "bundleKey",
                    "description",
                    "name",
                    "readOnly",
                    "rights",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getServiceAccount:getServiceAccount": {
            "description": "Provides a data source to read VCD Service Accounts.\n\nSupported in provider *v3.10+* and VCD 10.4+.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst example = vcd.getServiceAccount({\n    org: \"my-org\",\n    name: \"my-parent-network\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexample = vcd.get_service_account(org=\"my-org\",\n    name=\"my-parent-network\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Vcd.GetServiceAccount.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"my-parent-network\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupServiceAccount(ctx, \u0026vcd.LookupServiceAccountArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"my-parent-network\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetServiceAccountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = VcdFunctions.getServiceAccount(GetServiceAccountArgs.builder()\n            .org(\"my-org\")\n            .name(\"my-parent-network\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: vcd:getServiceAccount\n      arguments:\n        org: my-org\n        name: my-parent-network\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServiceAccount.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the Service Account in an organisation\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful\nwhen connected as sysadmin working across different organisations.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServiceAccount.\n",
                "properties": {
                    "active": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string"
                    },
                    "softwareId": {
                        "type": "string"
                    },
                    "softwareVersion": {
                        "type": "string"
                    },
                    "uri": {
                        "type": "string"
                    }
                },
                "required": [
                    "active",
                    "name",
                    "roleId",
                    "softwareId",
                    "softwareVersion",
                    "uri",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getSolutionAddOn:getSolutionAddOn": {
            "description": "Supported in provider *v3.13+* and VCD 10.4.1+.\n\nProvides a data source to read Solution Add-Ons in Cloud Director. A Solution Add-On is the\nrepresentation of a solution that is custom built for Cloud Director in the Cloud\nDirector extensibility ecosystem. A Solution Add-On can encapsulate UI and API Cloud Director\nextensions together with their backend services and lifecycle management. Solution dd-ns are\ndistributed as .iso files. A Solution Add-On can contain numerous elements: UI plugins, vApps,\nusers, roles, runtime defined entities, and more.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst dse14 = vcd.getSolutionAddOn({\n    name: \"vmware.ds-1.4.0-23376809\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ndse14 = vcd.get_solution_add_on(name=\"vmware.ds-1.4.0-23376809\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dse14 = Vcd.GetSolutionAddOn.Invoke(new()\n    {\n        Name = \"vmware.ds-1.4.0-23376809\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupSolutionAddOn(ctx, \u0026vcd.LookupSolutionAddOnArgs{\n\t\t\tName: \"vmware.ds-1.4.0-23376809\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetSolutionAddOnArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dse14 = VcdFunctions.getSolutionAddOn(GetSolutionAddOnArgs.builder()\n            .name(\"vmware.ds-1.4.0-23376809\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  dse14:\n    fn::invoke:\n      function: vcd:getSolutionAddOn\n      arguments:\n        name: vmware.ds-1.4.0-23376809\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSolutionAddOn.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Solution Add-On name, e.g. `vmware.ds-1.4.0-23376809`. Solution Add-On\nresource [`vcd.SolutionAddOn`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/solution_add_on)\n`import` with `list@` capability can help listing available names.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSolutionAddOn.\n",
                "properties": {
                    "catalogItemId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rdeState": {
                        "type": "string"
                    }
                },
                "required": [
                    "catalogItemId",
                    "name",
                    "rdeState",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getSolutionAddOnInstance:getSolutionAddOnInstance": {
            "description": "Supported in provider *v3.13+* and VCD 10.4.1+.\n\nProvides a data source to read Solution Add-On Instances in Cloud Director. A Solution Add-On\nInstance is created from an existing Solution Add-On by supplying configuration values of that\nparticular instance.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst dse14 = vcd.getSolutionAddOnInstance({\n    name: \"MyDseInstance\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ndse14 = vcd.get_solution_add_on_instance(name=\"MyDseInstance\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dse14 = Vcd.GetSolutionAddOnInstance.Invoke(new()\n    {\n        Name = \"MyDseInstance\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupSolutionAddOnInstance(ctx, \u0026vcd.LookupSolutionAddOnInstanceArgs{\n\t\t\tName: \"MyDseInstance\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetSolutionAddOnInstanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dse14 = VcdFunctions.getSolutionAddOnInstance(GetSolutionAddOnInstanceArgs.builder()\n            .name(\"MyDseInstance\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  dse14:\n    fn::invoke:\n      function: vcd:getSolutionAddOnInstance\n      arguments:\n        name: MyDseInstance\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSolutionAddOnInstance.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSolutionAddOnInstance.\n",
                "properties": {
                    "addOnId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "input": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rdeState": {
                        "type": "string"
                    }
                },
                "required": [
                    "addOnId",
                    "input",
                    "name",
                    "rdeState",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getSolutionAddOnInstancePublish:getSolutionAddOnInstancePublish": {
            "description": "Supported in provider *v3.13+* and VCD 10.4.1+.\n\nProvides a data source to read publishing configuration of Solution Add-On Instances in Cloud Director.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst _public = vcd.getSolutionAddOnInstancePublish({\n    addOnInstanceName: \"MyDseInstanceName\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\npublic = vcd.get_solution_add_on_instance_publish(add_on_instance_name=\"MyDseInstanceName\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @public = Vcd.GetSolutionAddOnInstancePublish.Invoke(new()\n    {\n        AddOnInstanceName = \"MyDseInstanceName\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupSolutionAddOnInstancePublish(ctx, \u0026vcd.LookupSolutionAddOnInstancePublishArgs{\n\t\t\tAddOnInstanceName: \"MyDseInstanceName\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetSolutionAddOnInstancePublishArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var public = VcdFunctions.getSolutionAddOnInstancePublish(GetSolutionAddOnInstancePublishArgs.builder()\n            .addOnInstanceName(\"MyDseInstanceName\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  public:\n    fn::invoke:\n      function: vcd:getSolutionAddOnInstancePublish\n      arguments:\n        addOnInstanceName: MyDseInstanceName\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSolutionAddOnInstancePublish.\n",
                "properties": {
                    "addOnInstanceName": {
                        "type": "string",
                        "description": "The name of Solution Add-On Instance\n"
                    }
                },
                "type": "object",
                "required": [
                    "addOnInstanceName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSolutionAddOnInstancePublish.\n",
                "properties": {
                    "addOnInstanceId": {
                        "type": "string"
                    },
                    "addOnInstanceName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orgIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "publishToAllTenants": {
                        "type": "boolean"
                    },
                    "rdeState": {
                        "type": "string"
                    }
                },
                "required": [
                    "addOnInstanceId",
                    "addOnInstanceName",
                    "orgIds",
                    "publishToAllTenants",
                    "rdeState",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getSolutionLandingZone:getSolutionLandingZone": {
            "description": "Supported in provider *v3.13+* and VCD 10.4.1+.\n\nProvides a data source to read VCD Solution Add-on Landing Zone.\n\n\u003e Only `System Administrator` can read this configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst slz = vcd.getSolutionLandingZone({});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nslz = vcd.get_solution_landing_zone()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var slz = Vcd.GetSolutionLandingZone.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupSolutionLandingZone(ctx, \u0026vcd.LookupSolutionLandingZoneArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetSolutionLandingZoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var slz = VcdFunctions.getSolutionLandingZone();\n\n    }\n}\n```\n```yaml\nvariables:\n  slz:\n    fn::invoke:\n      function: vcd:getSolutionLandingZone\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSolutionLandingZone.\n",
                "properties": {
                    "org": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getSolutionLandingZone.\n",
                "properties": {
                    "catalogs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getSolutionLandingZoneCatalog:getSolutionLandingZoneCatalog"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    },
                    "vdcs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getSolutionLandingZoneVdc:getSolutionLandingZoneVdc"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "catalogs",
                    "state",
                    "vdcs",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getStorageProfile:getStorageProfile": {
            "description": "Provides a data source for VDC storage profile.\n\nSupported in provider *v3.1+*\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst sp = vcd.getStorageProfile({\n    org: \"my-org\",\n    vdc: \"my-vdc\",\n    name: \"ssd-storage-profile\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsp = vcd.get_storage_profile(org=\"my-org\",\n    vdc=\"my-vdc\",\n    name=\"ssd-storage-profile\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sp = Vcd.GetStorageProfile.Invoke(new()\n    {\n        Org = \"my-org\",\n        Vdc = \"my-vdc\",\n        Name = \"ssd-storage-profile\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetStorageProfile(ctx, \u0026vcd.GetStorageProfileArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tVdc:  pulumi.StringRef(\"my-vdc\"),\n\t\t\tName: \"ssd-storage-profile\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetStorageProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var sp = VcdFunctions.getStorageProfile(GetStorageProfileArgs.builder()\n            .org(\"my-org\")\n            .vdc(\"my-vdc\")\n            .name(\"ssd-storage-profile\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  sp:\n    fn::invoke:\n      function: vcd:getStorageProfile\n      arguments:\n        org: my-org\n        vdc: my-vdc\n        name: ssd-storage-profile\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## IOPS settings\n\n(Supported from VCD *v10.2*)\n\n* `iops_limiting_enabled` - True if this storage profile is IOPS-based placement enabled\n* `maximum_disk_iops` - The maximum IOPS value that this storage profile is permitted to deliver. Value of 0 means this max setting is disabled and there is no max disk IOPS restriction\n* `default_disk_iops` - Value of 0 for disk IOPS means that no IOPS would be reserved or provisioned for that virtual disk\n* `disk_iops_per_gb_max` - The maximum disk IOPs per GB value that this storage profile is permitted to deliver. A value of 0 means there is no per GB IOPS restriction\n* `iops_limit` - Maximum number of IOPs that can be allocated for this profile. `0` means `maximum possible`\n",
            "inputs": {
                "description": "A collection of arguments for invoking getStorageProfile.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Storage profile name.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations.\n",
                        "willReplaceOnChanges": true
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStorageProfile.\n",
                "properties": {
                    "default": {
                        "description": "True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified\n",
                        "type": "boolean"
                    },
                    "enabled": {
                        "description": "True if this storage profile is enabled for use in the VDC\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "iopsAllocated": {
                        "description": "Total IOPS currently allocated to this storage profile\n",
                        "type": "integer"
                    },
                    "iopsSettings": {
                        "description": "A block providing IOPS settings. See IOPS settings below for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getStorageProfileIopsSetting:getStorageProfileIopsSetting"
                        },
                        "type": "array"
                    },
                    "limit": {
                        "description": "Maximum number of storage bytes (scaled by 'units' field) allocated for this profile. `0` means `maximum possible`\n",
                        "type": "integer"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getStorageProfileMetadataEntry:getStorageProfileMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "units": {
                        "description": "Scale used to define Limit\n",
                        "type": "string"
                    },
                    "usedStorage": {
                        "description": "Storage used, by the storage profile (in Megabytes)\n",
                        "type": "integer"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "default",
                    "enabled",
                    "iopsAllocated",
                    "iopsSettings",
                    "limit",
                    "metadata",
                    "metadataEntries",
                    "name",
                    "units",
                    "usedStorage",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getSubscribedCatalog:getSubscribedCatalog": {
            "description": "Provides a VMware Cloud Director subscribed catalog resource. This can be used to read a subscribed catalog.\n\nA `vcd.SubscribedCatalog` is a catalog that was created by subscribing to another catalog. It can be used, to some extent,\nlike any other catalog, but users must keep in mind that this resource depends on the connection to another catalog, which\nmay not even be in the same VCD. For more information, see the full [Catalog subscription and sharing](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/catalog_subscription_and_sharing) guide.\n\nSupported in provider *v3.8+*\n\n## Example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst subscriber = vcd.getSubscribedCatalog({\n    org: \"my-org\",\n    name: \"subscriber\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsubscriber = vcd.get_subscribed_catalog(org=\"my-org\",\n    name=\"subscriber\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var subscriber = Vcd.GetSubscribedCatalog.Invoke(new()\n    {\n        Org = \"my-org\",\n        Name = \"subscriber\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupSubscribedCatalog(ctx, \u0026vcd.LookupSubscribedCatalogArgs{\n\t\t\tOrg:  pulumi.StringRef(\"my-org\"),\n\t\t\tName: \"subscriber\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetSubscribedCatalogArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var subscriber = VcdFunctions.getSubscribedCatalog(GetSubscribedCatalogArgs.builder()\n            .org(\"my-org\")\n            .name(\"subscriber\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  subscriber:\n    fn::invoke:\n      function: vcd:getSubscribedCatalog\n      arguments:\n        org: my-org\n        name: subscriber\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Filter arguments\n\n* `name_regex` (Optional) matches the name using a regular expression.\n* `date` (Optional) is an expression starting with an operator (`\u003e`, `\u003c`, `\u003e=`, `\u003c=`, `==`), followed by a date, with\n  optional spaces in between. For example: `\u003e 2020-02-01 12:35:00.523Z`\n  The filter recognizes several formats, but one of `yyyy-mm-dd [hh:mm[:ss[.nnnZ]]]` or `dd-MMM-yyyy [hh:mm[:ss[.nnnZ]]]`\n  is recommended.\n  Comparison with equality operator (`==`) need to define the date to the microseconds.\n* `latest` (Optional) If `true`, retrieve the latest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the newest item.\n* `earliest` (Optional) If `true`, retrieve the earliest item among the ones matching other parameters. If no other parameters\n  are set, it retrieves the oldest item.\n* `metadata` (Optional) One or more parameters that will match metadata contents.\n\nSee [Filters reference](https://www.terraform.io/providers/vmware/vcd/latest/docs/guides/data_source_filters) for details and examples.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSubscribedCatalog.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/vcd:index/getSubscribedCatalogFilter:getSubscribedCatalogFilter",
                        "description": "Retrieves the data source using one or more filter parameters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Catalog name. Required if `filter` is not set.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSubscribedCatalog.\n",
                "properties": {
                    "catalogVersion": {
                        "description": "Version number from this catalog.\n",
                        "type": "integer"
                    },
                    "created": {
                        "description": "Date and time of catalog creation.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "Description of the catalog. This is inherited from the publishing catalog\n",
                        "type": "string"
                    },
                    "failedTasks": {
                        "description": "List of synchronization tasks that are have failed. They can refer to the catalog or any of its catalog items.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "filter": {
                        "$ref": "#/types/vcd:index/getSubscribedCatalogFilter:getSubscribedCatalogFilter"
                    },
                    "href": {
                        "description": "the catalog's Hyper reference.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isLocal": {
                        "description": "(*v3.8.1+*) Indicates if this catalog was created in the current organization.\n",
                        "type": "boolean"
                    },
                    "isPublished": {
                        "description": "Indicates if this catalog is available for subscription. (Always return `false` for this data source)\n",
                        "type": "boolean"
                    },
                    "isShared": {
                        "description": "Indicates if the catalog is shared (`true` or `false`).\n",
                        "type": "boolean"
                    },
                    "makeLocalCopy": {
                        "type": "boolean"
                    },
                    "mediaItemLists": {
                        "description": "List of media item names in this catalog, in alphabetical order.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "numberOfMedia": {
                        "description": "Number of media items available in this catalog.\n",
                        "type": "integer"
                    },
                    "numberOfVappTemplates": {
                        "description": "Number of vApp templates available in this catalog.\n",
                        "type": "integer"
                    },
                    "org": {
                        "type": "string"
                    },
                    "ownerName": {
                        "description": "Owner of the catalog.\n",
                        "type": "string"
                    },
                    "publishSubscriptionType": {
                        "description": "Shows if the catalog is published, if it is a subscription from another one or none of those. (Always returns `SUBSCRIBED` for this data source)\n",
                        "type": "string"
                    },
                    "runningTasks": {
                        "description": "List of running synchronization tasks that are still running. They can refer to the catalog or any of its catalog items.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "storageProfileId": {
                        "description": "Allows to set specific storage profile to be used for catalog.\n",
                        "type": "string"
                    },
                    "subscriptionUrl": {
                        "description": "The URL to which this catalog is subscribed.\n",
                        "type": "string"
                    },
                    "vappTemplateLists": {
                        "description": "List of vApp template names in this catalog, in alphabetical order.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "catalogVersion",
                    "created",
                    "description",
                    "failedTasks",
                    "href",
                    "isLocal",
                    "isPublished",
                    "isShared",
                    "makeLocalCopy",
                    "mediaItemLists",
                    "name",
                    "numberOfMedia",
                    "numberOfVappTemplates",
                    "ownerName",
                    "publishSubscriptionType",
                    "runningTasks",
                    "storageProfileId",
                    "subscriptionUrl",
                    "vappTemplateLists",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getTask:getTask": {
            "description": "Provides a data source for available tasks.\n\nSupported in provider *v3.8+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nexport = async () =\u003e {\n    const some_task = await vcd.getTask({\n        id: \"d4fdcaa9-8db4-45a9-80b8-69de49901bc7\",\n    });\n    return {\n        \"some-task\": some_task,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nsome_task = vcd.get_task(id=\"d4fdcaa9-8db4-45a9-80b8-69de49901bc7\")\npulumi.export(\"some-task\", some_task)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var some_task = Vcd.GetTask.Invoke(new()\n    {\n        Id = \"d4fdcaa9-8db4-45a9-80b8-69de49901bc7\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"some-task\"] = some_task,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsome_task, err := vcd.GetTask(ctx, \u0026vcd.GetTaskArgs{\n\t\t\tId: \"d4fdcaa9-8db4-45a9-80b8-69de49901bc7\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"some-task\", some_task)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetTaskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var some-task = VcdFunctions.getTask(GetTaskArgs.builder()\n            .id(\"d4fdcaa9-8db4-45a9-80b8-69de49901bc7\")\n            .build());\n\n        ctx.export(\"some-task\", some_task);\n    }\n}\n```\n```yaml\nvariables:\n  some-task:\n    fn::invoke:\n      function: vcd:getTask\n      arguments:\n        id: d4fdcaa9-8db4-45a9-80b8-69de49901bc7\noutputs:\n  some-task: ${[\"some-task\"]}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n```\nSample output:\n\nsome_task = {\n  \"cancel_requested\" = false\n  \"description\" = \"\"\n  \"end_time\" = \"2022-10-27T06:17:27.326Z\"\n  \"error\" = tostring(null)\n  \"expiry_time\" = \"2023-01-25T06:17:26.122Z\"\n  \"href\" = \"https://example.com/api/task/d4fdcaa9-8db4-45a9-80b8-69de49901bc7\"\n  \"id\" = \"d4fdcaa9-8db4-45a9-80b8-69de49901bc7\"\n  \"name\" = tostring(null)\n  \"operation\" = \"Created Catalog remote-subscriber(919e800b-088b-40ea-813c-5458b55829e7)\"\n  \"operation_name\" = \"catalogCreateCatalog\"\n  \"org_id\" = \"79b61f14-34f2-4b65-98cb-b5427ce57d67\"\n  \"org_name\" = \"datacloud\"\n  \"owner_id\" = \"919e800b-088b-40ea-813c-5458b55829e7\"\n  \"owner_name\" = \"remote-subscriber\"\n  \"owner_type\" = \"application/vnd.vmware.admin.catalog+xml\"\n  \"progress\" = 0\n  \"start_time\" = \"2022-10-27T06:17:26.122Z\"\n  \"status\" = \"success\"\n  \"type\" = \"application/vnd.vmware.vcloud.task+xml\"\n  \"user_id\" = \"cb5df7fb-34c4-4ce1-99e2-f0094458c486\"\n  \"user_name\" = \"administrator\"\n}\n```\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTask.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the task\n"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTask.\n",
                "properties": {
                    "cancelRequested": {
                        "description": "Whether user has requested this processing to be canceled (`true` or `false`).\n",
                        "type": "boolean"
                    },
                    "description": {
                        "description": "An optional description of the task.\n",
                        "type": "string"
                    },
                    "endTime": {
                        "description": "The date and time that processing of the task was completed. May not be present if the task is still being executed.\n",
                        "type": "string"
                    },
                    "error": {
                        "description": "error information from a failed task.\n",
                        "type": "string"
                    },
                    "expiryTime": {
                        "description": "The date and time at which the task resource will be destroyed and no longer available for retrieval. May not be present if the task has not been executed or is still being executed.\n",
                        "type": "string"
                    },
                    "href": {
                        "description": "The URI of the task.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "description": "Name of the task. May not be unique. Defines the general operation being performed.\n",
                        "type": "string"
                    },
                    "operation": {
                        "description": "A message describing the operation that is tracked by this task.\n",
                        "type": "string"
                    },
                    "operationName": {
                        "description": "The short name of the operation that is tracked by this task.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "description": "The unique identifier of the user org.\n",
                        "type": "string"
                    },
                    "orgName": {
                        "description": "The name of the org to which the user belongs.\n",
                        "type": "string"
                    },
                    "ownerId": {
                        "description": "The unique identifier of the task owner.\n",
                        "type": "string"
                    },
                    "ownerName": {
                        "description": "The name of the task owner. This is typically the object that the task is creating or updating.\n",
                        "type": "string"
                    },
                    "ownerType": {
                        "description": "The type of the task owner.\n",
                        "type": "string"
                    },
                    "progress": {
                        "description": "Indicator of task progress as an approximate percentage between 0 and 100. Not available for all tasks.\n",
                        "type": "integer"
                    },
                    "startTime": {
                        "description": "The date and time the system started executing the task. May not be present if the task has not been executed yet.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "The execution status of the task. One of queued, preRunning, running, success, error, aborted.\n",
                        "type": "string"
                    },
                    "type": {
                        "description": "Type of the task.\n",
                        "type": "string"
                    },
                    "userId": {
                        "description": "The unique identifier of the task user.\n",
                        "type": "string"
                    },
                    "userName": {
                        "description": "The name of the user who started the task.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "cancelRequested",
                    "description",
                    "endTime",
                    "error",
                    "expiryTime",
                    "href",
                    "id",
                    "name",
                    "operation",
                    "operationName",
                    "orgId",
                    "orgName",
                    "ownerId",
                    "ownerName",
                    "ownerType",
                    "progress",
                    "startTime",
                    "status",
                    "type",
                    "userId",
                    "userName"
                ],
                "type": "object"
            }
        },
        "vcd:index/getUiPlugin:getUiPlugin": {
            "description": "Provides a VMware Cloud Director UI Plugin data source. This can be used to fetch and read an existing UI Plugin.\n\n\u003e Reading UI Plugins requires System Administrator privileges.\n\nSupported in provider *v3.10+* and requires VCD 10.3+\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst existingUiPlugin = vcd.getUiPlugin({\n    vendor: \"VMware\",\n    name: \"Customize Portal\",\n    version: \"3.1.4\",\n});\nexport const license = existingUiPlugin.then(existingUiPlugin =\u003e existingUiPlugin.license);\nexport const tenants = existingUiPlugin.then(existingUiPlugin =\u003e existingUiPlugin.tenantIds);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nexisting_ui_plugin = vcd.get_ui_plugin(vendor=\"VMware\",\n    name=\"Customize Portal\",\n    version=\"3.1.4\")\npulumi.export(\"license\", existing_ui_plugin.license)\npulumi.export(\"tenants\", existing_ui_plugin.tenant_ids)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var existingUiPlugin = Vcd.GetUiPlugin.Invoke(new()\n    {\n        Vendor = \"VMware\",\n        Name = \"Customize Portal\",\n        Version = \"3.1.4\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"license\"] = existingUiPlugin.Apply(getUiPluginResult =\u003e getUiPluginResult.License),\n        [\"tenants\"] = existingUiPlugin.Apply(getUiPluginResult =\u003e getUiPluginResult.TenantIds),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texistingUiPlugin, err := vcd.LookupUiPlugin(ctx, \u0026vcd.LookupUiPluginArgs{\n\t\t\tVendor:  \"VMware\",\n\t\t\tName:    \"Customize Portal\",\n\t\t\tVersion: \"3.1.4\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"license\", existingUiPlugin.License)\n\t\tctx.Export(\"tenants\", existingUiPlugin.TenantIds)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetUiPluginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var existingUiPlugin = VcdFunctions.getUiPlugin(GetUiPluginArgs.builder()\n            .vendor(\"VMware\")\n            .name(\"Customize Portal\")\n            .version(\"3.1.4\")\n            .build());\n\n        ctx.export(\"license\", existingUiPlugin.applyValue(getUiPluginResult -\u003e getUiPluginResult.license()));\n        ctx.export(\"tenants\", existingUiPlugin.applyValue(getUiPluginResult -\u003e getUiPluginResult.tenantIds()));\n    }\n}\n```\n```yaml\nvariables:\n  existingUiPlugin:\n    fn::invoke:\n      function: vcd:getUiPlugin\n      arguments:\n        vendor: VMware\n        name: Customize Portal\n        version: 3.1.4\noutputs:\n  license: ${existingUiPlugin.license}\n  tenants: ${existingUiPlugin.tenantIds}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUiPlugin.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the UI Plugin\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "The vendor of the UI Plugin\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the UI Plugin\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vendor",
                    "version"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUiPlugin.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "license": {
                        "type": "string"
                    },
                    "link": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "providerScoped": {
                        "type": "boolean"
                    },
                    "status": {
                        "type": "string"
                    },
                    "tenantIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "tenantScoped": {
                        "type": "boolean"
                    },
                    "vendor": {
                        "type": "string"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "enabled",
                    "license",
                    "link",
                    "name",
                    "providerScoped",
                    "status",
                    "tenantIds",
                    "tenantScoped",
                    "vendor",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVapp:getVapp": {
            "description": "Provides a VMware Cloud Director vApp data source. This can be used to reference vApps.\n\nSupported in provider *v2.5+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst test_tf = vcd.getVapp({\n    name: \"test-tf\",\n    org: \"tf\",\n    vdc: \"vdc-tf\",\n});\nexport const id = test_tf.then(test_tf =\u003e test_tf.id);\nexport const name = test_tf.then(test_tf =\u003e test_tf.name);\nexport const description = test_tf.then(test_tf =\u003e test_tf.description);\nexport const href = test_tf.then(test_tf =\u003e test_tf.href);\nexport const statusText = test_tf.then(test_tf =\u003e test_tf.statusText);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntest_tf = vcd.get_vapp(name=\"test-tf\",\n    org=\"tf\",\n    vdc=\"vdc-tf\")\npulumi.export(\"id\", test_tf.id)\npulumi.export(\"name\", test_tf.name)\npulumi.export(\"description\", test_tf.description)\npulumi.export(\"href\", test_tf.href)\npulumi.export(\"statusText\", test_tf.status_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test_tf = Vcd.GetVapp.Invoke(new()\n    {\n        Name = \"test-tf\",\n        Org = \"tf\",\n        Vdc = \"vdc-tf\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"id\"] = test_tf.Apply(test_tf =\u003e test_tf.Apply(getVappResult =\u003e getVappResult.Id)),\n        [\"name\"] = test_tf.Apply(test_tf =\u003e test_tf.Apply(getVappResult =\u003e getVappResult.Name)),\n        [\"description\"] = test_tf.Apply(test_tf =\u003e test_tf.Apply(getVappResult =\u003e getVappResult.Description)),\n        [\"href\"] = test_tf.Apply(test_tf =\u003e test_tf.Apply(getVappResult =\u003e getVappResult.Href)),\n        [\"statusText\"] = test_tf.Apply(test_tf =\u003e test_tf.Apply(getVappResult =\u003e getVappResult.StatusText)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest_tf, err := vcd.LookupVapp(ctx, \u0026vcd.LookupVappArgs{\n\t\t\tName: \"test-tf\",\n\t\t\tOrg:  pulumi.StringRef(\"tf\"),\n\t\t\tVdc:  pulumi.StringRef(\"vdc-tf\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"id\", test_tf.Id)\n\t\tctx.Export(\"name\", test_tf.Name)\n\t\tctx.Export(\"description\", test_tf.Description)\n\t\tctx.Export(\"href\", test_tf.Href)\n\t\tctx.Export(\"statusText\", test_tf.StatusText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVappArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test-tf = VcdFunctions.getVapp(GetVappArgs.builder()\n            .name(\"test-tf\")\n            .org(\"tf\")\n            .vdc(\"vdc-tf\")\n            .build());\n\n        ctx.export(\"id\", test_tf.id());\n        ctx.export(\"name\", test_tf.name());\n        ctx.export(\"description\", test_tf.description());\n        ctx.export(\"href\", test_tf.href());\n        ctx.export(\"statusText\", test_tf.statusText());\n    }\n}\n```\n```yaml\nvariables:\n  test-tf:\n    fn::invoke:\n      function: vcd:getVapp\n      arguments:\n        name: test-tf\n        org: tf\n        vdc: vdc-tf\noutputs:\n  id: ${[\"test-tf\"].id}\n  name: ${[\"test-tf\"].name}\n  description: ${[\"test-tf\"].description}\n  href: ${[\"test-tf\"].href}\n  statusText: ${[\"test-tf\"].statusText}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Metadata\n\nThe `metadata_entry` (*v3.8+*) is a set of metadata entries that have the following structure:\n\n* `key` - Key of this metadata entry.\n* `value` - Value of this metadata entry.\n* `type` - Type of this metadata entry. One of: `MetadataStringValue`, `MetadataNumberValue`, `MetadataDateTimeValue`, `MetadataBooleanValue`.\n* `user_access` - User access level for this metadata entry. One of: `PRIVATE` (hidden), `READONLY` (read only), `READWRITE` (read/write).\n* `is_system` - Domain for this metadata entry. true if it belongs to `SYSTEM`, false if it belongs to `GENERAL`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVapp.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "A unique name for the vApp\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVapp.\n",
                "properties": {
                    "description": {
                        "description": "An optional description for the vApp\n",
                        "type": "string"
                    },
                    "guestProperties": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key value map of vApp guest properties.\n",
                        "type": "object"
                    },
                    "href": {
                        "description": "The vApp Hyper Reference\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inheritedMetadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "(*v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides\ndetails on the origin of the vApp (e.g. `vapp.origin.id`, `vapp.origin.name`, `vapp.origin.type`).\n",
                        "type": "object"
                    },
                    "leases": {
                        "description": "(*v3.5+*) - The information about the vApp lease. It includes the following fields:\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getVappLease:getVappLease"
                        },
                        "type": "array"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "description": "(Deprecated) Use `metadata_entry` instead. Key value map of metadata assigned to this vApp. Key and value can be any string.\n",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries assigned to this vApp. See Metadata section for details.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getVappMetadataEntry:getVappMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "status": {
                        "description": "The vApp status as a numeric code\n",
                        "type": "integer"
                    },
                    "statusText": {
                        "description": "The vApp status as text.\n",
                        "type": "string"
                    },
                    "vappNetworkNames": {
                        "description": "(*3.13.0+*) A list of vApp network names included in this vApp\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vappOrgNetworkNames": {
                        "description": "(*v3.13.0+*) A list of vApp Org network names included in this vApp\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vdc": {
                        "type": "string"
                    },
                    "vmNames": {
                        "description": "(*v3.13.0+*) A list of VM names included in this vApp\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "description",
                    "guestProperties",
                    "href",
                    "inheritedMetadata",
                    "leases",
                    "metadata",
                    "metadataEntries",
                    "name",
                    "status",
                    "statusText",
                    "vappNetworkNames",
                    "vappOrgNetworkNames",
                    "vmNames",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVappNetwork:getVappNetwork": {
            "description": "Provides a VMware Cloud Director vApp network data source. This can be used to access a vApp network.\n\nSupported in provider *v2.7+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst web = vcd.getVapp({\n    name: \"web\",\n});\nconst network1 = web.then(web =\u003e vcd.getVappNetwork({\n    vappName: web.name,\n    name: \"isolated-network\",\n}));\nexport const gateway = network1.then(network1 =\u003e network1.gateway);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nweb = vcd.get_vapp(name=\"web\")\nnetwork1 = vcd.get_vapp_network(vapp_name=web.name,\n    name=\"isolated-network\")\npulumi.export(\"gateway\", network1.gateway)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var web = Vcd.GetVapp.Invoke(new()\n    {\n        Name = \"web\",\n    });\n\n    var network1 = Vcd.GetVappNetwork.Invoke(new()\n    {\n        VappName = web.Apply(getVappResult =\u003e getVappResult.Name),\n        Name = \"isolated-network\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"gateway\"] = network1.Apply(getVappNetworkResult =\u003e getVappNetworkResult.Gateway),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tweb, err := vcd.LookupVapp(ctx, \u0026vcd.LookupVappArgs{\n\t\t\tName: \"web\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork1, err := vcd.LookupVappNetwork(ctx, \u0026vcd.LookupVappNetworkArgs{\n\t\t\tVappName: web.Name,\n\t\t\tName:     \"isolated-network\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"gateway\", network1.Gateway)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVappArgs;\nimport com.pulumi.vcd.inputs.GetVappNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var web = VcdFunctions.getVapp(GetVappArgs.builder()\n            .name(\"web\")\n            .build());\n\n        final var network1 = VcdFunctions.getVappNetwork(GetVappNetworkArgs.builder()\n            .vappName(web.applyValue(getVappResult -\u003e getVappResult.name()))\n            .name(\"isolated-network\")\n            .build());\n\n        ctx.export(\"gateway\", network1.applyValue(getVappNetworkResult -\u003e getVappNetworkResult.gateway()));\n    }\n}\n```\n```yaml\nvariables:\n  web:\n    fn::invoke:\n      function: vcd:getVapp\n      arguments:\n        name: web\n  network1:\n    fn::invoke:\n      function: vcd:getVappNetwork\n      arguments:\n        vappName: ${web.name}\n        name: isolated-network\noutputs:\n  gateway: ${network1.gateway}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVappNetwork.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "A name for the vApp network, unique within the vApp\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vApp name.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vappName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappNetwork.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "dhcpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVappNetworkDhcpPool:getVappNetworkDhcpPool"
                        },
                        "type": "array"
                    },
                    "dns1": {
                        "type": "string"
                    },
                    "dns2": {
                        "type": "string"
                    },
                    "dnsSuffix": {
                        "type": "string"
                    },
                    "gateway": {
                        "type": "string"
                    },
                    "guestVlanAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "netmask": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "orgNetworkName": {
                        "type": "string"
                    },
                    "prefixLength": {
                        "type": "string"
                    },
                    "retainIpMacEnabled": {
                        "type": "boolean"
                    },
                    "staticIpPools": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVappNetworkStaticIpPool:getVappNetworkStaticIpPool"
                        },
                        "type": "array"
                    },
                    "vappName": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "dhcpPools",
                    "dns1",
                    "dns2",
                    "dnsSuffix",
                    "gateway",
                    "guestVlanAllowed",
                    "name",
                    "netmask",
                    "orgNetworkName",
                    "prefixLength",
                    "retainIpMacEnabled",
                    "staticIpPools",
                    "vappName",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVappOrgNetwork:getVappOrgNetwork": {
            "description": "Provides a data source for VMware Cloud Director Org network attached to vApp. This can be used to access vApp Org VDC network.\n\nSupported in provider *v2.7+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst web = vcd.getVapp({\n    name: \"web\",\n});\nconst network1 = web.then(web =\u003e vcd.getVappOrgNetwork({\n    vappName: web.name,\n    orgNetworkName: \"my-vapp-org-network\",\n}));\nexport const id = network1VcdVappNetwork.id;\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nweb = vcd.get_vapp(name=\"web\")\nnetwork1 = vcd.get_vapp_org_network(vapp_name=web.name,\n    org_network_name=\"my-vapp-org-network\")\npulumi.export(\"id\", network1_vcd_vapp_network[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var web = Vcd.GetVapp.Invoke(new()\n    {\n        Name = \"web\",\n    });\n\n    var network1 = Vcd.GetVappOrgNetwork.Invoke(new()\n    {\n        VappName = web.Apply(getVappResult =\u003e getVappResult.Name),\n        OrgNetworkName = \"my-vapp-org-network\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"id\"] = network1VcdVappNetwork.Id,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tweb, err := vcd.LookupVapp(ctx, \u0026vcd.LookupVappArgs{\n\t\t\tName: \"web\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupVappOrgNetwork(ctx, \u0026vcd.LookupVappOrgNetworkArgs{\n\t\t\tVappName:       web.Name,\n\t\t\tOrgNetworkName: \"my-vapp-org-network\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"id\", network1VcdVappNetwork.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVappArgs;\nimport com.pulumi.vcd.inputs.GetVappOrgNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var web = VcdFunctions.getVapp(GetVappArgs.builder()\n            .name(\"web\")\n            .build());\n\n        final var network1 = VcdFunctions.getVappOrgNetwork(GetVappOrgNetworkArgs.builder()\n            .vappName(web.applyValue(getVappResult -\u003e getVappResult.name()))\n            .orgNetworkName(\"my-vapp-org-network\")\n            .build());\n\n        ctx.export(\"id\", network1VcdVappNetwork.id());\n    }\n}\n```\n```yaml\nvariables:\n  web:\n    fn::invoke:\n      function: vcd:getVapp\n      arguments:\n        name: web\n  network1:\n    fn::invoke:\n      function: vcd:getVappOrgNetwork\n      arguments:\n        vappName: ${web.name}\n        orgNetworkName: my-vapp-org-network\noutputs:\n  id: ${network1VcdVappNetwork.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVappOrgNetwork.\n",
                "properties": {
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    },
                    "orgNetworkName": {
                        "type": "string",
                        "description": "A name for the vApp Org network, unique within the vApp.\n"
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vApp name.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgNetworkName",
                    "vappName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappOrgNetwork.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isFenced": {
                        "type": "boolean"
                    },
                    "org": {
                        "type": "string"
                    },
                    "orgNetworkName": {
                        "type": "string"
                    },
                    "retainIpMacEnabled": {
                        "type": "boolean"
                    },
                    "vappName": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    }
                },
                "required": [
                    "isFenced",
                    "orgNetworkName",
                    "retainIpMacEnabled",
                    "vappName",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVappVm:getVappVm": {
            "description": "Provides a VMware Cloud Director VM data source. This can be used to access VMs within a vApp.\n\nSupported in provider *v2.6+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst web = vcd.getVapp({\n    name: \"web\",\n});\nconst web1 = web.then(web =\u003e vcd.getVappVm({\n    vappName: web.name,\n    name: \"web1\",\n}));\nexport const vmId = id;\nexport const vm = web1;\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nweb = vcd.get_vapp(name=\"web\")\nweb1 = vcd.get_vapp_vm(vapp_name=web.name,\n    name=\"web1\")\npulumi.export(\"vmId\", id)\npulumi.export(\"vm\", web1)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var web = Vcd.GetVapp.Invoke(new()\n    {\n        Name = \"web\",\n    });\n\n    var web1 = Vcd.GetVappVm.Invoke(new()\n    {\n        VappName = web.Apply(getVappResult =\u003e getVappResult.Name),\n        Name = \"web1\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"vmId\"] = id,\n        [\"vm\"] = web1,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tweb, err := vcd.LookupVapp(ctx, \u0026vcd.LookupVappArgs{\n\t\t\tName: \"web\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tweb1, err := vcd.LookupVappVm(ctx, \u0026vcd.LookupVappVmArgs{\n\t\t\tVappName: web.Name,\n\t\t\tName:     \"web1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"vmId\", id)\n\t\tctx.Export(\"vm\", web1)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVappArgs;\nimport com.pulumi.vcd.inputs.GetVappVmArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var web = VcdFunctions.getVapp(GetVappArgs.builder()\n            .name(\"web\")\n            .build());\n\n        final var web1 = VcdFunctions.getVappVm(GetVappVmArgs.builder()\n            .vappName(web.applyValue(getVappResult -\u003e getVappResult.name()))\n            .name(\"web1\")\n            .build());\n\n        ctx.export(\"vmId\", id);\n        ctx.export(\"vm\", web1.applyValue(getVappVmResult -\u003e getVappVmResult));\n    }\n}\n```\n```yaml\nvariables:\n  web:\n    fn::invoke:\n      function: vcd:getVapp\n      arguments:\n        name: web\n  web1:\n    fn::invoke:\n      function: vcd:getVappVm\n      arguments:\n        vappName: ${web.name}\n        name: web1\noutputs:\n  vmId: ${id}\n  vm: ${web1}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nSample output:\n\n```\nvm = {\n  \"computer_name\" = \"TestVM\"\n  \"cpu_cores\" = 1\n  \"cpus\" = 2\n  \"description\" = \"This OVA provides a minimal installed profile of PhotonOS. Default password for root user is changeme\"\n  \"disk\" = []\n  \"guest_properties\" = {}\n  \"href\" = \"https://my-vcd.org/api/vApp/vm-ecb449a2-0b11-494d-bbc7-6ae2f2ff9b82\"\n  \"id\" = \"urn:vcloud:vm:ecb449a2-0b11-494d-bbc7-6ae2f2ff9b82\"\n  \"memory\" = 1024\n  \"metadata\" = {\n    \"vm_metadata\" = \"VM Metadata.\"\n  }\n  \"name\" = \"vm-datacloud\"\n  \"network\" = [\n    {\n      \"ip\" = \"192.168.2.10\"\n      \"ip_allocation_mode\" = \"MANUAL\"\n      \"is_primary\" = true\n      \"mac\" = \"00:50:56:29:08:89\"\n      \"name\" = \"net-datacloud-r\"\n      \"type\" = \"org\"\n    },\n  ]\n  \"org\" = \"datacloud\"\n  \"storage_profile\" = \"*\"\n  \"vapp_name\" = \"vapp-datacloud\"\n  \"vdc\" = \"vdc-datacloud\"\n}\n```\n\n## Metadata\n\nThe `metadata_entry` (*v3.8+*) is a set of metadata entries that have the following structure:\n\n* `key` - Key of this metadata entry.\n* `value` - Value of this metadata entry.\n* `type` - Type of this metadata entry. One of: `MetadataStringValue`, `MetadataNumberValue`, `MetadataDateTimeValue`, `MetadataBooleanValue`.\n* `user_access` - User access level for this metadata entry. One of: `PRIVATE` (hidden), `READONLY` (read only), `READWRITE` (read/write).\n* `is_system` - Domain for this metadata entry. true if it belongs to `SYSTEM`, false if it belongs to `GENERAL`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVappVm.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "A name for the VM, unique within the vApp\n"
                    },
                    "networkDhcpWaitSeconds": {
                        "type": "integer",
                        "description": "Allows to wait for up to a defined amount of\nseconds before IP address is reported for NICs with `ip_allocation_mode=DHCP` setting. It\nconstantly checks if IP is reported so the time given is a maximum. VM must be powered on and\n__at least one__ of the following __must be true__:\n* VM has guest tools. It waits for IP address to be reported in vCD UI. This is a slower option, but\ndoes not require for the VM to use Edge Gateways DHCP service.\n* VM DHCP interface is connected to routed Org network and is using Edge Gateways DHCP service (not\nrelayed). It works by querying DHCP leases on edge gateway. In general it is quicker than waiting\nuntil UI reports IP addresses, but is more constrained. However this is the only option if guest\ntools are not present on the VM.\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    },
                    "placementPolicyId": {
                        "type": "string",
                        "description": "(*v3.8+*) VM placement policy ID.\n"
                    },
                    "sizingPolicyId": {
                        "type": "string",
                        "description": "(*v3.0+*, *vCD 10.0+*) VM sizing policy ID.\n"
                    },
                    "vappName": {
                        "type": "string",
                        "description": "The vApp this VM belongs to.\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "vappName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappVm.\n",
                "properties": {
                    "bootOptions": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVappVmBootOption:getVappVmBootOption"
                        },
                        "type": "array"
                    },
                    "computerName": {
                        "description": "Computer name to assign to this virtual machine.\n",
                        "type": "string"
                    },
                    "cpuCores": {
                        "description": "The number of cores per socket\n",
                        "type": "integer"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "description": "The limit (in MHz) for how much of CPU can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n",
                        "type": "integer"
                    },
                    "cpuPriority": {
                        "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload. Values can be: `LOW`, `NORMAL`, `HIGH` and `CUSTOM`\n",
                        "type": "string"
                    },
                    "cpuReservation": {
                        "description": "The amount of MHz reservation on the underlying virtualization infrastructure\n",
                        "type": "integer"
                    },
                    "cpuShares": {
                        "description": "Custom priority for the resource in MHz\n",
                        "type": "integer"
                    },
                    "cpus": {
                        "description": "The number of virtual CPUs allocated to the VM\n",
                        "type": "integer"
                    },
                    "customizations": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVappVmCustomization:getVappVmCustomization"
                        },
                        "type": "array"
                    },
                    "description": {
                        "description": "The VM description. Note: description is read only. Currently, this field has\nthe description of the OVA used to create the VM\n",
                        "type": "string"
                    },
                    "disks": {
                        "description": "Independent disk attachment configuration.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getVappVmDisk:getVappVmDisk"
                        },
                        "type": "array"
                    },
                    "exposeHardwareVirtualization": {
                        "description": "Expose hardware-assisted CPU virtualization to guest OS\n",
                        "type": "boolean"
                    },
                    "extraConfigs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVappVmExtraConfig:getVappVmExtraConfig"
                        },
                        "type": "array"
                    },
                    "firmware": {
                        "type": "string"
                    },
                    "guestProperties": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key value map of guest properties\n",
                        "type": "object"
                    },
                    "hardwareVersion": {
                        "description": "(*v2.9+*) Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.).\n",
                        "type": "string"
                    },
                    "href": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inheritedMetadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "(*v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides\ndetails on the origin of the VM (e.g. `vm.origin.id`, `vm.origin.name`, `vm.origin.type`).\n",
                        "type": "object"
                    },
                    "internalDisks": {
                        "description": "(*v2.7+*) A block providing internal disk of VM details\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getVappVmInternalDisk:getVappVmInternalDisk"
                        },
                        "type": "array"
                    },
                    "memory": {
                        "description": "The amount of RAM (in MB) allocated to the VM\n",
                        "type": "integer"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "description": "The limit (in MB) for how much of memory can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.\n",
                        "type": "integer"
                    },
                    "memoryPriority": {
                        "description": "Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload. Values can be: `LOW`, `NORMAL`, `HIGH` and `CUSTOM`\n",
                        "type": "string"
                    },
                    "memoryReservation": {
                        "description": "The amount of RAM (in MB) reservation on the underlying virtualization infrastructure\n",
                        "type": "integer"
                    },
                    "memoryShares": {
                        "description": "Custom priority for the resource in MB\n",
                        "type": "integer"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "description": "(Deprecated) Use `metadata_entry` instead. Key value map of metadata assigned to this VM\n",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "description": "A set of metadata entries assigned to this VM. See Metadata section for details\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getVappVmMetadataEntry:getVappVmMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkDhcpWaitSeconds": {
                        "type": "integer"
                    },
                    "networks": {
                        "description": "A block defining a network interface. Multiple can be used.\n",
                        "items": {
                            "$ref": "#/types/vcd:index/getVappVmNetwork:getVappVmNetwork"
                        },
                        "type": "array"
                    },
                    "org": {
                        "type": "string"
                    },
                    "osType": {
                        "description": "(*v2.9+*) Operating System type.\n",
                        "type": "string"
                    },
                    "placementPolicyId": {
                        "description": "(*v3.8+*) VM placement policy ID.\n",
                        "type": "string"
                    },
                    "securityTags": {
                        "description": "(*v3.9+*) Set of security tags assigned to this VM.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "sizingPolicyId": {
                        "description": "(*v3.0+*, *vCD 10.0+*) VM sizing policy ID.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "(*v3.8+*) The vApp status as a numeric code.\n",
                        "type": "integer"
                    },
                    "statusText": {
                        "description": "(*v3.8+*) The vApp status as text.\n",
                        "type": "string"
                    },
                    "storageProfile": {
                        "type": "string"
                    },
                    "vappId": {
                        "type": "string"
                    },
                    "vappName": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    },
                    "vmType": {
                        "description": "(*3.2+*) - type of the VM (either `vcd.VappVm` or `vcd.Vm`)\n",
                        "type": "string"
                    }
                },
                "required": [
                    "bootOptions",
                    "computerName",
                    "cpuCores",
                    "cpuHotAddEnabled",
                    "cpuLimit",
                    "cpuPriority",
                    "cpuReservation",
                    "cpuShares",
                    "cpus",
                    "customizations",
                    "description",
                    "disks",
                    "exposeHardwareVirtualization",
                    "extraConfigs",
                    "firmware",
                    "guestProperties",
                    "hardwareVersion",
                    "href",
                    "inheritedMetadata",
                    "internalDisks",
                    "memory",
                    "memoryHotAddEnabled",
                    "memoryLimit",
                    "memoryPriority",
                    "memoryReservation",
                    "memoryShares",
                    "metadata",
                    "metadataEntries",
                    "name",
                    "networks",
                    "osType",
                    "placementPolicyId",
                    "securityTags",
                    "sizingPolicyId",
                    "status",
                    "statusText",
                    "storageProfile",
                    "vappId",
                    "vappName",
                    "vmType",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVcenter:getVcenter": {
            "description": "Provides a data source for vCenter server attached to VCD.\n\nSupported in provider *v3.0+*\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst vc = vcd.getVcenter({\n    name: \"vcenter-one\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nvc = vcd.get_vcenter(name=\"vcenter-one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vc = Vcd.GetVcenter.Invoke(new()\n    {\n        Name = \"vcenter-one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.GetVcenter(ctx, \u0026vcd.GetVcenterArgs{\n\t\t\tName: \"vcenter-one\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVcenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vc = VcdFunctions.getVcenter(GetVcenterArgs.builder()\n            .name(\"vcenter-one\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vc:\n    fn::invoke:\n      function: vcd:getVcenter\n      arguments:\n        name: vcenter-one\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVcenter.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "vCenter name\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVcenter.\n",
                "properties": {
                    "connectionStatus": {
                        "description": "vCenter connection status (e.g. `CONNECTED`).\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isEnabled": {
                        "description": "Boolean value if vCenter is enabled.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "status": {
                        "description": "vCenter status (e.g. `READY`).\n",
                        "type": "string"
                    },
                    "vcenterHost": {
                        "description": "Hostname of configured vCenter.\n",
                        "type": "string"
                    },
                    "vcenterVersion": {
                        "description": "vCenter version (e.g. `6.7.0`)\n",
                        "type": "string"
                    }
                },
                "required": [
                    "connectionStatus",
                    "isEnabled",
                    "name",
                    "status",
                    "vcenterHost",
                    "vcenterVersion",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVdcGroup:getVdcGroup": {
            "description": "Supported in provider *v3.5+* and VCD 10.2+.\n\nProvides a data source to read NSX-T VDC group and reference in other resources.\n\n\u003e Only `System Administrator` and `Org Users` with right `View VDC Group` can access VDC groups using this data source.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst startVdc = vcd.getVdcGroup({\n    org: \"myOrg\",\n    name: \"myVDC\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nstart_vdc = vcd.get_vdc_group(org=\"myOrg\",\n    name=\"myVDC\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var startVdc = Vcd.GetVdcGroup.Invoke(new()\n    {\n        Org = \"myOrg\",\n        Name = \"myVDC\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupVdcGroup(ctx, \u0026vcd.LookupVdcGroupArgs{\n\t\t\tOrg:  pulumi.StringRef(\"myOrg\"),\n\t\t\tName: pulumi.StringRef(\"myVDC\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVdcGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var startVdc = VcdFunctions.getVdcGroup(GetVdcGroupArgs.builder()\n            .org(\"myOrg\")\n            .name(\"myVDC\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  startVdc:\n    fn::invoke:\n      function: vcd:getVdcGroup\n      arguments:\n        org: myOrg\n        name: myVDC\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVdcGroup.\n",
                "properties": {
                    "defaultPolicyStatus": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "errorMessage": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of VDC group\n\nEither `name` or `id` must be used. If both are missing, an error arises.\n",
                        "willReplaceOnChanges": true
                    },
                    "localEgress": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of VDC group\n",
                        "willReplaceOnChanges": true
                    },
                    "networkPoolId": {
                        "type": "string"
                    },
                    "networkPoolUniversalId": {
                        "type": "string"
                    },
                    "networkProviderType": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "universalNetworkingEnabled": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getVdcGroup.\n",
                "properties": {
                    "defaultPolicyStatus": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "dfwEnabled": {
                        "type": "boolean"
                    },
                    "errorMessage": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "localEgress": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkPoolId": {
                        "type": "string"
                    },
                    "networkPoolUniversalId": {
                        "type": "string"
                    },
                    "networkProviderType": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "participatingOrgVdcs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVdcGroupParticipatingOrgVdc:getVdcGroupParticipatingOrgVdc"
                        },
                        "type": "array"
                    },
                    "status": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "universalNetworkingEnabled": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "defaultPolicyStatus",
                    "description",
                    "dfwEnabled",
                    "errorMessage",
                    "id",
                    "localEgress",
                    "name",
                    "networkPoolId",
                    "networkPoolUniversalId",
                    "networkProviderType",
                    "participatingOrgVdcs",
                    "status",
                    "type",
                    "universalNetworkingEnabled"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVersion:getVersion": {
            "description": "Provides a VMware Cloud Director version data source to fetch the VCD version, the maximum supported API version and\nperform some optional checks with version constraints.\n\nSupported in provider *v3.12+*. Requires System Administrator privileges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\n// This data source will assert that the VCD version is exactly 10.5.1, otherwise it will fail\nconst eq1051 = vcd.getVersion({\n    condition: \"= 10.5.1\",\n    failIfNotMatch: true,\n});\n// This data source will assert that the VCD version is greater than or equal to 10.4.2, but it won't fail if it is not\nconst gte1042 = vcd.getVersion({\n    condition: \"\u003e= 10.4.2\",\n    failIfNotMatch: false,\n});\nexport const isGte1042 = gte1042.then(gte1042 =\u003e gte1042.matchesCondition);\n// This data source will assert that the VCD version is less than 10.5.0\nconst lt1050 = vcd.getVersion({\n    condition: \"\u003c 10.5.0\",\n    failIfNotMatch: true,\n});\n// This data source will assert that the VCD version is 10.5.X\nconst is105 = vcd.getVersion({\n    condition: \"~\u003e 10.5\",\n    failIfNotMatch: true,\n});\n// This data source will assert that the VCD version is not 10.5.1\nconst not1051 = vcd.getVersion({\n    condition: \"!= 10.5.1\",\n    failIfNotMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\n# This data source will assert that the VCD version is exactly 10.5.1, otherwise it will fail\neq1051 = vcd.get_version(condition=\"= 10.5.1\",\n    fail_if_not_match=True)\n# This data source will assert that the VCD version is greater than or equal to 10.4.2, but it won't fail if it is not\ngte1042 = vcd.get_version(condition=\"\u003e= 10.4.2\",\n    fail_if_not_match=False)\npulumi.export(\"isGte1042\", gte1042.matches_condition)\n# This data source will assert that the VCD version is less than 10.5.0\nlt1050 = vcd.get_version(condition=\"\u003c 10.5.0\",\n    fail_if_not_match=True)\n# This data source will assert that the VCD version is 10.5.X\nis105 = vcd.get_version(condition=\"~\u003e 10.5\",\n    fail_if_not_match=True)\n# This data source will assert that the VCD version is not 10.5.1\nnot1051 = vcd.get_version(condition=\"!= 10.5.1\",\n    fail_if_not_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // This data source will assert that the VCD version is exactly 10.5.1, otherwise it will fail\n    var eq1051 = Vcd.GetVersion.Invoke(new()\n    {\n        Condition = \"= 10.5.1\",\n        FailIfNotMatch = true,\n    });\n\n    // This data source will assert that the VCD version is greater than or equal to 10.4.2, but it won't fail if it is not\n    var gte1042 = Vcd.GetVersion.Invoke(new()\n    {\n        Condition = \"\u003e= 10.4.2\",\n        FailIfNotMatch = false,\n    });\n\n    // This data source will assert that the VCD version is less than 10.5.0\n    var lt1050 = Vcd.GetVersion.Invoke(new()\n    {\n        Condition = \"\u003c 10.5.0\",\n        FailIfNotMatch = true,\n    });\n\n    // This data source will assert that the VCD version is 10.5.X\n    var is105 = Vcd.GetVersion.Invoke(new()\n    {\n        Condition = \"~\u003e 10.5\",\n        FailIfNotMatch = true,\n    });\n\n    // This data source will assert that the VCD version is not 10.5.1\n    var not1051 = Vcd.GetVersion.Invoke(new()\n    {\n        Condition = \"!= 10.5.1\",\n        FailIfNotMatch = true,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"isGte1042\"] = gte1042.Apply(getVersionResult =\u003e getVersionResult.MatchesCondition),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// This data source will assert that the VCD version is exactly 10.5.1, otherwise it will fail\n\t\t_, err := vcd.GetVersion(ctx, \u0026vcd.GetVersionArgs{\n\t\t\tCondition:      pulumi.StringRef(\"= 10.5.1\"),\n\t\t\tFailIfNotMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// This data source will assert that the VCD version is greater than or equal to 10.4.2, but it won't fail if it is not\n\t\tgte1042, err := vcd.GetVersion(ctx, \u0026vcd.GetVersionArgs{\n\t\t\tCondition:      pulumi.StringRef(\"\u003e= 10.4.2\"),\n\t\t\tFailIfNotMatch: pulumi.BoolRef(false),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"isGte1042\", gte1042.MatchesCondition)\n\t\t// This data source will assert that the VCD version is less than 10.5.0\n\t\t_, err = vcd.GetVersion(ctx, \u0026vcd.GetVersionArgs{\n\t\t\tCondition:      pulumi.StringRef(\"\u003c 10.5.0\"),\n\t\t\tFailIfNotMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// This data source will assert that the VCD version is 10.5.X\n\t\t_, err = vcd.GetVersion(ctx, \u0026vcd.GetVersionArgs{\n\t\t\tCondition:      pulumi.StringRef(\"~\u003e 10.5\"),\n\t\t\tFailIfNotMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// This data source will assert that the VCD version is not 10.5.1\n\t\t_, err = vcd.GetVersion(ctx, \u0026vcd.GetVersionArgs{\n\t\t\tCondition:      pulumi.StringRef(\"!= 10.5.1\"),\n\t\t\tFailIfNotMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVersionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // This data source will assert that the VCD version is exactly 10.5.1, otherwise it will fail\n        final var eq1051 = VcdFunctions.getVersion(GetVersionArgs.builder()\n            .condition(\"= 10.5.1\")\n            .failIfNotMatch(true)\n            .build());\n\n        // This data source will assert that the VCD version is greater than or equal to 10.4.2, but it won't fail if it is not\n        final var gte1042 = VcdFunctions.getVersion(GetVersionArgs.builder()\n            .condition(\"\u003e= 10.4.2\")\n            .failIfNotMatch(false)\n            .build());\n\n        ctx.export(\"isGte1042\", gte1042.applyValue(getVersionResult -\u003e getVersionResult.matchesCondition()));\n        // This data source will assert that the VCD version is less than 10.5.0\n        final var lt1050 = VcdFunctions.getVersion(GetVersionArgs.builder()\n            .condition(\"\u003c 10.5.0\")\n            .failIfNotMatch(true)\n            .build());\n\n        // This data source will assert that the VCD version is 10.5.X\n        final var is105 = VcdFunctions.getVersion(GetVersionArgs.builder()\n            .condition(\"~\u003e 10.5\")\n            .failIfNotMatch(true)\n            .build());\n\n        // This data source will assert that the VCD version is not 10.5.1\n        final var not1051 = VcdFunctions.getVersion(GetVersionArgs.builder()\n            .condition(\"!= 10.5.1\")\n            .failIfNotMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  # This data source will assert that the VCD version is exactly 10.5.1, otherwise it will fail\n  eq1051:\n    fn::invoke:\n      function: vcd:getVersion\n      arguments:\n        condition: = 10.5.1\n        failIfNotMatch: true\n  # This data source will assert that the VCD version is greater than or equal to 10.4.2, but it won't fail if it is not\n  gte1042:\n    fn::invoke:\n      function: vcd:getVersion\n      arguments:\n        condition: '\u003e= 10.4.2'\n        failIfNotMatch: false\n  # This data source will assert that the VCD version is less than 10.5.0\n  lt1050:\n    fn::invoke:\n      function: vcd:getVersion\n      arguments:\n        condition: \u003c 10.5.0\n        failIfNotMatch: true\n  # This data source will assert that the VCD version is 10.5.X\n  is105:\n    fn::invoke:\n      function: vcd:getVersion\n      arguments:\n        condition: ~\u003e 10.5\n        failIfNotMatch: true\n  # This data source will assert that the VCD version is not 10.5.1\n  not1051:\n    fn::invoke:\n      function: vcd:getVersion\n      arguments:\n        condition: '!= 10.5.1'\n        failIfNotMatch: true\noutputs:\n  isGte1042: ${gte1042.matchesCondition}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVersion.\n",
                "properties": {
                    "condition": {
                        "type": "string",
                        "description": "A version constraint to check against the VCD version\n"
                    },
                    "failIfNotMatch": {
                        "type": "boolean",
                        "description": "Required if `condition` is set. Throws an error if the version constraint set in `condition` is not met\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getVersion.\n",
                "properties": {
                    "apiVersion": {
                        "description": "The maximum supported API version\n",
                        "type": "string"
                    },
                    "condition": {
                        "type": "string"
                    },
                    "failIfNotMatch": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "matchesCondition": {
                        "description": "It is true if the VCD version matches the constraint set in `condition`\n",
                        "type": "boolean"
                    },
                    "vcdVersion": {
                        "description": "The VCD version\n",
                        "type": "string"
                    }
                },
                "required": [
                    "apiVersion",
                    "matchesCondition",
                    "vcdVersion",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVgpuProfile:getVgpuProfile": {
            "description": "Supported in provider *3.11* and VCD *10.4.0+*.\n\n\u003e **Note:** This data source requires system administrator privileges.\n\nProvides a datasource to read vGPU profiles in VMware Cloud Director.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst profile_name = vcd.getVgpuProfile({\n    name: \"my-profile\",\n});\nexport const profileId = profile_name.then(profile_name =\u003e profile_name.id);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nprofile_name = vcd.get_vgpu_profile(name=\"my-profile\")\npulumi.export(\"profileId\", profile_name.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var profile_name = Vcd.GetVgpuProfile.Invoke(new()\n    {\n        Name = \"my-profile\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"profileId\"] = profile_name.Apply(profile_name =\u003e profile_name.Apply(getVgpuProfileResult =\u003e getVgpuProfileResult.Id)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tprofile_name, err := vcd.GetVgpuProfile(ctx, \u0026vcd.GetVgpuProfileArgs{\n\t\t\tName: \"my-profile\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"profileId\", profile_name.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVgpuProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var profile-name = VcdFunctions.getVgpuProfile(GetVgpuProfileArgs.builder()\n            .name(\"my-profile\")\n            .build());\n\n        ctx.export(\"profileId\", profile_name.id());\n    }\n}\n```\n```yaml\nvariables:\n  profile-name:\n    fn::invoke:\n      function: vcd:getVgpuProfile\n      arguments:\n        name: my-profile\noutputs:\n  profileId: ${[\"profile-name\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVgpuProfile.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the vGPU profile.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVgpuProfile.\n",
                "properties": {
                    "id": {
                        "description": "ID of the vGPU profile.\n",
                        "type": "string"
                    },
                    "instructions": {
                        "description": "Instructions for the vGPU profile.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "tenantFacingName": {
                        "description": "Tenant facing name of the vGPU profile.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id",
                    "instructions",
                    "name",
                    "tenantFacingName"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVm:getVm": {
            "inputs": {
                "description": "A collection of arguments for invoking getVm.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "A name or ID for the standalone VM in VDC\n"
                    },
                    "networkDhcpWaitSeconds": {
                        "type": "integer"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n"
                    },
                    "placementPolicyId": {
                        "type": "string"
                    },
                    "sizingPolicyId": {
                        "type": "string"
                    },
                    "vappName": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVm.\n",
                "properties": {
                    "bootOptions": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmBootOption:getVmBootOption"
                        },
                        "type": "array"
                    },
                    "computerName": {
                        "type": "string"
                    },
                    "cpuCores": {
                        "type": "integer"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPriority": {
                        "type": "string"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShares": {
                        "type": "integer"
                    },
                    "cpus": {
                        "type": "integer"
                    },
                    "customizations": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmCustomization:getVmCustomization"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "disks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmDisk:getVmDisk"
                        },
                        "type": "array"
                    },
                    "exposeHardwareVirtualization": {
                        "type": "boolean"
                    },
                    "extraConfigs": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmExtraConfig:getVmExtraConfig"
                        },
                        "type": "array"
                    },
                    "firmware": {
                        "type": "string"
                    },
                    "guestProperties": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "hardwareVersion": {
                        "type": "string"
                    },
                    "href": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inheritedMetadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "internalDisks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmInternalDisk:getVmInternalDisk"
                        },
                        "type": "array"
                    },
                    "memory": {
                        "type": "integer"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryPriority": {
                        "type": "string"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryShares": {
                        "type": "integer"
                    },
                    "metadata": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use metadata_entry instead",
                        "type": "object"
                    },
                    "metadataEntries": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmMetadataEntry:getVmMetadataEntry"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkDhcpWaitSeconds": {
                        "type": "integer"
                    },
                    "networks": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmNetwork:getVmNetwork"
                        },
                        "type": "array"
                    },
                    "org": {
                        "type": "string"
                    },
                    "osType": {
                        "type": "string"
                    },
                    "placementPolicyId": {
                        "type": "string"
                    },
                    "securityTags": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "sizingPolicyId": {
                        "type": "string"
                    },
                    "status": {
                        "type": "integer"
                    },
                    "statusText": {
                        "type": "string"
                    },
                    "storageProfile": {
                        "type": "string"
                    },
                    "vappId": {
                        "type": "string"
                    },
                    "vappName": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    },
                    "vmType": {
                        "type": "string"
                    }
                },
                "required": [
                    "bootOptions",
                    "computerName",
                    "cpuCores",
                    "cpuHotAddEnabled",
                    "cpuLimit",
                    "cpuPriority",
                    "cpuReservation",
                    "cpuShares",
                    "cpus",
                    "customizations",
                    "description",
                    "disks",
                    "exposeHardwareVirtualization",
                    "extraConfigs",
                    "firmware",
                    "guestProperties",
                    "hardwareVersion",
                    "href",
                    "inheritedMetadata",
                    "internalDisks",
                    "memory",
                    "memoryHotAddEnabled",
                    "memoryLimit",
                    "memoryPriority",
                    "memoryReservation",
                    "memoryShares",
                    "metadata",
                    "metadataEntries",
                    "name",
                    "networks",
                    "osType",
                    "placementPolicyId",
                    "securityTags",
                    "sizingPolicyId",
                    "status",
                    "statusText",
                    "storageProfile",
                    "vappId",
                    "vappName",
                    "vmType",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVmAffinityRule:getVmAffinityRule": {
            "description": "Provides a VMware Cloud Director VM affinity rule data source. This can be\nused to read VM affinity and anti-affinity rules.\n\nSupported in provider *v2.9+*\n\n\u003e **Note:** The vCD UI defines two different entities (*Affinity Rules* and *Anti-Affinity Rules*). This data source combines both\nentities: they are differentiated by the `polarity` property (See below).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst tf_rule_by_name = vcd.getVmAffinityRule({\n    name: \"my-rule\",\n});\nconst tf_rule_by_id = vcd.getVmAffinityRule({\n    ruleId: \"eda9011c-6841-4060-9336-d2f609c110c3\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntf_rule_by_name = vcd.get_vm_affinity_rule(name=\"my-rule\")\ntf_rule_by_id = vcd.get_vm_affinity_rule(rule_id=\"eda9011c-6841-4060-9336-d2f609c110c3\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tf_rule_by_name = Vcd.GetVmAffinityRule.Invoke(new()\n    {\n        Name = \"my-rule\",\n    });\n\n    var tf_rule_by_id = Vcd.GetVmAffinityRule.Invoke(new()\n    {\n        RuleId = \"eda9011c-6841-4060-9336-d2f609c110c3\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vcd.LookupVmAffinityRule(ctx, \u0026vcd.LookupVmAffinityRuleArgs{\n\t\t\tName: pulumi.StringRef(\"my-rule\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.LookupVmAffinityRule(ctx, \u0026vcd.LookupVmAffinityRuleArgs{\n\t\t\tRuleId: pulumi.StringRef(\"eda9011c-6841-4060-9336-d2f609c110c3\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVmAffinityRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tf-rule-by-name = VcdFunctions.getVmAffinityRule(GetVmAffinityRuleArgs.builder()\n            .name(\"my-rule\")\n            .build());\n\n        final var tf-rule-by-id = VcdFunctions.getVmAffinityRule(GetVmAffinityRuleArgs.builder()\n            .ruleId(\"eda9011c-6841-4060-9336-d2f609c110c3\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  tf-rule-by-name:\n    fn::invoke:\n      function: vcd:getVmAffinityRule\n      arguments:\n        name: my-rule\n  tf-rule-by-id:\n    fn::invoke:\n      function: vcd:getVmAffinityRule\n      arguments:\n        ruleId: eda9011c-6841-4060-9336-d2f609c110c3\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmAffinityRule.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of VM affinity rule. Needed if we don't provide `rule_id`\n"
                    },
                    "org": {
                        "type": "string",
                        "description": "The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleId": {
                        "type": "string",
                        "description": "Is the ID of the affinity rule. It's the preferred way to retrieve the affinity\nrule, especially if the rule name could have duplicates\n"
                    },
                    "vdc": {
                        "type": "string",
                        "description": "The name of VDC to use, optional if defined at provider level\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getVmAffinityRule.\n",
                "properties": {
                    "enabled": {
                        "description": "True if this affinity rule is enabled.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "type": "string"
                    },
                    "polarity": {
                        "description": "One of `Affinity` or `Anti-Affinity`. This property cannot be changed. Once created, if we\nneed to change polarity, we need to remove the rule and create a new one.\n",
                        "type": "string"
                    },
                    "required": {
                        "description": "True if this affinity rule is required. When a rule is mandatory, a host failover will not \npower on the VM if doing so would violate the rule.\n",
                        "type": "boolean"
                    },
                    "ruleId": {
                        "type": "string"
                    },
                    "vdc": {
                        "type": "string"
                    },
                    "vmIds": {
                        "description": "A set of virtual machine IDs that compose this rule.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "enabled",
                    "polarity",
                    "required",
                    "vmIds",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVmGroup:getVmGroup": {
            "description": "Provides a VMware Cloud Director VM Group data source. This can be used to fetch vSphere VM Groups and create VM Placement Policies with them.\n\nSupported in provider *v3.8+*\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_vdc = vcd.getProviderVdc({\n    name: \"my-pvdc\",\n});\nconst vm_group = my_vdc.then(my_vdc =\u003e vcd.getVmGroup({\n    name: \"vmware-license-group\",\n    providerVdcId: my_vdc.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_vdc = vcd.get_provider_vdc(name=\"my-pvdc\")\nvm_group = vcd.get_vm_group(name=\"vmware-license-group\",\n    provider_vdc_id=my_vdc.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_vdc = Vcd.GetProviderVdc.Invoke(new()\n    {\n        Name = \"my-pvdc\",\n    });\n\n    var vm_group = Vcd.GetVmGroup.Invoke(new()\n    {\n        Name = \"vmware-license-group\",\n        ProviderVdcId = my_vdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_vdc, err := vcd.LookupProviderVdc(ctx, \u0026vcd.LookupProviderVdcArgs{\n\t\t\tName: \"my-pvdc\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vcd.GetVmGroup(ctx, \u0026vcd.GetVmGroupArgs{\n\t\t\tName:          \"vmware-license-group\",\n\t\t\tProviderVdcId: my_vdc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetProviderVdcArgs;\nimport com.pulumi.vcd.inputs.GetVmGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-vdc = VcdFunctions.getProviderVdc(GetProviderVdcArgs.builder()\n            .name(\"my-pvdc\")\n            .build());\n\n        final var vm-group = VcdFunctions.getVmGroup(GetVmGroupArgs.builder()\n            .name(\"vmware-license-group\")\n            .providerVdcId(my_vdc.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  my-vdc:\n    fn::invoke:\n      function: vcd:getProviderVdc\n      arguments:\n        name: my-pvdc\n  vm-group:\n    fn::invoke:\n      function: vcd:getVmGroup\n      arguments:\n        name: vmware-license-group\n        providerVdcId: ${[\"my-vdc\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Attributes reference\n\n* `cluster_name` - Name of the vSphere cluster associated to this VM Group.\n* `named_vm_group_id` - ID of the named VM Group. Used to create Logical VM Groups.\n* `vcenter_id` - ID of the vCenter server.\n* `cluster_moref` - Managed object reference of the vSphere cluster associated to this VM Group.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmGroup.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of VM Group to fetch from vSphere.\n"
                    },
                    "providerVdcId": {
                        "type": "string",
                        "description": "The ID of [Provider VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc) to which the VM Group belongs.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "providerVdcId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmGroup.\n",
                "properties": {
                    "clusterMoref": {
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namedVmGroupId": {
                        "type": "string"
                    },
                    "providerVdcId": {
                        "type": "string"
                    },
                    "vcenterId": {
                        "type": "string"
                    }
                },
                "required": [
                    "clusterMoref",
                    "clusterName",
                    "name",
                    "namedVmGroupId",
                    "providerVdcId",
                    "vcenterId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVmPlacementPolicy:getVmPlacementPolicy": {
            "description": "Provides a VMware Cloud Director VM Placement Policy data source. This can be used to read a VM Placement Policy.\n\nSupported in provider *v3.8+* and requires VCD 10.2+\n\n\u003e **Note:** This resource can be used by both system administrators and tenant users.\n\n## Example Usage\n\n### System Administrators\n\nSystem administrators have full privileges to retrieve information of the Provider VDC to which the VM Placement Policy\nbelongs. The way to fetch a VM Placement Policy in this case would be:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_vdc = vcd.getOrgVdc({\n    org: \"test\",\n    name: \"vdc-test\",\n});\nconst my_pvdc = my_vdc.then(my_vdc =\u003e vcd.getProviderVdc({\n    name: my_vdc.providerVdcName,\n}));\nconst tf_policy_name = my_pvdc.then(my_pvdc =\u003e vcd.getVmPlacementPolicy({\n    name: \"my-policy\",\n    providerVdcId: my_pvdc.id,\n}));\nexport const policyId = tf_policy_name.then(tf_policy_name =\u003e tf_policy_name.id);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_vdc = vcd.get_org_vdc(org=\"test\",\n    name=\"vdc-test\")\nmy_pvdc = vcd.get_provider_vdc(name=my_vdc.provider_vdc_name)\ntf_policy_name = vcd.get_vm_placement_policy(name=\"my-policy\",\n    provider_vdc_id=my_pvdc.id)\npulumi.export(\"policyId\", tf_policy_name.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_vdc = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"test\",\n        Name = \"vdc-test\",\n    });\n\n    var my_pvdc = Vcd.GetProviderVdc.Invoke(new()\n    {\n        Name = my_vdc.Apply(getOrgVdcResult =\u003e getOrgVdcResult.ProviderVdcName),\n    });\n\n    var tf_policy_name = Vcd.GetVmPlacementPolicy.Invoke(new()\n    {\n        Name = \"my-policy\",\n        ProviderVdcId = my_pvdc.Apply(getProviderVdcResult =\u003e getProviderVdcResult.Id),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"policyId\"] = tf_policy_name.Apply(tf_policy_name =\u003e tf_policy_name.Apply(getVmPlacementPolicyResult =\u003e getVmPlacementPolicyResult.Id)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_vdc, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"test\"),\n\t\t\tName: \"vdc-test\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmy_pvdc, err := vcd.LookupProviderVdc(ctx, \u0026vcd.LookupProviderVdcArgs{\n\t\t\tName: my_vdc.ProviderVdcName,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttf_policy_name, err := vcd.LookupVmPlacementPolicy(ctx, \u0026vcd.LookupVmPlacementPolicyArgs{\n\t\t\tName:          \"my-policy\",\n\t\t\tProviderVdcId: pulumi.StringRef(my_pvdc.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policyId\", tf_policy_name.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetProviderVdcArgs;\nimport com.pulumi.vcd.inputs.GetVmPlacementPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-vdc = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"test\")\n            .name(\"vdc-test\")\n            .build());\n\n        final var my-pvdc = VcdFunctions.getProviderVdc(GetProviderVdcArgs.builder()\n            .name(my_vdc.providerVdcName())\n            .build());\n\n        final var tf-policy-name = VcdFunctions.getVmPlacementPolicy(GetVmPlacementPolicyArgs.builder()\n            .name(\"my-policy\")\n            .providerVdcId(my_pvdc.id())\n            .build());\n\n        ctx.export(\"policyId\", tf_policy_name.id());\n    }\n}\n```\n```yaml\nvariables:\n  my-vdc:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: test\n        name: vdc-test\n  my-pvdc:\n    fn::invoke:\n      function: vcd:getProviderVdc\n      arguments:\n        name: ${[\"my-vdc\"].providerVdcName}\n  tf-policy-name:\n    fn::invoke:\n      function: vcd:getVmPlacementPolicy\n      arguments:\n        name: my-policy\n        providerVdcId: ${[\"my-pvdc\"].id}\noutputs:\n  policyId: ${[\"tf-policy-name\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Tenant Users\n\nTenant users don't have access to Provider VDC information so the only way to retrieve VM Placement Policies is to\nfetch them using the VDC information. The only constraint is that the desired VM Placement Policy **must be assigned\nto the VDC**.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst my_vdc = vcd.getOrgVdc({\n    org: \"test\",\n    name: \"vdc-test\",\n});\nconst tf_policy_name = my_vdc.then(my_vdc =\u003e vcd.getVmPlacementPolicy({\n    name: \"my-policy\",\n    vdcId: my_vdc.id,\n}));\nexport const policyId = tf_policy_name.then(tf_policy_name =\u003e tf_policy_name.id);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\nmy_vdc = vcd.get_org_vdc(org=\"test\",\n    name=\"vdc-test\")\ntf_policy_name = vcd.get_vm_placement_policy(name=\"my-policy\",\n    vdc_id=my_vdc.id)\npulumi.export(\"policyId\", tf_policy_name.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_vdc = Vcd.GetOrgVdc.Invoke(new()\n    {\n        Org = \"test\",\n        Name = \"vdc-test\",\n    });\n\n    var tf_policy_name = Vcd.GetVmPlacementPolicy.Invoke(new()\n    {\n        Name = \"my-policy\",\n        VdcId = my_vdc.Apply(getOrgVdcResult =\u003e getOrgVdcResult.Id),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"policyId\"] = tf_policy_name.Apply(tf_policy_name =\u003e tf_policy_name.Apply(getVmPlacementPolicyResult =\u003e getVmPlacementPolicyResult.Id)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_vdc, err := vcd.LookupOrgVdc(ctx, \u0026vcd.LookupOrgVdcArgs{\n\t\t\tOrg:  pulumi.StringRef(\"test\"),\n\t\t\tName: \"vdc-test\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttf_policy_name, err := vcd.LookupVmPlacementPolicy(ctx, \u0026vcd.LookupVmPlacementPolicyArgs{\n\t\t\tName:  \"my-policy\",\n\t\t\tVdcId: pulumi.StringRef(my_vdc.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policyId\", tf_policy_name.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetOrgVdcArgs;\nimport com.pulumi.vcd.inputs.GetVmPlacementPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-vdc = VcdFunctions.getOrgVdc(GetOrgVdcArgs.builder()\n            .org(\"test\")\n            .name(\"vdc-test\")\n            .build());\n\n        final var tf-policy-name = VcdFunctions.getVmPlacementPolicy(GetVmPlacementPolicyArgs.builder()\n            .name(\"my-policy\")\n            .vdcId(my_vdc.id())\n            .build());\n\n        ctx.export(\"policyId\", tf_policy_name.id());\n    }\n}\n```\n```yaml\nvariables:\n  my-vdc:\n    fn::invoke:\n      function: vcd:getOrgVdc\n      arguments:\n        org: test\n        name: vdc-test\n  tf-policy-name:\n    fn::invoke:\n      function: vcd:getVmPlacementPolicy\n      arguments:\n        name: my-policy\n        vdcId: ${[\"my-vdc\"].id}\noutputs:\n  policyId: ${[\"tf-policy-name\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmPlacementPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name VM Placement Policy.\n"
                    },
                    "providerVdcId": {
                        "type": "string",
                        "description": "The ID of the [Provider VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc) to which the VM Placement Policy belongs.\n"
                    },
                    "vdcId": {
                        "type": "string",
                        "description": "The ID of the [VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/org_vdc) to which the VM Placement Policy is assigned.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmPlacementPolicy.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "logicalVmGroupIds": {
                        "description": "This attribute can't be retrieved if the data source is used by a tenant user when fetching by `vdc_id`.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "providerVdcId": {
                        "type": "string"
                    },
                    "vdcId": {
                        "type": "string"
                    },
                    "vmGroupIds": {
                        "description": "This attribute can't be retrieved if the data source is used by a tenant user when fetching by `vdc_id`.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "description",
                    "logicalVmGroupIds",
                    "name",
                    "vmGroupIds",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVmSizingPolicy:getVmSizingPolicy": {
            "description": "Provides a VMware Cloud Director VM sizing policy data source. This can be\nused to read VM sizing policy.\n\nSupported in provider *v3.0+* and requires VCD 10.0+\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst tf_policy_name = vcd.getVmSizingPolicy({\n    name: \"my-rule\",\n});\nexport const policyId = tf_policy_name.then(tf_policy_name =\u003e tf_policy_name.id);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntf_policy_name = vcd.get_vm_sizing_policy(name=\"my-rule\")\npulumi.export(\"policyId\", tf_policy_name.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tf_policy_name = Vcd.GetVmSizingPolicy.Invoke(new()\n    {\n        Name = \"my-rule\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"policyId\"] = tf_policy_name.Apply(tf_policy_name =\u003e tf_policy_name.Apply(getVmSizingPolicyResult =\u003e getVmSizingPolicyResult.Id)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttf_policy_name, err := vcd.LookupVmSizingPolicy(ctx, \u0026vcd.LookupVmSizingPolicyArgs{\n\t\t\tName: \"my-rule\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policyId\", tf_policy_name.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVmSizingPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tf-policy-name = VcdFunctions.getVmSizingPolicy(GetVmSizingPolicyArgs.builder()\n            .name(\"my-rule\")\n            .build());\n\n        ctx.export(\"policyId\", tf_policy_name.id());\n    }\n}\n```\n```yaml\nvariables:\n  tf-policy-name:\n    fn::invoke:\n      function: vcd:getVmSizingPolicy\n      arguments:\n        name: my-rule\noutputs:\n  policyId: ${[\"tf-policy-name\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmSizingPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name VM sizing policy\n\n\u003e **Note:**\nPreviously, it was incorrectly stated that the `org` argument was required. In fact, it is not, and it has been deprecated in the resource schema.\nTo preserve compatibility until the next release, though, the parameter is still parsed, but ignored.\n\nAll arguments defined in [`vcd.VmSizingPolicy`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vm_sizing_policy#argument-reference) are supported.\n"
                    },
                    "org": {
                        "type": "string",
                        "deprecationMessage": "Unneeded property, which was included by mistake"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmSizingPolicy.\n",
                "properties": {
                    "cpus": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmSizingPolicyCpus:getVmSizingPolicyCpus"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "memories": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmSizingPolicyMemory:getVmSizingPolicyMemory"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "org": {
                        "deprecationMessage": "Unneeded property, which was included by mistake",
                        "type": "string"
                    }
                },
                "required": [
                    "cpus",
                    "description",
                    "memories",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vcd:index/getVmVgpuPolicy:getVmVgpuPolicy": {
            "description": "Experimental in provider *3.11*.\n\nProvides a data source to read vGPU policies in VMware Cloud Director.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vcd from \"@pulumi/vcd\";\n\nconst tf_policy_name = vcd.getVmVgpuPolicy({\n    name: \"my-rule\",\n});\nexport const policyId = tf_policy_name.then(tf_policy_name =\u003e tf_policy_name.id);\n```\n```python\nimport pulumi\nimport pulumi_vcd as vcd\n\ntf_policy_name = vcd.get_vm_vgpu_policy(name=\"my-rule\")\npulumi.export(\"policyId\", tf_policy_name.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Vcd = Pulumi.Vcd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tf_policy_name = Vcd.GetVmVgpuPolicy.Invoke(new()\n    {\n        Name = \"my-rule\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"policyId\"] = tf_policy_name.Apply(tf_policy_name =\u003e tf_policy_name.Apply(getVmVgpuPolicyResult =\u003e getVmVgpuPolicyResult.Id)),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ergSey/pulumi-vcd/sdk/go/vcd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttf_policy_name, err := vcd.LookupVmVgpuPolicy(ctx, \u0026vcd.LookupVmVgpuPolicyArgs{\n\t\t\tName: \"my-rule\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policyId\", tf_policy_name.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vcd.VcdFunctions;\nimport com.pulumi.vcd.inputs.GetVmVgpuPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tf-policy-name = VcdFunctions.getVmVgpuPolicy(GetVmVgpuPolicyArgs.builder()\n            .name(\"my-rule\")\n            .build());\n\n        ctx.export(\"policyId\", tf_policy_name.id());\n    }\n}\n```\n```yaml\nvariables:\n  tf-policy-name:\n    fn::invoke:\n      function: vcd:getVmVgpuPolicy\n      arguments:\n        name: my-rule\noutputs:\n  policyId: ${[\"tf-policy-name\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmVgpuPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the VM vGPU policy.\n\nAll arguments defined in [`vcd.VmVgpuPolicy`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/vm_vgpu_policy#argument-reference) are supported.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmVgpuPolicy.\n",
                "properties": {
                    "cpus": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmVgpuPolicyCpus:getVmVgpuPolicyCpus"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "memories": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmVgpuPolicyMemory:getVmVgpuPolicyMemory"
                        },
                        "type": "array"
                    },
                    "name": {
                        "type": "string"
                    },
                    "providerVdcScopes": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmVgpuPolicyProviderVdcScope:getVmVgpuPolicyProviderVdcScope"
                        },
                        "type": "array"
                    },
                    "vgpuProfiles": {
                        "items": {
                            "$ref": "#/types/vcd:index/getVmVgpuPolicyVgpuProfile:getVmVgpuPolicyVgpuProfile"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "cpus",
                    "description",
                    "memories",
                    "name",
                    "providerVdcScopes",
                    "vgpuProfiles",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}