// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Vcd
{
    [VcdResourceType("vcd:index/cseKubernetesCluster:CseKubernetesCluster")]
    public partial class CseKubernetesCluster : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Must be a file generated by [`vcd.ApiToken` resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_token),
        /// or a file that follows the same formatting, that stores the API token used to create and manage the cluster,
        /// owned by the user specified in `owner`. Be careful about this file, as it contains sensitive information
        /// </summary>
        [Output("apiTokenFile")]
        public Output<string?> ApiTokenFile { get; private set; } = null!;

        /// <summary>
        /// If errors occur before the Kubernetes cluster becomes available, and this argument is `true`,
        /// CSE Server will automatically attempt to repair the cluster. Defaults to `false`.
        /// Since CSE 4.1.1, when the cluster is available/provisioned, this flag is set automatically to false.
        /// </summary>
        [Output("autoRepairOnErrors")]
        public Output<bool> AutoRepairOnErrors { get; private set; } = null!;

        /// <summary>
        /// The version of CAPVCD used by this cluster
        /// </summary>
        [Output("capvcdVersion")]
        public Output<string> CapvcdVersion { get; private set; } = null!;

        /// <summary>
        /// The cluster resource set bindings of this cluster
        /// </summary>
        [Output("clusterResourceSetBindings")]
        public Output<ImmutableArray<string>> ClusterResourceSetBindings { get; private set; } = null!;

        /// <summary>
        /// See **Control Plane**
        /// </summary>
        [Output("controlPlane")]
        public Output<Outputs.CseKubernetesClusterControlPlane> ControlPlane { get; private set; } = null!;

        /// <summary>
        /// The version of the Cloud Provider Interface used by this cluster
        /// </summary>
        [Output("cpiVersion")]
        public Output<string> CpiVersion { get; private set; } = null!;

        /// <summary>
        /// Specifies the CSE version to use. Accepted versions: `4.1.0`, `4.1.1` (also for *4.1.1a*),
        /// `4.2.0`, `4.2.1`, `4.2.2` (VCD Provider *v3.14.1+*) and `4.2.3` (VCD Provider *v3.14.1+*)
        /// </summary>
        [Output("cseVersion")]
        public Output<string> CseVersion { get; private set; } = null!;

        /// <summary>
        /// The version of the Container Storage Interface used by this cluster
        /// </summary>
        [Output("csiVersion")]
        public Output<string> CsiVersion { get; private set; } = null!;

        /// <summary>
        /// See **Default Storage Class**
        /// </summary>
        [Output("defaultStorageClass")]
        public Output<Outputs.CseKubernetesClusterDefaultStorageClass?> DefaultStorageClass { get; private set; } = null!;

        /// <summary>
        /// A set of events that happened during the Kubernetes cluster lifecycle. They're ordered from most recent to least. Each event has:
        /// </summary>
        [Output("events")]
        public Output<ImmutableArray<Outputs.CseKubernetesClusterEvent>> Events { get; private set; } = null!;

        /// <summary>
        /// The ready-to-use Kubeconfig file **contents** as a raw string. Only available when `state=provisioned`
        /// </summary>
        [Output("kubeconfig")]
        public Output<string> Kubeconfig { get; private set; } = null!;

        /// <summary>
        /// The ID of the vApp Template that corresponds to a Kubernetes template OVA
        /// </summary>
        [Output("kubernetesTemplateId")]
        public Output<string> KubernetesTemplateId { get; private set; } = null!;

        /// <summary>
        /// The version of Kubernetes installed in this cluster
        /// </summary>
        [Output("kubernetesVersion")]
        public Output<string> KubernetesVersion { get; private set; } = null!;

        /// <summary>
        /// The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        /// start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the network that the Kubernetes cluster will use
        /// </summary>
        [Output("networkId")]
        public Output<string> NetworkId { get; private set; } = null!;

        /// <summary>
        /// After the Kubernetes cluster becomes available, nodes that become unhealthy will be
        /// remediated according to unhealthy node conditions and remediation rules. Defaults to `false`
        /// </summary>
        [Output("nodeHealthCheck")]
        public Output<bool?> NodeHealthCheck { get; private set; } = null!;

        /// <summary>
        /// The time, in minutes, to wait for the cluster operations to be successfully completed. For example, during cluster
        /// creation, it should be in `provisioned`state before the timeout is reached, otherwise the operation will return an
        /// error. For cluster deletion, this timeoutspecifies the time to wait until the cluster is completely deleted. Setting
        /// this argument to `0` means to wait indefinitely
        /// </summary>
        [Output("operationsTimeoutMinutes")]
        public Output<int?> OperationsTimeoutMinutes { get; private set; } = null!;

        /// <summary>
        /// The name of organization that will host the Kubernetes cluster, optional if defined in the provider configuration
        /// </summary>
        [Output("org")]
        public Output<string?> Org { get; private set; } = null!;

        /// <summary>
        /// The user that creates the cluster and owns the API token specified in `api_token`.
        /// It must have the `Kubernetes Cluster Author` role that was created during CSE installation.
        /// If not specified, it assumes it's the user from the provider configuration
        /// 
        /// &gt; Versions 4.2.2 and 4.2.3 should not use the System administrator for the `owner` nor `api_token_file`, as stated in their
        /// [release notes](https://docs.vmware.com/en/VMware-Cloud-Director-Container-Service-Extension/4.2.2/rn/vmware-cloud-director-container-service-extension-422-release-notes/index.html#Known%20Issues),
        /// there is an existing issue that prevents the cluster to be created.
        /// </summary>
        [Output("owner")]
        public Output<string?> Owner { get; private set; } = null!;

        /// <summary>
        /// A CIDR block for the pods to use. Defaults to `100.96.0.0/11`
        /// </summary>
        [Output("podsCidr")]
        public Output<string?> PodsCidr { get; private set; } = null!;

        /// <summary>
        /// Specifies the Kubernetes runtime to use. Defaults to `tkg` (Tanzu Kubernetes Grid)
        /// </summary>
        [Output("runtime")]
        public Output<string?> Runtime { get; private set; } = null!;

        /// <summary>
        /// A CIDR block for the services to use. Defaults to `100.64.0.0/13`
        /// </summary>
        [Output("servicesCidr")]
        public Output<string?> ServicesCidr { get; private set; } = null!;

        /// <summary>
        /// The SSH public key used to log in into the cluster nodes
        /// </summary>
        [Output("sshPublicKey")]
        public Output<string?> SshPublicKey { get; private set; } = null!;

        /// <summary>
        /// The Kubernetes cluster status, can be `provisioning` when it is being created, `provisioned` when it was successfully
        /// created and ready to use, or `error` when an error occurred. `provisioning` can only be obtained when a timeout happens during
        /// cluster creation. `error` can only be obtained either with a timeout or when `auto_repair_on_errors=false`.
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        /// <summary>
        /// A set of vApp Template names that can be fetched with a
        /// [`vcd.CatalogVappTemplate` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) to upgrade the cluster.
        /// </summary>
        [Output("supportedUpgrades")]
        public Output<ImmutableArray<string>> SupportedUpgrades { get; private set; } = null!;

        /// <summary>
        /// The version of TKG installed in this cluster
        /// </summary>
        [Output("tkgProductVersion")]
        public Output<string> TkgProductVersion { get; private set; } = null!;

        /// <summary>
        /// The ID of the VDC that hosts the Kubernetes cluster
        /// </summary>
        [Output("vdcId")]
        public Output<string> VdcId { get; private set; } = null!;

        /// <summary>
        /// A virtual IP subnet for the cluster
        /// </summary>
        [Output("virtualIpSubnet")]
        public Output<string?> VirtualIpSubnet { get; private set; } = null!;

        /// <summary>
        /// See **Worker Pools**
        /// </summary>
        [Output("workerPools")]
        public Output<ImmutableArray<Outputs.CseKubernetesClusterWorkerPool>> WorkerPools { get; private set; } = null!;


        /// <summary>
        /// Create a CseKubernetesCluster resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public CseKubernetesCluster(string name, CseKubernetesClusterArgs args, CustomResourceOptions? options = null)
            : base("vcd:index/cseKubernetesCluster:CseKubernetesCluster", name, args ?? new CseKubernetesClusterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private CseKubernetesCluster(string name, Input<string> id, CseKubernetesClusterState? state = null, CustomResourceOptions? options = null)
            : base("vcd:index/cseKubernetesCluster:CseKubernetesCluster", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "https://github.com/vmware/terraform-provider-vcd/releases/download/v3.14.1/",
                AdditionalSecretOutputs =
                {
                    "kubeconfig",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing CseKubernetesCluster resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static CseKubernetesCluster Get(string name, Input<string> id, CseKubernetesClusterState? state = null, CustomResourceOptions? options = null)
        {
            return new CseKubernetesCluster(name, id, state, options);
        }
    }

    public sealed class CseKubernetesClusterArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Must be a file generated by [`vcd.ApiToken` resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_token),
        /// or a file that follows the same formatting, that stores the API token used to create and manage the cluster,
        /// owned by the user specified in `owner`. Be careful about this file, as it contains sensitive information
        /// </summary>
        [Input("apiTokenFile")]
        public Input<string>? ApiTokenFile { get; set; }

        /// <summary>
        /// If errors occur before the Kubernetes cluster becomes available, and this argument is `true`,
        /// CSE Server will automatically attempt to repair the cluster. Defaults to `false`.
        /// Since CSE 4.1.1, when the cluster is available/provisioned, this flag is set automatically to false.
        /// </summary>
        [Input("autoRepairOnErrors")]
        public Input<bool>? AutoRepairOnErrors { get; set; }

        /// <summary>
        /// See **Control Plane**
        /// </summary>
        [Input("controlPlane", required: true)]
        public Input<Inputs.CseKubernetesClusterControlPlaneArgs> ControlPlane { get; set; } = null!;

        /// <summary>
        /// Specifies the CSE version to use. Accepted versions: `4.1.0`, `4.1.1` (also for *4.1.1a*),
        /// `4.2.0`, `4.2.1`, `4.2.2` (VCD Provider *v3.14.1+*) and `4.2.3` (VCD Provider *v3.14.1+*)
        /// </summary>
        [Input("cseVersion", required: true)]
        public Input<string> CseVersion { get; set; } = null!;

        /// <summary>
        /// See **Default Storage Class**
        /// </summary>
        [Input("defaultStorageClass")]
        public Input<Inputs.CseKubernetesClusterDefaultStorageClassArgs>? DefaultStorageClass { get; set; }

        /// <summary>
        /// The ID of the vApp Template that corresponds to a Kubernetes template OVA
        /// </summary>
        [Input("kubernetesTemplateId", required: true)]
        public Input<string> KubernetesTemplateId { get; set; } = null!;

        /// <summary>
        /// The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        /// start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the network that the Kubernetes cluster will use
        /// </summary>
        [Input("networkId", required: true)]
        public Input<string> NetworkId { get; set; } = null!;

        /// <summary>
        /// After the Kubernetes cluster becomes available, nodes that become unhealthy will be
        /// remediated according to unhealthy node conditions and remediation rules. Defaults to `false`
        /// </summary>
        [Input("nodeHealthCheck")]
        public Input<bool>? NodeHealthCheck { get; set; }

        /// <summary>
        /// The time, in minutes, to wait for the cluster operations to be successfully completed. For example, during cluster
        /// creation, it should be in `provisioned`state before the timeout is reached, otherwise the operation will return an
        /// error. For cluster deletion, this timeoutspecifies the time to wait until the cluster is completely deleted. Setting
        /// this argument to `0` means to wait indefinitely
        /// </summary>
        [Input("operationsTimeoutMinutes")]
        public Input<int>? OperationsTimeoutMinutes { get; set; }

        /// <summary>
        /// The name of organization that will host the Kubernetes cluster, optional if defined in the provider configuration
        /// </summary>
        [Input("org")]
        public Input<string>? Org { get; set; }

        /// <summary>
        /// The user that creates the cluster and owns the API token specified in `api_token`.
        /// It must have the `Kubernetes Cluster Author` role that was created during CSE installation.
        /// If not specified, it assumes it's the user from the provider configuration
        /// 
        /// &gt; Versions 4.2.2 and 4.2.3 should not use the System administrator for the `owner` nor `api_token_file`, as stated in their
        /// [release notes](https://docs.vmware.com/en/VMware-Cloud-Director-Container-Service-Extension/4.2.2/rn/vmware-cloud-director-container-service-extension-422-release-notes/index.html#Known%20Issues),
        /// there is an existing issue that prevents the cluster to be created.
        /// </summary>
        [Input("owner")]
        public Input<string>? Owner { get; set; }

        /// <summary>
        /// A CIDR block for the pods to use. Defaults to `100.96.0.0/11`
        /// </summary>
        [Input("podsCidr")]
        public Input<string>? PodsCidr { get; set; }

        /// <summary>
        /// Specifies the Kubernetes runtime to use. Defaults to `tkg` (Tanzu Kubernetes Grid)
        /// </summary>
        [Input("runtime")]
        public Input<string>? Runtime { get; set; }

        /// <summary>
        /// A CIDR block for the services to use. Defaults to `100.64.0.0/13`
        /// </summary>
        [Input("servicesCidr")]
        public Input<string>? ServicesCidr { get; set; }

        /// <summary>
        /// The SSH public key used to log in into the cluster nodes
        /// </summary>
        [Input("sshPublicKey")]
        public Input<string>? SshPublicKey { get; set; }

        /// <summary>
        /// The ID of the VDC that hosts the Kubernetes cluster
        /// </summary>
        [Input("vdcId", required: true)]
        public Input<string> VdcId { get; set; } = null!;

        /// <summary>
        /// A virtual IP subnet for the cluster
        /// </summary>
        [Input("virtualIpSubnet")]
        public Input<string>? VirtualIpSubnet { get; set; }

        [Input("workerPools", required: true)]
        private InputList<Inputs.CseKubernetesClusterWorkerPoolArgs>? _workerPools;

        /// <summary>
        /// See **Worker Pools**
        /// </summary>
        public InputList<Inputs.CseKubernetesClusterWorkerPoolArgs> WorkerPools
        {
            get => _workerPools ?? (_workerPools = new InputList<Inputs.CseKubernetesClusterWorkerPoolArgs>());
            set => _workerPools = value;
        }

        public CseKubernetesClusterArgs()
        {
        }
        public static new CseKubernetesClusterArgs Empty => new CseKubernetesClusterArgs();
    }

    public sealed class CseKubernetesClusterState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Must be a file generated by [`vcd.ApiToken` resource](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/api_token),
        /// or a file that follows the same formatting, that stores the API token used to create and manage the cluster,
        /// owned by the user specified in `owner`. Be careful about this file, as it contains sensitive information
        /// </summary>
        [Input("apiTokenFile")]
        public Input<string>? ApiTokenFile { get; set; }

        /// <summary>
        /// If errors occur before the Kubernetes cluster becomes available, and this argument is `true`,
        /// CSE Server will automatically attempt to repair the cluster. Defaults to `false`.
        /// Since CSE 4.1.1, when the cluster is available/provisioned, this flag is set automatically to false.
        /// </summary>
        [Input("autoRepairOnErrors")]
        public Input<bool>? AutoRepairOnErrors { get; set; }

        /// <summary>
        /// The version of CAPVCD used by this cluster
        /// </summary>
        [Input("capvcdVersion")]
        public Input<string>? CapvcdVersion { get; set; }

        [Input("clusterResourceSetBindings")]
        private InputList<string>? _clusterResourceSetBindings;

        /// <summary>
        /// The cluster resource set bindings of this cluster
        /// </summary>
        public InputList<string> ClusterResourceSetBindings
        {
            get => _clusterResourceSetBindings ?? (_clusterResourceSetBindings = new InputList<string>());
            set => _clusterResourceSetBindings = value;
        }

        /// <summary>
        /// See **Control Plane**
        /// </summary>
        [Input("controlPlane")]
        public Input<Inputs.CseKubernetesClusterControlPlaneGetArgs>? ControlPlane { get; set; }

        /// <summary>
        /// The version of the Cloud Provider Interface used by this cluster
        /// </summary>
        [Input("cpiVersion")]
        public Input<string>? CpiVersion { get; set; }

        /// <summary>
        /// Specifies the CSE version to use. Accepted versions: `4.1.0`, `4.1.1` (also for *4.1.1a*),
        /// `4.2.0`, `4.2.1`, `4.2.2` (VCD Provider *v3.14.1+*) and `4.2.3` (VCD Provider *v3.14.1+*)
        /// </summary>
        [Input("cseVersion")]
        public Input<string>? CseVersion { get; set; }

        /// <summary>
        /// The version of the Container Storage Interface used by this cluster
        /// </summary>
        [Input("csiVersion")]
        public Input<string>? CsiVersion { get; set; }

        /// <summary>
        /// See **Default Storage Class**
        /// </summary>
        [Input("defaultStorageClass")]
        public Input<Inputs.CseKubernetesClusterDefaultStorageClassGetArgs>? DefaultStorageClass { get; set; }

        [Input("events")]
        private InputList<Inputs.CseKubernetesClusterEventGetArgs>? _events;

        /// <summary>
        /// A set of events that happened during the Kubernetes cluster lifecycle. They're ordered from most recent to least. Each event has:
        /// </summary>
        public InputList<Inputs.CseKubernetesClusterEventGetArgs> Events
        {
            get => _events ?? (_events = new InputList<Inputs.CseKubernetesClusterEventGetArgs>());
            set => _events = value;
        }

        [Input("kubeconfig")]
        private Input<string>? _kubeconfig;

        /// <summary>
        /// The ready-to-use Kubeconfig file **contents** as a raw string. Only available when `state=provisioned`
        /// </summary>
        public Input<string>? Kubeconfig
        {
            get => _kubeconfig;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _kubeconfig = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The ID of the vApp Template that corresponds to a Kubernetes template OVA
        /// </summary>
        [Input("kubernetesTemplateId")]
        public Input<string>? KubernetesTemplateId { get; set; }

        /// <summary>
        /// The version of Kubernetes installed in this cluster
        /// </summary>
        [Input("kubernetesVersion")]
        public Input<string>? KubernetesVersion { get; set; }

        /// <summary>
        /// The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        /// start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the network that the Kubernetes cluster will use
        /// </summary>
        [Input("networkId")]
        public Input<string>? NetworkId { get; set; }

        /// <summary>
        /// After the Kubernetes cluster becomes available, nodes that become unhealthy will be
        /// remediated according to unhealthy node conditions and remediation rules. Defaults to `false`
        /// </summary>
        [Input("nodeHealthCheck")]
        public Input<bool>? NodeHealthCheck { get; set; }

        /// <summary>
        /// The time, in minutes, to wait for the cluster operations to be successfully completed. For example, during cluster
        /// creation, it should be in `provisioned`state before the timeout is reached, otherwise the operation will return an
        /// error. For cluster deletion, this timeoutspecifies the time to wait until the cluster is completely deleted. Setting
        /// this argument to `0` means to wait indefinitely
        /// </summary>
        [Input("operationsTimeoutMinutes")]
        public Input<int>? OperationsTimeoutMinutes { get; set; }

        /// <summary>
        /// The name of organization that will host the Kubernetes cluster, optional if defined in the provider configuration
        /// </summary>
        [Input("org")]
        public Input<string>? Org { get; set; }

        /// <summary>
        /// The user that creates the cluster and owns the API token specified in `api_token`.
        /// It must have the `Kubernetes Cluster Author` role that was created during CSE installation.
        /// If not specified, it assumes it's the user from the provider configuration
        /// 
        /// &gt; Versions 4.2.2 and 4.2.3 should not use the System administrator for the `owner` nor `api_token_file`, as stated in their
        /// [release notes](https://docs.vmware.com/en/VMware-Cloud-Director-Container-Service-Extension/4.2.2/rn/vmware-cloud-director-container-service-extension-422-release-notes/index.html#Known%20Issues),
        /// there is an existing issue that prevents the cluster to be created.
        /// </summary>
        [Input("owner")]
        public Input<string>? Owner { get; set; }

        /// <summary>
        /// A CIDR block for the pods to use. Defaults to `100.96.0.0/11`
        /// </summary>
        [Input("podsCidr")]
        public Input<string>? PodsCidr { get; set; }

        /// <summary>
        /// Specifies the Kubernetes runtime to use. Defaults to `tkg` (Tanzu Kubernetes Grid)
        /// </summary>
        [Input("runtime")]
        public Input<string>? Runtime { get; set; }

        /// <summary>
        /// A CIDR block for the services to use. Defaults to `100.64.0.0/13`
        /// </summary>
        [Input("servicesCidr")]
        public Input<string>? ServicesCidr { get; set; }

        /// <summary>
        /// The SSH public key used to log in into the cluster nodes
        /// </summary>
        [Input("sshPublicKey")]
        public Input<string>? SshPublicKey { get; set; }

        /// <summary>
        /// The Kubernetes cluster status, can be `provisioning` when it is being created, `provisioned` when it was successfully
        /// created and ready to use, or `error` when an error occurred. `provisioning` can only be obtained when a timeout happens during
        /// cluster creation. `error` can only be obtained either with a timeout or when `auto_repair_on_errors=false`.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        [Input("supportedUpgrades")]
        private InputList<string>? _supportedUpgrades;

        /// <summary>
        /// A set of vApp Template names that can be fetched with a
        /// [`vcd.CatalogVappTemplate` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) to upgrade the cluster.
        /// </summary>
        public InputList<string> SupportedUpgrades
        {
            get => _supportedUpgrades ?? (_supportedUpgrades = new InputList<string>());
            set => _supportedUpgrades = value;
        }

        /// <summary>
        /// The version of TKG installed in this cluster
        /// </summary>
        [Input("tkgProductVersion")]
        public Input<string>? TkgProductVersion { get; set; }

        /// <summary>
        /// The ID of the VDC that hosts the Kubernetes cluster
        /// </summary>
        [Input("vdcId")]
        public Input<string>? VdcId { get; set; }

        /// <summary>
        /// A virtual IP subnet for the cluster
        /// </summary>
        [Input("virtualIpSubnet")]
        public Input<string>? VirtualIpSubnet { get; set; }

        [Input("workerPools")]
        private InputList<Inputs.CseKubernetesClusterWorkerPoolGetArgs>? _workerPools;

        /// <summary>
        /// See **Worker Pools**
        /// </summary>
        public InputList<Inputs.CseKubernetesClusterWorkerPoolGetArgs> WorkerPools
        {
            get => _workerPools ?? (_workerPools = new InputList<Inputs.CseKubernetesClusterWorkerPoolGetArgs>());
            set => _workerPools = value;
        }

        public CseKubernetesClusterState()
        {
        }
        public static new CseKubernetesClusterState Empty => new CseKubernetesClusterState();
    }
}
