// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Vcd
{
    [VcdResourceType("vcd:index/vappVm:VappVm")]
    public partial class VappVm : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Automatically accept EULA if OVA has it. Default is `true`
        /// </summary>
        [Output("acceptAllEulas")]
        public Output<bool?> AcceptAllEulas { get; private set; } = null!;

        /// <summary>
        /// Use `boot_image_id` instead. Media name to mount as boot image. Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).
        /// </summary>
        [Output("bootImage")]
        public Output<string?> BootImage { get; private set; } = null!;

        /// <summary>
        /// Media URN to mount as boot image. You can fetch it using a [`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_media) data source.
        /// Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).
        /// </summary>
        [Output("bootImageId")]
        public Output<string?> BootImageId { get; private set; } = null!;

        /// <summary>
        /// A block to define boot options of the VM. See Boot Options
        /// </summary>
        [Output("bootOptions")]
        public Output<Outputs.VappVmBootOptions> BootOptions { get; private set; } = null!;

        /// <summary>
        /// Use a [`vcd.Catalog`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog) data source along with `vapp_template_id` or `boot_image_id` instead. The catalog name in which to find the given vApp Template or media for `boot_image`.
        /// </summary>
        [Output("catalogName")]
        public Output<string?> CatalogName { get; private set; } = null!;

        /// <summary>
        /// Computer name to assign to this virtual machine.
        /// </summary>
        [Output("computerName")]
        public Output<string> ComputerName { get; private set; } = null!;

        /// <summary>
        /// Performs disk consolidation during creation.
        /// The main use case is when one wants to grow template disk size using `override_template_disk` in
        /// fast provisioned VDCs. **Note:** Consolidating disks requires right `vApp: VM Migrate, Force
        /// Undeploy, Relocate, Consolidate`. This operation _may take long time_ depending on disk size and
        /// storage performance.
        /// </summary>
        [Output("consolidateDisksOnCreate")]
        public Output<bool?> ConsolidateDisksOnCreate { get; private set; } = null!;

        /// <summary>
        /// The ID of *an existing VM* to make a copy of it (it
        /// cannot be a vApp template). The source VM *must be in the same Org* (but can be in different VDC).
        /// *Note:* `sizing_policy_id` must be specified when creating a standalone VM (using `vcd.Vm`
        /// resource) and using different source/destination VDCs.
        /// </summary>
        [Output("copyFromVmId")]
        public Output<string?> CopyFromVmId { get; private set; } = null!;

        /// <summary>
        /// The number of cores per socket.
        /// </summary>
        [Output("cpuCores")]
        public Output<int> CpuCores { get; private set; } = null!;

        /// <summary>
        /// True if the virtual machine supports addition of virtual CPUs while powered on. Default is `false`.
        /// </summary>
        [Output("cpuHotAddEnabled")]
        public Output<bool?> CpuHotAddEnabled { get; private set; } = null!;

        /// <summary>
        /// The limit (in MHz) for how much of CPU can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.
        /// </summary>
        [Output("cpuLimit")]
        public Output<int> CpuLimit { get; private set; } = null!;

        /// <summary>
        /// Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload
        /// </summary>
        [Output("cpuPriority")]
        public Output<string> CpuPriority { get; private set; } = null!;

        /// <summary>
        /// The amount of MHz reservation on the underlying virtualization infrastructure.
        /// </summary>
        [Output("cpuReservation")]
        public Output<int> CpuReservation { get; private set; } = null!;

        /// <summary>
        /// Custom priority for the resource in MHz. This is a read-only, unless the `cpu_priority` is "CUSTOM"
        /// </summary>
        [Output("cpuShares")]
        public Output<int> CpuShares { get; private set; } = null!;

        /// <summary>
        /// The number of virtual CPUs to allocate to the VM. Socket count is a result of: virtual logical processors/cores per socket. If `cpu_hot_add_enabled` is true, then cpus will be increased without VM power off.
        /// </summary>
        [Output("cpus")]
        public Output<int> Cpus { get; private set; } = null!;

        /// <summary>
        /// A block to define for guest customization options. See Customization
        /// </summary>
        [Output("customization")]
        public Output<Outputs.VappVmCustomization> Customization { get; private set; } = null!;

        /// <summary>
        /// The VM description. Note: for VM from Template `description` is read only. Currently, this field has
        /// the description of the OVA used to create the VM.
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// Independent disk attachment configuration. See Disk below for details.
        /// </summary>
        [Output("disks")]
        public Output<ImmutableArray<Outputs.VappVmDisk>> Disks { get; private set; } = null!;

        /// <summary>
        /// Boolean for exposing full CPU virtualization to the
        /// guest operating system so that applications that require hardware virtualization can run on virtual machines without binary
        /// translation or paravirtualization. Useful for hypervisor nesting provided underlying hardware supports it. Default is `false`.
        /// </summary>
        [Output("exposeHardwareVirtualization")]
        public Output<bool?> ExposeHardwareVirtualization { get; private set; } = null!;

        /// <summary>
        /// (*v3.13.+*) The VM extra configuration. See Extra Configuration for more detail. *Not populated on VCD 10.4.0*.
        /// </summary>
        [Output("extraConfigs")]
        public Output<ImmutableArray<Outputs.VappVmExtraConfig>> ExtraConfigs { get; private set; } = null!;

        /// <summary>
        /// Specify boot firmware of the VM. Can be `efi` or `bios`. If unset, defaults to `bios`. Changing the value requires the VM to power off.
        /// </summary>
        [Output("firmware")]
        public Output<string> Firmware { get; private set; } = null!;

        /// <summary>
        /// Key value map of guest properties
        /// </summary>
        [Output("guestProperties")]
        public Output<ImmutableDictionary<string, string>?> GuestProperties { get; private set; } = null!;

        /// <summary>
        /// Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.). Required when creating empty VM.
        /// </summary>
        [Output("hardwareVersion")]
        public Output<string> HardwareVersion { get; private set; } = null!;

        /// <summary>
        /// VM Hyper Reference
        /// </summary>
        [Output("href")]
        public Output<string> Href { get; private set; } = null!;

        /// <summary>
        /// (*v3.13.+*) A true/false value telling whether the resource was imported.
        /// </summary>
        [Output("imported")]
        public Output<bool> Imported { get; private set; } = null!;

        /// <summary>
        /// (*v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides
        /// details on the origin of the VM (e.g. `vm.origin.id`, `vm.origin.name`, `vm.origin.type`).
        /// </summary>
        [Output("inheritedMetadata")]
        public Output<ImmutableDictionary<string, string>> InheritedMetadata { get; private set; } = null!;

        /// <summary>
        /// (*v2.7+*) A block providing internal disk of VM details. See Internal Disk below for details.
        /// </summary>
        [Output("internalDisks")]
        public Output<ImmutableArray<Outputs.VappVmInternalDisk>> InternalDisks { get; private set; } = null!;

        /// <summary>
        /// The amount of RAM (in MB) to allocate to the VM. If `memory_hot_add_enabled` is true, then memory will be increased without VM power off
        /// </summary>
        [Output("memory")]
        public Output<int> Memory { get; private set; } = null!;

        /// <summary>
        /// True if the virtual machine supports addition of memory while powered on. Default is `false`.
        /// </summary>
        [Output("memoryHotAddEnabled")]
        public Output<bool?> MemoryHotAddEnabled { get; private set; } = null!;

        /// <summary>
        /// The limit (in MB) for how much of memory can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.
        /// </summary>
        [Output("memoryLimit")]
        public Output<int> MemoryLimit { get; private set; } = null!;

        /// <summary>
        /// Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload
        /// </summary>
        [Output("memoryPriority")]
        public Output<string> MemoryPriority { get; private set; } = null!;

        /// <summary>
        /// The amount of RAM (in MB) reservation on the underlying virtualization infrastructure
        /// </summary>
        [Output("memoryReservation")]
        public Output<int> MemoryReservation { get; private set; } = null!;

        /// <summary>
        /// Custom priority for the resource in MB. This is a read-only, unless the `memory_priority` is "CUSTOM"
        /// </summary>
        [Output("memoryShares")]
        public Output<int> MemoryShares { get; private set; } = null!;

        /// <summary>
        /// Use `metadata_entry` instead. Key value map of metadata to assign to this VM
        /// </summary>
        [Output("metadata")]
        public Output<ImmutableDictionary<string, string>> Metadata { get; private set; } = null!;

        /// <summary>
        /// A set of metadata entries to assign. See Metadata section for details.
        /// </summary>
        [Output("metadataEntries")]
        public Output<ImmutableArray<Outputs.VappVmMetadataEntry>> MetadataEntries { get; private set; } = null!;

        /// <summary>
        /// A name for the VM, unique within the vApp
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Optional number of seconds to try and wait for DHCP IP (only valid
        /// for adapters in `network` block with `ip_allocation_mode=DHCP`). It constantly checks if IP is present so the time given
        /// is a maximum. VM must be powered on and _at least one_ of the following _must be true_:
        /// * VM has Guest Tools. It waits for IP address to be reported by Guest Tools. This is a slower option, but
        /// does not require for the VM to use Edge Gateways DHCP service.
        /// * VM DHCP interface is connected to routed Org network and is using Edge Gateways DHCP service (not
        /// relayed). It works by querying DHCP leases on Edge Gateway. In general it is quicker than waiting
        /// until Guest Tools report IP addresses, but is more constrained. However this is the only option if Guest
        /// Tools are not present on the VM.
        /// </summary>
        [Output("networkDhcpWaitSeconds")]
        public Output<int?> NetworkDhcpWaitSeconds { get; private set; } = null!;

        /// <summary>
        /// A block to define network interface. Multiple can be used. See Network and 
        /// example for usage details.
        /// </summary>
        [Output("networks")]
        public Output<ImmutableArray<Outputs.VappVmNetwork>> Networks { get; private set; } = null!;

        /// <summary>
        /// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
        /// </summary>
        [Output("org")]
        public Output<string?> Org { get; private set; } = null!;

        /// <summary>
        /// Operating System type. Possible values can be found in Os Types. Required when creating empty VM.
        /// </summary>
        [Output("osType")]
        public Output<string> OsType { get; private set; } = null!;

        /// <summary>
        /// Allows to update internal disk in template before first VM boot. Disk is matched by `bus_type`, `bus_number` and `unit_number`. See Override template Disk below for details.
        /// </summary>
        [Output("overrideTemplateDisks")]
        public Output<ImmutableArray<Outputs.VappVmOverrideTemplateDisk>> OverrideTemplateDisks { get; private set; } = null!;

        /// <summary>
        /// VM placement policy or [vGPU policy][vgpu-policy] (*3.11+*) ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)
        /// In this case, if the placement policy is not set, it will pick the VDC default on creation. It must be set explicitly
        /// if one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `""` to be removed.
        /// </summary>
        [Output("placementPolicyId")]
        public Output<string> PlacementPolicyId { get; private set; } = null!;

        /// <summary>
        /// A boolean value stating if this VM should be powered on. Default is `true`
        /// </summary>
        [Output("powerOn")]
        public Output<bool?> PowerOn { get; private set; } = null!;

        /// <summary>
        /// True if the update of resource should fail when virtual machine power off needed. Default is `false`.
        /// </summary>
        [Output("preventUpdatePowerOff")]
        public Output<bool?> PreventUpdatePowerOff { get; private set; } = null!;

        /// <summary>
        /// Set of security tags to be managed by the `vcd.VappVm` resource.
        /// To remove `security_tags` you must set `security_tags = []` and do not remove the attribute. Removing the attribute will cause the tags to remain unchanged and just stop being managed by this resource.
        /// This is to be consistent with existing security tags that were created by the `vcd_security_tags` resource.
        /// </summary>
        [Output("securityTags")]
        public Output<ImmutableArray<string>> SecurityTags { get; private set; } = null!;

        /// <summary>
        /// Set of extra configuration key/values to be added or modified. See Extra Configuration
        /// 
        /// &gt; **Note:** Only one of `security_tags` attribute or [`vcd.SecurityTag`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/security_tag) resource
        /// should be used. Using both would cause a behavioral conflict.
        /// </summary>
        [Output("setExtraConfigs")]
        public Output<ImmutableArray<Outputs.VappVmSetExtraConfig>> SetExtraConfigs { get; private set; } = null!;

        /// <summary>
        /// VM sizing policy ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)
        /// using `vcd_org_vdc.vm_sizing_policy_ids` (and `vcd_org_vdc.default_compute_policy_id` to make it default).
        /// In this case, if the sizing policy is not set, it will pick the VDC default on creation. It must be set explicitly
        /// if one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `""` to be removed.
        /// </summary>
        [Output("sizingPolicyId")]
        public Output<string> SizingPolicyId { get; private set; } = null!;

        /// <summary>
        /// (*v3.8+*) The vApp status as a numeric code.
        /// </summary>
        [Output("status")]
        public Output<int> Status { get; private set; } = null!;

        /// <summary>
        /// (*v3.8+*) The vApp status as text.
        /// </summary>
        [Output("statusText")]
        public Output<string> StatusText { get; private set; } = null!;

        /// <summary>
        /// Storage profile to override the default one
        /// </summary>
        [Output("storageProfile")]
        public Output<string> StorageProfile { get; private set; } = null!;

        /// <summary>
        /// Use `vapp_template_id` instead. The name of the vApp Template to use
        /// </summary>
        [Output("templateName")]
        public Output<string?> TemplateName { get; private set; } = null!;

        /// <summary>
        /// ID of parent vApp
        /// </summary>
        [Output("vappId")]
        public Output<string> VappId { get; private set; } = null!;

        /// <summary>
        /// The vApp this VM belongs to.
        /// </summary>
        [Output("vappName")]
        public Output<string> VappName { get; private set; } = null!;

        /// <summary>
        /// The URN of the vApp Template to use. You can fetch it using a [`vcd.CatalogVappTemplate`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) data source.
        /// </summary>
        [Output("vappTemplateId")]
        public Output<string?> VappTemplateId { get; private set; } = null!;

        /// <summary>
        /// The name of VDC to use, optional if defined at provider level
        /// </summary>
        [Output("vdc")]
        public Output<string?> Vdc { get; private set; } = null!;

        /// <summary>
        /// The name of the VM in vApp Template to use. For cases when vApp template has more than one VM.
        /// </summary>
        [Output("vmNameInTemplate")]
        public Output<string?> VmNameInTemplate { get; private set; } = null!;

        /// <summary>
        /// (*3.2+*) Type of the VM (either `vcd.VappVm` or `vcd.Vm`).
        /// </summary>
        [Output("vmType")]
        public Output<string> VmType { get; private set; } = null!;


        /// <summary>
        /// Create a VappVm resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public VappVm(string name, VappVmArgs args, CustomResourceOptions? options = null)
            : base("vcd:index/vappVm:VappVm", name, args ?? new VappVmArgs(), MakeResourceOptions(options, ""))
        {
        }

        private VappVm(string name, Input<string> id, VappVmState? state = null, CustomResourceOptions? options = null)
            : base("vcd:index/vappVm:VappVm", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "https://github.com/vmware/terraform-provider-vcd/releases/download/v3.14.1/",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing VappVm resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static VappVm Get(string name, Input<string> id, VappVmState? state = null, CustomResourceOptions? options = null)
        {
            return new VappVm(name, id, state, options);
        }
    }

    public sealed class VappVmArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Automatically accept EULA if OVA has it. Default is `true`
        /// </summary>
        [Input("acceptAllEulas")]
        public Input<bool>? AcceptAllEulas { get; set; }

        /// <summary>
        /// Use `boot_image_id` instead. Media name to mount as boot image. Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).
        /// </summary>
        [Input("bootImage")]
        public Input<string>? BootImage { get; set; }

        /// <summary>
        /// Media URN to mount as boot image. You can fetch it using a [`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_media) data source.
        /// Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).
        /// </summary>
        [Input("bootImageId")]
        public Input<string>? BootImageId { get; set; }

        /// <summary>
        /// A block to define boot options of the VM. See Boot Options
        /// </summary>
        [Input("bootOptions")]
        public Input<Inputs.VappVmBootOptionsArgs>? BootOptions { get; set; }

        /// <summary>
        /// Use a [`vcd.Catalog`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog) data source along with `vapp_template_id` or `boot_image_id` instead. The catalog name in which to find the given vApp Template or media for `boot_image`.
        /// </summary>
        [Input("catalogName")]
        public Input<string>? CatalogName { get; set; }

        /// <summary>
        /// Computer name to assign to this virtual machine.
        /// </summary>
        [Input("computerName")]
        public Input<string>? ComputerName { get; set; }

        /// <summary>
        /// Performs disk consolidation during creation.
        /// The main use case is when one wants to grow template disk size using `override_template_disk` in
        /// fast provisioned VDCs. **Note:** Consolidating disks requires right `vApp: VM Migrate, Force
        /// Undeploy, Relocate, Consolidate`. This operation _may take long time_ depending on disk size and
        /// storage performance.
        /// </summary>
        [Input("consolidateDisksOnCreate")]
        public Input<bool>? ConsolidateDisksOnCreate { get; set; }

        /// <summary>
        /// The ID of *an existing VM* to make a copy of it (it
        /// cannot be a vApp template). The source VM *must be in the same Org* (but can be in different VDC).
        /// *Note:* `sizing_policy_id` must be specified when creating a standalone VM (using `vcd.Vm`
        /// resource) and using different source/destination VDCs.
        /// </summary>
        [Input("copyFromVmId")]
        public Input<string>? CopyFromVmId { get; set; }

        /// <summary>
        /// The number of cores per socket.
        /// </summary>
        [Input("cpuCores")]
        public Input<int>? CpuCores { get; set; }

        /// <summary>
        /// True if the virtual machine supports addition of virtual CPUs while powered on. Default is `false`.
        /// </summary>
        [Input("cpuHotAddEnabled")]
        public Input<bool>? CpuHotAddEnabled { get; set; }

        /// <summary>
        /// The limit (in MHz) for how much of CPU can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.
        /// </summary>
        [Input("cpuLimit")]
        public Input<int>? CpuLimit { get; set; }

        /// <summary>
        /// Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload
        /// </summary>
        [Input("cpuPriority")]
        public Input<string>? CpuPriority { get; set; }

        /// <summary>
        /// The amount of MHz reservation on the underlying virtualization infrastructure.
        /// </summary>
        [Input("cpuReservation")]
        public Input<int>? CpuReservation { get; set; }

        /// <summary>
        /// Custom priority for the resource in MHz. This is a read-only, unless the `cpu_priority` is "CUSTOM"
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// The number of virtual CPUs to allocate to the VM. Socket count is a result of: virtual logical processors/cores per socket. If `cpu_hot_add_enabled` is true, then cpus will be increased without VM power off.
        /// </summary>
        [Input("cpus")]
        public Input<int>? Cpus { get; set; }

        /// <summary>
        /// A block to define for guest customization options. See Customization
        /// </summary>
        [Input("customization")]
        public Input<Inputs.VappVmCustomizationArgs>? Customization { get; set; }

        /// <summary>
        /// The VM description. Note: for VM from Template `description` is read only. Currently, this field has
        /// the description of the OVA used to create the VM.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("disks")]
        private InputList<Inputs.VappVmDiskArgs>? _disks;

        /// <summary>
        /// Independent disk attachment configuration. See Disk below for details.
        /// </summary>
        public InputList<Inputs.VappVmDiskArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VappVmDiskArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// Boolean for exposing full CPU virtualization to the
        /// guest operating system so that applications that require hardware virtualization can run on virtual machines without binary
        /// translation or paravirtualization. Useful for hypervisor nesting provided underlying hardware supports it. Default is `false`.
        /// </summary>
        [Input("exposeHardwareVirtualization")]
        public Input<bool>? ExposeHardwareVirtualization { get; set; }

        /// <summary>
        /// Specify boot firmware of the VM. Can be `efi` or `bios`. If unset, defaults to `bios`. Changing the value requires the VM to power off.
        /// </summary>
        [Input("firmware")]
        public Input<string>? Firmware { get; set; }

        [Input("guestProperties")]
        private InputMap<string>? _guestProperties;

        /// <summary>
        /// Key value map of guest properties
        /// </summary>
        public InputMap<string> GuestProperties
        {
            get => _guestProperties ?? (_guestProperties = new InputMap<string>());
            set => _guestProperties = value;
        }

        /// <summary>
        /// Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.). Required when creating empty VM.
        /// </summary>
        [Input("hardwareVersion")]
        public Input<string>? HardwareVersion { get; set; }

        /// <summary>
        /// VM Hyper Reference
        /// </summary>
        [Input("href")]
        public Input<string>? Href { get; set; }

        /// <summary>
        /// The amount of RAM (in MB) to allocate to the VM. If `memory_hot_add_enabled` is true, then memory will be increased without VM power off
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// True if the virtual machine supports addition of memory while powered on. Default is `false`.
        /// </summary>
        [Input("memoryHotAddEnabled")]
        public Input<bool>? MemoryHotAddEnabled { get; set; }

        /// <summary>
        /// The limit (in MB) for how much of memory can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload
        /// </summary>
        [Input("memoryPriority")]
        public Input<string>? MemoryPriority { get; set; }

        /// <summary>
        /// The amount of RAM (in MB) reservation on the underlying virtualization infrastructure
        /// </summary>
        [Input("memoryReservation")]
        public Input<int>? MemoryReservation { get; set; }

        /// <summary>
        /// Custom priority for the resource in MB. This is a read-only, unless the `memory_priority` is "CUSTOM"
        /// </summary>
        [Input("memoryShares")]
        public Input<int>? MemoryShares { get; set; }

        [Input("metadata")]
        private InputMap<string>? _metadata;

        /// <summary>
        /// Use `metadata_entry` instead. Key value map of metadata to assign to this VM
        /// </summary>
        [Obsolete(@"Use metadata_entry instead")]
        public InputMap<string> Metadata
        {
            get => _metadata ?? (_metadata = new InputMap<string>());
            set => _metadata = value;
        }

        [Input("metadataEntries")]
        private InputList<Inputs.VappVmMetadataEntryArgs>? _metadataEntries;

        /// <summary>
        /// A set of metadata entries to assign. See Metadata section for details.
        /// </summary>
        public InputList<Inputs.VappVmMetadataEntryArgs> MetadataEntries
        {
            get => _metadataEntries ?? (_metadataEntries = new InputList<Inputs.VappVmMetadataEntryArgs>());
            set => _metadataEntries = value;
        }

        /// <summary>
        /// A name for the VM, unique within the vApp
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Optional number of seconds to try and wait for DHCP IP (only valid
        /// for adapters in `network` block with `ip_allocation_mode=DHCP`). It constantly checks if IP is present so the time given
        /// is a maximum. VM must be powered on and _at least one_ of the following _must be true_:
        /// * VM has Guest Tools. It waits for IP address to be reported by Guest Tools. This is a slower option, but
        /// does not require for the VM to use Edge Gateways DHCP service.
        /// * VM DHCP interface is connected to routed Org network and is using Edge Gateways DHCP service (not
        /// relayed). It works by querying DHCP leases on Edge Gateway. In general it is quicker than waiting
        /// until Guest Tools report IP addresses, but is more constrained. However this is the only option if Guest
        /// Tools are not present on the VM.
        /// </summary>
        [Input("networkDhcpWaitSeconds")]
        public Input<int>? NetworkDhcpWaitSeconds { get; set; }

        [Input("networks")]
        private InputList<Inputs.VappVmNetworkArgs>? _networks;

        /// <summary>
        /// A block to define network interface. Multiple can be used. See Network and 
        /// example for usage details.
        /// </summary>
        public InputList<Inputs.VappVmNetworkArgs> Networks
        {
            get => _networks ?? (_networks = new InputList<Inputs.VappVmNetworkArgs>());
            set => _networks = value;
        }

        /// <summary>
        /// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
        /// </summary>
        [Input("org")]
        public Input<string>? Org { get; set; }

        /// <summary>
        /// Operating System type. Possible values can be found in Os Types. Required when creating empty VM.
        /// </summary>
        [Input("osType")]
        public Input<string>? OsType { get; set; }

        [Input("overrideTemplateDisks")]
        private InputList<Inputs.VappVmOverrideTemplateDiskArgs>? _overrideTemplateDisks;

        /// <summary>
        /// Allows to update internal disk in template before first VM boot. Disk is matched by `bus_type`, `bus_number` and `unit_number`. See Override template Disk below for details.
        /// </summary>
        public InputList<Inputs.VappVmOverrideTemplateDiskArgs> OverrideTemplateDisks
        {
            get => _overrideTemplateDisks ?? (_overrideTemplateDisks = new InputList<Inputs.VappVmOverrideTemplateDiskArgs>());
            set => _overrideTemplateDisks = value;
        }

        /// <summary>
        /// VM placement policy or [vGPU policy][vgpu-policy] (*3.11+*) ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)
        /// In this case, if the placement policy is not set, it will pick the VDC default on creation. It must be set explicitly
        /// if one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `""` to be removed.
        /// </summary>
        [Input("placementPolicyId")]
        public Input<string>? PlacementPolicyId { get; set; }

        /// <summary>
        /// A boolean value stating if this VM should be powered on. Default is `true`
        /// </summary>
        [Input("powerOn")]
        public Input<bool>? PowerOn { get; set; }

        /// <summary>
        /// True if the update of resource should fail when virtual machine power off needed. Default is `false`.
        /// </summary>
        [Input("preventUpdatePowerOff")]
        public Input<bool>? PreventUpdatePowerOff { get; set; }

        [Input("securityTags")]
        private InputList<string>? _securityTags;

        /// <summary>
        /// Set of security tags to be managed by the `vcd.VappVm` resource.
        /// To remove `security_tags` you must set `security_tags = []` and do not remove the attribute. Removing the attribute will cause the tags to remain unchanged and just stop being managed by this resource.
        /// This is to be consistent with existing security tags that were created by the `vcd_security_tags` resource.
        /// </summary>
        public InputList<string> SecurityTags
        {
            get => _securityTags ?? (_securityTags = new InputList<string>());
            set => _securityTags = value;
        }

        [Input("setExtraConfigs")]
        private InputList<Inputs.VappVmSetExtraConfigArgs>? _setExtraConfigs;

        /// <summary>
        /// Set of extra configuration key/values to be added or modified. See Extra Configuration
        /// 
        /// &gt; **Note:** Only one of `security_tags` attribute or [`vcd.SecurityTag`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/security_tag) resource
        /// should be used. Using both would cause a behavioral conflict.
        /// </summary>
        public InputList<Inputs.VappVmSetExtraConfigArgs> SetExtraConfigs
        {
            get => _setExtraConfigs ?? (_setExtraConfigs = new InputList<Inputs.VappVmSetExtraConfigArgs>());
            set => _setExtraConfigs = value;
        }

        /// <summary>
        /// VM sizing policy ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)
        /// using `vcd_org_vdc.vm_sizing_policy_ids` (and `vcd_org_vdc.default_compute_policy_id` to make it default).
        /// In this case, if the sizing policy is not set, it will pick the VDC default on creation. It must be set explicitly
        /// if one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `""` to be removed.
        /// </summary>
        [Input("sizingPolicyId")]
        public Input<string>? SizingPolicyId { get; set; }

        /// <summary>
        /// Storage profile to override the default one
        /// </summary>
        [Input("storageProfile")]
        public Input<string>? StorageProfile { get; set; }

        /// <summary>
        /// Use `vapp_template_id` instead. The name of the vApp Template to use
        /// </summary>
        [Input("templateName")]
        public Input<string>? TemplateName { get; set; }

        /// <summary>
        /// The vApp this VM belongs to.
        /// </summary>
        [Input("vappName", required: true)]
        public Input<string> VappName { get; set; } = null!;

        /// <summary>
        /// The URN of the vApp Template to use. You can fetch it using a [`vcd.CatalogVappTemplate`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) data source.
        /// </summary>
        [Input("vappTemplateId")]
        public Input<string>? VappTemplateId { get; set; }

        /// <summary>
        /// The name of VDC to use, optional if defined at provider level
        /// </summary>
        [Input("vdc")]
        public Input<string>? Vdc { get; set; }

        /// <summary>
        /// The name of the VM in vApp Template to use. For cases when vApp template has more than one VM.
        /// </summary>
        [Input("vmNameInTemplate")]
        public Input<string>? VmNameInTemplate { get; set; }

        public VappVmArgs()
        {
        }
        public static new VappVmArgs Empty => new VappVmArgs();
    }

    public sealed class VappVmState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Automatically accept EULA if OVA has it. Default is `true`
        /// </summary>
        [Input("acceptAllEulas")]
        public Input<bool>? AcceptAllEulas { get; set; }

        /// <summary>
        /// Use `boot_image_id` instead. Media name to mount as boot image. Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).
        /// </summary>
        [Input("bootImage")]
        public Input<string>? BootImage { get; set; }

        /// <summary>
        /// Media URN to mount as boot image. You can fetch it using a [`vcd.CatalogMedia`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_media) data source.
        /// Image is mounted only during VM creation. On update if value is changed to empty it will eject the mounted media. If you want to mount an image later, please use [vcd.InsertedMedia](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/inserted_media).
        /// </summary>
        [Input("bootImageId")]
        public Input<string>? BootImageId { get; set; }

        /// <summary>
        /// A block to define boot options of the VM. See Boot Options
        /// </summary>
        [Input("bootOptions")]
        public Input<Inputs.VappVmBootOptionsGetArgs>? BootOptions { get; set; }

        /// <summary>
        /// Use a [`vcd.Catalog`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog) data source along with `vapp_template_id` or `boot_image_id` instead. The catalog name in which to find the given vApp Template or media for `boot_image`.
        /// </summary>
        [Input("catalogName")]
        public Input<string>? CatalogName { get; set; }

        /// <summary>
        /// Computer name to assign to this virtual machine.
        /// </summary>
        [Input("computerName")]
        public Input<string>? ComputerName { get; set; }

        /// <summary>
        /// Performs disk consolidation during creation.
        /// The main use case is when one wants to grow template disk size using `override_template_disk` in
        /// fast provisioned VDCs. **Note:** Consolidating disks requires right `vApp: VM Migrate, Force
        /// Undeploy, Relocate, Consolidate`. This operation _may take long time_ depending on disk size and
        /// storage performance.
        /// </summary>
        [Input("consolidateDisksOnCreate")]
        public Input<bool>? ConsolidateDisksOnCreate { get; set; }

        /// <summary>
        /// The ID of *an existing VM* to make a copy of it (it
        /// cannot be a vApp template). The source VM *must be in the same Org* (but can be in different VDC).
        /// *Note:* `sizing_policy_id` must be specified when creating a standalone VM (using `vcd.Vm`
        /// resource) and using different source/destination VDCs.
        /// </summary>
        [Input("copyFromVmId")]
        public Input<string>? CopyFromVmId { get; set; }

        /// <summary>
        /// The number of cores per socket.
        /// </summary>
        [Input("cpuCores")]
        public Input<int>? CpuCores { get; set; }

        /// <summary>
        /// True if the virtual machine supports addition of virtual CPUs while powered on. Default is `false`.
        /// </summary>
        [Input("cpuHotAddEnabled")]
        public Input<bool>? CpuHotAddEnabled { get; set; }

        /// <summary>
        /// The limit (in MHz) for how much of CPU can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.
        /// </summary>
        [Input("cpuLimit")]
        public Input<int>? CpuLimit { get; set; }

        /// <summary>
        /// Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload
        /// </summary>
        [Input("cpuPriority")]
        public Input<string>? CpuPriority { get; set; }

        /// <summary>
        /// The amount of MHz reservation on the underlying virtualization infrastructure.
        /// </summary>
        [Input("cpuReservation")]
        public Input<int>? CpuReservation { get; set; }

        /// <summary>
        /// Custom priority for the resource in MHz. This is a read-only, unless the `cpu_priority` is "CUSTOM"
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// The number of virtual CPUs to allocate to the VM. Socket count is a result of: virtual logical processors/cores per socket. If `cpu_hot_add_enabled` is true, then cpus will be increased without VM power off.
        /// </summary>
        [Input("cpus")]
        public Input<int>? Cpus { get; set; }

        /// <summary>
        /// A block to define for guest customization options. See Customization
        /// </summary>
        [Input("customization")]
        public Input<Inputs.VappVmCustomizationGetArgs>? Customization { get; set; }

        /// <summary>
        /// The VM description. Note: for VM from Template `description` is read only. Currently, this field has
        /// the description of the OVA used to create the VM.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("disks")]
        private InputList<Inputs.VappVmDiskGetArgs>? _disks;

        /// <summary>
        /// Independent disk attachment configuration. See Disk below for details.
        /// </summary>
        public InputList<Inputs.VappVmDiskGetArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VappVmDiskGetArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// Boolean for exposing full CPU virtualization to the
        /// guest operating system so that applications that require hardware virtualization can run on virtual machines without binary
        /// translation or paravirtualization. Useful for hypervisor nesting provided underlying hardware supports it. Default is `false`.
        /// </summary>
        [Input("exposeHardwareVirtualization")]
        public Input<bool>? ExposeHardwareVirtualization { get; set; }

        [Input("extraConfigs")]
        private InputList<Inputs.VappVmExtraConfigGetArgs>? _extraConfigs;

        /// <summary>
        /// (*v3.13.+*) The VM extra configuration. See Extra Configuration for more detail. *Not populated on VCD 10.4.0*.
        /// </summary>
        public InputList<Inputs.VappVmExtraConfigGetArgs> ExtraConfigs
        {
            get => _extraConfigs ?? (_extraConfigs = new InputList<Inputs.VappVmExtraConfigGetArgs>());
            set => _extraConfigs = value;
        }

        /// <summary>
        /// Specify boot firmware of the VM. Can be `efi` or `bios`. If unset, defaults to `bios`. Changing the value requires the VM to power off.
        /// </summary>
        [Input("firmware")]
        public Input<string>? Firmware { get; set; }

        [Input("guestProperties")]
        private InputMap<string>? _guestProperties;

        /// <summary>
        /// Key value map of guest properties
        /// </summary>
        public InputMap<string> GuestProperties
        {
            get => _guestProperties ?? (_guestProperties = new InputMap<string>());
            set => _guestProperties = value;
        }

        /// <summary>
        /// Virtual Hardware Version (e.g.`vmx-14`, `vmx-13`, `vmx-12`, etc.). Required when creating empty VM.
        /// </summary>
        [Input("hardwareVersion")]
        public Input<string>? HardwareVersion { get; set; }

        /// <summary>
        /// VM Hyper Reference
        /// </summary>
        [Input("href")]
        public Input<string>? Href { get; set; }

        /// <summary>
        /// (*v3.13.+*) A true/false value telling whether the resource was imported.
        /// </summary>
        [Input("imported")]
        public Input<bool>? Imported { get; set; }

        [Input("inheritedMetadata")]
        private InputMap<string>? _inheritedMetadata;

        /// <summary>
        /// (*v3.11+*; *VCD 10.5.1+*) A map that contains read-only metadata that is automatically added by VCD (10.5.1+) and provides
        /// details on the origin of the VM (e.g. `vm.origin.id`, `vm.origin.name`, `vm.origin.type`).
        /// </summary>
        public InputMap<string> InheritedMetadata
        {
            get => _inheritedMetadata ?? (_inheritedMetadata = new InputMap<string>());
            set => _inheritedMetadata = value;
        }

        [Input("internalDisks")]
        private InputList<Inputs.VappVmInternalDiskGetArgs>? _internalDisks;

        /// <summary>
        /// (*v2.7+*) A block providing internal disk of VM details. See Internal Disk below for details.
        /// </summary>
        public InputList<Inputs.VappVmInternalDiskGetArgs> InternalDisks
        {
            get => _internalDisks ?? (_internalDisks = new InputList<Inputs.VappVmInternalDiskGetArgs>());
            set => _internalDisks = value;
        }

        /// <summary>
        /// The amount of RAM (in MB) to allocate to the VM. If `memory_hot_add_enabled` is true, then memory will be increased without VM power off
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// True if the virtual machine supports addition of memory while powered on. Default is `false`.
        /// </summary>
        [Input("memoryHotAddEnabled")]
        public Input<bool>? MemoryHotAddEnabled { get; set; }

        /// <summary>
        /// The limit (in MB) for how much of memory can be consumed on the underlying virtualization infrastructure. `-1` value for unlimited.
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// Pre-determined relative priorities according to which the non-reserved portion of this resource is made available to the virtualized workload
        /// </summary>
        [Input("memoryPriority")]
        public Input<string>? MemoryPriority { get; set; }

        /// <summary>
        /// The amount of RAM (in MB) reservation on the underlying virtualization infrastructure
        /// </summary>
        [Input("memoryReservation")]
        public Input<int>? MemoryReservation { get; set; }

        /// <summary>
        /// Custom priority for the resource in MB. This is a read-only, unless the `memory_priority` is "CUSTOM"
        /// </summary>
        [Input("memoryShares")]
        public Input<int>? MemoryShares { get; set; }

        [Input("metadata")]
        private InputMap<string>? _metadata;

        /// <summary>
        /// Use `metadata_entry` instead. Key value map of metadata to assign to this VM
        /// </summary>
        [Obsolete(@"Use metadata_entry instead")]
        public InputMap<string> Metadata
        {
            get => _metadata ?? (_metadata = new InputMap<string>());
            set => _metadata = value;
        }

        [Input("metadataEntries")]
        private InputList<Inputs.VappVmMetadataEntryGetArgs>? _metadataEntries;

        /// <summary>
        /// A set of metadata entries to assign. See Metadata section for details.
        /// </summary>
        public InputList<Inputs.VappVmMetadataEntryGetArgs> MetadataEntries
        {
            get => _metadataEntries ?? (_metadataEntries = new InputList<Inputs.VappVmMetadataEntryGetArgs>());
            set => _metadataEntries = value;
        }

        /// <summary>
        /// A name for the VM, unique within the vApp
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Optional number of seconds to try and wait for DHCP IP (only valid
        /// for adapters in `network` block with `ip_allocation_mode=DHCP`). It constantly checks if IP is present so the time given
        /// is a maximum. VM must be powered on and _at least one_ of the following _must be true_:
        /// * VM has Guest Tools. It waits for IP address to be reported by Guest Tools. This is a slower option, but
        /// does not require for the VM to use Edge Gateways DHCP service.
        /// * VM DHCP interface is connected to routed Org network and is using Edge Gateways DHCP service (not
        /// relayed). It works by querying DHCP leases on Edge Gateway. In general it is quicker than waiting
        /// until Guest Tools report IP addresses, but is more constrained. However this is the only option if Guest
        /// Tools are not present on the VM.
        /// </summary>
        [Input("networkDhcpWaitSeconds")]
        public Input<int>? NetworkDhcpWaitSeconds { get; set; }

        [Input("networks")]
        private InputList<Inputs.VappVmNetworkGetArgs>? _networks;

        /// <summary>
        /// A block to define network interface. Multiple can be used. See Network and 
        /// example for usage details.
        /// </summary>
        public InputList<Inputs.VappVmNetworkGetArgs> Networks
        {
            get => _networks ?? (_networks = new InputList<Inputs.VappVmNetworkGetArgs>());
            set => _networks = value;
        }

        /// <summary>
        /// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
        /// </summary>
        [Input("org")]
        public Input<string>? Org { get; set; }

        /// <summary>
        /// Operating System type. Possible values can be found in Os Types. Required when creating empty VM.
        /// </summary>
        [Input("osType")]
        public Input<string>? OsType { get; set; }

        [Input("overrideTemplateDisks")]
        private InputList<Inputs.VappVmOverrideTemplateDiskGetArgs>? _overrideTemplateDisks;

        /// <summary>
        /// Allows to update internal disk in template before first VM boot. Disk is matched by `bus_type`, `bus_number` and `unit_number`. See Override template Disk below for details.
        /// </summary>
        public InputList<Inputs.VappVmOverrideTemplateDiskGetArgs> OverrideTemplateDisks
        {
            get => _overrideTemplateDisks ?? (_overrideTemplateDisks = new InputList<Inputs.VappVmOverrideTemplateDiskGetArgs>());
            set => _overrideTemplateDisks = value;
        }

        /// <summary>
        /// VM placement policy or [vGPU policy][vgpu-policy] (*3.11+*) ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)
        /// In this case, if the placement policy is not set, it will pick the VDC default on creation. It must be set explicitly
        /// if one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `""` to be removed.
        /// </summary>
        [Input("placementPolicyId")]
        public Input<string>? PlacementPolicyId { get; set; }

        /// <summary>
        /// A boolean value stating if this VM should be powered on. Default is `true`
        /// </summary>
        [Input("powerOn")]
        public Input<bool>? PowerOn { get; set; }

        /// <summary>
        /// True if the update of resource should fail when virtual machine power off needed. Default is `false`.
        /// </summary>
        [Input("preventUpdatePowerOff")]
        public Input<bool>? PreventUpdatePowerOff { get; set; }

        [Input("securityTags")]
        private InputList<string>? _securityTags;

        /// <summary>
        /// Set of security tags to be managed by the `vcd.VappVm` resource.
        /// To remove `security_tags` you must set `security_tags = []` and do not remove the attribute. Removing the attribute will cause the tags to remain unchanged and just stop being managed by this resource.
        /// This is to be consistent with existing security tags that were created by the `vcd_security_tags` resource.
        /// </summary>
        public InputList<string> SecurityTags
        {
            get => _securityTags ?? (_securityTags = new InputList<string>());
            set => _securityTags = value;
        }

        [Input("setExtraConfigs")]
        private InputList<Inputs.VappVmSetExtraConfigGetArgs>? _setExtraConfigs;

        /// <summary>
        /// Set of extra configuration key/values to be added or modified. See Extra Configuration
        /// 
        /// &gt; **Note:** Only one of `security_tags` attribute or [`vcd.SecurityTag`](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/security_tag) resource
        /// should be used. Using both would cause a behavioral conflict.
        /// </summary>
        public InputList<Inputs.VappVmSetExtraConfigGetArgs> SetExtraConfigs
        {
            get => _setExtraConfigs ?? (_setExtraConfigs = new InputList<Inputs.VappVmSetExtraConfigGetArgs>());
            set => _setExtraConfigs = value;
        }

        /// <summary>
        /// VM sizing policy ID. To be used, it needs to be assigned to [Org VDC](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/org_vdc)
        /// using `vcd_org_vdc.vm_sizing_policy_ids` (and `vcd_org_vdc.default_compute_policy_id` to make it default).
        /// In this case, if the sizing policy is not set, it will pick the VDC default on creation. It must be set explicitly
        /// if one wants to update it to another policy (the VM requires at least one Compute Policy), and needs to be set to `""` to be removed.
        /// </summary>
        [Input("sizingPolicyId")]
        public Input<string>? SizingPolicyId { get; set; }

        /// <summary>
        /// (*v3.8+*) The vApp status as a numeric code.
        /// </summary>
        [Input("status")]
        public Input<int>? Status { get; set; }

        /// <summary>
        /// (*v3.8+*) The vApp status as text.
        /// </summary>
        [Input("statusText")]
        public Input<string>? StatusText { get; set; }

        /// <summary>
        /// Storage profile to override the default one
        /// </summary>
        [Input("storageProfile")]
        public Input<string>? StorageProfile { get; set; }

        /// <summary>
        /// Use `vapp_template_id` instead. The name of the vApp Template to use
        /// </summary>
        [Input("templateName")]
        public Input<string>? TemplateName { get; set; }

        /// <summary>
        /// ID of parent vApp
        /// </summary>
        [Input("vappId")]
        public Input<string>? VappId { get; set; }

        /// <summary>
        /// The vApp this VM belongs to.
        /// </summary>
        [Input("vappName")]
        public Input<string>? VappName { get; set; }

        /// <summary>
        /// The URN of the vApp Template to use. You can fetch it using a [`vcd.CatalogVappTemplate`](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/catalog_vapp_template) data source.
        /// </summary>
        [Input("vappTemplateId")]
        public Input<string>? VappTemplateId { get; set; }

        /// <summary>
        /// The name of VDC to use, optional if defined at provider level
        /// </summary>
        [Input("vdc")]
        public Input<string>? Vdc { get; set; }

        /// <summary>
        /// The name of the VM in vApp Template to use. For cases when vApp template has more than one VM.
        /// </summary>
        [Input("vmNameInTemplate")]
        public Input<string>? VmNameInTemplate { get; set; }

        /// <summary>
        /// (*3.2+*) Type of the VM (either `vcd.VappVm` or `vcd.Vm`).
        /// </summary>
        [Input("vmType")]
        public Input<string>? VmType { get; set; }

        public VappVmState()
        {
        }
        public static new VappVmState Empty => new VappVmState();
    }
}
