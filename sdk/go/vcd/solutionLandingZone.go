// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vcd

import (
	"context"
	"reflect"

	"errors"
	"github.com/ergSey/pulumi-vcd/sdk/go/vcd/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type SolutionLandingZone struct {
	pulumi.CustomResourceState

	// This catalog stores all executable .ISO files for solution add-ons. There
	// can be a single `catalog` element and the required field is `id`.
	Catalog SolutionLandingZoneCatalogOutput `pulumi:"catalog"`
	// Destination Organization name for Solution Add-ons
	Org pulumi.StringPtrOutput `pulumi:"org"`
	// reports the state of parent [Runtime Defined
	// Entity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)
	State pulumi.StringOutput `pulumi:"state"`
	// A single vdc block that defines landing VDC configuration
	//
	// <a id="vdc"></a>
	Vdcs SolutionLandingZoneVdcArrayOutput `pulumi:"vdcs"`
}

// NewSolutionLandingZone registers a new resource with the given unique name, arguments, and options.
func NewSolutionLandingZone(ctx *pulumi.Context,
	name string, args *SolutionLandingZoneArgs, opts ...pulumi.ResourceOption) (*SolutionLandingZone, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Catalog == nil {
		return nil, errors.New("invalid value for required argument 'Catalog'")
	}
	if args.Vdcs == nil {
		return nil, errors.New("invalid value for required argument 'Vdcs'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SolutionLandingZone
	err := ctx.RegisterResource("vcd:index/solutionLandingZone:SolutionLandingZone", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSolutionLandingZone gets an existing SolutionLandingZone resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSolutionLandingZone(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SolutionLandingZoneState, opts ...pulumi.ResourceOption) (*SolutionLandingZone, error) {
	var resource SolutionLandingZone
	err := ctx.ReadResource("vcd:index/solutionLandingZone:SolutionLandingZone", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SolutionLandingZone resources.
type solutionLandingZoneState struct {
	// This catalog stores all executable .ISO files for solution add-ons. There
	// can be a single `catalog` element and the required field is `id`.
	Catalog *SolutionLandingZoneCatalog `pulumi:"catalog"`
	// Destination Organization name for Solution Add-ons
	Org *string `pulumi:"org"`
	// reports the state of parent [Runtime Defined
	// Entity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)
	State *string `pulumi:"state"`
	// A single vdc block that defines landing VDC configuration
	//
	// <a id="vdc"></a>
	Vdcs []SolutionLandingZoneVdc `pulumi:"vdcs"`
}

type SolutionLandingZoneState struct {
	// This catalog stores all executable .ISO files for solution add-ons. There
	// can be a single `catalog` element and the required field is `id`.
	Catalog SolutionLandingZoneCatalogPtrInput
	// Destination Organization name for Solution Add-ons
	Org pulumi.StringPtrInput
	// reports the state of parent [Runtime Defined
	// Entity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)
	State pulumi.StringPtrInput
	// A single vdc block that defines landing VDC configuration
	//
	// <a id="vdc"></a>
	Vdcs SolutionLandingZoneVdcArrayInput
}

func (SolutionLandingZoneState) ElementType() reflect.Type {
	return reflect.TypeOf((*solutionLandingZoneState)(nil)).Elem()
}

type solutionLandingZoneArgs struct {
	// This catalog stores all executable .ISO files for solution add-ons. There
	// can be a single `catalog` element and the required field is `id`.
	Catalog SolutionLandingZoneCatalog `pulumi:"catalog"`
	// Destination Organization name for Solution Add-ons
	Org *string `pulumi:"org"`
	// A single vdc block that defines landing VDC configuration
	//
	// <a id="vdc"></a>
	Vdcs []SolutionLandingZoneVdc `pulumi:"vdcs"`
}

// The set of arguments for constructing a SolutionLandingZone resource.
type SolutionLandingZoneArgs struct {
	// This catalog stores all executable .ISO files for solution add-ons. There
	// can be a single `catalog` element and the required field is `id`.
	Catalog SolutionLandingZoneCatalogInput
	// Destination Organization name for Solution Add-ons
	Org pulumi.StringPtrInput
	// A single vdc block that defines landing VDC configuration
	//
	// <a id="vdc"></a>
	Vdcs SolutionLandingZoneVdcArrayInput
}

func (SolutionLandingZoneArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*solutionLandingZoneArgs)(nil)).Elem()
}

type SolutionLandingZoneInput interface {
	pulumi.Input

	ToSolutionLandingZoneOutput() SolutionLandingZoneOutput
	ToSolutionLandingZoneOutputWithContext(ctx context.Context) SolutionLandingZoneOutput
}

func (*SolutionLandingZone) ElementType() reflect.Type {
	return reflect.TypeOf((**SolutionLandingZone)(nil)).Elem()
}

func (i *SolutionLandingZone) ToSolutionLandingZoneOutput() SolutionLandingZoneOutput {
	return i.ToSolutionLandingZoneOutputWithContext(context.Background())
}

func (i *SolutionLandingZone) ToSolutionLandingZoneOutputWithContext(ctx context.Context) SolutionLandingZoneOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SolutionLandingZoneOutput)
}

// SolutionLandingZoneArrayInput is an input type that accepts SolutionLandingZoneArray and SolutionLandingZoneArrayOutput values.
// You can construct a concrete instance of `SolutionLandingZoneArrayInput` via:
//
//	SolutionLandingZoneArray{ SolutionLandingZoneArgs{...} }
type SolutionLandingZoneArrayInput interface {
	pulumi.Input

	ToSolutionLandingZoneArrayOutput() SolutionLandingZoneArrayOutput
	ToSolutionLandingZoneArrayOutputWithContext(context.Context) SolutionLandingZoneArrayOutput
}

type SolutionLandingZoneArray []SolutionLandingZoneInput

func (SolutionLandingZoneArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SolutionLandingZone)(nil)).Elem()
}

func (i SolutionLandingZoneArray) ToSolutionLandingZoneArrayOutput() SolutionLandingZoneArrayOutput {
	return i.ToSolutionLandingZoneArrayOutputWithContext(context.Background())
}

func (i SolutionLandingZoneArray) ToSolutionLandingZoneArrayOutputWithContext(ctx context.Context) SolutionLandingZoneArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SolutionLandingZoneArrayOutput)
}

// SolutionLandingZoneMapInput is an input type that accepts SolutionLandingZoneMap and SolutionLandingZoneMapOutput values.
// You can construct a concrete instance of `SolutionLandingZoneMapInput` via:
//
//	SolutionLandingZoneMap{ "key": SolutionLandingZoneArgs{...} }
type SolutionLandingZoneMapInput interface {
	pulumi.Input

	ToSolutionLandingZoneMapOutput() SolutionLandingZoneMapOutput
	ToSolutionLandingZoneMapOutputWithContext(context.Context) SolutionLandingZoneMapOutput
}

type SolutionLandingZoneMap map[string]SolutionLandingZoneInput

func (SolutionLandingZoneMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SolutionLandingZone)(nil)).Elem()
}

func (i SolutionLandingZoneMap) ToSolutionLandingZoneMapOutput() SolutionLandingZoneMapOutput {
	return i.ToSolutionLandingZoneMapOutputWithContext(context.Background())
}

func (i SolutionLandingZoneMap) ToSolutionLandingZoneMapOutputWithContext(ctx context.Context) SolutionLandingZoneMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SolutionLandingZoneMapOutput)
}

type SolutionLandingZoneOutput struct{ *pulumi.OutputState }

func (SolutionLandingZoneOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SolutionLandingZone)(nil)).Elem()
}

func (o SolutionLandingZoneOutput) ToSolutionLandingZoneOutput() SolutionLandingZoneOutput {
	return o
}

func (o SolutionLandingZoneOutput) ToSolutionLandingZoneOutputWithContext(ctx context.Context) SolutionLandingZoneOutput {
	return o
}

// This catalog stores all executable .ISO files for solution add-ons. There
// can be a single `catalog` element and the required field is `id`.
func (o SolutionLandingZoneOutput) Catalog() SolutionLandingZoneCatalogOutput {
	return o.ApplyT(func(v *SolutionLandingZone) SolutionLandingZoneCatalogOutput { return v.Catalog }).(SolutionLandingZoneCatalogOutput)
}

// Destination Organization name for Solution Add-ons
func (o SolutionLandingZoneOutput) Org() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SolutionLandingZone) pulumi.StringPtrOutput { return v.Org }).(pulumi.StringPtrOutput)
}

// reports the state of parent [Runtime Defined
// Entity](https://www.terraform.io/providers/vmware/vcd/latest/docs/resources/rde)
func (o SolutionLandingZoneOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *SolutionLandingZone) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// A single vdc block that defines landing VDC configuration
//
// <a id="vdc"></a>
func (o SolutionLandingZoneOutput) Vdcs() SolutionLandingZoneVdcArrayOutput {
	return o.ApplyT(func(v *SolutionLandingZone) SolutionLandingZoneVdcArrayOutput { return v.Vdcs }).(SolutionLandingZoneVdcArrayOutput)
}

type SolutionLandingZoneArrayOutput struct{ *pulumi.OutputState }

func (SolutionLandingZoneArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SolutionLandingZone)(nil)).Elem()
}

func (o SolutionLandingZoneArrayOutput) ToSolutionLandingZoneArrayOutput() SolutionLandingZoneArrayOutput {
	return o
}

func (o SolutionLandingZoneArrayOutput) ToSolutionLandingZoneArrayOutputWithContext(ctx context.Context) SolutionLandingZoneArrayOutput {
	return o
}

func (o SolutionLandingZoneArrayOutput) Index(i pulumi.IntInput) SolutionLandingZoneOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SolutionLandingZone {
		return vs[0].([]*SolutionLandingZone)[vs[1].(int)]
	}).(SolutionLandingZoneOutput)
}

type SolutionLandingZoneMapOutput struct{ *pulumi.OutputState }

func (SolutionLandingZoneMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SolutionLandingZone)(nil)).Elem()
}

func (o SolutionLandingZoneMapOutput) ToSolutionLandingZoneMapOutput() SolutionLandingZoneMapOutput {
	return o
}

func (o SolutionLandingZoneMapOutput) ToSolutionLandingZoneMapOutputWithContext(ctx context.Context) SolutionLandingZoneMapOutput {
	return o
}

func (o SolutionLandingZoneMapOutput) MapIndex(k pulumi.StringInput) SolutionLandingZoneOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SolutionLandingZone {
		return vs[0].(map[string]*SolutionLandingZone)[vs[1].(string)]
	}).(SolutionLandingZoneOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SolutionLandingZoneInput)(nil)).Elem(), &SolutionLandingZone{})
	pulumi.RegisterInputType(reflect.TypeOf((*SolutionLandingZoneArrayInput)(nil)).Elem(), SolutionLandingZoneArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SolutionLandingZoneMapInput)(nil)).Elem(), SolutionLandingZoneMap{})
	pulumi.RegisterOutputType(SolutionLandingZoneOutput{})
	pulumi.RegisterOutputType(SolutionLandingZoneArrayOutput{})
	pulumi.RegisterOutputType(SolutionLandingZoneMapOutput{})
}
