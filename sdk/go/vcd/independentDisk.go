// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vcd

import (
	"context"
	"reflect"

	"errors"
	"github.com/ergSey/pulumi-vcd/sdk/go/vcd/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type IndependentDisk struct {
	pulumi.CustomResourceState

	// (Computed, *v3.6+*) IDs of VM which are using the disk
	AttachedVmIds pulumi.StringArrayOutput `pulumi:"attachedVmIds"`
	// Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`
	BusSubType pulumi.StringOutput `pulumi:"busSubType"`
	// Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off
	BusType pulumi.StringOutput `pulumi:"busType"`
	// (Computed) Data store name. Readable only for system user.
	DatastoreName pulumi.StringOutput `pulumi:"datastoreName"`
	// independent disk description
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// (Computed, *v3.6+* and VCD 10.2+) True if disk is encrypted
	Encrypted pulumi.BoolOutput `pulumi:"encrypted"`
	// (Computed) IOPS request for the created disk
	Iops pulumi.IntOutput `pulumi:"iops"`
	// (Computed) True if the disk is already attached
	IsAttached pulumi.BoolOutput `pulumi:"isAttached"`
	// Use `metadataEntry` instead. Key value map of metadata to assign to this independent disk.
	//
	// Deprecated: Use metadataEntry instead
	Metadata pulumi.StringMapOutput `pulumi:"metadata"`
	// A set of metadata entries to assign. See Metadata section for details.
	MetadataEntries IndependentDiskMetadataEntryArrayOutput `pulumi:"metadataEntries"`
	// Disk name
	Name pulumi.StringOutput `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
	Org pulumi.StringPtrOutput `pulumi:"org"`
	// (Computed) The owner name of the disk
	OwnerName pulumi.StringOutput `pulumi:"ownerName"`
	// This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`
	SharingType pulumi.StringOutput `pulumi:"sharingType"`
	// Size of disk in MB.
	SizeInMb pulumi.IntOutput `pulumi:"sizeInMb"`
	// The name of storage profile where disk will be created
	StorageProfile pulumi.StringOutput `pulumi:"storageProfile"`
	// (Computed, *v3.6+* and VCD 10.2+) The UUID of this named disk's device backing
	Uuid pulumi.StringOutput `pulumi:"uuid"`
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrOutput `pulumi:"vdc"`
}

// NewIndependentDisk registers a new resource with the given unique name, arguments, and options.
func NewIndependentDisk(ctx *pulumi.Context,
	name string, args *IndependentDiskArgs, opts ...pulumi.ResourceOption) (*IndependentDisk, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SizeInMb == nil {
		return nil, errors.New("invalid value for required argument 'SizeInMb'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource IndependentDisk
	err := ctx.RegisterResource("vcd:index/independentDisk:IndependentDisk", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIndependentDisk gets an existing IndependentDisk resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIndependentDisk(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IndependentDiskState, opts ...pulumi.ResourceOption) (*IndependentDisk, error) {
	var resource IndependentDisk
	err := ctx.ReadResource("vcd:index/independentDisk:IndependentDisk", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IndependentDisk resources.
type independentDiskState struct {
	// (Computed, *v3.6+*) IDs of VM which are using the disk
	AttachedVmIds []string `pulumi:"attachedVmIds"`
	// Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`
	BusSubType *string `pulumi:"busSubType"`
	// Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off
	BusType *string `pulumi:"busType"`
	// (Computed) Data store name. Readable only for system user.
	DatastoreName *string `pulumi:"datastoreName"`
	// independent disk description
	Description *string `pulumi:"description"`
	// (Computed, *v3.6+* and VCD 10.2+) True if disk is encrypted
	Encrypted *bool `pulumi:"encrypted"`
	// (Computed) IOPS request for the created disk
	Iops *int `pulumi:"iops"`
	// (Computed) True if the disk is already attached
	IsAttached *bool `pulumi:"isAttached"`
	// Use `metadataEntry` instead. Key value map of metadata to assign to this independent disk.
	//
	// Deprecated: Use metadataEntry instead
	Metadata map[string]string `pulumi:"metadata"`
	// A set of metadata entries to assign. See Metadata section for details.
	MetadataEntries []IndependentDiskMetadataEntry `pulumi:"metadataEntries"`
	// Disk name
	Name *string `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
	Org *string `pulumi:"org"`
	// (Computed) The owner name of the disk
	OwnerName *string `pulumi:"ownerName"`
	// This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`
	SharingType *string `pulumi:"sharingType"`
	// Size of disk in MB.
	SizeInMb *int `pulumi:"sizeInMb"`
	// The name of storage profile where disk will be created
	StorageProfile *string `pulumi:"storageProfile"`
	// (Computed, *v3.6+* and VCD 10.2+) The UUID of this named disk's device backing
	Uuid *string `pulumi:"uuid"`
	// The name of VDC to use, optional if defined at provider level
	Vdc *string `pulumi:"vdc"`
}

type IndependentDiskState struct {
	// (Computed, *v3.6+*) IDs of VM which are using the disk
	AttachedVmIds pulumi.StringArrayInput
	// Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`
	BusSubType pulumi.StringPtrInput
	// Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off
	BusType pulumi.StringPtrInput
	// (Computed) Data store name. Readable only for system user.
	DatastoreName pulumi.StringPtrInput
	// independent disk description
	Description pulumi.StringPtrInput
	// (Computed, *v3.6+* and VCD 10.2+) True if disk is encrypted
	Encrypted pulumi.BoolPtrInput
	// (Computed) IOPS request for the created disk
	Iops pulumi.IntPtrInput
	// (Computed) True if the disk is already attached
	IsAttached pulumi.BoolPtrInput
	// Use `metadataEntry` instead. Key value map of metadata to assign to this independent disk.
	//
	// Deprecated: Use metadataEntry instead
	Metadata pulumi.StringMapInput
	// A set of metadata entries to assign. See Metadata section for details.
	MetadataEntries IndependentDiskMetadataEntryArrayInput
	// Disk name
	Name pulumi.StringPtrInput
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
	Org pulumi.StringPtrInput
	// (Computed) The owner name of the disk
	OwnerName pulumi.StringPtrInput
	// This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`
	SharingType pulumi.StringPtrInput
	// Size of disk in MB.
	SizeInMb pulumi.IntPtrInput
	// The name of storage profile where disk will be created
	StorageProfile pulumi.StringPtrInput
	// (Computed, *v3.6+* and VCD 10.2+) The UUID of this named disk's device backing
	Uuid pulumi.StringPtrInput
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrInput
}

func (IndependentDiskState) ElementType() reflect.Type {
	return reflect.TypeOf((*independentDiskState)(nil)).Elem()
}

type independentDiskArgs struct {
	// Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`
	BusSubType *string `pulumi:"busSubType"`
	// Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off
	BusType *string `pulumi:"busType"`
	// independent disk description
	Description *string `pulumi:"description"`
	// Use `metadataEntry` instead. Key value map of metadata to assign to this independent disk.
	//
	// Deprecated: Use metadataEntry instead
	Metadata map[string]string `pulumi:"metadata"`
	// A set of metadata entries to assign. See Metadata section for details.
	MetadataEntries []IndependentDiskMetadataEntry `pulumi:"metadataEntries"`
	// Disk name
	Name *string `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
	Org *string `pulumi:"org"`
	// This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`
	SharingType *string `pulumi:"sharingType"`
	// Size of disk in MB.
	SizeInMb int `pulumi:"sizeInMb"`
	// The name of storage profile where disk will be created
	StorageProfile *string `pulumi:"storageProfile"`
	// The name of VDC to use, optional if defined at provider level
	Vdc *string `pulumi:"vdc"`
}

// The set of arguments for constructing a IndependentDisk resource.
type IndependentDiskArgs struct {
	// Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`
	BusSubType pulumi.StringPtrInput
	// Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off
	BusType pulumi.StringPtrInput
	// independent disk description
	Description pulumi.StringPtrInput
	// Use `metadataEntry` instead. Key value map of metadata to assign to this independent disk.
	//
	// Deprecated: Use metadataEntry instead
	Metadata pulumi.StringMapInput
	// A set of metadata entries to assign. See Metadata section for details.
	MetadataEntries IndependentDiskMetadataEntryArrayInput
	// Disk name
	Name pulumi.StringPtrInput
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
	Org pulumi.StringPtrInput
	// This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`
	SharingType pulumi.StringPtrInput
	// Size of disk in MB.
	SizeInMb pulumi.IntInput
	// The name of storage profile where disk will be created
	StorageProfile pulumi.StringPtrInput
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrInput
}

func (IndependentDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*independentDiskArgs)(nil)).Elem()
}

type IndependentDiskInput interface {
	pulumi.Input

	ToIndependentDiskOutput() IndependentDiskOutput
	ToIndependentDiskOutputWithContext(ctx context.Context) IndependentDiskOutput
}

func (*IndependentDisk) ElementType() reflect.Type {
	return reflect.TypeOf((**IndependentDisk)(nil)).Elem()
}

func (i *IndependentDisk) ToIndependentDiskOutput() IndependentDiskOutput {
	return i.ToIndependentDiskOutputWithContext(context.Background())
}

func (i *IndependentDisk) ToIndependentDiskOutputWithContext(ctx context.Context) IndependentDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndependentDiskOutput)
}

// IndependentDiskArrayInput is an input type that accepts IndependentDiskArray and IndependentDiskArrayOutput values.
// You can construct a concrete instance of `IndependentDiskArrayInput` via:
//
//	IndependentDiskArray{ IndependentDiskArgs{...} }
type IndependentDiskArrayInput interface {
	pulumi.Input

	ToIndependentDiskArrayOutput() IndependentDiskArrayOutput
	ToIndependentDiskArrayOutputWithContext(context.Context) IndependentDiskArrayOutput
}

type IndependentDiskArray []IndependentDiskInput

func (IndependentDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IndependentDisk)(nil)).Elem()
}

func (i IndependentDiskArray) ToIndependentDiskArrayOutput() IndependentDiskArrayOutput {
	return i.ToIndependentDiskArrayOutputWithContext(context.Background())
}

func (i IndependentDiskArray) ToIndependentDiskArrayOutputWithContext(ctx context.Context) IndependentDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndependentDiskArrayOutput)
}

// IndependentDiskMapInput is an input type that accepts IndependentDiskMap and IndependentDiskMapOutput values.
// You can construct a concrete instance of `IndependentDiskMapInput` via:
//
//	IndependentDiskMap{ "key": IndependentDiskArgs{...} }
type IndependentDiskMapInput interface {
	pulumi.Input

	ToIndependentDiskMapOutput() IndependentDiskMapOutput
	ToIndependentDiskMapOutputWithContext(context.Context) IndependentDiskMapOutput
}

type IndependentDiskMap map[string]IndependentDiskInput

func (IndependentDiskMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IndependentDisk)(nil)).Elem()
}

func (i IndependentDiskMap) ToIndependentDiskMapOutput() IndependentDiskMapOutput {
	return i.ToIndependentDiskMapOutputWithContext(context.Background())
}

func (i IndependentDiskMap) ToIndependentDiskMapOutputWithContext(ctx context.Context) IndependentDiskMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndependentDiskMapOutput)
}

type IndependentDiskOutput struct{ *pulumi.OutputState }

func (IndependentDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndependentDisk)(nil)).Elem()
}

func (o IndependentDiskOutput) ToIndependentDiskOutput() IndependentDiskOutput {
	return o
}

func (o IndependentDiskOutput) ToIndependentDiskOutputWithContext(ctx context.Context) IndependentDiskOutput {
	return o
}

// (Computed, *v3.6+*) IDs of VM which are using the disk
func (o IndependentDiskOutput) AttachedVmIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringArrayOutput { return v.AttachedVmIds }).(pulumi.StringArrayOutput)
}

// Disk bus subtype. Values can be: `buslogic`, `lsilogic`, `lsilogicsas`, `VirtualSCSI` for `SCSI`, `ahci` for `SATA` and (*v3.6+*) `nvmecontroller` for `NVME`
func (o IndependentDiskOutput) BusSubType() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.BusSubType }).(pulumi.StringOutput)
}

// Disk bus type. Values can be: `IDE`, `SCSI`, `SATA`, (*v3.6+*) `NVME`. **Note** When the disk type is IDE then VM is required to be powered off
func (o IndependentDiskOutput) BusType() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.BusType }).(pulumi.StringOutput)
}

// (Computed) Data store name. Readable only for system user.
func (o IndependentDiskOutput) DatastoreName() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.DatastoreName }).(pulumi.StringOutput)
}

// independent disk description
func (o IndependentDiskOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// (Computed, *v3.6+* and VCD 10.2+) True if disk is encrypted
func (o IndependentDiskOutput) Encrypted() pulumi.BoolOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.BoolOutput { return v.Encrypted }).(pulumi.BoolOutput)
}

// (Computed) IOPS request for the created disk
func (o IndependentDiskOutput) Iops() pulumi.IntOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.IntOutput { return v.Iops }).(pulumi.IntOutput)
}

// (Computed) True if the disk is already attached
func (o IndependentDiskOutput) IsAttached() pulumi.BoolOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.BoolOutput { return v.IsAttached }).(pulumi.BoolOutput)
}

// Use `metadataEntry` instead. Key value map of metadata to assign to this independent disk.
//
// Deprecated: Use metadataEntry instead
func (o IndependentDiskOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringMapOutput { return v.Metadata }).(pulumi.StringMapOutput)
}

// A set of metadata entries to assign. See Metadata section for details.
func (o IndependentDiskOutput) MetadataEntries() IndependentDiskMetadataEntryArrayOutput {
	return o.ApplyT(func(v *IndependentDisk) IndependentDiskMetadataEntryArrayOutput { return v.MetadataEntries }).(IndependentDiskMetadataEntryArrayOutput)
}

// Disk name
func (o IndependentDiskOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
func (o IndependentDiskOutput) Org() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringPtrOutput { return v.Org }).(pulumi.StringPtrOutput)
}

// (Computed) The owner name of the disk
func (o IndependentDiskOutput) OwnerName() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.OwnerName }).(pulumi.StringOutput)
}

// This is the sharing type. Values can be: `DiskSharing`,`ControllerSharing`, or `None`
func (o IndependentDiskOutput) SharingType() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.SharingType }).(pulumi.StringOutput)
}

// Size of disk in MB.
func (o IndependentDiskOutput) SizeInMb() pulumi.IntOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.IntOutput { return v.SizeInMb }).(pulumi.IntOutput)
}

// The name of storage profile where disk will be created
func (o IndependentDiskOutput) StorageProfile() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.StorageProfile }).(pulumi.StringOutput)
}

// (Computed, *v3.6+* and VCD 10.2+) The UUID of this named disk's device backing
func (o IndependentDiskOutput) Uuid() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.Uuid }).(pulumi.StringOutput)
}

// The name of VDC to use, optional if defined at provider level
func (o IndependentDiskOutput) Vdc() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringPtrOutput { return v.Vdc }).(pulumi.StringPtrOutput)
}

type IndependentDiskArrayOutput struct{ *pulumi.OutputState }

func (IndependentDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IndependentDisk)(nil)).Elem()
}

func (o IndependentDiskArrayOutput) ToIndependentDiskArrayOutput() IndependentDiskArrayOutput {
	return o
}

func (o IndependentDiskArrayOutput) ToIndependentDiskArrayOutputWithContext(ctx context.Context) IndependentDiskArrayOutput {
	return o
}

func (o IndependentDiskArrayOutput) Index(i pulumi.IntInput) IndependentDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IndependentDisk {
		return vs[0].([]*IndependentDisk)[vs[1].(int)]
	}).(IndependentDiskOutput)
}

type IndependentDiskMapOutput struct{ *pulumi.OutputState }

func (IndependentDiskMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IndependentDisk)(nil)).Elem()
}

func (o IndependentDiskMapOutput) ToIndependentDiskMapOutput() IndependentDiskMapOutput {
	return o
}

func (o IndependentDiskMapOutput) ToIndependentDiskMapOutputWithContext(ctx context.Context) IndependentDiskMapOutput {
	return o
}

func (o IndependentDiskMapOutput) MapIndex(k pulumi.StringInput) IndependentDiskOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IndependentDisk {
		return vs[0].(map[string]*IndependentDisk)[vs[1].(string)]
	}).(IndependentDiskOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IndependentDiskInput)(nil)).Elem(), &IndependentDisk{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndependentDiskArrayInput)(nil)).Elem(), IndependentDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndependentDiskMapInput)(nil)).Elem(), IndependentDiskMap{})
	pulumi.RegisterOutputType(IndependentDiskOutput{})
	pulumi.RegisterOutputType(IndependentDiskArrayOutput{})
	pulumi.RegisterOutputType(IndependentDiskMapOutput{})
}
